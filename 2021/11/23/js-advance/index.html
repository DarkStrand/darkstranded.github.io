<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">js进阶 | DarkStrand</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "FLのBlog";
  mashiro_option.author_name = "Blog";
  mashiro_option.site_url = "";
  mashiro_option.v_appId = "zMhFPcMIscDyGbtxHjYFffkx-gzGzoHsz";
  mashiro_option.v_appKey = "c4XBymCm0OmYWLklOAKbUlhE";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/pexels-designecologist-1779487.jpg,https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/pexels-serpstat-572056.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
  
  <!--自定义看板娘-->
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="">
          <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/touxiang.JPG">
        </a>
      </div>
      <div class="header-info">
        <p>Live your life with passion! With some drive!</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://gitee.com/darkstranded" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/github.jpeg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/wechat.jpeg">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/qrwechat.png">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">FLの</span>
            <span class="shironeko">Blog</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/生活/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/资源/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/转载/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/悦读/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          书单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          番组
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/图集/">
                          <i class="fa fa-photo" aria-hidden="true"></i>
                          图集
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                      <li>
                        <a href="/lab/">
                          <i class="fa fa-cogs" aria-hidden="true"></i>
                          Lab
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/client/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-android faa-vertical" aria-hidden="true"></i>
                    客户端
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg);" src="/images/bg1.jpg" data-src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      js进阶</h1>
      <p class="entry-census">
        <span>
          <a href="DarkStrand.cn">
            <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="DarkStrand.cn">DarkStrand</a>
        </span>
        <span class="bull">
        ·</span>
        2021-11-23<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>JavaScript 的数据类型有下图所示的8种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/js进阶/1.png" alt="js数据类型"></p>
<p>其中，前7种类型为<code>基础类型</code>，最后1种（Object）为<code>引用类型</code>，也是需要重点关注的，因为它在日常工作中是使用最频繁，也是需要关注最多技术细节的数据类型。</p>
<p>而引用数据类型（Object）又分为图上这几种常见的类型：Array-数组对象、RegExp-正则对象、Date-日期对象、Math-数学函数、Function-函数对象。</p>
<p>在这里，请重点了解下面两点，因为各种 JavaScript 的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分为两类来进行存储：</p>
<ol>
<li><code>基础类型</code>存储在<code>栈内存</code>，被引用或拷贝时，会创建一个完全相等的变量；</li>
<li><code>引用类型</code>存储在<code>堆内存</code>，存储的是地址，多个引用指向同一个地址，这里会涉及一个“<strong>共享</strong>”的概念。</li>
</ol>
<p>关于引用类型下面直接通过两段代码来讲解，让你深入理解一下核心“共享”的概念。</p>
<h3 id="题目一：初出茅庐"><a href="#题目一：初出茅庐" class="headerlink" title="题目一：初出茅庐"></a>题目一：初出茅庐</h3><pre><code class="js">let a = {
  name: &#39;lee&#39;,
  age: 18
}
let b = a;
console.log(a.name);  //第一个console  &#39;lee&#39;
b.name = &#39;son&#39;;
console.log(a.name);  //第二个console  &#39;son&#39;
console.log(b.name);  //第三个console  &#39;son&#39;
</code></pre>
<p>这道题比较简单，我们可以看到第一个 console 打出来 name 是&#39;lee&#39;，这应该没什么疑问；但是在执行了 b.name=&#39;son&#39; 之后，结果你会发现 a 和 b 的属性 name 都是 &#39;son&#39;，第二个和第三个打印结果是一样的，这里就体现了引用类型的“共享”的特性，即这两个值都存在同一块内存中 共享，一个发生了改变，另一个也随之跟着变化。</p>
<h3 id="题目二：渐入佳境"><a href="#题目二：渐入佳境" class="headerlink" title="题目二：渐入佳境"></a>题目二：渐入佳境</h3><pre><code class="js">let a = {
  name: &#39;Julia&#39;,
  age: 20
}
function change(o) {
  o.age = 24;
  o = {
    name: &#39;Kath&#39;,
    age: 30
  }
  return o;
}
let b = change(a);     // 注意这里没有new，后面new相关会有专门文章讲解
console.log(b.age);    // 第一个console
console.log(a.age);    // 第二个console
</code></pre>
<p>这道题涉及了 function，你通过上述代码可以看到第一个 console 的结果是30，b最后打印结果是 {name: &#39;Kath&#39;, age:30}；第二个 console 的返回结果是24，而 a 最后的打印结果是{name:&#39;Julia&#39;, age:24}。</p>
<p>是不是和你预想的有些区别？你要注意的是，<strong>这里的 function 和 return 带来了不一样的东西</strong>。</p>
<p>原因在于：函数传参进来的 o ，传递的是对象在堆中的内存地址值，通过调用 o.age=24 确实改变了 a 对象的 age 属性；12行把参数 o 的地址重新返回了，将{name: &#39;Kath&#39;,age:30}存入其中，最后返回 b 的值就变成了{name:&#39;Kath&#39;,age:30}。而如果把第12行去掉，那么 b 就会返回 undefined。</p>
<p>讲完数据类型的基本概念，我们继续看下一部分，如何对数据类型进行检测，这也是比较重要的问题。</p>
<h2 id="1-2-检测"><a href="#1-2-检测" class="headerlink" title="1.2 检测"></a>1.2 检测</h2><p>数据类型检测也是面试过程中经常会遇到的问题，比如：如何判断是否为数组？让你写一段代码把 JavaScript 的各种数据类型判断出来，等等。类似的题目会很多，而且在平常写代码过程中我们也会经常用到。</p>
<p>有时候回答比如“用 typeof 来判断”，然后就没有其他答案了，但这样的回答是不能令面试官满意的，因为他要考察你对 JS 的数据类型理解的深度，所以我们先要做到的是对各种数据类型的判断方法了然于胸，然后再进行归纳总结，给面试官一个满意的答案。</p>
<p>数据类型的判断方法其实有很多种，比如 typeof 和 instanceof，下面介绍三种在工作中经常会遇到的数据类型检测方法。</p>
<h3 id="1-2-1-第一种判读方法：typeof"><a href="#1-2-1-第一种判读方法：typeof" class="headerlink" title="1.2.1 第一种判读方法：typeof"></a>1.2.1 第一种判读方法：typeof</h3><p>这是比较常用的一种，那么我们通过一段代码来快速回顾一下这个方法。</p>
<pre><code class="js">typeof 1 // &#39;number&#39;
typeof &#39;1&#39; // &#39;string&#39;
typeof undefined // &#39;undefined&#39;
typeof true // &#39;boolean&#39;
typeof Symbol() // &#39;symbol&#39;
typeof null // &#39;object&#39;
typeof [] // &#39;object&#39;
typeof {} // &#39;object&#39;
typeof console // &#39;object&#39;
typeof console.log // &#39;function&#39;
</code></pre>
<p>你可以看到，前6个都是基础数据类型，而为什么第6个 null 的 typeof 是&#39;object&#39;呢？这里要和你强调一下，虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过&#39;===null&#39;来判断就好。</p>
<p>此外还要注意，引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 ok 以外，其余都是&#39;object&#39;，是无法判断出来的。</p>
<h3 id="1-2-2-第二种判断方法：instanceof"><a href="#1-2-2-第二种判断方法：instanceof" class="headerlink" title="1.2.2 第二种判断方法：instanceof"></a>1.2.2 第二种判断方法：instanceof</h3><p>想必 instanceof 的方法你也听说过，我们 new 一个对象，那么这个新对象就是它原型链继承上面的对象了，通过 instanceof 我们能判断这个对象是否是之前那个构造函数生成的对象，这样就基本可以判断出这个新对象的数据类型。下面通过代码来了解一下。</p>
<pre><code class="js">let Car = function() {}
let benz = new Car()
benz instanceof Car // true
let car = new String(&#39;Mercedes Benz&#39;)
car instanceof String // true
let str = &#39;Covid-19&#39;
str instanceof String // false
</code></pre>
<p>上面就是用 instanceof 方法判断数据类型的大致流程，那么如果让你自己实现一个 instanceof 的底层实现，应该怎么写呢？请看下面的代码。</p>
<pre><code class="js">function myInstanceof(left, right) {
  // 这里先用typeof来判断基础数据类型，如果是，直接返回false
  if (typeof left !== &#39;object&#39; || left === null) return false;
  // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
  let proto = Object.getPrototypeOf(left);
  while (true) {
    //无限循环的写法（也可以使用for）
    //循环往下寻找，直到找到相同的原型对象
    if (proto === null) return false; // 找到最顶层
    if (proto === right.prototype) return true; //找到相同原型对象，返回true
    proto = Object.getPrototypeOf(proto); //没找到继续向上一层原型链查找
  }
}
// 验证一下自己实现的myInstanceof是否OK
console.log(myInstanceof(new Number(123), Number)); // true
console.log(myInstanceof(123, Number));

</code></pre>
<p>现在你知道了两种判断数据类型的方法，那么它们之间有什么差异呢？我总结了下面两点：</p>
<ol>
<li><code>instanceof</code> <code>可以</code>准确判断复杂<code>引用</code>数据类型，但是<code>不能</code>正确判断<code>基础</code>数据类型；</li>
<li>而 <code>typeof</code> 也存在弊端，它虽然可以判断<code>基础</code>数据类型（null除外），但是<code>引用</code>数据类型中，除了 <code>function</code> 类型以外，其他的也无法判断。</li>
</ol>
<p>总之，不管单独用 instanceof 还是 typeof，都不能满足所有场景的需求，而只能通过二者混写的方式来判断。但是这种方式判断出来的其实也只是大多数情况，并且写起来也比较难受，其实个人比较推荐下面的第三种方法，想比上述两个而言，能更好地解决数据类型检测问题。</p>
<h3 id="1-2-3-第三种判断方法：constructor"><a href="#1-2-3-第三种判断方法：constructor" class="headerlink" title="1.2.3 第三种判断方法：constructor"></a>1.2.3 第三种判断方法：constructor</h3><p>原理：每一个实力对象都可通过constructor来访问它的构造函数，其实也是根据原型链的原理来的。</p>
<pre><code class="js">&#39;5&#39;.__proto__.constructor === String // true
[5].__proto__.constructor === Array // true

undefined.__proto__.constructor // Cannot read property &#39;__proto__&#39; of undefined

null.__proto__.constructor // Cannot read property &#39;__proto__&#39; of undefined
</code></pre>
<p>由于undefined和null是无效的对象，因此是没有constructor属性的，这两个值不能用这种方法判断。</p>
<h3 id="1-2-4-第四种判断方法：Object-prototype-toString"><a href="#1-2-4-第四种判断方法：Object-prototype-toString" class="headerlink" title="1.2.4 第四种判断方法：Object.prototype.toString"></a>1.2.4 第四种判断方法：Object.prototype.toString</h3><p><code>toString()</code> 是 <code>Object</code> 的原型方法，调用该方法，可以统一返回格式为 &quot;<code>[object Xxx]</code>&quot; 的字符串，其中 <code>Xxx</code> 就是对象的类型。对于 Object 对象，直接调用 <code>toString()</code> 就能返回 <code>[object Object]</code>；而对于其他对象，则需要通过 <code>call</code> 来调用，才能返回正确的类型信息。我们来看一下代码。</p>
<pre><code class="js">Object.prototype.toString({})       // &quot;[object Object]&quot;
Object.prototype.toString.call({})  // 同上结果，加上call也ok
Object.prototype.toString.call(1)    // &quot;[object Number]&quot;
Object.prototype.toString.call(&#39;1&#39;)  // &quot;[object String]&quot;
Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;
Object.prototype.toString.call(function(){})  // &quot;[object Function]&quot;
Object.prototype.toString.call(null)   //&quot;[object Null]&quot;
Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;
Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;
Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;
Object.prototype.toString.call([])       //&quot;[object Array]&quot;
Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;
Object.prototype.toString.call(window)   //&quot;[object Window]&quot;
</code></pre>
<p>从上面这段代码可以看出，<code>Object.prototype.toString.call()</code> 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</p>
<p>但是在写判断条件的时候一定要注意，使用这个方法最后返回统一字符串格式为&quot;<code>[object Xxx]</code>&quot;，而这里字符串里面的&quot;Xxx&quot;，<strong>第一个首字母要大写</strong>（注意：使用typeof 返回的是小写），这里需要多加留意。</p>
<p>那么下面来实现一个全局通用的数据类型判断方法，来加深理解，代码如下。</p>
<pre><code class="js">function getType(obj){
  let type  = typeof obj;
  if (type !== &quot;object&quot;) {    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type;
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#39;$1&#39;);  // 注意正则中间有个空格
}
/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */
getType([])     // &quot;Array&quot; typeof []是object，因此toString返回
getType(&#39;123&#39;)  // &quot;string&quot; typeof 直接返回
getType(window) // &quot;Window&quot; toString返回
getType(null)   // &quot;Null&quot;首字母大写，typeof null是object，需toString来判断
getType(undefined)   // &quot;undefined&quot; typeof 直接返回
getType()            // &quot;undefined&quot; typeof 直接返回
getType(function(){}) // &quot;function&quot; typeof能判断，因此首字母小写
getType(/123/g)      //&quot;RegExp&quot; toString返回
</code></pre>
<h2 id="1-3-转换"><a href="#1-3-转换" class="headerlink" title="1.3 转换"></a>1.3 转换</h2><p>在日常的业务开发中，经常会遇到 JavaScript 数据类型转换问题，有的时候需要我们主动进行强制转换，而有的时候 JavaScript 会进行隐式转换，隐式转换的时候就需要我们多加留心。</p>
<p>那么这部分都会涉及哪些内容呢？我们先看一段代码，了解下大致的情况。</p>
<pre><code class="js">&#39;123&#39; == 123   // false or true? true
&#39;&#39; == null    // false or true? false
&#39;&#39; == 0        // false or true? true
[] == 0        // false or true? true
[] == &#39;&#39;       // false or true? true
[] == ![]      // false or true? true
null == undefined //  false or true? true
Number(null)     // 返回什么？0
Number(&#39;&#39;)      // 返回什么？ 0
parseInt(&#39;&#39;);    // 返回什么？NaN
{}+10           // 返回什么？10
let obj = {
    [Symbol.toPrimitive]() {
        return 200;
    },
    valueOf() {
        return 300;
    },
    toString() {
        return &#39;Hello&#39;;
    }
}
console.log(obj + 200); // 这里打印出来是多少？400
</code></pre>
<h3 id="1-3-1-强制类型转换"><a href="#1-3-1-强制类型转换" class="headerlink" title="1.3.1 强制类型转换"></a>1.3.1 强制类型转换</h3><p>强制类型转换方式包括 <code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>、<code>toString()</code>、<code>String()</code>、<code>Boolean()</code>，这几种方法都比较类似，通过字面意思可以很容易理解，都是通过自身的方法来进行数据类型的强制转换。</p>
<p>上面代码中，第8行的结果是0，第9行的结果同样是0，第10行的结果是NaN。这些都是很明显的强制类型转换，因为用到了 Number() 和 parseInt()。</p>
<h4 id="1-3-1-1-Number-方法的强制转换规则"><a href="#1-3-1-1-Number-方法的强制转换规则" class="headerlink" title="1.3.1.1 Number()方法的强制转换规则"></a>1.3.1.1 <strong>Number()方法的强制转换规则</strong></h4><ul>
<li>如果是布尔值，true 和 false 分别被转换为 1 和 0；</li>
<li>如果是数字，返回自身；</li>
<li>如果是 null，返回0；</li>
<li>如果是 undefined，返回 NaN；</li>
<li>如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X/0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为0；如果不是以上格式的字符串，均返回 NaN；</li>
<li>如果是 Symbol，抛出错误；</li>
<li>如果是对象，并且部署了 <code>[Symbol.toPrimitive]</code>，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值（Object转换规则会在下面细讲）。</li>
</ul>
<p>下面通过一段代码来说明上述规则。</p>
<pre><code class="js">Number(true);        // 1
Number(false);       // 0
Number(&#39;0111&#39;);      //111
Number(null);        //0
Number(&#39;&#39;);          //0
Number(&#39;1a&#39;);        //NaN
Number(-0X11);       //-17
Number(&#39;0X11&#39;)       //17
Number(undefined)    // NaN
Number({})           // NaN
Number([])           // 0
</code></pre>
<p>其中，分别列举了比较常见的 Number 转换的例子，它们都会把对应的非数字类型转换成数字类型，而有一些实在无法转换成数字的，最后只能输出 NaN 的结果。</p>
<h4 id="1-3-1-2-Boolean-方法的强制转换规则"><a href="#1-3-1-2-Boolean-方法的强制转换规则" class="headerlink" title="1.3.1.2 Boolean()方法的强制转换规则"></a>1.3.1.2 <strong>Boolean()方法的强制转换规则</strong></h4><p>这个方法的规则是：除了 undefined、null、false、&#39;&#39;、0（包括+0，-0）、NaN转换出来是 false，其他都是true。</p>
<pre><code class="js">Boolean(0)          //false
Boolean(null)       //false
Boolean(undefined)  //false
Boolean(NaN)        //false
Boolean(1)          //true
Boolean(13)         //true
Boolean(&#39;12&#39;)       //true
</code></pre>
<h4 id="1-3-1-3-parseInt-方法的强制转换规则"><a href="#1-3-1-3-parseInt-方法的强制转换规则" class="headerlink" title="1.3.1.3 parseInt()方法的强制转换规则"></a>1.3.1.3 <strong>parseInt()方法的强制转换规则</strong></h4><p>只能将字符串转换成数值，与<code>Number()</code>转字符串的区别是：</p>
<ul>
<li>字符串数字开头或者负号开头，往后取值，直到非数字停止。如：<code>parseInt(&#39;123x&#39;) -&gt; 123</code>、<code>parseInt(&#39;-023x&#39;) -&gt; -23</code>，注意：<code>parseInt(&#39;-0a&#39;) -&gt; -0</code>、<code>parseInt(&#39;-0x&#39;) -&gt; NaN</code>（0x为十六进制的开头）、<code>parseInt(&#39;-abc&#39;) -&gt; NaN</code>；</li>
<li>字符串非数字或者负号开头，则为<code>NaN</code>，如：<code>parseInt(&#39;x123&#39;) -&gt; NaN</code>；</li>
<li>空字符串，返回<code>NaN</code>，如：<code>parseInt(&#39;&#39;) -&gt; NaN</code>；</li>
<li><code>parseInt(&#39;1.1&#39;) -&gt; 1</code>这也是它和 parseFloat()的区别。</li>
</ul>
<p><strong>Number() 和 parseInt() 对比的一张表</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>Number()</th>
<th>parseInt()</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#39;&#39;</td>
<td>0</td>
<td>NaN</td>
</tr>
<tr>
<td>true/false</td>
<td>1/0</td>
<td>NaN</td>
</tr>
<tr>
<td>&#39;0123&#39;</td>
<td>123</td>
<td>123</td>
</tr>
<tr>
<td>&#39;123x&#39;</td>
<td>NaN</td>
<td>123</td>
</tr>
<tr>
<td>&#39;x123&#39;</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>&#39;01.1&#39;</td>
<td>1.1</td>
<td>1</td>
</tr>
<tr>
<td>{}</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>[]</td>
<td>0</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p><strong>parseInt() 还有第二个参数</strong></p>
<p>第二个参数用于指定转换时，转换成多少进制(如2进制、8进制、10进制、16进制 等等)，默认为10进制。</p>
<pre><code class="javascript">parseInt(&#39;-023x&#39;, 8) // -19

parseInt(&#39;010&#39;, 10) // 10

parseInt(&#39;010&#39;, 8) // 8

parseInt(&#39;0x10&#39;,10) // 0

parseInt(&#39;0x10&#39;,16) // 16

parseInt(&#39;0xf&#39;, 16) // 15
</code></pre>
<p>说到这第二个参数，有一个非常经典的面试题：</p>
<pre><code class="javascript">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt) // 会得到什么结果？？？
</code></pre>
<p>如果你不假思索的写出了 <code>[1, 2, 3]</code>，那你的面试可能就会Game Over了。</p>
<p>为什么？？？</p>
<p>正确答案应该是 <code>[1, NaN, NaN]</code>... 原因就出在parseInt()的第二个参数身上：</p>
<p><em>语法</em></p>
<pre><code class="sh">parseInt(string, radix)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">必需。要被解析的字符串。</td>
</tr>
<tr>
<td style="text-align:left">radix</td>
<td style="text-align:left">可选。表示要解析的数字的基数。该值介于 2～36之间。<br>如果省略该参数或其值为0，则数字将以10为基础来解析。如果它以“0x” 或 “0X” 开头，将以16为基数。<br>如果该参数小于2或者大于36，则parseInt()将返回 NaN。</td>
</tr>
</tbody>
</table>
<p>然而，map的语法又是这样的：</p>
<pre><code class="sh">array.map(function(currentValue, index, arr), thisValue)
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/js进阶/2.png" alt></p>
<p><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code>，其实拆解出来就是： <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map((currentValue, index) =&gt; parseInt(currentValue, index))</code></p>
<p>三个值转换相当于：<code>parseInt(&#39;1&#39;, 0)</code>、<code>parseInt(&#39;2&#39;, 1)</code>、<code>parseInt(&#39;3&#39;, 2)</code></p>
<blockquote>
<ol>
<li>parseInt(&#39;1&#39;, 0) 第二个参数为0，相当没传，即默认值，也就是10进制，正确转换成1；</li>
<li>parseInt(&#39;2&#39;, 1)第二参数不合法，看文档，第二个参数是2-36的值，<em>如果该参数小于2或者大于36，则 parseInt() 将返回NaN</em>；</li>
<li>parseInt(&#39;3&#39;, 2)参数合法，但是，二进制里没有3这个数字，所以返回 NaN。</li>
</ol>
</blockquote>
<h4 id="1-3-1-4-parseFloat"><a href="#1-3-1-4-parseFloat" class="headerlink" title="1.3.1.4 parseFloat"></a>1.3.1.4 <strong>parseFloat</strong></h4><p>与 parseInt()一样，parseFloat()也可以解析以数字开头的部分数字字符串（非数字部分字符串在转换过程中会被去除）。与 parseInt() 不同的是，parseFloat() 可以将字符串转换成浮点数；但同时，parseFloat() 只接受一个参数，且仅能处理10进制字符串。</p>
<ul>
<li>字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。</li>
<li>如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后面都是零），parseFloat()会返回整数。</li>
</ul>
<pre><code class="js">parseFloat(&#39;1234blue&#39;) // 1234
parseFloat(&#39;0xA&#39;)      // 0
parseFloat(&#39;0908.5&#39;)   // 908.5
parseFloat(&#39;3.125e7&#39;)  // 31250000
parseFloat(&#39;123.45.67&#39;)// 123.45
parseFloat(&#39;&#39;)         // NaN
parseFloat(&#39;num123&#39;)   // NaN
</code></pre>
<h4 id="1-3-1-5-toString和String"><a href="#1-3-1-5-toString和String" class="headerlink" title="1.3.1.5 toString和String"></a>1.3.1.5 <strong>toString和String</strong></h4><p>String()和toString()都是将其他类型的变量转换为字符串类型。</p>
<pre><code class="js">let a = 1;
let b = 2;
console.log(String(a)) // &#39;1&#39;
console.log(typeof String(a)) // String
console.log(b.toString()) // &#39;2&#39;
console.log(typeof b.toString()) // String

String(true) // &#39;true&#39;
String(false) // &#39;false&#39;
String([])  // &#39;&#39;
String({}) // &#39;[object Object]&#39;
</code></pre>
<p>区别：toString()无法转换 null 和 undefined</p>
<pre><code class="js">let a;
let b = null;
a.toString() // Uncaught TypeError: Cannot read property &#39;toString&#39; of undefined
b.toString() // Uncaught TypeError: Cannot read property &#39;toString&#39; of null
console.log(String(a)) // &#39;undefined&#39;
console.log(String(b)) // &#39;null&#39;
</code></pre>
<h4 id="1-3-1-6-valueOf"><a href="#1-3-1-6-valueOf" class="headerlink" title="1.3.1.6 valueOf()"></a>1.3.1.6 valueOf()</h4><p>js对象中的 <code>valueOf()</code> 方法和 <code>toString()</code> 方法非常类似，但是，当需要返回对象的原始值而非字符串的时候才调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用 valueOf() 方法。</p>
<p><strong>Object.prototype.valueOf()</strong></p>
<p>JavaScript 调用 <code>valueOf()</code> 方法将对象转换为原始值。你很少需要自己调用 <code>valueOf()</code> 方法。</p>
<p>默认情况下，<code>valueOf()</code> 方法由Object 后面的每个对象继承。每个内置的核心对象都会覆盖此方法以放回适当的值。</p>
<p>如果对象没有原始值，则 <code>valueOf()</code> 将返回对象本身。</p>
<p>你可以在自己的代码中使用 <code>valueOf()</code> 将内置对象转换为原始值。创建自定义对象时，可以覆盖 <code>Object.prototype.valueOf()</code> 来调用自定义方法，而不是默认 <code>Object</code> 方法。</p>
<p><em>覆盖自定义对象的 valueOf()方法</em></p>
<p>你可以创建一个取代 <code>valueOf()</code> 方法的函数，你的方法必需不能传入参数。</p>
<p>假设你有个对象叫 <code>MyNumberType</code> 而你想为它创建一个 <code>valueOf()</code> 方法。下面的代码为 <code>valueOf()</code> 方法赋予了一个自定义函数：</p>
<pre><code class="js">MyNumberType.prototype.valueOf = function(){ 
  return customPrimitiveValue 
}
</code></pre>
<p>有了这样一个方法，下一次每当 <code>MyNumberType</code> 要被转换为原始类型值时，JavaScript 在此之前会自动调用自定义的 <code>valueOf()</code> 方法。</p>
<p>valueOf() 方法一般都会被 JavaScript 自动调用，但你也可以像下面代码那样自己调用：</p>
<pre><code class="js">myNumberType.valueOf()
</code></pre>
<p><strong>String.prototype.valueOf()</strong></p>
<p>语法：<code>strObj.valueOf()</code></p>
<p>返回值：表示给定<code>String</code>对象的原始值</p>
<p>说明：<code>valueOf()</code>方法返回一个<code>String</code>对象的原始值，该值等同于<code>String.prototype.toString()</code>。</p>
<p>该方法通常在 JavaScript 内部被调用，而不是在代码里显示调用。</p>
<pre><code class="js">let x = new String(&#39;Hello World&#39;)
console.log(x.valueOf()) // Hello World
</code></pre>
<p><strong>Date.prototype.valueOf()</strong></p>
<p>语法：<code>dateObj.valueOf()</code></p>
<p>返回值：表示给定<code>Date</code>对象的原始值</p>
<p>说明：<code>valueOf()</code>方法返回以数值格式表示的一个<code>Date</code>对象的原始值。该值从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期对象所代表时间的毫秒数。</p>
<p>该方法的功能和<code>Date.prototype.getTime()</code>方法一样。</p>
<p>该方法通常在 JavaScript 内部调用，而不是在代码中显示调用。</p>
<pre><code class="js">var x = new Date(2018,1,12)
var myVar = x.valueOf()
console.log(myVar) // 1518364800000
</code></pre>
<p><strong>Number.prototype.valueOf()</strong></p>
<p>语法：<code>numObj.valueOf()</code></p>
<p>返回值：表示给定<code>Number</code>对象的原始值。</p>
<p>说明：该方法通常在 JavaScript 内部调用，而不是在代码中显示调用。覆盖<code>Object.prototype.valueOf()</code>方法</p>
<p>案例：</p>
<pre><code class="js">var numObj = new Number(2018)
console.log(typeof numObj) // object
console.log(numObj) // Number {2018}
var num = numObj.valueOf()
console.log(typeof num) // number
console.log(num) // 2018
</code></pre>
<p><strong>Boolean.prototype.valueOf()</strong></p>
<p>语法：<code>bool.valueOf()</code></p>
<p>返回值：返回给定<code>Boolean</code>对象的原始值</p>
<p>说明：<code>Boolean</code>的<code>valueOf()</code>方法返回一个<code>Boolean</code>字面量的原始值作为布尔数据类型。该方法通常在 JavaScript 内部调用，而不是在代码中显示调用。</p>
<p>案例：</p>
<pre><code class="js">var x = new Boolean()
console.log(typeof x) // object
console.log(x) // Boolean {false}
var xv = x.valueOf()
console.log(typeof xv) // boolean
console.log(xv) // false

var y = new Boolean(&#39;weiqinl&#39;)
console.log(typeof y) // object
console.log(y.valueOf()) // true
</code></pre>
<p><strong>Symbol.prototype.valueOf()</strong></p>
<p>语法：<code>Symbol.valueOf()</code></p>
<p>返回值：返回给定<code>Symbol</code>对象的原始值</p>
<p>说明：<code>Symbol</code>的<code>valueOf()</code>方法返回<code>Symbol</code>对象的原始值作为<code>Symbol</code>数据类型。JavaScript 调用<code>valueOf()</code>方法将对象转换为原始值。</p>
<p>案例：</p>
<pre><code class="js">Object(Symbol(&#39;foo&#39;)) + &#39;bar&#39;
&gt;Uncaught TypeError: Cannot convert a Symbol value to a string at &lt;anonymous&gt;:1:23
Object(Symbol(&#39;f00&#39;)).valueOf() + &#39;bar&#39;
&gt;uncaught TypeError: Cannot convert a Symbol value to a string at &lt;anonymous&gt;:1:33
Object(Symbol(&#39;foo&#39;)).toString() + &#39;bar&#39;
&gt;&quot;Symbol(foo)bar&quot;
</code></pre>
<h4 id="1-3-1-7-总结"><a href="#1-3-1-7-总结" class="headerlink" title="1.3.1.7 总结"></a>1.3.1.7 总结</h4><table>
<thead>
<tr>
<th>值</th>
<th>Number()</th>
<th>parseInt()</th>
<th>parseFloat()</th>
<th>toString()</th>
<th>String()</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>&#39;1&#39;</td>
<td>&#39;1&#39;</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>&#39;0&#39;</td>
<td>&#39;0&#39;</td>
</tr>
<tr>
<td>&#39;&#39;</td>
<td>0</td>
<td>NaN</td>
<td>NaN</td>
<td>&#39;&#39;</td>
<td>&#39;&#39;</td>
</tr>
<tr>
<td>&#39;blue123&#39;</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>&#39;blue123&#39;</td>
<td>&#39;blue123&#39;</td>
</tr>
<tr>
<td>&#39;123blue&#39;</td>
<td>NaN</td>
<td>123</td>
<td>123</td>
<td>&#39;123blue&#39;</td>
<td>&#39;123blue&#39;</td>
</tr>
<tr>
<td>&#39;0123&#39;</td>
<td>123</td>
<td>123</td>
<td>123</td>
<td>0123&#39;</td>
<td>&#39;0123&#39;</td>
</tr>
<tr>
<td>&#39;-012.5&#39;</td>
<td>-12.5</td>
<td>-12</td>
<td>-12.5</td>
<td>&#39;-012.5&#39;</td>
<td>&#39;-012.5&#39;</td>
</tr>
<tr>
<td>&#39;012.5.5&#39;</td>
<td>NaN</td>
<td>12</td>
<td>12.5</td>
<td>&#39;0121.5.5&#39;</td>
<td>&#39;012.5.5&#39;</td>
</tr>
<tr>
<td>&#39;0xA&#39;&#39;&#39;</td>
<td>10</td>
<td>10</td>
<td>0</td>
<td>&#39;0xA&#39;</td>
<td>&#39;0xA&#39;</td>
</tr>
<tr>
<td>&#39;0x11&#39;</td>
<td>17</td>
<td>17</td>
<td>0</td>
<td>&#39;0x11&#39;</td>
<td>&#39;0x11&#39;</td>
</tr>
<tr>
<td>true</td>
<td>1</td>
<td>NaN</td>
<td>NaN</td>
<td>&#39;true&#39;</td>
<td>&#39;true&#39;</td>
</tr>
<tr>
<td>false</td>
<td>0</td>
<td>NaN</td>
<td>NaN</td>
<td>&#39;false&#39;</td>
<td>&#39;false&#39;</td>
</tr>
<tr>
<td>null</td>
<td>0</td>
<td>NaN</td>
<td>NaN</td>
<td>报错</td>
<td>&#39;null&#39;</td>
</tr>
<tr>
<td>undefined</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>报错</td>
<td>&#39;undefined&#39;</td>
</tr>
<tr>
<td>{}</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>&#39;[object Object]&#39;</td>
<td>&#39;[object Object]&#39;</td>
</tr>
<tr>
<td>[]</td>
<td>0</td>
<td>NaN</td>
<td>NaN</td>
<td>&#39;&#39;</td>
<td>&#39;&#39;</td>
</tr>
</tbody>
</table>
<h3 id="1-3-2-隐式类型转换"><a href="#1-3-2-隐式类型转换" class="headerlink" title="1.3.2 隐式类型转换"></a>1.3.2 隐式类型转换</h3><p>凡是通过逻辑运算符（&amp;&amp;、||、!）、运算符（+、-、*、/）、关系操作符（&gt;、&lt;、&lt;=、&gt;=）、相等运算符（==）或者 if/while 条件的操作，如果遇到两个数据类型不一样的情况，都会出现隐式类型转换。</p>
<p>下面着重讲解一下日常用得比较多的“==” 和 “+” 这两个符号的隐式转换规则。</p>
<h4 id="1-3-2-1-39-39-的隐式类型转换规则"><a href="#1-3-2-1-39-39-的隐式类型转换规则" class="headerlink" title="1.3.2.1 &#39;==&#39;的隐式类型转换规则"></a>1.3.2.1 &#39;==&#39;的隐式类型转换规则</h4><ul>
<li>如果类型相同，无须进行类型转换；</li>
<li>如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；</li>
<li>如果其中一个是 Symbol 类型，那么返回 false；</li>
<li>两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number；</li>
<li>如果一个操作值是 boolean，那么转换成 number；</li>
<li>如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 value/toString 方法进行转换）</li>
</ul>
<p>如果直接死记这些理论会有点懵，我们还是直接看代码，这样更容易理解一些，如下所示。</p>
<pre><code class="js">null == undefined       // true  规则2
null == 0               // false 规则2
&#39;&#39; == null              // false 规则2
&#39;&#39; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比
&#39;123&#39; == 123            // true  规则4 字符串转隐式转换成Number之后再对比
0 == false              // true  e规则 布尔型隐式转换成Number之后再对比
1 == true               // true  e规则 布尔型隐式转换成Number之后再对比
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
// 注意这里a又可以等于1、2、3
console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换
// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下
</code></pre>
<h4 id="1-3-2-2-39-39-的隐式类型转换规则"><a href="#1-3-2-2-39-39-的隐式类型转换规则" class="headerlink" title="1.3.2.2 &#39;+&#39;的隐式类型转换规则"></a>1.3.2.2 &#39;+&#39;的隐式类型转换规则</h4><p>&#39;+&#39;号操作符，不仅可以用作数字相加，还可以用作字符串拼接。仅当&#39;+&#39;号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。</p>
<p>除了上述比较常规的情况外，还有一些特殊的规则，如下所示。</p>
<ul>
<li>如果其中一个是字符串，另一个是 undefined、null或布尔型，则调用 String() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li>
<li>如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</li>
<li>如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接。</li>
</ul>
<p>下面结合代码理解上述规则，如下所示。</p>
<pre><code class="js">1 + 2        // 3  常规情况
&#39;1&#39; + &#39;2&#39;    // &#39;12&#39; 常规情况
// 下面看一下特殊情况
&#39;1&#39; + undefined   // &quot;1undefined&quot; 规则1，undefined转换字符串
&#39;1&#39; + null        // &quot;1null&quot; 规则1，null转换字符串
&#39;1&#39; + true        // &quot;1true&quot; 规则1，true转换字符串
&#39;1&#39; + 1n          // &#39;11&#39; 比较特殊字符串和BigInt相加，BigInt转换为字符串
1 + undefined     // NaN  规则2，undefined转换数字相加NaN
1 + null          // 1    规则2，null转换为0
1 + true          // 2    规则2，true转换为1，二者相加为2
1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加
&#39;1&#39; + 3           // &#39;13&#39; 规则3，字符串拼接
</code></pre>
<p>整体来看，如果数据中有字符串，JavaScript 类型转换还是更倾向于转换成字符串，因为第三条规则中可以看到再字符串和数字相加的过程中最后返回的还是字符串，这里需要关注一下。</p>
<p>了解了&#39;+&#39;的转换规则后，我们最后再看一下Object的转换规则。</p>
<h3 id="1-3-3-Object的转换规则"><a href="#1-3-3-Object的转换规则" class="headerlink" title="1.3.3 Object的转换规则"></a>1.3.3 Object的转换规则</h3><p>对象转换的规则，会先调用内置的 [ToPrimitive] 函数，其规则逻辑如下：</p>
<ul>
<li>如果部署了 Symbol.toPrimitive 方法，优先调用再返回；</li>
<li>调用 valueOf()，如果转换为基础类型，则返回；</li>
<li>调用 toString()，如果转换为基础类型，则返回；</li>
<li>如果都没有返回基础类型，会报错。</li>
</ul>
<p>直接理解有些晦涩，还是直接看代码。</p>
<pre><code class="js">var obj = {
  value: 1,
  valueOf() {
    return 2;
  },
  toString() {
    return &#39;3&#39;
  },
  [Symbol.toPrimitive]() {
    return 4
  }
}
console.log(obj + 1); // 输出5
// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&#39;31&#39;(字符串拼接)
// 再看两个特殊的case：
10 + {}
// &quot;10[object Object]&quot;，注意：{}会默认调用valueOf是{}，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&#39;+&#39;运算，按照字符串拼接规则来，参考&#39;+&#39;的规则C
[1,2,undefined,4,5] + 10
// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&#39;+&#39;的第3条规则
</code></pre>
<h1 id="2-实现深浅拷贝"><a href="#2-实现深浅拷贝" class="headerlink" title="2. 实现深浅拷贝"></a>2. 实现深浅拷贝</h1><p>开始前，先抛出两个问题，可以思考一下</p>
<ol>
<li>拷贝一个很多嵌套的对象怎么实现？</li>
<li>在面试官眼中，写成什么样的深拷贝代码才能算合格？</li>
</ol>
<h2 id="2-1-浅拷贝的原理和实现"><a href="#2-1-浅拷贝的原理和实现" class="headerlink" title="2.1 浅拷贝的原理和实现"></a>2.1 浅拷贝的原理和实现</h2><p>对于浅拷贝的定义我们可以初步理解为：</p>
<blockquote>
<p>自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象。</p>
</blockquote>
<p>下面总结了一些 JavaScript 提供的浅拷贝方法，一起来看看哪些方法能实现上述定义所描述的过程。</p>
<h3 id="2-1-1-object-assign"><a href="#2-1-1-object-assign" class="headerlink" title="2.1.1 object.assign"></a>2.1.1 object.assign</h3><p><code>object.assign</code> 是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并等多个用途，其中一个用途就是可以进行浅拷贝。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。</p>
<blockquote>
<p>object.assign 的语法为：Object.assign(target, ...sources)</p>
</blockquote>
<p>object.assign 的示例代码如下：</p>
<pre><code class="js">let target = {};
let source = { a: { b: 1 } };
Object.assign(target, source);
console.log(target); // { a: { b: 1 } };
</code></pre>
<p>从上面的代码中可以看到，通过 <code>object.assign</code> 我们的确简单实现了一个浅拷贝，“target” 就是我们新拷贝的对象，下面再看一个和上面不太一样的例子。</p>
<pre><code class="js">let target = {};
let source = { a: { b: 2 } };
Object.assign(target, source);
console.log(target); // { a: { b: 10 } }; 
source.a.b = 10; 
console.log(source); // { a: { b: 10 } }; 
console.log(target); // { a: { b: 10 } };
</code></pre>
<p>从上面代码中我们可以看到，首先通过 Object.assign 将 source 拷贝到 target 对象中，然后我们尝试将 source 对象中的 b 属性由 2 修改为 10。通过控制台可以发现，打印结果中，三个 target 里的 b 属性变为 10 了，证明 Object.assign 暂时实现了我们想要的拷贝效果。</p>
<p>但是使用 object.assign 方法有几点需要注意：</p>
<ul>
<li>它不会拷贝对象的继承属性；</li>
<li>它不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 Symbol 类型的属性。</li>
</ul>
<p>可以简单理解为：Object.assign 循环遍历原对象的属性，通过复制的方法将其赋值给目标对象的相应属性，来看一下这段代码，以验证它可以拷贝 Symbol 类型的对象。</p>
<pre><code class="js">let obj1 = { a:{ b:1 }, sym:Symbol(1)}; 
Object.defineProperty(obj1, &#39;innumerable&#39; ,{
    value:&#39;不可枚举属性&#39;,
    enumerable:false
});
let obj2 = {};
Object.assign(obj2,obj1)
obj1.a.b = 2;
console.log(&#39;obj1&#39;,obj1);
console.log(&#39;obj2&#39;,obj2);
</code></pre>
<p>我们来看一下控制台打印的结果，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/js进阶/3.png" alt></p>
<p>从上面的样例代码中可以看到，利用 object.assign 也可以拷贝 Symbol 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中依旧存在着访问共同堆内存的问题，也就是说这种方法还不能进一步复制，而只是完成了浅拷贝的功能。</p>
<h3 id="2-1-2-扩展运算符方式"><a href="#2-1-2-扩展运算符方式" class="headerlink" title="2.1.2 扩展运算符方式"></a>2.1.2 扩展运算符方式</h3><p>我们也可以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。</p>
<blockquote>
<p>扩展运算符的语法为：let cloneObj = {...obj};</p>
</blockquote>
<p>代码如下所示。</p>
<pre><code class="js">/* 对象的拷贝 */
let obj = {a:1,b:{c:1}}
let obj2 = {...obj}
obj.a = 2
console.log(obj)  //{a:2,b:{c:1}} 
console.log(obj2); //{a:1,b:{c:1}}
obj.b.c = 2
console.log(obj)  //{a:2,b:{c:2}} 
console.log(obj2); //{a:1,b:{c:2}}
/* 数组的拷贝 */
let arr = [1, 2, 3];
let newArr = [...arr]; //跟arr.slice()是一样的效果
</code></pre>
<p>扩展运算符和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。</p>
<h3 id="2-1-3-concat拷贝数组"><a href="#2-1-3-concat拷贝数组" class="headerlink" title="2.1.3 concat拷贝数组"></a>2.1.3 concat拷贝数组</h3><p>数组的 concat 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。不过 concat 只能用于数组的浅拷贝，使用场景比较局限。代码如下所示。</p>
<pre><code class="js">let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr);  // [ 1, 2, 3 ]
console.log(newArr); // [ 1, 100, 3 ]
</code></pre>
<h3 id="2-1-4-slice拷贝数组"><a href="#2-1-4-slice拷贝数组" class="headerlink" title="2.1.4 slice拷贝数组"></a>2.1.4 slice拷贝数组</h3><p>slice 方法也比较有局限性，因为它仅仅针对数组类型。slice 方法返回一个新的数组对象，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。</p>
<blockquote>
<p>slice 的语法为：arr.slice(begin, end);</p>
</blockquote>
<p>我们来看一下 slice 怎么使用，代码如下所示。</p>
<pre><code class="js">let arr = [1, 2, {val: 4}];
let newArr = arr.slice();
newArr[2].val = 1000;
console.log(arr);  //[ 1, 2, { val: 1000 } ]
</code></pre>
<p>从上面的代码中可以看出，这就是浅拷贝的限制所在了——它只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。</p>
<h3 id="2-1-5-手工实现一个浅拷贝"><a href="#2-1-5-手工实现一个浅拷贝" class="headerlink" title="2.1.5 手工实现一个浅拷贝"></a>2.1.5 手工实现一个浅拷贝</h3><p>根据以上对浅拷贝的理解，如果让你自己实现一个浅拷贝，大致的思路分为两点：</p>
<ol>
<li>对基础数据做一个最基本的拷贝；</li>
<li>对引用类型开辟一个新的存储，并且拷贝一层对象属性。</li>
</ol>
<p>那么，围绕着这两个思路，自己实现一个浅拷贝，代码如下。</p>
<pre><code class="js">const shallowClone = (target) =&gt; {
  if (typeof target === &#39;object&#39; &amp;&amp; target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
</code></pre>
<h2 id="2-2-深拷贝的原理和实现"><a href="#2-2-深拷贝的原理和实现" class="headerlink" title="2.2 深拷贝的原理和实现"></a>2.2 深拷贝的原理和实现</h2><p>浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。</p>
<p>这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，深拷贝的原理可以总结如下：</p>
<blockquote>
<p>将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p>
</blockquote>
<h3 id="2-2-1-JSON-stringify"><a href="#2-2-1-JSON-stringify" class="headerlink" title="2.2.1 JSON.stringify"></a>2.2.1 JSON.stringify</h3><p>JSON.stringify() 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 JSON 的字符串，并将对象里面的内容转换成字符串，最后再用 JSON.parse() 的方法将 JSON 字符串生成一个新的对象。示例代码如下所示。</p>
<pre><code class="js">let obj1 = { a:1, b:[1,2,3] }
let str = JSON.stringify(obj1)；
let obj2 = JSON.parse(str)；
console.log(obj2);   //{a:1,b:[1,2,3]} 
obj1.a = 2；
obj1.b.push(4);
console.log(obj1);   //{a:2,b:[1,2,3,4]}
console.log(obj2);   //{a:1,b:[1,2,3]}
</code></pre>
<p>从上面的代码可以看到，通过 JSON.stringify 可以初步实现一个对象的深拷贝，通过改变 obj1 的 b属性，其实可以看出 obj2 这个对象也不受影响。</p>
<p>但是使用 JSON.stringify 实现深拷贝还是有一些地方值得注意，总结有这几点：</p>
<ol>
<li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</li>
<li>拷贝 Date 引用类型会变成字符串；</li>
<li>无法拷贝不可枚举的属性；</li>
<li>无法拷贝对象的原型链；</li>
<li>拷贝 RegExp 引用类型会变成空对象；</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</li>
<li>无法拷贝对象的循环应用，即对象成环（obj[key]=obj）。</li>
</ol>
<p>针对这些存在的问题，可以尝试用下面这段代码亲自执行，看看如此复杂的对象，如果用 JSON.stringify 实现深拷贝会出现什么情况。</p>
<pre><code class="js">function Obj() { 
  this.func = function () { alert(1) }; 
  this.obj = {a:1};
  this.arr = [1,2,3];
  this.und = undefined; 
  this.reg = /123/; 
  this.date = new Date(0); 
  this.NaN = NaN;
  this.infinity = Infinity;
  this.sym = Symbol(1);
} 
let obj1 = new Obj();
Object.defineProperty(obj1,&#39;innumerable&#39;,{ 
  enumerable:false,
  value:&#39;innumerable&#39;
});
console.log(&#39;obj1&#39;,obj1);
let str = JSON.stringify(obj1);
let obj2 = JSON.parse(str);
console.log(&#39;obj2&#39;,obj2);
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/js进阶/4.png" alt></p>
<h3 id="2-2-2-基础版（手写递归实现）"><a href="#2-2-2-基础版（手写递归实现）" class="headerlink" title="2.2.2 基础版（手写递归实现）"></a>2.2.2 基础版（手写递归实现）</h3><p>下面是一个实现 <code>deepClone</code> 函数封装的例子，通过 <code>for in</code> 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制，代码如下所示。</p>
<pre><code class="js">let obj1 = {
  a:{
    b:1
  }
}
function deepClone(obj) { 
  let cloneObj = {}
  for(let key in obj) {                 //遍历
    if(typeof obj[key] ===&#39;object&#39;) { 
      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归
    } else {
      cloneObj[key] = obj[key]  //基本类型的话直接复制值
    }
  }
  return cloneObj
}
let obj2 = deepClone(obj1);
obj1.a.b = 2;
console.log(obj2);   //  {a:{b:1}}
</code></pre>
<p>虽然利用递归能实现一个深拷贝，但是同上面的 <code>JSON.stringify</code> 一样，还是有一些问题没有完全解决，例如：</p>
<ol>
<li>这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；</li>
<li>这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；</li>
<li>对象的属性里面成环，即循环引用没有解决。</li>
</ol>
<p>这种基础版本的写法也比较简单，可以应对大部分的应用情况。但是在面试的过程中，如果只能写出这样的一个有缺陷的深拷贝方法，有可能不会通过。</p>
<p>所以为了“拯救”这些缺陷，下面是改进版本。</p>
<h3 id="2-2-3-改进版（改进后递归实现）"><a href="#2-2-3-改进版（改进后递归实现）" class="headerlink" title="2.2.3 改进版（改进后递归实现）"></a>2.2.3 改进版（改进后递归实现）</h3><p>针对上面的几个待解决问题，先通过四点想关的理论告诉你分别应该怎么做。</p>
<ol>
<li>针对能够遍历对象的<code>不可枚举</code>属性以及 <code>Symbol</code> 类型，我们可以使用 Reflect.ownKeys 方法；</li>
<li>当参数为 <code>Date</code>、<code>RegExp</code> 类型，则直接生成一个新的实例返回；</li>
<li>利用 Object 的 <code>getOwnPropertyDescriptors</code> 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 <code>create</code> 方法创建一个新对象，并继承传入原对象的原型链；</li>
<li>利用 <code>WeakMap</code> 类型作为 <code>Hash表</code>，因为 WeakMap 是<code>弱引用类型</code>，可以有效防止<code>内存泄漏</code>（可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测<code>循环引用</code>很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。</li>
</ol>
<p>关于第4点的 WeakMap，如果不太了解，建议在面试中不要写出这样的代码，如果只是死记硬背会给自己挖坑。</p>
<p>当然，如果你在考虑到循环引用的问题之后，还能用 WeakMap 来很好地解决，并且向面试官解释这样做的目的，那么你所展示的代码，以及你对问题思考的全面性，在面试官眼中应该算是合格的了。</p>
<p>那么针对上面这几个问题，我们来看下改进后的递归实现的深拷贝代码应该是什么样子的，如下所示。</p>
<pre><code class="js">const isComplexDataType = obj =&gt; (typeof obj === &#39;object&#39; || typeof obj === &#39;function&#39;) &amp;&amp; (obj !== null)
const deepClone = function (obj, hash = new WeakMap()) {
  if (obj.constructor === Date) 
  return new Date(obj)       // 日期对象直接返回一个新的日期对象
  if (obj.constructor === RegExp)
  return new RegExp(obj)     //正则对象直接返回一个新的正则对象
  //如果循环引用了就用 weakMap 来解决
  if (hash.has(obj)) return hash.get(obj)
  let allDesc = Object.getOwnPropertyDescriptors(obj)
  //遍历传入参数所有键的特性
  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)
  //继承原型链
  hash.set(obj, cloneObj)
  for (let key of Reflect.ownKeys(obj)) { 
    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &#39;function&#39;) ? deepClone(obj[key], hash) : obj[key]
  }
  return cloneObj
}
// 下面是验证代码
let obj = {
  num: 0,
  str: &#39;&#39;,
  boolean: true,
  unf: undefined,
  nul: null,
  obj: { name: &#39;我是一个对象&#39;, id: 1 },
  arr: [0, 1, 2],
  func: function () { console.log(&#39;我是一个函数&#39;) },
  date: new Date(0),
  reg: new RegExp(&#39;/我是一个正则/ig&#39;),
  [Symbol(&#39;1&#39;)]: 1,
};
Object.defineProperty(obj, &#39;innumerable&#39;, {
  enumerable: false, value: &#39;不可枚举属性&#39; }
);
obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))
obj.loop = obj    // 设置loop成循环引用的属性
let cloneObj = deepClone(obj)
cloneObj.arr.push(4)
console.log(&#39;obj&#39;, obj)
console.log(&#39;cloneObj&#39;, cloneObj)
</code></pre>
<blockquote>
<p><strong>语法</strong>：<code>Object.create(proto[, propertiesObject])</code></p>
<p><strong>参数</strong>：<code>proto</code> 新创建对象的原型对象</p>
<p>​            <code>propertiesObject</code> 可选。如果没有指定为<code>undefined</code>，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应<code>Object.defineProperties()</code>的第二个参数。</p>
<p><strong>返回值</strong>：一个新对象，带着指定的原型对象和属性。</p>
</blockquote>
<blockquote>
<p><strong>语法</strong>：<code>Object.getPrototypeOf()</code></p>
<p><strong>参数</strong>：<code>obj</code> 要返回其原型的对象</p>
<p><strong>返回值</strong>：给定对象的原型。如果没有继承原型，则返回<code>null</code>。</p>
</blockquote>
<blockquote>
<p><strong>语法</strong>：<code>Reflect.ownKeys(target)</code></p>
<p><strong>参数</strong>：<code>target</code> 获取自身属性键的目标对象。</p>
<p><strong>返回值</strong>：由目标对象的自身属性键组成的<code>Array</code>。</p>
<p><strong>区别</strong>：Object.keys()返回属性key，但不包括不可枚举的属性<br>            Reflect.ownKeys()返回所有属性key</p>
</blockquote>
<blockquote>
<p><strong>语法</strong>：<code>Object.getOwnPropertyDescriptors(obj)</code></p>
<p><strong>参数</strong>：<code>obj</code> 任意对象</p>
<p><strong>返回值</strong>：所指定对象的所有自身属性的描述符，如果没有自身属性，则返回空对象。</p>
</blockquote>
<h1 id="3-继承实现：探究JS常见的6种继承方式"><a href="#3-继承实现：探究JS常见的6种继承方式" class="headerlink" title="3. 继承实现：探究JS常见的6种继承方式"></a>3. 继承实现：探究JS常见的6种继承方式</h1><h2 id="3-1-继承概念的探究"><a href="#3-1-继承概念的探究" class="headerlink" title="3.1 继承概念的探究"></a>3.1 继承概念的探究</h2><p>说到继承的概念，首先要说一个经典的例子。</p>
<p>先定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等，由汽车这个类可以派生出“轿车”和“货车”两个类，那么可以在汽车的基础属性上，为轿车添加一个后备箱、给货车添加一个大货箱。这样轿车和货车就是不一样的，但是二者都属于汽车这个类，这样从例子中就能详细说明汽车、轿车以及卡车之间的继承关系。</p>
<p>继承可以使得子类别具有父类的各种方法和属性，比如上面的例子中“轿车”和“货车”分别继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性。在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法。</p>
<p>继承的基本概念就初步介绍这些，下面我们就来看看 JavaScript 中都有哪些实现继承的方法。</p>
<h2 id="3-2-JS实现继承的几种方式"><a href="#3-2-JS实现继承的几种方式" class="headerlink" title="3.2 JS实现继承的几种方式"></a>3.2 JS实现继承的几种方式</h2><h3 id="3-2-1-第一种：原型链继承"><a href="#3-2-1-第一种：原型链继承" class="headerlink" title="3.2.1 第一种：原型链继承"></a>3.2.1 第一种：原型链继承</h3><p>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。</p>
<p>下面我们结合代码来了解一下。</p>
<pre><code class="js">function Parent1() {
    this.name = &#39;parent1&#39;
  this.play = [1,2,3]
}
function Child1() {
    this.type = &#39;child2&#39;
}
Child1.prototype = new Parent1()
console.log(new Child1)
</code></pre>
<p>上面的代码看似没有问题，虽然父类的方法和属性都能够访问，但其实有一个潜在的问题，再举个例子来说明这个问题。</p>
<pre><code class="js">var s1 = new Child1()
var s2 = new Child2()
s1.play.push(4)
console.log(s1.play, s2.play)
</code></pre>
<p>这段代码在控制台执行之后，可以看到结果如下：</p>
<pre><code class="js">&gt; (4) [1,2,3,4]
&gt; (4) [1,2,3,4]
</code></pre>
<p>明明只改变了 s1 的 play 属性，为什么 s2 也跟着变了呢？原因也很简单，因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</p>
<p>那么要解决这个问题的话，我们就得再看看其他的继承方式，下面我们看看能解决原型属性共享问题的第二种方法。</p>
<h3 id="3-2-2-第二种：构造函数继承（借助call）"><a href="#3-2-2-第二种：构造函数继承（借助call）" class="headerlink" title="3.2.2 第二种：构造函数继承（借助call）"></a>3.2.2 第二种：构造函数继承（借助call）</h3><p>直接通过代码来了解，如下所示。</p>
<pre><code class="js">function Parent1() {
    this.name = &#39;parent1&#39;
}
Parent1.prototype.getName = function() {
    return this.name
}
function Child1() {
    Parent1.call(this)
  this.type = &#39;child1&#39;
}
let child = new Child1()
console.log(child) // 没问题
console.log(child.getName()) // 会报错
</code></pre>
<p>执行上面的这段代码，可以得到这样的结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/js进阶/5.png" alt></p>
<p>可以看到最后打印的 child 在控制台显示，除了 Child1 的属性 type 之外，也继承了 Parent1 的属性 name。这样写的时候子类虽然能够拿到父类的属性值，解决了第一种继承方式的弊端，但问题是，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法。</p>
<p>因此，从上面的结果就可以看到构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</p>
<p>上面的两种继承方式各有优缺点，那么结合二者的优点，于是就产生了下面这种组合的继承方式。</p>
<h3 id="3-2-3-第三种：组合继承（前两种组合）"><a href="#3-2-3-第三种：组合继承（前两种组合）" class="headerlink" title="3.2.3 第三种：组合继承（前两种组合）"></a>3.2.3 第三种：组合继承（前两种组合）</h3><p>这种方式结合了前两种继承方式的优缺点，结合起来的继承，代码如下。</p>
<pre><code class="js">function Parent3() {
    this.name = &#39;parent3&#39;
  this.play = [1,2,3]
}
Parent3.prototype.getName = function() {
  return this.name
}
function Child3() {
  // 第二次调用Parent3()
  Parent3.call(this)
  this.type = &#39;child3&#39;
}
// 第一次调用 Parent3()
Child3.prototype = new Parent3()
// 手动挂上构造器，指向自己的构造函数
Child3.prototype.constructor = Child3
var s3 = new Child3()
var s4 = new Child3()
s3.play.push(4)
console.log(s3.play, s4.play) // 互不影响
console.log(s3.getName()) // 正常输出&#39;parent3&#39;
console.log(s4.getName()) // 正常输出&#39;parent3&#39;
</code></pre>
<p>执行上面的代码，可以看到控制台的输出结果，之前方法一和方法二的问题都得以解决。</p>
<p>但是这里又增加了一个新问题：通过注释我们可以看到 Parent3 执行了两次，第一次是改变 Child3 的 prototype 的时候，第二次是通过 call 方法调用 Parent3 的时候，那么 Parent3 多构造一次就多进行了一次性能开销，这是我们不愿看到的。</p>
<p>那么是否有更好的办法解决这个问题呢？下面的第六种继承方式可以更好地解决这里的问题。</p>
<p>上面介绍的更多是围绕着构造函数的方式，那么对于 JavaScript 的普通对象，怎么实现继承呢？</p>
<h3 id="3-2-4-第四种：原型式继承"><a href="#3-2-4-第四种：原型式继承" class="headerlink" title="3.2.4 第四种：原型式继承"></a>3.2.4 第四种：原型式继承</h3><p>这里不得不提到的就是 ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数）。</p>
<p>我们通过一段代码，看看普通对象是怎么实现的继承。</p>
<pre><code class="js">let parent4 = {
    name: &#39;parent4&#39;,
  friends: [&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;],
  getName: function() {
        return this.name
  }
}

let person4 = Object.create(parent4)
person4.name = &#39;tom&#39;
person4.friends.push(&#39;jerry&#39;)

let person5 = Object.create(parent4)
person5.friends.push(&#39;lucy&#39;)

console.log(person4.name) // &#39;tom&#39;
console.log(person4.name === person4.getName()) // true
console.log(person5.name) // &#39;parent4&#39;
console.log(person4.friends) // [&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;, &#39;jerry&#39;, &#39;lucy&#39;]
console.log(person5.friends) // [&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;, &#39;jerry&#39;, &#39;lucy&#39;]
</code></pre>
<p>从上面的代码中可以看到，通过 Object.create 这个方法可以实现普通对象的继承，不仅仅能继承属性，同样也可以继承 getName 的方法。</p>
<p>第一个结果“tom”，比较容易理解，perosn4 继承了 parent4 的 name 属性，但是在这个基础上又进行了自定义。</p>
<p>第二个是继承过来的 getName 方法检查自己的 name 是否和属性里面的值一样，答案是 true。</p>
<p>第三个结果“parent4”也比较容易理解，person5 继承了 parent4 的 name 属性，没有进行覆盖，因此输出父对象的属性。</p>
<p>最后两个输出结果是一样的，讲到这里应该可以联想到 2 讲中浅拷贝的知识点，关于引用数据类型“共享”的问题，其实 Object.create 方法是可以为一些对象实现浅拷贝的。</p>
<p>那么关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能，接下来我们看一下在这个继承基础上进行优化之后的另一种继承方式——寄生式继承。</p>
<h3 id="3-2-5-第五种：寄生式继承"><a href="#3-2-5-第五种：寄生式继承" class="headerlink" title="3.2.5 第五种：寄生式继承"></a>3.2.5 第五种：寄生式继承</h3><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫做寄生式继承。</p>
<p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。那么我们看一下代码是怎么实现。</p>
<pre><code class="js">let parent5 = {
    name: &#39;parent5&#39;,
  friends: [&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;],
  getName: function() {
        return this.name
  }
}
function clone(original) {
    let clone = Object.create(original)
  clone.getFriends = function() {
    return this.friends
  }
  return clone
}
let person5 = clone(parent5)
console.log(person5.getName()) // &#39;parent5&#39;
console.log(person5.getFriends()) // [&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;]
</code></pre>
<p>通过上面这段代码，我们可以看到 person5 是通过寄生式继承生成的实例，它不仅仅有 getName 的方法，而且可以看到它最后也拥有了 getFriends 的方法。</p>
<p>从最后的的输出结果可以看到，person5 通过 clone 的方法，增加了 getFriends 的方法，从而使 person5 这个普通对象在继承过程中又增加了一个方法，这样的继承方式就是寄生式继承。</p>
<p>在上面第三种组合继承方式中提到了一些弊端，即两次调用父类的构造函数造成浪费，下面要介绍的寄生组合继承就可以解决这个问题。</p>
<h3 id="3-2-5-第六种：寄生组合式继承"><a href="#3-2-5-第六种：寄生组合式继承" class="headerlink" title="3.2.5 第六种：寄生组合式继承"></a>3.2.5 第六种：寄生组合式继承</h3><p>结合第四种中提及的继承方式，解决普通对象的继承问题的 Object.create 方法，我们在前面这几种继承方式的优缺点基础上进行改造，得出了寄生组合式的继承方式，这也是所有继承方式里面相对最优的继承方式，代码如下。</p>
<pre><code class="js">function clone(parent, child) {
 // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
  child.prototype = Object.create(parent.prototype)
  child.prototype.constructor = child
}
function Parent6() {
    this.name = &#39;parent6&#39;
  this.play = [1,2,3]
}
Parent6.prototype.getName = function() {
    return this.name
}
function Child6() {
    Parent6.call(this)
  this.friends = &#39;child5&#39;
}
clone(Parent6, Child6)
Child6.prototype.getFriends = function() {
    return this.friends
}

let person6 = new Child6()
console.log(person6)
console.log(person6.getName())
console.log(person6.getFriends())
</code></pre>
<p>通过这段代码可以看出来，这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销，我们来看一下上面这一段代码的执行结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/js进阶/6.png" alt></p>
<p>可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题，可以输出预期的结果。</p>
<p>整体看下来，这六种继承方式中，寄生组合式继承是这六种里面最优的继承方式。另外，ES6还提到了继承的关键字 <code>extends</code>，我们再看下 <code>extends</code>的底层实现继承的逻辑。</p>
<h3 id="3-2-6-ES6的-extends-关键字实现逻辑"><a href="#3-2-6-ES6的-extends-关键字实现逻辑" class="headerlink" title="3.2.6 ES6的 extends 关键字实现逻辑"></a>3.2.6 ES6的 extends 关键字实现逻辑</h3><p>我们可以利用 <code>ES6</code> 里的 <code>extends</code> 语法糖，使用关键词很容易直接实现 JavaScript 的继承，但是如果想深入了解 <code>extends</code> 语法糖是怎么实现的，就得深入研究 <code>extends</code> 的底层逻辑。</p>
<p>我们先看下 <code>extends</code> 如何直接实现继承，代码如下。</p>
<pre><code class="js">class Person {
    constructor(name) {
    this.name = name
  }
  // 原型方法
  // 即 Person.prototype.getName = function(){}
  // 下面可以简写为 getName(){...}
  getName = function(){
        console.log(&#39;Person:&#39;, this.name)
  }
}
class Gamer extends Person {
    constructor(name, age) {
    // 子类中存在构造函数，则需要在使用‘this’之前先调用 super()
    super(name)
    this.age = age
  }
}
const asuna = new Gamer(&#39;Asuna&#39;, age)
asuna.getName() // 成功访问到父类的方法
</code></pre>
<p>因为浏览器的兼容性问题，如果遇到不支持 ES6 的浏览器，那么就得利用 <code>babel</code>这个编译工具，将 ES6 的代码编译成 ES5，让一些不支持新语法的浏览器也能运行。</p>
<p>那么最后 extends 编译成了什么样子呢？我们看一下转译之后的代码片段。</p>
<pre><code class="js">function _possibleConstructorReturn(self, call) {
    // ...
    return call &amp;&amp; (typeof call === &#39;object&#39; || typeof call === &#39;function&#39;) ? call : self;
}
function _inherits(subClass, superClass) {
    // 这里可以看到
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Parent = function Parent() {
    // 验证是否是 Parent 构造出来的 this
    _classCallCheck(this, Parent);
};
var Child = (function (_Parent) {
    _inherits(Child, _Parent);
    function Child() {
        _classCallCheck(this, Child);
        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));
    }
    return Child;
}(Parent));
</code></pre>
<p>从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/js进阶/7.png" alt></p>
<p>通过 <code>Object.create</code> 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 <code>extends</code> 的语法糖和寄生组合继承的方式基本类似。</p>
<p>综上，我们可以看到不同的继承方式有不同的优缺点，我们需要深入了解各种方式的优缺点，这样才能在日常开发中，选择最适合当前场景的继承方式。</p>
<h1 id="4-继承进阶：如何实现new、apply、call、bind的底层逻辑"><a href="#4-继承进阶：如何实现new、apply、call、bind的底层逻辑" class="headerlink" title="4.继承进阶：如何实现new、apply、call、bind的底层逻辑"></a>4.继承进阶：如何实现new、apply、call、bind的底层逻辑</h1><h2 id="4-1-方法的基本介绍"><a href="#4-1-方法的基本介绍" class="headerlink" title="4.1 方法的基本介绍"></a>4.1 方法的基本介绍</h2><h3 id="4-1-1-new原理介绍"><a href="#4-1-1-new原理介绍" class="headerlink" title="4.1.1 new原理介绍"></a>4.1.1 new原理介绍</h3><p><code>new</code> 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 <code>new</code> 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递。下面我们通过一段代码来看一个简单的 new 的例子。</p>
<pre><code class="js">function Person() {
    this.name = &#39;Jack&#39;
}
var p = new Person()
console.log(p.name) // &#39;Jack&#39;
</code></pre>
<p>这段代码比较容易理解，从输出结果可以看出，p 是一个通过 person 这个构造函数生成的一个实例对象，这个应该很容易理解。那么 new 在这个生成实例的过程中到底进行了哪些步骤来实现呢？总结下来大致分为以下几个步骤。</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（this指向新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<p>那么问题来了，如果不用 new 这个关键词，结合上面的代码改造一下，去掉 new，会发生什么样的变化呢？我们再来看下面这段代码。</p>
<pre><code class="js">function Person() {
    this.name = &#39;Jack&#39;
}
var p = Person()
console.log(p) // undefined
console.log(name) // &#39;Jack&#39;
console.log(p.name) // &#39;name&#39; of undefined
</code></pre>
<p>从上面的代码中可以看到，我们没有使用 <code>new</code> 这个关键词，返回的结果就是 <code>undefined</code>。其中由于 JavaScript 代码在默认情况下 <code>this</code> 的指向是 <code>window</code>，那么 name 的输出结果就为 Jack，这是一种不存在 <code>new</code> 关键词的情况。</p>
<p>那么当构造函数中有 <code>return</code> 一个对象的操作，结果又会是什么样子呢？我们再来看一段在上面的基础上改造过的代码。</p>
<pre><code class="js">function Person(){
   this.name = &#39;Jack&#39;; 
   return {age: 18}
}
var p = new Person(); 
console.log(p)  // {age: 18}
console.log(p.name) // undefined
console.log(p.age) // 18
</code></pre>
<p>通过这段代码又可以看出，当构造函数最后 <code>return</code> 出来的是一个和<code>this</code> 无关的对象时，<code>new</code> 命令会直接返回这个新对象，而不是通过 <code>new</code> 执行步骤生成的 <code>this</code> 对象。</p>
<p>但是这里要求构造函数必须是返回一个对象，如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象。接下来还是在上面这段代码的基础之上稍微改动一下。</p>
<pre><code class="js">function Person(){
   this.name = &#39;Jack&#39;; 
   return &#39;tom&#39;;
}
var p = new Person(); 
console.log(p)  // {name: &#39;Jack&#39;}
console.log(p.name) // Jack
</code></pre>
<p>可以看出，当构造函数中 return 的不是一个对象时，那么它还是会根据 new 关键词的执行逻辑，生成一个新的对象（绑定了最新 this ），最后返回出来。</p>
<blockquote>
<p>总结：new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。</p>
</blockquote>
<h3 id="4-1-2-apply-amp-call-amp-bind-原理介绍"><a href="#4-1-2-apply-amp-call-amp-bind-原理介绍" class="headerlink" title="4.1.2 apply &amp; call &amp; bind 原理介绍"></a>4.1.2 apply &amp; call &amp; bind 原理介绍</h3><p>先来了解一下这三个方法的基本情况，call、apply和bind是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数。</p>
<p>请看这三个函数的基本语法。</p>
<pre><code class="js">func.call(thisArg, param1, param2, ...)
func.apply(thisArg, [param1,param2,...])
func.bind(thisArg, param1, param2, ...)
</code></pre>
<p>其中 <code>func</code> 是要调用的函数，<code>thisArg</code> 一般为 <code>this</code> 所指向的对象，后面的 <code>param1、2</code> 为函数 <code>func</code> 的多个参数，如果 <code>func</code> 不需要参数，则后面的<code>param1、2</code> 可以不写。</p>
<p>这三个方法共有的、比较明显的<code>作用</code>就是，都可以改变函数 <code>func</code> 的 <code>this</code> 指向。<code>call</code>和 <code>apply</code> 的<code>区别</code>在于，传参的写法不同：apply 的第 2 个参数为数组； call 则是从第 2 个至第 N 个都是给 func 的传参；而 <code>bind</code> 和这两个（call、apply）又不同，<code>bind</code> 虽然改变了 <code>func</code> 的 <code>this</code> 指向，但不是马上执行，而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。</p>
<p>这几个方法的区别和原理基本讲清楚了，但是理解起来是不是很抽象呢？那么我举个形象的例子再配合着代码一起看下。</p>
<p>例如，生活中我不经常做饭，家里没有锅，周末突然想给自己做个饭尝尝。但是家里没有锅，而我又不想出去买，所以就问隔壁邻居借了一个锅来用，这样做了饭，又节省了开销，一举两得。</p>
<p>对应在程序中：A 对象有个 getName 的方法，B 对象也需要临时使用同样的方法，那么这时候我们是单独为 B 对象扩展一个方法，还是借用一下 A 对象的方法呢？当然是可以借用 A 对象的 getName 方法，既达到了目的，又节省重复定义，节约内存空间。</p>
<p>为了更好地掌握这部分概念，我们结合一段代码再深入理解一下这几个方法。</p>
<pre><code class="js">let a = {
  name: &#39;jack&#39;,
  getName: function(msg) {
    return msg + this.name;
  } 
}
let b = {
  name: &#39;lily&#39;
}
console.log(a.getName(&#39;hello~&#39;));  // hello~jack
console.log(a.getName.call(b, &#39;hi~&#39;));  // hi~lily
console.log(a.getName.apply(b, [&#39;hi~&#39;]))  // hi~lily
let name = a.getName.bind(b, &#39;hello~&#39;);
console.log(name());  // hello~lily
</code></pre>
<p>从上面的代码执行的结果中可以发现，使用这三种方式都可以达成我们想要的目标，即通过改变 this 的指向，让 b 对象可以直接使用 a 对象中的 getName 方法。从结果中可以看到，最后三个方法输出的都是和 lily 相关的打印结果，满足了我们的预期。</p>
<p>关于这三个方法的原理相关先介绍到这里，我们再看看这几个方法的使用场景。</p>
<h2 id="4-2-方法的应用场景"><a href="#4-2-方法的应用场景" class="headerlink" title="4.2 方法的应用场景"></a>4.2 方法的应用场景</h2><p>下面几种应用场景，多加体会就会发现它们的理念都是“借用”方法的思路。我们来看看都有哪些。</p>
<h3 id="4-2-1-判断数据类型"><a href="#4-2-1-判断数据类型" class="headerlink" title="4.2.1 判断数据类型"></a>4.2.1 判断数据类型</h3><p>用  <code>Object.prototype.toString</code> 来判断类型是最合适的，借用它我们几乎可以判断所有类型的数据，之前1.2.4数据类型的判读讲过。</p>
<pre><code class="js">function getType(obj) {
    let type = typeof obj
  if (type != &#39;object&#39;) {
    return type
  }
  return Object.prototype.toString.call(obj).replace(/^$/,&#39;$1&#39;)
}
</code></pre>
<p>结合上面这段代码，以及在前面讲的 <code>call</code> 的方法的“借用”思路，那么判断数据类型就是借用了 <code>Object</code> 的原型链上的 <code>toString</code> 方法，最后返回用来判断传入的 obj 的字符串，来确定最后的数据类型，这里就不再多做讲解了。</p>
<h3 id="4-2-2-类数组借用方法"><a href="#4-2-2-类数组借用方法" class="headerlink" title="4.2.2 类数组借用方法"></a>4.2.2 类数组借用方法</h3><p>类数组相关知识会在第二个模块“深入数组”中详细介绍，这里先简单说一下，类数组因为不是真正的数组，所以没有数组类型上自带的种种方法，所以我们就可以利用一些方法去借用数组的方法，比如借用数组的 push 方法，看下面的一段代码。</p>
<pre><code class="js">var arrayLike = {
    0: &#39;java&#39;,
  1: &#39;script&#39;,
  length: 2
}
Array.prototype.push.call(arrayLike, &#39;jack&#39;, &#39;lily&#39;)
console.log(typeof arrayLike) // &#39;object&#39;
console.log(arrayLike)
// {0: &#39;java&#39;, 1: &#39;script&#39;, 2: &#39;jack&#39;, 3: &#39;lily&#39;, length: 4}
</code></pre>
<p>从上面的代码中可以看到，arrayLike 是一个对象，模拟数组的一个类数组。从数据类型上看，它是一个对象。从上面的代码中可以看出，用 typeof 来判断输出的是&#39;object&#39;，它自身是不会有数组的 push 方法的，这里我们就用 call 的方法来借用 Array 原型链上的 push 方法，可以实现一个类数组的 push 方法，给 arrayLike 添加新的元素。</p>
<p>从上面的控制台可以看出，push 满足了我们想要实现添加元素的诉求。</p>
<h3 id="4-2-3-获取数组的最大-最小值"><a href="#4-2-3-获取数组的最大-最小值" class="headerlink" title="4.2.3 获取数组的最大/最小值"></a>4.2.3 获取数组的最大/最小值</h3><p>我们可以用 apply 来实现数组中判断最大/最小值，apply 直接传递数组作为调用方法的参数，也可以减少一步展开数组，可以直接使用 Math.max、Math.min 来获取数组的最大值/最小值，请看下面这段代码。</p>
<pre><code class="js">let arr = [13,6,10,11,16]
const max = Math.max.apply(Math, arr)
const min = Math.min.apply(Math, arr)
console.log(max) // 16
console.log(min) // 6
</code></pre>
<h3 id="4-2-4-继承"><a href="#4-2-4-继承" class="headerlink" title="4.2.4 继承"></a>4.2.4 继承</h3><p>我们在上一讲中说到了继承，它与 new 、call 共同实现了各种各样的继承方式。那么下面我们结合着这一讲的内容再来回顾一下组合继承方式，代码如下。</p>
<pre><code class="js">function Parent3() {
    this.name = &#39;parent3&#39;
  this.play = [1,2,3]
}
Parent3.prototype.getName = function() {
  return this.name
}
function Child3() {
  Parent3.call(this)
  this.type = &#39;child3&#39;
}
Child3.prototype = new Parent3()
Child3.prototype.constructor = Child3
var s3 = new Child3()
console.log(s3.getName()) // &#39;parent3&#39;
</code></pre>
<h2 id="4-3-如何自己实现这些方法"><a href="#4-3-如何自己实现这些方法" class="headerlink" title="4.3 如何自己实现这些方法"></a>4.3 如何自己实现这些方法</h2><p>手写实现new、call、apply、bind一直是比较高频的题目，结合本讲的内容，我们一起来手工实现一下这几个方法。</p>
<h3 id="4-3-1-new的实现"><a href="#4-3-1-new的实现" class="headerlink" title="4.3.1 new的实现"></a>4.3.1 new的实现</h3><p>我们刚才在讲 new 的原理时，介绍了执行 new 的过程。那么来看下在这过程中，new 被调用后大致做了哪几件事情。</p>
<ol>
<li>让实例可以访问到私有属性；</li>
<li>让实例可以返回构造函数原型（constructor.prototype）所在原型链上的属性；</li>
<li>构造函数返回的最后结果是引用数据类型。</li>
</ol>
<pre><code class="js">function _new(ctor, ...args) {
    if (typeof ctor != &#39;function&#39;) {
    throw &#39;ctor must be a function&#39;
  }
  let obj = new Object()
  obj.__proto__ = Object.create(ctor.prototype)
  let res = ctor.apply(obj, [...args])

  let isObject = typeof res === &#39;object&#39; &amp;&amp; res !== null
  let isFunction = typeof res === &#39;function&#39;
  return isObject || isFunction ? res : obj
}
</code></pre>
<p>接下来我们再看看 apply 和 call 的实现方法。</p>
<h3 id="4-3-2-apply-和-call-的实现"><a href="#4-3-2-apply-和-call-的实现" class="headerlink" title="4.3.2 apply 和 call 的实现"></a>4.3.2 apply 和 call 的实现</h3><p>由于 apply 和 call 基本原理是差不多的，只是参数存在区别，因此我们将这两个的实现方法放在一起讲。</p>
<p>依然是结合方法“借用”的原理，我们一起来思考一下这两个方法如何实现，请看下面实现的代码。</p>
<pre><code class="js">Function.prototype.call = function(context, ..args) {
    var context = context || window
  context.fn = this
  var result = eval(&#39;context.fn(...args)&#39;)
  delete context.fn
  return result
}
Function.prototype.apply = function(context, args) {
    let context = context || window
  context.fn = this
  let result = eval(&#39;context.fn(...args)&#39;)
  delete context.fn
  return result
}
</code></pre>
<p> 从上面的代码可以看出，实现 call 和 apply 的关键就在 eval 这行代码。其中显示了用 context 这个临时变量来指定上下文，然后还是通过执行 eval 来执行 context.fn 这个函数，最后返回 result。</p>
<p>要注意这两个方法和 bind 的区别就在于，这两个方法是直接返回执行结果，而 bind 方法是返回一个函数，因此这里直接用 eval 执行得到结果。</p>
<p>另一种写法</p>
<pre><code class="js">&lt;!-- mycall.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;link rel=&quot;shortcut icon&quot; href=&quot;./myicon.ico&quot;&gt;
  &lt;title&gt;手写call&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;script&gt;
    // Function.prototype.call方法
    // 接受 1+ 个参数
    // 第一个参数指明了调用call方法的函数中this的指向
    // 后面的参数作为调用call方法的函数的参数
    // 如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象
    // 使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。

    // thisArg为null或undefined时默认指向window
    Function.prototype.mycall = function (thisArg = window, ...args) {
      // 创建一个独一无二的symbol：fn
      let fn = Symbol(&#39;thisFn&#39;);
      // 将fn作为属性添加到thisArg上
      thisArg[fn] = this;
      // 执行thisArg[fn], 并储存返回值
      let res = thisArg[fn](...args);
      // 删除该方法以避免对传入对象造成污染
      delete thisArg[fn];
      // 返回函数执行的返回值
      return res;
    }

    // 情景1：普通函数
    let xiaohua = {
      name: &#39;xiaohua&#39;,
      fn() {
        console.log(&#39;xiaohua.fn&#39;, 1);
      }
    }

    let xiaohuang = {
      name: &#39;xiaohuang&#39;,
      intr(...args) {
        console.log(&#39;hello, myname is &#39; + this.name);
        return Array.from(args).reduce((total, item) =&gt; total + item, 0);
      }
    }

    xiaohua.fn();  // xiaohua.fn, 1
    let res = xiaohuang.intr.mycall(xiaohua, 1, 2, 3, 4, 5);  // &#39;hello, myname is xiaohua&#39;    
    console.log(res);  // 15
    // symbol不和任何属性重名，不会污染源对象
    xiaohua.fn();  // xiaohua.fn, 1

    // 情景2： 构造函数
    let Animal = function (name) {
      this.name = name;
    }

    let Cat = function (name, color) {
      Animal.mycall(this, name);
      this.color = color;
    }

    let cat = new Cat(&#39;tom&#39;, &#39;red&#39;);

    console.log(cat);   // Cat.{name: &quot;tom&quot;, color: &quot;red&quot;}
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h3 id="4-3-3-bind的实现"><a href="#4-3-3-bind的实现" class="headerlink" title="4.3.3 bind的实现"></a>4.3.3 bind的实现</h3><p>结合上面两个方法的实现，bind的实现思路基本和 apply 一样，但是在最后实现返回结果这里，bind 和 apply 有着比较大的差异，bind 不需要直接执行，因此不再需要用 eval，而是需要通过返回一个函数的方式将结果返回，之后再通过执行这个结果，得到想要的执行效果。</p>
<pre><code class="js">Function.prototype.bind = function (context, ...args) {
    if (typeof this !== &quot;function&quot;) {
      throw new Error(&quot;this must be a function&quot;);
    }
    var self = this;
    var fbound = function () {
        self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));
    }
    if(this.prototype) {
      fbound.prototype = Object.create(this.prototype);
    }
    return fbound;
}
</code></pre>
<p>从上面的代码中可以看到，实现 bind 的核心在于返回的时候需要返回一个函数，故这里的 fbound 需要返回，但是在返回的过程中原型链对象上的属性不能丢失。因此这里需要用 Object.create 方法，将 this.prototype 上面的属性挂到 fbound 的原型上面，最后再返回 fbound。这样调用 bind 方法接收到函数的对象，再通过执行接收的函数，即可得到想要的结果。</p>
<p><a href="https://www.jianshu.com/p/7099023ec069" target="_blank" rel="noopener">手写call</a></p>
<p><a href="https://blog.csdn.net/qq_43201542/article/details/107946851" target="_blank" rel="noopener">如何手写一个call，apply，bind</a></p>
<h1 id="5-函数那些事：JS闭包难点剖析"><a href="#5-函数那些事：JS闭包难点剖析" class="headerlink" title="5. 函数那些事：JS闭包难点剖析"></a>5. 函数那些事：JS闭包难点剖析</h1><h2 id="5-1-作用域基本介绍"><a href="#5-1-作用域基本介绍" class="headerlink" title="5.1 作用域基本介绍"></a>5.1 作用域基本介绍</h2><p>JavaScript 的作用域通俗来讲，就是指变量能够被访问到的范围，在 JavaScript 中作用域也分为好几种，ES5 之前只有全局作用域和函数作用域两种。ES6 出现之后，又新增了块级作用域，下面我们就来看看这三种作用域的概念，为闭包的学习打好基础。</p>
<h3 id="5-1-1-全局作用域"><a href="#5-1-1-全局作用域" class="headerlink" title="5.1.1 全局作用域"></a>5.1.1 全局作用域</h3><p>在编程语言中，不论 Java 也好，JavaScript 也罢，变量一般都会分为<code>全局变量</code>和<code>局部变量</code>两种。那么变量定义在函数外部，代码最前面的一般情况下都是<code>全局变量</code>。</p>
<p>在 JavaScript 中，全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个全局变量。下面通过看一段代码来说明一下什么是全局的作用域。</p>
<pre><code class="js">var globalName = &#39;global&#39;
function getName() {
    console.log(globalName) // &#39;global&#39;
  var name = &#39;inner&#39;
  console.log(name) // &#39;inner&#39;
}
getName()
console.log(name) // 
console.log(globalName) // &#39;global&#39;
function setName() {
    vName = &#39;setName&#39;
}
setName()
console.log(vName) // &#39;setName&#39;
console.log(window.vName) // &#39;setName&#39;
</code></pre>
<p>从这段代码中我们可以看到，<code>globalName</code> 这个变量无论在什么地方都是可以被访问到的，所以它就是<code>全局变量</code>。而在 <code>getName</code> 函数中作为局部变量的 <code>name</code> 变量是不具备这种能力的。</p>
<p>如果在 JavaScript 中所有没有经过定义，而直接被赋值的变量默认就是一个全局变量，比如上面代码中 <code>setName</code> 函数里面的<code>vName</code>变量一样。</p>
<p>我们可以发现全局变量也是拥有全局的作用域，无论你在何处都可以使用它，在浏览器控制台输入 <code>window.vName</code> 的时候，就可以访问到 <code>window</code> 上所有全局变量。</p>
<p>当然全局作用域有相应的缺点，我们定义很多全局变量的时候，会容易引起变量命名的冲突，所以在定义变量的时候应该注意作用域的问题。</p>
<h3 id="5-1-2-函数作用域"><a href="#5-1-2-函数作用域" class="headerlink" title="5.1.2 函数作用域"></a>5.1.2 函数作用域</h3><p>在 JavaScript 中，函数中定义的变量叫作<code>函数变量</code>，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为 <code>函数作用域</code>，下面我们来看一段代码。</p>
<pre><code class="js">function getName () {
  var name = &#39;inner&#39;;
  console.log(name); //inner
}
getName();
console.log(name);
</code></pre>
<p>上面代码中，<code>name</code> 这个变量是在 <code>getName</code> 中进行定义的，所以 <code>name</code> 是一个局部的变量，它的作用域就是在 <code>getName</code> 这个函数里边，也称作 <code>函数作用域</code>。</p>
<p>除了这个函数内部，其他地方都是不能访问它的。同时，当这个函数被执行完之后，这个局部变量也相应会被销毁。所以你会看到在 <code>getName</code> 函数外面的 <code>name</code> 是访问不到的。</p>
<h3 id="5-1-3-块级作用域"><a href="#5-1-3-块级作用域" class="headerlink" title="5.1.3 块级作用域"></a>5.1.3 块级作用域</h3><p>ES6 中新增了块级作用域，最直接的表现就是新增的 <code>let</code> 关键词，使用 <code>let</code> 关键词定义变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。</p>
<p>听起来好像还不是很能理解块级作用域的意思，那么我们来举个更形象例子，看看到底哪些才是块级作用域呢？其实就是在 JS 编码过程中 <code>if</code> 语句及 <code>for</code> 语句后面<code>{...}</code> 这里面所包括的，就是<code>块级作用域</code>。</p>
<p>下面结合一段代码来说明。</p>
<pre><code class="js">console.log(a) //a is not defined
if(true){
  let a = &#39;123&#39;；
  console.log(a)； // 123
}
console.log(a) //a is not defined
</code></pre>
<p>从这段代码可以看出，变量 <code>a</code> 是在 <code>if</code>语句<code>{...}</code>中由<code>let</code>关键词进行定义的变量，所以它的作用域是<code>if</code>语句括号中的那部分，而在外面进行访问<code>a</code>变量是会报错的，因为这里不是它的作用域。所以在 <code>if</code>代码块的前后输出<code>a</code>这个变量的结果，控制台会显示<code>a</code>并没有定义。</p>
<p>那么有了上面这几种作用域的概念做铺垫之后，下面我们就可以来学习闭包的概念。</p>
<h2 id="5-2-什么是闭包？"><a href="#5-2-什么是闭包？" class="headerlink" title="5.2 什么是闭包？"></a>5.2 什么是闭包？</h2><p>先来看下红宝书上和 MDN 上给出的闭包的概念。</p>
<blockquote>
<p>红宝书：闭包是指有权访问另外一个函数作用域中的变量的函数。</p>
</blockquote>
<blockquote>
<p>MDN：一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。</p>
</blockquote>
<h3 id="5-2-1-闭包的基本概念"><a href="#5-2-1-闭包的基本概念" class="headerlink" title="5.2.1 闭包的基本概念"></a>5.2.1 闭包的基本概念</h3><p>通俗来讲：闭包其实就是一个可以访问其他函数内部变量的<strong>函数</strong>。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。</p>
<p>因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。下面我们通过代码先来看一个简单的例子。</p>
<pre><code class="js">function fun1() {
    var a = 1
  return function() {
        console.log(a)
  }
}
fun1()
var result = fun1()
result() // 1
</code></pre>
<p>结合闭包的概念，我们把这段代码放到控制台执行一下，就可以发现最后输出的结果是 1 （即a变量的值）。那么可以很清楚地发现，a变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值。</p>
<h3 id="5-2-2-闭包产生的原因"><a href="#5-2-2-闭包产生的原因" class="headerlink" title="5.2.2 闭包产生的原因"></a>5.2.2 闭包产生的原因</h3><p>我们在前面介绍了作用域的概念，那么你还需要明白<code>作用域链</code>的基本概念。其实很简单，当访问一个变量时，代码解释器会首先在当前作用域查找，如果没找到，就去父级作用域查找，直到找到该变量或者不存在父级作用域中，这样的链路就是<code>作用域链</code>。</p>
<p>需要注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。那么我们还是通过下面的代码来详细说明一下作用域链。</p>
<pre><code class="js">var a = 1
function fun1() {
  var a = 2
  function fun2() {
        var a = 3
    console.log(a) // 3
  }
}
</code></pre>
<p>从中可以看出，fun1 函数的作用域指向全局作用域（window）和它自己本身；fun2 函数的作用域指向全局作用域 （window）、fun1 和它本身；而作用域是从最底层向上找，直到找到全局作用域 window 为止，如果全局还没有的话就会报错。</p>
<p>那么这就很形象地说明了什么是作用域链，即当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。</p>
<p>由此可见，闭包产生的本质就是：<strong>当前环境中存在指向父级作用域的引用</strong>。那么还是拿上的代码举例。</p>
<pre><code class="js">function fun1() {
  var a = 2
  function fun2() {
    console.log(a);  //2
  }
  return fun2;
}
var result = fun1();
result();
</code></pre>
<p>从上面这段代码可以看出，这里 result 会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对 fun2 函数的引用，fun2 函数恰恰引用了 window、fun1 和 fun2 的作用域。因此 fun2 函数是可以访问到 fun1 函数的作用域的变量。</p>
<p>那是不是只有返回函数才算是产生了闭包呢？其实也不是，回到闭包的本质，<strong>我们只需要让父级作用域的引用存在即可</strong>，因此还可以这么改代码，如下所示。</p>
<pre><code class="js">var fun3
function fun1() {
    var a = 2
  fun3 = function() {
        console.log(a)
  }
}
fun1()
fun3()
</code></pre>
<p>可以看出，其中实现的结果和前一段代码的效果其实是一样的，就是在给 fun3 函数赋值后，fun3 函数就拥有了 window、fun1 和 fun3 本身这几个作用域的访问权限；然后还是从下往上查找，直到找到 fun1 的作用域中存在 a 这个变量；因此输出的结果还是2，最后产生了闭包，形式变了，本质没有改变。</p>
<p>因此最后返回的不管是不是函数，也都不能说明没有产生闭包。</p>
<h3 id="5-2-3-闭包的表现形式"><a href="#5-2-3-闭包的表现形式" class="headerlink" title="5.2.3 闭包的表现形式"></a>5.2.3 闭包的表现形式</h3><p>那么明白了闭包的本质后，我们来看看闭包的表现形式及应用场景到底有哪些？</p>
<ol>
<li>返回一个函数。</li>
<li>在<code>定时器</code>、<code>事件监听</code>、<code>Ajax请求</code>、<code>web Workers</code>或者<code>任何异步</code>中，只要使用了回调函数，实际上就是在使用闭包。</li>
</ol>
<pre><code class="js">// 定时器
setTimeout(function handler(){
  console.log(&#39;1&#39;);
}，1000);
// 事件监听
$(&#39;#app&#39;).click(function(){
  console.log(&#39;Event Listener&#39;);
});
</code></pre>
<ol start="3">
<li>作为函数参数传递的形式</li>
</ol>
<pre><code class="js">var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
foo();  // 输出2，而不是1
</code></pre>
<ol start="4">
<li><p>IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量，如下所示。</p>
<pre><code class="js">var a = 2
(function IIFE() {
    console.log(a) // 输出2
})()
</code></pre>
<p>IIFE这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。</p>
</li>
</ol>
<h2 id="5-3-如何解决循环输出问题？"><a href="#5-3-如何解决循环输出问题？" class="headerlink" title="5.3 如何解决循环输出问题？"></a>5.3 如何解决循环输出问题？</h2><p>在互联网大厂的面试中，解决循环输出问题是比较高频的面试题，一般都会给一段这样的代码让你解释。</p>
<pre><code class="js">for (var i = 1; i&lt;= 5;i++) {
    setTimeout(function() {
        console.log(i)
  },0)
}
</code></pre>
<p>上面这段代码执行之后，从控制台执行的结果可以看出来，结果输出的是 5 个 6，那么一般面试官都会先问为什么都是 6？我想让你实现输出 1、2、3、4、5 的话怎么办呢？</p>
<p>结合本讲所学的知识思考一下，可以围绕这两点来回答。</p>
<ol>
<li>setTimeout为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完成后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。</li>
<li>因为setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是6了，因此最后输出的连续就都是 6。</li>
</ol>
<p>那我们再来看看如何按顺序依次输出 1、2、3、4、5呢？</p>
<h3 id="5-3-1-利用-IIFE"><a href="#5-3-1-利用-IIFE" class="headerlink" title="5.3.1 利用 IIFE"></a>5.3.1 利用 IIFE</h3><p>可以利用 IIFE（立即执行函数），当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行，改造后的代码如下。</p>
<pre><code class="js">for(var i = 1;i &lt;= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}
</code></pre>
<p>可以看到，通过这样改造使用 IIFE（立即执行函数），可以实现序号的依次输出。</p>
<h3 id="5-3-2-使用-ES6-中的-let"><a href="#5-3-2-使用-ES6-中的-let" class="headerlink" title="5.3.2 使用 ES6 中的 let"></a>5.3.2 使用 ES6 中的 let</h3><p>ES6中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。</p>
<pre><code class="js">for(let i = 1; i &lt;= 5; i++){
  setTimeout(function() {
    console.log(i);
  },0)
}
</code></pre>
<p>从上面的代码可以看出，通过 let 定义变量的方式，重新定义 i 变量，则可以用最少的改动成本，解决该问题。</p>
<h3 id="5-3-3-定时器传入第三个参数"><a href="#5-3-3-定时器传入第三个参数" class="headerlink" title="5.3.3 定时器传入第三个参数"></a>5.3.3 定时器传入第三个参数</h3><p>setTimeout 作为最常用的定时器，它是存在第三个参数的，日常工作中我们经常使用的一般是前两个，一个是回调函数，另一个是时间，而第三个参数用得比较少。</p>
<pre><code class="js">for(var i=1;i&lt;=5;i++){
  setTimeout(function(j) {
    console.log(j)
  }, 0, i)
}
</code></pre>
<p>从中可以看到，第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现我们想要的结果，这也是一种解决循环输出问题的途径。</p>
<h1 id="6-进阶练习：实现-JSON-stringify"><a href="#6-进阶练习：实现-JSON-stringify" class="headerlink" title="6. 进阶练习：实现 JSON.stringify"></a>6. 进阶练习：实现 JSON.stringify</h1><h2 id="6-1-方法基本介绍"><a href="#6-1-方法基本介绍" class="headerlink" title="6.1 方法基本介绍"></a>6.1 方法基本介绍</h2><p>JSON.stringify 是日常开发中经常用到的 JSON 对象中的一个方法，JSON 对象包含两个方法：一是用于解析成 JSON 对象的 <code>parse()</code>；二是用于将对象转换成 JSON 字符串方法的 <code>stringify()</code>。下面我们分别来看下两个方法的基本使用情况。</p>
<h3 id="6-1-1-JSON-parse"><a href="#6-1-1-JSON-parse" class="headerlink" title="6.1.1 JSON.parse"></a>6.1.1 JSON.parse</h3><p>JSON.parse 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。该方法有两个参数：第一个参数是需要解析处理的 JSON 字符串，第二个参数是可选参数提供可选的 reviver 函数，用在返回之前对所得到的对象执行变换操作。</p>
<blockquote>
<p>该方法的语法为：JSON.parse(text[, reviver])</p>
</blockquote>
<p>下面通过一段代码来看看这个方法以及 reviver 参数的用法，如下所示。</p>
<pre><code class="js">const json = &#39;{&quot;result&quot;: true, &quot;count&quot;: 2}&#39;
const obj = JSON.parse(json)
console.log(obj.count) // 2
console.log(obj.result) // true

/* 带第二个参数的情况 */
JSON.parse(&#39;{&quot;p&quot;: 5}&#39;, function(k, v) {
    if (k === &#39;&#39;) return v  // 如果k不是空，
  return v * 2            // 就将属性值变为原来的2倍返回
})                        // { p: 10 }
</code></pre>
<p>上面的代码说明了，我们可以将一个符合 JSON 格式的字符串转化成对象返回；带第二个参数的情况，可以将待处理的字符串进行一定的操作处理，比如上面这个例子就是将属性值乘以 2 进行返回。</p>
<p>下面我们来了解一下 JSON.stringify 的基本情况。</p>
<h3 id="6-1-2-JSON-stringify"><a href="#6-1-2-JSON-stringify" class="headerlink" title="6.1.2 JSON.stringify"></a>6.1.2 JSON.stringify</h3><p>JSON.stringify 方法是将一个 JavaScript 对象或值转换为 JSON 字符串，默认该方法其实有三个参数：第一个参数是必选，后面两个是可选参数非必选。第一个参数传入的是要转换的对象；第二个是一个 replacer 函数，比如指定的 replacer 是数组，则可选择性地仅处理包含数组指定的属性；第三个参数用来控制结果字符串里面的间距，后面两个参数整体用得比较少。</p>
<blockquote>
<p>该方法的语法为：JSON.stringify(value[, replacer [, space]])</p>
</blockquote>
<p>下面我们通过一段代码来看看后面几个参数的妙用，如下所示。</p>
<pre><code class="js">JSON.stringify({ x: 1, y: 2 }) // &quot;{&quot;x&quot;: 1, &quot;y&quot;: 2}&quot;
JSON.stringify({ x: [10, undefined, function(){}, Symbol(&#39;&#39;)] })
// &quot;{&quot;x&quot;: [10, null, null, null]}&quot;

/* 第二个参数的例子 */
function replacer(key, value) {
    if (typeof value === &#39;string&#39;) {
        return undefined
  }
  return value
}
var foo = {foundation: &#39;Mozilla&#39;, model: &#39;box&#39;, week: 4, transport: &#39;car&#39;, month: 7}
var jsonString = JSON.stringify(foo, replacer)
console.log(jsonString) // &quot;{&quot;week&quot;: 4, &quot;month&quot;: 7}&quot;

/* 第三个参数的例子 */
JSON.stringify({a: 2}, null, &#39; &#39;)
/* 
{
 &quot;a&quot;: 2
} 
*/
JSON.stringify({a: 2}, null, &#39;&#39;)  // &quot;{&quot;a&quot;: 2}&quot;
</code></pre>
<p>从上面的代码中可以看到，增加第二个参数 replacer 带来的变化：通过替换方法把对象中的属性为字符串的过滤掉，在 stringify 之后返回的仅为数字的属性变为字符串之后的结果；当第三个参数传入的是多个空格的时候，则会增加结果字符串里面的间距数量，从最后一段代码中可以看到结果。</p>
<p>下面我们再看下 JSON.stringify 的内部针对各种数据类型的转换方式。</p>
<h2 id="6-2-如何自己手动实现？"><a href="#6-2-如何自己手动实现？" class="headerlink" title="6.2 如何自己手动实现？"></a>6.2 如何自己手动实现？</h2><p>为了让你更好地理解实现的过程，回想一下 【1. 数据类型】中的基本知识，我们当时讲了那么多种数据类型，如果它们都使用这个方法，返回的结果又会是怎么样的呢？</p>
<h3 id="6-2-1-分析各种数据类型及边界情况"><a href="#6-2-1-分析各种数据类型及边界情况" class="headerlink" title="6.2.1 分析各种数据类型及边界情况"></a>6.2.1 分析各种数据类型及边界情况</h3><p>我们来分析一下都有哪些数据类型传入，传入了之后会有什么返回，通过分析的结果我们之后才能更好地实现编码。大致的分析汇总如下表所示（可参考MDN文档）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">JSON.stringify</th>
<th style="text-align:center">输入</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基础数据类型</td>
<td style="text-align:center">undefined</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">&quot;false&quot;/&quot;true&quot;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">number</td>
<td style="text-align:center">字符串类型的数值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">symbol</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">null</td>
<td style="text-align:center">&quot;null&quot;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">string</td>
<td style="text-align:center">string</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">NaN 和 Infinity</td>
<td style="text-align:center">&quot;null&quot;</td>
</tr>
<tr>
<td style="text-align:center">引用数据类型</td>
<td style="text-align:center">function</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">Array数组中出现了undefined、function以及 symbol</td>
<td style="text-align:center">string<br>/<br>&quot;null&quot;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">RegExp</td>
<td style="text-align:center">&quot;{}&quot;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">Date</td>
<td style="text-align:center">Date 的 toJSON() 字符串值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">普通object</td>
<td style="text-align:center">1. 如果有 toJSON() 方法，那么序列化 toJSON() 的返回值<br>2. 如果属性值中出现了 undefined、任意的函数以及 symbol值，忽略<br>3. 所有以 symbol 为属性键的属性都会被完全忽略掉</td>
</tr>
</tbody>
</table>
<p>上面这个表中，基本整理出了各种数据类型通过 JSON.stringify 这个方法之后返回对应的值，但是还有一个特殊情况需要注意：对于包含循环引用的对象（深拷贝那讲中也有提到）执行此方法，会抛出错误。</p>
<p>那么根据上面梳理的这个表格，我们来一起看下代码怎么编写吧。</p>
<h3 id="6-2-2-代码逻辑实现"><a href="#6-2-2-代码逻辑实现" class="headerlink" title="6.2.2 代码逻辑实现"></a>6.2.2 代码逻辑实现</h3><p>我们先利用 typeof 把基础数据类型和引用数据类型分开，分开之后再根据不同情况来分别处理不同的情况，按照这个逻辑代码实现如下。</p>
<pre><code class="js">function jsonStringify(data) {
  let type = typeof data;

  if(type !== &#39;object&#39;) {
    let result = data;
    //data 可能是基础数据类型的情况在这里处理
    if (Number.isNaN(data) || data === Infinity) {
       //NaN 和 Infinity 序列化返回 &quot;null&quot;
       result = &quot;null&quot;;
    } else if (type === &#39;function&#39; || type === &#39;undefined&#39; || type === &#39;symbol&#39;) {
      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理
       return undefined;
    } else if (type === &#39;string&#39;) {
       result = &#39;&quot;&#39; + data + &#39;&quot;&#39;;
    }
    return String(result);
  } else if (type === &#39;object&#39;) {
     if (data === null) {
        return &quot;null&quot;  // 第01讲有讲过 typeof null 为&#39;object&#39;的特殊情况
     } else if (data.toJSON &amp;&amp; typeof data.toJSON === &#39;function&#39;) {
        return jsonStringify(data.toJSON());
     } else if (data instanceof Array) {
        let result = [];
        //如果是数组，那么数组里面的每一项类型又有可能是多样的
        data.forEach((item, index) =&gt; {
        if (typeof item === &#39;undefined&#39; || typeof item === &#39;function&#39; || typeof item === &#39;symbol&#39;) {
               result[index] = &quot;null&quot;;
           } else {
               result[index] = jsonStringify(item);
           }
         });
         result = &quot;[&quot; + result + &quot;]&quot;;
         return result.replace(/&#39;/g, &#39;&quot;&#39;);
      } else {
         // 处理普通对象
         let result = [];
         Object.keys(data).forEach((item, index) =&gt; {
            if (typeof item !== &#39;symbol&#39;) {
              //key 如果是 symbol 对象，忽略
              if (data[item] !== undefined &amp;&amp; typeof data[item] !== &#39;function&#39; &amp;&amp; typeof data[item] !== &#39;symbol&#39;) {
                //键值如果是 undefined、function、symbol 为属性值，忽略
                result.push(&#39;&quot;&#39; + item + &#39;&quot;&#39; + &quot;:&quot; + jsonStringify(data[item]));
              }
            }
         });
         return (&quot;{&quot; + result + &quot;}&quot;).replace(/&#39;/g, &#39;&quot;&#39;);
        }
    }
}
</code></pre>
<p>整体来说这段代码还是比较复杂的，如果在面试过程中让你当场手写，其实整体还是需要考虑很多东西的。当然上面的代码根据每个人的思路不同，你也可以写出自己认为更优的代码，比如你也可以尝试直接使用 switch 语句，来分别针对特殊情况进行处理，整体写出来可能看起来会比上面的写法更清晰一些，这些可以根据自己情况而定。</p>
<h3 id="6-2-3-实现效果测试"><a href="#6-2-3-实现效果测试" class="headerlink" title="6.2.3 实现效果测试"></a>6.2.3 实现效果测试</h3><p>上面的这个方法已经实现了，那么用起来会不会有问题呢？我们就用上面的代码来进行一些用例的检测吧。</p>
<pre><code class="js">let nl = null;
console.log(jsonStringify(nl) === JSON.stringify(nl));
// true
let und = undefined;
console.log(jsonStringify(undefined) === JSON.stringify(undefined));
// true
let boo = false;
console.log(jsonStringify(boo) === JSON.stringify(boo));
// true
let nan = NaN;
console.log(jsonStringify(nan) === JSON.stringify(nan));
// true
let inf = Infinity;
console.log(jsonStringify(Infinity) === JSON.stringify(Infinity));
// true
let str = &quot;jack&quot;;
console.log(jsonStringify(str) === JSON.stringify(str));
// true
let reg = new RegExp(&quot;\w&quot;);
console.log(jsonStringify(reg) === JSON.stringify(reg));
// true
let date = new Date();
console.log(jsonStringify(date) === JSON.stringify(date));
// true
let sym = Symbol(1);
console.log(jsonStringify(sym) === JSON.stringify(sym));
// true
let array = [1,2,3];
console.log(jsonStringify(array) === JSON.stringify(array));
// true
let obj = {
    name: &#39;jack&#39;,
    age: 18,
    attr: [&#39;coding&#39;, 123],
    date: new Date(),
    uni: Symbol(2),
    sayHi: function() {
        console.log(&quot;hi&quot;)
    },
    info: {
        sister: &#39;lily&#39;,
        age: 16,
        intro: {
            money: undefined,
            job: null
        }
    }
}
console.log(jsonStringify(obj) === JSON.stringify(obj));
// true
</code></pre>
<h1 id="7-数组原理（上）：梳理数组API"><a href="#7-数组原理（上）：梳理数组API" class="headerlink" title="7. 数组原理（上）：梳理数组API"></a>7. 数组原理（上）：梳理数组API</h1><p><strong>数组概念的探究</strong></p>
<p>截止 ES7 规范，数组共包含 33 个标准的 API 方法和一个非标准的 API 方法，使用场景和使用方案纷繁复杂，其中还有不少坑。为了方便可以循序渐进学习这部分内容，下面将从数组的概念开始讲起。</p>
<p>由于数组的 API 较多，很多相近的名字也容易导致混淆，所以在这里按照“会改变自身值的” “不会改变自身值的” “遍历方法” 这三种类型分开讲解。</p>
<h2 id="7-1-Array的构造器"><a href="#7-1-Array的构造器" class="headerlink" title="7.1  Array的构造器"></a>7.1  Array的构造器</h2><p>Array 构造器用于创建一个新的数组。通常，我们推荐使用<code>对象字面量</code>的方式创建一个数组，例如 <code>var a = []</code>就是一个比较好的写法。但是，总有对象字面量表述乏力的时候，比如，我想创建一个长度为 6 的空数组，用对象字面量的方式是无法创建的，因此只能写出下面这样。</p>
<pre><code class="js">// 使用 Array 构造器，可以自定义长度
var a = Array(6) // [empty * 6]

// 使用对象字面量
var b = []
b.length = 6 // [undefined * 6]
</code></pre>
<p>Array 构造器根据参数长度的不同，有如下两种不同的处理方式：</p>
<ul>
<li><code>new Array(arg1, arg2, ...)</code>，参数长度为 0 或 长度大于等于 2 时，传入的参数将按照顺序依次成为新数组的第 0 至第 N 项（参数长度为 0 时，返回空数组）；</li>
<li><code>new Array(len)</code>，当 len 不是数值时，处理同上，返回一个只包含 len 元素一项的数组；当 len 为数值时，len 最大不能超过 32 位无符号整型，即需要小于 2 的 32次方（len 最大为 <code>Math.pow(2, 32)</code>），否则将抛出 RangeError。</li>
</ul>
<p>以上就是 Array 构造器的基本情况，我们来看下 ES6 新增的几个构造方法。</p>
<h2 id="7-2-ES6新增的构造方法：Array-of-和-Array-from"><a href="#7-2-ES6新增的构造方法：Array-of-和-Array-from" class="headerlink" title="7.2 ES6新增的构造方法：Array.of 和 Array.from"></a>7.2 ES6新增的构造方法：Array.of 和 Array.from</h2><p>鉴于数组的常用性，ES6 专门扩展了数组构造器 Array，新增了2个方法：<code>Array.of</code>、<code>Array.from</code>。其中，Array.of 整体用得比较少；而 Array.from 具有灵活性，你在平常开发中应该会经常使用。</p>
<h3 id="7-2-1-Array-of"><a href="#7-2-1-Array-of" class="headerlink" title="7.2.1 Array.of"></a>7.2.1 Array.of</h3><p>Array.of 用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其他。它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。</p>
<p>比如，在下面的这几行代码中，你可以看到区别：当参数为两个时，返回的结果是一致的；当参数是一个时，Array.of 会把参数变成数组里的一项，而构造器则会生成长度和第一个参数相同的空数组。</p>
<pre><code class="js">Array.of(8.0) // [8]
Array(8) // [empty * 8]
Array.of(8.0, 5) // [8, 5]
Array(8.0, 5) // [8, 5]
Array.of(&#39;8&#39;) // [&#39;8&#39;]
Array(&#39;8&#39;) // [&#39;8&#39;]
</code></pre>
<h3 id="7-2-2-Array-from"><a href="#7-2-2-Array-from" class="headerlink" title="7.2.2 Array.from"></a>7.2.2 Array.from</h3><p>Array.from 的设计初衷是快速便捷地基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例。其实就是，只要一个对象有迭代器，Array.from  就能把它变成一个数组（注意：是返回新的数组，不改变原对象）</p>
<p>从语法上，Array.from 拥有3个参数：</p>
<ol>
<li>类似数组的对象，必选；</li>
<li>加工函数，新生成的数组会经过该函数的加工再返回；</li>
<li>this 作用域，表示加工函数执行时 this 的值。</li>
</ol>
<p>这三个参数里面第一个参数是必选的，后两个参数都是可选的。</p>
<pre><code class="js">var obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;, length: 3 }
Array.from(obj, function(value, index) {
    console.log(value, index, this, arguments.length)
  return value.repeat(3) // 必须指定返回值，否则返回 undefined
}, obj)
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/js进阶/8.png" alt="js数据类型"></p>
<p>结果中可以看出<code>console.log(value,index,this,arguments.length)</code>对应的四个值，并且看到 return 的 value 重复了三遍，最后返回的数组为 <code>[&#39;aaa&#39;,&#39;bbb&#39;,&#39;ccc&#39;]</code>。</p>
<p>这表明了通过 <code>Array.from</code>这个方法可以自己定义加工函数的处理方式，从而返回想要得到的值；如果不确定返回值，则会返回 undefined，最终生成的也是一个包含若干个 undefined 元素的空数组。</p>
<p>实际上，如果这里不指定 this 的话，加工函数完全可以是一个箭头函数。上述代码可以简写为如下形式。</p>
<pre><code class="js">Array.from(obj, (value) =&gt; value.repeat(3))
// [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;]
</code></pre>
<p>除了上述 obj 对象以外，拥有迭代器的对象还包括 String、Set、Map等，Array.from 统统可以处理，请看下面的代码。</p>
<pre><code class="js">// String
Array.from(&#39;abc&#39;);         // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
// Set
Array.from(new Set([&#39;abc&#39;, &#39;def&#39;])); // [&quot;abc&quot;, &quot;def&quot;]
// Map
Array.from(new Map([[1, &#39;ab&#39;], [2, &#39;de&#39;]])); 
// [[1, &#39;ab&#39;], [2, &#39;de&#39;]]
</code></pre>
<h2 id="7-3-Array的判断"><a href="#7-3-Array的判断" class="headerlink" title="7.3 Array的判断"></a>7.3 Array的判断</h2><p>在 ES5 提供Array.isArray方法之前，我们至少有如下5中方式去判断一个变量是否为数组。</p>
<pre><code class="js">var a = []
// 1. 基于instanceof
a instanceof Array

// 2. 基于construcotr
a.constructor === Array

// 3. 基于Object.prototype.isPrototypeOf
Array.prototype.isPrototypeOf(a)

// 4. 基于getPrototypeOf
Object.getPrototypeOf(a) === Array.prototype

// 5. 基于Object.prototype.toString
Object.prototype.toString.apply(a) === &#39;[object Array]&#39;
</code></pre>

        </div>
        <!-- .entry-content -->
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2021/11/23/js-parsing/" rel="prev">
              <div class="background">
                <img class="lazyload" src="/images/bg1.jpg" data-src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                JavaScript深度剖析</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2021/11/16/vue3/" rel="next">
              <div class="background">
                <img class="lazyload" src="/images/bg1.jpg" data-src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                vue3</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "zMhFPcMIscDyGbtxHjYFffkx-gzGzoHsz",
        appKey: "c4XBymCm0OmYWLklOAKbUlhE",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="DarkStrand.cn" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg" itemprop="image" alt="DarkStrand" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="DarkStrand.cn" itemprop="url" rel="author">DarkStrand</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>一个神奇的小伙</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 DarkStrand<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2021</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by &<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">DarkStrand</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Bazinga.mp4","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Bazinga.mp4","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/touxiang.JPG">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">FLのBlog</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://gitee.com/darkstranded" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/生活/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/资源/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/转载/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/悦读/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  书单
                </a>
              </li>
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  番组
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/tags/图集/">
                  <i class="fa fa-photo" aria-hidden="true"></i>
                  图集
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
              <li>
                <a href="/lab/">
                  <i class="fa fa-cogs" aria-hidden="true"></i>
                  Lab
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/client/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-android faa-vertical" aria-hidden="true"></i>
            客户端
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="2660651585"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>