<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">Nodejs | DarkStrand</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "FLのBlog";
  mashiro_option.author_name = "Blog";
  mashiro_option.site_url = "";
  mashiro_option.v_appId = "zMhFPcMIscDyGbtxHjYFffkx-gzGzoHsz";
  mashiro_option.v_appKey = "c4XBymCm0OmYWLklOAKbUlhE";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/pexels-designecologist-1779487.jpg,https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/pexels-serpstat-572056.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
  
  <!--自定义看板娘-->
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="">
          <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/touxiang.JPG">
        </a>
      </div>
      <div class="header-info">
        <p>Live your life with passion! With some drive!</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://gitee.com/darkstranded" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/github.jpeg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/wechat.jpeg">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/qrwechat.png">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">FLの</span>
            <span class="shironeko">Blog</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/资源/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/5.jpeg);" src="/images/bg1.jpg" data-src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/5.jpeg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      Nodejs</h1>
      <p class="entry-census">
        <span>
          <a href="hojun.cn">
            <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="hojun.cn">DarkStrand</a>
        </span>
        <span class="bull">
        ·</span>
        2021-8-13<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1 id="01-Node-js基础"><a href="#01-Node-js基础" class="headerlink" title="01-Node.js基础"></a>01-Node.js基础</h1><h2 id="一、Node-js是什么"><a href="#一、Node-js是什么" class="headerlink" title="一、Node.js是什么"></a>一、Node.js是什么</h2><p>Node.js is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine.</p>
<h3 id="1、-特性"><a href="#1、-特性" class="headerlink" title="1、 特性"></a>1、 特性</h3><p>Node.js可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：</p>
<ul>
<li>文件的读写（File System）</li>
<li>进程的管理（Process）</li>
<li>网络通信（HTTP/HTTPS）</li>
</ul>
<h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><h4 id="2-1-浏览器安全级别的限制"><a href="#2-1-浏览器安全级别的限制" class="headerlink" title="2.1 浏览器安全级别的限制"></a>2.1 浏览器安全级别的限制</h4><h5 id="Ajax限制"><a href="#Ajax限制" class="headerlink" title="Ajax限制"></a>Ajax限制</h5><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;browser-safe-sandbox&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;browser-safe-sandbox&lt;/div&gt;
  &lt;script&gt;
    const xhr = new XMLHttpRequest()
    xhr.open(&#39;get&#39;, &#39;https://m.maoyan.com/ajax/moreClassicList?sortId=1&amp;showType=3&amp;limit=10&amp;offset=30&amp;optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&amp;optimus_risk_level=71&amp;optimus_code=10&#39;, false)
    xhr.send()
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h5 id="浏览器预览"><a href="#浏览器预览" class="headerlink" title="浏览器预览"></a>浏览器预览</h5><pre><code>browser-sync start --server --files **/* --directory
</code></pre><h4 id="2-2-文件的读写（File-System）"><a href="#2-2-文件的读写（File-System）" class="headerlink" title="2.2 文件的读写（File System）"></a>2.2 文件的读写（File System）</h4><pre><code class="javascript">const fs = require(&#39;fs&#39;)

fs.readFile(&#39;./ajax.png&#39;, &#39;utf-8&#39;, (err, content) =&gt; {
  console.log(content)
})
</code></pre>
<h4 id="2-3-进程的管理（Process）"><a href="#2-3-进程的管理（Process）" class="headerlink" title="2.3 进程的管理（Process）"></a>2.3 进程的管理（Process）</h4><pre><code class="javascript">function main(argv) {
  console.log(argv)
}

main(process.argv.slice(2))
</code></pre>
<blockquote>
<p>运行</p>
</blockquote>
<pre><code>node 2.3-process.js argv1 argv2
</code></pre><h4 id="2-4-网络通信（HTTP-HTTPS）"><a href="#2-4-网络通信（HTTP-HTTPS）" class="headerlink" title="2.4 网络通信（HTTP/HTTPS）"></a>2.4 网络通信（HTTP/HTTPS）</h4><pre><code class="javascript">const http = require(&quot;http&quot;)

http.createServer((req,res) =&gt; {
  res.writeHead(200, {
    &quot;content-type&quot;: &quot;text/plain&quot;
  })
  res.write(&quot;hello nodejs&quot;)
  res.end()
}).listen(3000)
</code></pre>
<h2 id="二、Node相关工具"><a href="#二、Node相关工具" class="headerlink" title="二、Node相关工具"></a>二、Node相关工具</h2><h3 id="1、NVM：Node-Version-Manager"><a href="#1、NVM：Node-Version-Manager" class="headerlink" title="1、NVM：Node Version Manager"></a>1、NVM：Node Version Manager</h3><h4 id="1-1-Mac安装nvm"><a href="#1-1-Mac安装nvm" class="headerlink" title="1.1 Mac安装nvm"></a>1.1 Mac安装nvm</h4><pre><code>https://github.com/nvm-sh/nvm/blob/master/README.md
</code></pre><h4 id="1-2-Windows安装nvm"><a href="#1-2-Windows安装nvm" class="headerlink" title="1.2 Windows安装nvm"></a>1.2 Windows安装nvm</h4><pre><code>nvm-windows
nodist
</code></pre><h4 id="1-3-常用的nvm命令"><a href="#1-3-常用的nvm命令" class="headerlink" title="1.3 常用的nvm命令"></a>1.3 常用的nvm命令</h4><ul>
<li><code>nvm list</code>：查看当前环境安装了哪些版本</li>
<li><code>nvm use 14.15.0</code>：切换node版本</li>
<li><code>nvm alias default (v)14.15.0</code>：切换node默认版本</li>
</ul>
<h3 id="2、NPM：Node-Package-Manager"><a href="#2、NPM：Node-Package-Manager" class="headerlink" title="2、NPM：Node Package Manager"></a>2、NPM：Node Package Manager</h3><ul>
<li><code>npm view jquery versions</code>：查看包的所有版本</li>
</ul>
<h4 id="2-1-全局安装package"><a href="#2-1-全局安装package" class="headerlink" title="2.1 全局安装package"></a>2.1 全局安装package</h4><pre><code>$ npm install forever --global (-g)
$ forever
$ npm uninstall forever --global
$ forever

</code></pre><blockquote>
<p>全局安装包的目录</p>
</blockquote>
<ul>
<li><p>Mac</p>
<pre><code>/Users/felix/.nvm/versions/node/nvm各个版本/bin/

</code></pre></li>
</ul>
<ul>
<li><p>Windows</p>
<pre><code>C:\Users\你的用户名\AppData\Roaming\npm\node_modules

</code></pre></li>
</ul>
<h4 id="2-2-本地安装package"><a href="#2-2-本地安装package" class="headerlink" title="2.2 本地安装package"></a>2.2 本地安装package</h4><pre><code>$ cd ~/desktop
$ mkdir gp-project
$ cd gp-project
$ npm install underscore
$ npm list (ls)

</code></pre><h4 id="2-3-package-json初始化"><a href="#2-3-package-json初始化" class="headerlink" title="2.3 package.json初始化"></a>2.3 package.json初始化</h4><pre><code>$ pwd
$ npm init -y
$ ls
$ cat package.json

</code></pre><h4 id="2-4-使用package-json"><a href="#2-4-使用package-json" class="headerlink" title="2.4 使用package.json"></a>2.4 使用package.json</h4><ul>
<li><code>npm install —production</code>：只拉取生产环境的包</li>
</ul>
<pre><code>$ npm install underscore --save
$ cat package.json
$ npm install lodash --save-dev
$ cat package.json
$ rm -rf node_modules
$ ls
$ npm install
$ npm uninstall underscore --save
$ npm list | grep underscore  // 查看underscore包的树(依赖关系)
$ cat package.json

</code></pre><blockquote>
<p>&quot;dependencies&quot;：这些包是你的应用程序在生产环境中所需要的。</p>
<p>&quot;devDepedencies&quot;：这些包只是在开发和测试中需要的。</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/2018071517553381?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p3bF93aWxsb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="npm"></p>
<pre><code>// package.json
{
...
&quot;dependencies&quot;: { // --save / -S
},
&quot;devDependencies&quot;: { // --save-dev / -D
}

}

</code></pre><h4 id="2-5-安装指定版本的包"><a href="#2-5-安装指定版本的包" class="headerlink" title="2.5 安装指定版本的包"></a>2.5 安装指定版本的包</h4><ul>
<li><code>npm install jquery@2.2.4</code>： 安装指定版本</li>
<li><code>npm install jquery@1 -S</code>：安装1最高的版本</li>
</ul>
<pre><code>$ pwd
$ npm list
$ npm info underscore
$ npm view underscore versions
$ npm install underscore@1.8.0
$ npm list
$ npm uninstall underscore
$ npm list

</code></pre><h4 id="2-6-更新本地安装的包"><a href="#2-6-更新本地安装的包" class="headerlink" title="2.6 更新本地安装的包"></a>2.6 更新本地安装的包</h4><blockquote>
<p>-13.4.6</p>
<p>major: 13（主版本号）,minor: 4（次版本号），patch：6（补丁，单数不稳定，双数稳定）</p>
</blockquote>
<ul>
<li><code>npm outdated</code>：查看哪些包过期</li>
<li><code>npm update</code>：更新所有的包</li>
</ul>
<pre><code>$ npm info underscore
$ npm view underscore versions // 查看underscore包所有的版本
$ npm install underscore@1.4.4 --save-dev // 安装1.4.4的underscore到开发环境 
$ npm list | grep gulp // 查看gulp包的依赖关系
$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本
$ npm list | grep gulp
$ npm update

</code></pre><pre><code class="json">{
    &quot;dependencies&quot;: {
        &quot;jquery&quot;: &quot;^1.12.4&quot;, // ^锁定主版本号
        &quot;jquery&quot;: &quot;~1.12.4&quot;, // ~锁定主版本号和次版本号
        jquery: &quot;1.12.4&quot;, // 全部锁定
        jquery: &quot;*&quot; // 最新版本
    }
}

</code></pre>
<h4 id="2-7-清除缓存"><a href="#2-7-清除缓存" class="headerlink" title="2.7 清除缓存"></a>2.7 清除缓存</h4><ul>
<li><code>npm cache clean --force</code></li>
</ul>
<h4 id="2-8-上传自己的包"><a href="#2-8-上传自己的包" class="headerlink" title="2.8 上传自己的包"></a>2.8 上传自己的包</h4><h5 id="2-8-1-编写模块"><a href="#2-8-1-编写模块" class="headerlink" title="2.8.1 编写模块"></a>2.8.1 编写模块</h5><p>保存为index.js</p>
<pre><code class="javascript">exports.sayHello = function(){ 
  return &#39;Hello World&#39;; 
}

</code></pre>
<h5 id="2-8-2-初始化描述文件"><a href="#2-8-2-初始化描述文件" class="headerlink" title="2.8.2 初始化描述文件"></a>2.8.2 初始化描述文件</h5><ul>
<li>npm init package.json</li>
</ul>
<pre><code class="json">{ 
  &quot;name&quot;: &quot;gp19-npm&quot;, 
  &quot;version&quot;: &quot;1.0.1&quot;, 
  &quot;description&quot;: &quot;gp19 self module&quot;, 
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: { 
    &quot;test&quot;: &quot;make test&quot; 
  }, 
  &quot;repository&quot;: { 
    &quot;type&quot;: &quot;Git&quot;, 
    &quot;url&quot;: &quot;git+https://github.com/lurongtao/gp19-npm.git&quot; 
  }, 
  &quot;keywords&quot;: [ 
    &quot;demo&quot; 
  ], 
  &quot;author&quot;: &quot;Felixlu&quot;, 
  &quot;license&quot;: &quot;ISC&quot;, 
  &quot;bugs&quot;: { 
    &quot;url&quot;: &quot;https://github.com/lurongtao/gp19-npm/issues&quot; 
  }, 
  &quot;homepage&quot;: &quot;https://github.com/lurongtao/gp19-npm#readme&quot;, 
}

</code></pre>
<h5 id="2-8-3-注册npm仓库账号"><a href="#2-8-3-注册npm仓库账号" class="headerlink" title="2.8.3 注册npm仓库账号"></a>2.8.3 注册npm仓库账号</h5><ul>
<li>npm adduser</li>
</ul>
<pre><code>https://www.npmjs.com 上面的账号
felix_lurt/qqmko09ijn
$ npm adduser

</code></pre><h5 id="2-8-4-上传包"><a href="#2-8-4-上传包" class="headerlink" title="2.8.4 上传包"></a>2.8.4 上传包</h5><ul>
<li>npm publish</li>
</ul>
<p>坑：403 Forbidden</p>
<pre><code>查看npm源：npm config get registry
切换npm源方法一：npm config set registry http://registry.npmjs.org
切换npm源方法二：nrm use npm

</code></pre><h5 id="2-8-5-安装包"><a href="#2-8-5-安装包" class="headerlink" title="2.8.5 安装包"></a>2.8.5 安装包</h5><ul>
<li>npm install gp19-npm</li>
</ul>
<h5 id="2-8-6-卸载包"><a href="#2-8-6-卸载包" class="headerlink" title="2.8.6 卸载包"></a>2.8.6 卸载包</h5><pre><code>查看当前项目引用了哪些包 ：
npm ls
卸载包：
npm unpublish --force

</code></pre><h5 id="2-8-7-使用引入包"><a href="#2-8-7-使用引入包" class="headerlink" title="2.8.7 使用引入包"></a>2.8.7 使用引入包</h5><pre><code>var hello = require(&#39;gp19-npm&#39;)
hello.sayHello()

</code></pre><h4 id="2-9-npm脚本"><a href="#2-9-npm脚本" class="headerlink" title="2.9 npm脚本"></a>2.9 npm脚本</h4><p>Node开发离不开npm，而脚本功能是npm最强大、最常用的功能之一。</p>
<h5 id="2-9-1-什么是npm脚本？"><a href="#2-9-1-什么是npm脚本？" class="headerlink" title="2.9.1 什么是npm脚本？"></a>2.9.1 什么是npm脚本？</h5><p>npm允许在package.json文件里面，使用scripts字段定义脚本命令。</p>
<pre><code class="json">{
    // ...
    &quot;scripts&quot;: {
        &quot;builds&quot;: &quot;node build.js&quot;
    }
}

</code></pre>
<h5 id="2-9-2-执行顺序"><a href="#2-9-2-执行顺序" class="headerlink" title="2.9.2 执行顺序"></a>2.9.2 执行顺序</h5><p>如果npm脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p>
<blockquote>
<p>scripts1.js</p>
</blockquote>
<pre><code class="js">var x = 0
console.log(x)

</code></pre>
<blockquote>
<p>scripts2.js</p>
</blockquote>
<pre><code class="js">var y = 0
console.log(y)

</code></pre>
<pre><code class="json">&quot;scripts&quot; : {
    &quot;script1&quot;: &quot;node script1.js&quot;,
    &quot;script2&quot;: &quot;ndoe script2.js&quot;
}

</code></pre>
<p>如果是并行执行（即同时的平行执行），可以使用<code>&amp;</code>符号。</p>
<pre><code>$ npm run script1 &amp; npm run script2

</code></pre><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&amp;&amp;</code>符号。</p>
<pre><code>$ npm run script1 &amp;&amp; npm run script2

</code></pre><h5 id="2-9-3-简写形式"><a href="#2-9-3-简写形式" class="headerlink" title="2.9.3 简写形式"></a>2.9.3 简写形式</h5><p>常用的npm脚本简写形式</p>
<pre><code>npm start 是 npm run start

</code></pre><h5 id="2-9-4-变量"><a href="#2-9-4-变量" class="headerlink" title="2.9.4 变量"></a>2.9.4 变量</h5><p>npm脚本有一个非常强大功能，就是可以使用npm的内部变量。</p>
<p>首先，通过<code>npm _package_</code>前缀，npm脚本可以拿到package.json里面的字段。比如，下面是一个package.json。</p>
<blockquote>
<p>注意：一定要在npm脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到的</p>
</blockquote>
<pre><code class="json">{
    &quot;name&quot;: &quot;foo&quot;,
    &quot;version&quot;: &quot;1.2.5&quot;,
    &quot;scripts&quot;: {
        &quot;view&quot;: &quot;node view.js&quot;
    }
}

</code></pre>
<p>那么，变量<code>npm_package_name</code>返回foo，变量<code>npm_package_version</code>返回1.2.5。</p>
<pre><code class="js">// view.js
console.log(process.env.npm_package_name); // foo
console.log(process.env.npm_package_version); // 1.2.5

</code></pre>
<p>上面代码中，我们通过环境变量<code>process.env</code>对象，拿到<code>package.json</code>的字段值。如果是Bash脚本，可以用<code>$npm_package_name</code>和 <code>$npm_package_version</code>取到这两个值。</p>
<p>npmpackage前缀也支持嵌套的package.json字段。</p>
<pre><code class="json">&quot;repository&quot;: {
    &quot;type&quot;: &#39;git&#39;,
    &quot;url&quot;: &quot;xxx&quot;
},
&quot;scripts&quot;: {
    &quot;view&quot;: &quot;echo $npm_package_repository_type&quot;
}

</code></pre>
<p>上面代码中，repository字段的type属性，可以通过<code>npm_package_repository_type</code>取到。</p>
<p>下面是另外一个例子。</p>
<pre><code class="json">&quot;scripts&quot;: {
    &quot;install&quot;: &quot;foo.js&quot;
}

</code></pre>
<p>上面代码中，<code>npm_package_scripts_install</code>变量的值等于foo.js。</p>
<p>然后，npm脚本还可以通过<code>npmconfig</code>前缀，拿到npm的配置变量，即<code>npm config get xxx</code>命令返回的值。比如，当前模块的发型标签，可以通过<code>npm_config_tag</code>取到。</p>
<pre><code class="json">&quot;view&quot;: &quot;echo $npm_config_tag&quot;,

</code></pre>
<p>注意，package.json里面的config对象，可以被环境变量覆盖。</p>
<pre><code class="json">{
    &quot;name&quot;: &quot;foo&quot;,
    &quot;config&quot;: {&quot;port&quot;: &quot;8080&quot;},
    &quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;}
}

</code></pre>
<p>上面代码中，<code>npm_package_config_port</code>变量返回的是8080。这个值可以用下面的方法覆盖。</p>
<pre><code>$ npm config set foo:port 80

</code></pre><p>最后，env命令可以列出所有环境变量。</p>
<p>&quot;env&quot;:&quot;env&quot; </p>
<h4 id="2-10-npm安装git上发布的包"><a href="#2-10-npm安装git上发布的包" class="headerlink" title="2.10 npm安装git上发布的包"></a>2.10 npm安装git上发布的包</h4><pre><code># 这样适合安装公司内部的git服务器上的项目
npm install git+https://git@github.com:lurongtao/gp-project.git

# 或者以ssh的方式
npm install git+ssh://git@github.com:lurongtao/gp-project.git

</code></pre><h4 id="2-11-cross-env使用"><a href="#2-11-cross-env使用" class="headerlink" title="2.11 cross-env使用"></a>2.11 cross-env使用</h4><h5 id="2-11-1-cross-env是什么"><a href="#2-11-1-cross-env是什么" class="headerlink" title="2.11.1 cross-env是什么"></a>2.11.1 cross-env是什么</h5><p>运行跨平台设置和使用环境变量的脚本</p>
<h5 id="2-11-2-出现原因"><a href="#2-11-2-出现原因" class="headerlink" title="2.11.2 出现原因"></a>2.11.2 出现原因</h5><p>当您使用<code>NODE_ENV=production</code>，来设置环境变量时，大多数Windows命令提示将会阻塞（报错）。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows不支持<code>NOE_ENV=production</code>的设置方式。</p>
<h5 id="2-11-3-解决"><a href="#2-11-3-解决" class="headerlink" title="2.11.3 解决"></a>2.11.3 解决</h5><p>cross-env使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包（cross-env）能够提供一个设置环境变量的scripts，让你能够以Unix方式设置环境变量，然后在Windows上也能兼容运行。</p>
<h5 id="2-11-4-安装"><a href="#2-11-4-安装" class="headerlink" title="2.11.4 安装"></a>2.11.4 安装</h5><pre><code>npm install --save-dev cross-env

</code></pre><h5 id="2-11-5-使用"><a href="#2-11-5-使用" class="headerlink" title="2.11.5 使用"></a>2.11.5 使用</h5><pre><code class="json">{
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;
    }
}

</code></pre>
<p><code>NODE_ENV</code>环境变量将由<code>cross-env</code>设置，打印<code>process.env.NODE_ENV === &#39;production&#39;</code></p>
<h3 id="3、NRM：npm-registry-manager"><a href="#3、NRM：npm-registry-manager" class="headerlink" title="3、NRM：npm registry manager"></a>3、NRM：npm registry manager</h3><h4 id="3-1-手工切换源"><a href="#3-1-手工切换源" class="headerlink" title="3.1 手工切换源"></a>3.1 手工切换源</h4><h5 id="3-1-1-查看当前源"><a href="#3-1-1-查看当前源" class="headerlink" title="3.1.1 查看当前源"></a>3.1.1 查看当前源</h5><pre><code>npm config get registry

</code></pre><h5 id="3-1-2-切换淘宝源"><a href="#3-1-2-切换淘宝源" class="headerlink" title="3.1.2 切换淘宝源"></a>3.1.2 切换淘宝源</h5><pre><code>npm config set registry https://registry.npm.taobao.org

</code></pre><h4 id="3-2-NRM管理源"><a href="#3-2-NRM管理源" class="headerlink" title="3.2 NRM管理源"></a>3.2 NRM管理源</h4><p>NRM是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在npm源间切换。</p>
<h5 id="3-2-1-安装nrm"><a href="#3-2-1-安装nrm" class="headerlink" title="3.2.1 安装nrm"></a>3.2.1 安装nrm</h5><p>在命令行执行命令，<code>npm install -g nrm</code>，全局安装nrm。</p>
<h5 id="3-2-2-使用nrm"><a href="#3-2-2-使用nrm" class="headerlink" title="3.2.2 使用nrm"></a>3.2.2 使用nrm</h5><p>执行命令<code>nrm ls</code>查看可选的源。其中，带<code>*</code>的是当前使用的源，上面输出表明当前源是官方源。</p>
<h5 id="3-2-3-切换nrm"><a href="#3-2-3-切换nrm" class="headerlink" title="3.2.3 切换nrm"></a>3.2.3 切换nrm</h5><p>如果要切换到taobao源，执行命令<code>nrm use taobao</code>。</p>
<h5 id="3-2-4-测试速度"><a href="#3-2-4-测试速度" class="headerlink" title="3.2.4 测试速度"></a>3.2.4 测试速度</h5><p>你还可以通过<code>nrm test</code>测试相应源的响应时间。</p>
<h3 id="4、-NPX：npm-package-extention"><a href="#4、-NPX：npm-package-extention" class="headerlink" title="4、 NPX：npm package extention"></a>4、 NPX：npm package extention</h3><p>npm从5.2版开始，增加了npx命令。它有很多用处，本文介绍该命令的主要使用场景。</p>
<p>Node自带npm模块，所以可以直接使用npx命令。万一不能用，就要手动安装一下。</p>
<pre><code>$ npm install -g npx

</code></pre><h4 id="4-1-调用项目安装的模块"><a href="#4-1-调用项目安装的模块" class="headerlink" title="4.1 调用项目安装的模块"></a>4.1 调用项目安装的模块</h4><p>npx想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。</p>
<pre><code>$ npm install -D mocha

</code></pre><p>一般来说，调用Mocha，只能在项目脚本和package.json的scripts字段里面，如果想在命令行下调用，必须像下面这样。</p>
<pre><code># 项目的根目录下执行
$ node-modules/.bin/mocha --version

</code></pre><p>npx就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p>
<pre><code>$ npx mocha --version

</code></pre><p>npx的原理很简单，就是运行的时候，会倒<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p>
<p>由于npx会检查环境变量$PATH，所以系统命令也可以调用。</p>
<pre><code># 等同于 ls
$ npx ls

</code></pre><p>注意，Bash内置的命令不在$PATH里面，所以不能用。比如cd 是Bash命令，因此就不能用npx cd。</p>
<h4 id="4-2-避免全局安装模块"><a href="#4-2-避免全局安装模块" class="headerlink" title="4.2 避免全局安装模块"></a>4.2 避免全局安装模块</h4><p>除了调用项目内部模块，npx还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx可以运行它，而且不进行全局安装。</p>
<pre><code>$ npx create-react-app my-react-app

</code></pre><p>上面代码运行时，npx将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。</p>
<p>注意，只要npx后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个Web服务。</p>
<pre><code>$ npx http-server

</code></pre><h4 id="4-3-no-install参数和-ignore-existing参数"><a href="#4-3-no-install参数和-ignore-existing参数" class="headerlink" title="4.3 --no--install参数和--ignore-existing参数"></a>4.3 --no--install参数和--ignore-existing参数</h4><p>如果想让npx强制使用本地模块，不下载远程模块，可以使用--no-install参数。如果本地不存在该模块，就会报错。</p>
<pre><code>$ npx --no-install http-server

</code></pre><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用--ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。</p>
<pre><code>$ npx --ignore-existing http-server

</code></pre><h3 id="5、node的浏览端调试"><a href="#5、node的浏览端调试" class="headerlink" title="5、node的浏览端调试"></a>5、node的浏览端调试</h3><ul>
<li><code>node --inspect --inspect-brk server.js</code></li>
</ul>
<h3 id="6、node进程管理工具"><a href="#6、node进程管理工具" class="headerlink" title="6、node进程管理工具"></a>6、node进程管理工具</h3><ul>
<li><p>supervisor</p>
</li>
<li><p>nodemon</p>
<pre><code>npm install nodemon
nodemon server.js

</code></pre></li>
</ul>
<ul>
<li><p>forever</p>
</li>
<li><p>pm2</p>
</li>
</ul>
<h2 id="三、模块-包与CommonJS"><a href="#三、模块-包与CommonJS" class="headerlink" title="三、模块/包与CommonJS"></a>三、模块/包与CommonJS</h2><h3 id="1、模块-包分类"><a href="#1、模块-包分类" class="headerlink" title="1、模块/包分类"></a>1、模块/包分类</h3><p>Node.js有三类模块，即内置的模块、第三方的模块、自定义的模块。</p>
<h4 id="1-1-内置的模块"><a href="#1-1-内置的模块" class="headerlink" title="1.1 内置的模块"></a>1.1 内置的模块</h4><p>Node.js内置模块又叫核心模块，Node.js安装完成可直接使用。如：</p>
<pre><code class="js">const path = require(&#39;path&#39;)
var extname = path.extname(&#39;index.html&#39;)
console.log(extname)

</code></pre>
<h4 id="1-2-第三方的Node-js模块"><a href="#1-2-第三方的Node-js模块" class="headerlink" title="1.2 第三方的Node.js模块"></a>1.2 第三方的Node.js模块</h4><p>第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如：</p>
<pre><code>npm install chalk

</code></pre><pre><code class="js">const chalk = require(&#39;chalk&#39;)
console.log(chalk.blue(&#39;Hello world!&#39;))

</code></pre>
<h4 id="1-3-自定义的Node-js模块"><a href="#1-3-自定义的Node-js模块" class="headerlink" title="1.3 自定义的Node.js模块"></a>1.3 自定义的Node.js模块</h4><p>自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。</p>
<p>自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。</p>
<h5 id="1-3-1-模块定义、接口暴露和引用接口"><a href="#1-3-1-模块定义、接口暴露和引用接口" class="headerlink" title="1.3.1 模块定义、接口暴露和引用接口"></a>1.3.1 模块定义、接口暴露和引用接口</h5><p>我们可以把公共的功能抽离成为一个单独的js文件作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过<code>exports</code>或者<code>module.exports</code>暴露属性或者方法。</p>
<blockquote>
<p>m1.js</p>
</blockquote>
<pre><code class="js">const name = &#39;gp19&#39;

const sayName = () =&gt; {
    console.log(name)
}

console.log(&#39;module 1&#39;)

// 接口暴露方法一：
module.exports = {
    say: sayName
}

// 接口暴露方法二：
exports.say = sayName

// 错误！
exports = {
    say: sayName
}

</code></pre>
<blockquote>
<p>main.js</p>
</blockquote>
<pre><code class="js">const m1 = require(&#39;./m1&#39;)
m1.say()

</code></pre>
<h5 id="1-3-2-模块的循环引用"><a href="#1-3-2-模块的循环引用" class="headerlink" title="1.3.2 模块的循环引用"></a>1.3.2 模块的循环引用</h5><p>由于exports使用方式不对，会在两个不同js循环引用的情况下，导致其中一个js无法获取另外一个js的方法，从而导致执行报错。如：</p>
<ul>
<li>a.js</li>
</ul>
<pre><code class="js">exports.done = false
const b = require(&#39;./b.js&#39;)
console.log(&#39;in a, b.done = %j&#39;, b.done)
exports.done = true
console.log(&#39;a done&#39;)

</code></pre>
<ul>
<li>b.js</li>
</ul>
<pre><code class="js">console.log(&#39;b starting&#39;)
exports.done = false
const a = require(&#39;./a.js&#39;)
console.log(&#39;in b, a.done= %j&#39;, a.done)
exports.done = true
console.log(&#39;b done&#39;)

</code></pre>
<ul>
<li>main.js</li>
</ul>
<pre><code class="js">console.log(&#39;main starting&#39;)
const a = require(&#39;./a.js&#39;)
const b = require(&#39;./b.js&#39;)
console.log(&#39;in main, a.done = %j, b.done = %j&#39;, a.done, b.done)

</code></pre>
<p><code>main.js</code>首先会load <code>a.js</code>，此时执行到<code>const b = require(&#39;./b.js&#39;);</code>的时候，程序会转去load<code>b.js</code>, 在<code>b.js</code>中执行到<code>const a = require(&#39;./a.js&#39;);</code> 为了防止无限循环，将<code>a.js</code>exports的未完成副本返回到<code>b.js</code>模块。然后<code>b.js</code>完成加载，并将其导出对象提供给<code>a.js</code>模块。</p>
<p>我们知道nodeJs的对每个js文件进行了一层包装称为<code>module</code>，<code>module</code>中有一个属性<code>exports</code>，当调用<code>require(&#39;a.js&#39;)</code>的时候其实返回的是<code>module.exports</code>对象，<code>module.exports</code>初始化为一个<code>{}</code>空的object，所以在上面的例子中，执行到<code>b.js</code>中<code>const a = require(&#39;./a.js&#39;);</code>时不会load新的<code>a module</code>, 而是将已经load但是还未完成的<code>a module</code>的<code>exports</code>属性返回给<code>b module</code>，所以<code>b.js</code>拿到的是<code>a module</code>的<code>exports</code>对象，即：<code>{done:false}</code>, 虽然在<code>a.js</code>中<code>exports.done</code>被修改成了<code>true</code>，但是由于此时<code>a.js</code>未<code>load</code>完成，所以在<code>b.js</code>输出的<code>a module</code>的属性<code>done</code>为<code>false</code>，而在<code>main.js</code>中输出的<code>a module</code>的属性<code>done</code>为<code>true</code>. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。</p>
<h2 id="四、常用内置模块"><a href="#四、常用内置模块" class="headerlink" title="四、常用内置模块"></a>四、常用内置模块</h2><p>这里介绍几个常用的内置模块：url，querystring，http，events，fs，stream，readline，crypto，zlib</p>
<h3 id="1、url"><a href="#1、url" class="headerlink" title="1、url"></a>1、url</h3><h4 id="1-1-parse"><a href="#1-1-parse" class="headerlink" title="1.1 parse"></a>1.1 parse</h4><blockquote>
<p>要解析的内容，是否查询字符串</p>
</blockquote>
<p><code>url.parse(urlString[,parseQueryString[,slashesDenoteHost]])</code></p>
<pre><code class="js">const url = require(&#39;url&#39;)
const urlString = &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;
const parsedStr = url.parse(urlString)
console.log(parsedStr)

=&gt;

Url {
  protocol: &#39;https:&#39;,
  slashes: true,
  auth: null,
  host: &#39;www.baidu.com:443&#39;,
  port: &#39;443&#39;,
  hostname: &#39;www.baidu.com&#39;,
  hash: &#39;#tag=110&#39;,
  search: &#39;?id=8&amp;name=mouse&#39;,
  query: [Object: null prototype] { id: &#39;8&#39;, name: &#39;mouse&#39; },
  pathname: &#39;/ad/index.html&#39;,
  path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;,
  href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;
}

</code></pre>
<h4 id="1-2-format"><a href="#1-2-format" class="headerlink" title="1.2 format"></a>1.2 format</h4><blockquote>
<p>将一个解析后的URL对象、转成、一个格式化的URL字符串。</p>
</blockquote>
<p><code>url.format(urlObject)</code></p>
<pre><code class="js">const url = require(&#39;url&#39;)
const urlObject = {
  protocol: &#39;https:&#39;,
  slashes: true,
  auth: null,
  host: &#39;www.baidu.com:443&#39;,
  port: &#39;443&#39;,
  hostname: &#39;www.baidu.com&#39;,
  hash: &#39;#tag=110&#39;,
  search: &#39;?id=8&amp;name=mouse&#39;,
  query: { id: &#39;8&#39;, name: &#39;mouse&#39; },
  pathname: &#39;/ad/index.html&#39;,
  path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;,
  href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;
}
const parsedObj = url.format(urlObject)
console.log(parsedObj)

=&gt; 
&#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;

</code></pre>
<h4 id="1-3-resolve"><a href="#1-3-resolve" class="headerlink" title="1.3 resolve"></a>1.3 resolve</h4><blockquote>
<p>用于拼接URL（替换 域名后面第一个<code>/</code>后的内容,如果出现<code>.</code>就向上返回一级之后再拼接，两个<code>..</code>就向上反两级再拼接）</p>
</blockquote>
<p><code>url.resolve(from, to)</code></p>
<pre><code>const url = require(&#39;url&#39;)
var a = url.resolve(&#39;/one/two/three&#39;, &#39;four&#39;) 
var b = url.resolve(&#39;http://example.com/&#39;, &#39;/one&#39;)
var c = url.resolve(&#39;http://example.com/one&#39;, &#39;/two&#39;);
var d = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;./two&#39;);
var e = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;../two&#39;);
var f = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;.../two&#39;);
console.log(a +&quot;,&quot;+ b +&quot;,&quot;+ c+&#39;,&#39;+d+&#39;,&#39;+e+&#39;,&#39;+f);

=&gt;
/one/two/four,
http://example.com/one,
http://example.com/two,
http://example.com/one/ddd/ddd/two,
http://example.com/one/ddd/two
http://example.com/one/ddd/ddd/.../two

</code></pre><h3 id="2、querystring"><a href="#2、querystring" class="headerlink" title="2、querystring"></a>2、querystring</h3><h4 id="2-1-parse"><a href="#2-1-parse" class="headerlink" title="2.1 parse"></a>2.1 parse</h4><blockquote>
<p>将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。</p>
</blockquote>
<p><code>querystring.parse(str[, sep[, eq[, options]]])</code></p>
<ul>
<li><code>str</code>：欲转换的字符串</li>
<li><code>sep</code>：设置分隔符，默认为<code>&amp;</code></li>
<li><code>eq</code>：设置赋值符，默认为<code>=</code></li>
<li><code>[options]</code>maxKeys：可接受字符串的最大长度，默认为1000</li>
</ul>
<pre><code class="js">const querystring = require(&#39;querystring&#39;)
var qs = &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#39;
var parsed = querystring.parse(qs)
console.log(parsed)

=&gt;

{ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }

</code></pre>
<h4 id="2-2-stringify"><a href="#2-2-stringify" class="headerlink" title="2.2 stringify"></a>2.2 stringify</h4><blockquote>
<p>将对象转换成字符串，字符串里多个参数将用 ‘&amp;&#39; 分隔，将用 ‘=&#39; 赋值。</p>
</blockquote>
<p><code>querystring.stringify(obj[, sep[, eq[, options]]])</code></p>
<ul>
<li><code>obj</code>：欲转换的对象</li>
<li><code>sep</code>：设置分隔符，默认为<code>&amp;</code></li>
<li><code>eq</code>：设置赋值符，默认为<code>=</code></li>
</ul>
<pre><code class="js">const querystring = require(&#39;querystring&#39;)
var qo = { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }
var parsed = querystring.stringify(qo)
console.log(parsed)

==&gt;
&#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;


const querystring = require(&#39;querystring&#39;)
var qo = {foo: &#39;bar&#39;, baz: &#39;qux&#39;}
var parsed =querystring.stringify(qo, &#39;;&#39;, &#39;:&#39;)
console.log(parsed)

==&gt;
&#39;foo:bar;baz:qux&#39;

</code></pre>
<h4 id="2-3-escape-unescape"><a href="#2-3-escape-unescape" class="headerlink" title="2.3 escape/unescape"></a>2.3 escape/unescape</h4><blockquote>
<p>以针对网址查询字符串的特定要求优化的方式对给定的 <code>str</code> 执行网址百分比编码</p>
<p><code>querystring.escape()</code> 方法被 <code>querystring.stringify()</code> 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 <code>querystring.escape</code> 分配给替代函数来提供替换的百分比编码实现。</p>
</blockquote>
<p><code>querystring.escape(str)</code></p>
<pre><code class="js">const querystring = require(&#39;querystring&#39;)
var str = &#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39;
var escaped = querystring.escape(str)
console.log(escaped)

==&gt; &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39;

</code></pre>
<blockquote>
<p>在给定的 <code>str</code> 上执行网址百分比编码字符的解码。</p>
<p><code>querystring.unescape()</code> 方法被 <code>querystring.parse()</code> 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 <code>querystring.unescape</code> 分配给替代函数来提供替代的解码实现。</p>
<p>默认情况下，<code>querystring.unescape()</code> 方法将尝试使用 JavaScript 内置的 <code>decodeURIComponent()</code> 方法进行解码。 如果失败，则将使用更安全的不会因格式错误的网址而抛出错误的同类方法。</p>
</blockquote>
<p><code>querystring.unescape(str)</code></p>
<pre><code class="js">const querystring = require(&#39;querystring&#39;)
var str = &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39;
var unescaped = querystring.unescape(str)
console.log(unescaped)

==&gt;
&#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39;

</code></pre>
<h3 id="3、http-https"><a href="#3、http-https" class="headerlink" title="3、http/https"></a>3、http/https</h3><h4 id="3-1-get"><a href="#3-1-get" class="headerlink" title="3.1 get"></a>3.1 get</h4><pre><code class="js">var http = require(&#39;http&#39;)
var https = require(&#39;https&#39;)

// 1、接口 2、跨域
const server = http.createServer((request, response) =&gt; {
  var url = request.url.substr(1)

  var data = &#39;&#39;


  response.writeHeader(200, {
    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;,
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;
  })

  //response.write(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;)
  //response.end()
  // 或
  //response.end(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;)

  https.get(`https://m.lagou.com/listmore.json${url}`, (res) =&gt; {

    res.on(&#39;data&#39;, (chunk) =&gt; {
      data += chunk
    })

    res.on(&#39;end&#39;, () =&gt; {
      response.end(JSON.stringify({
        ret: true,
        data
      }))
    })
  })

})

server.listen(8080, () =&gt; {
  console.log(&#39;localhost:8080&#39;)
})

</code></pre>
<h4 id="3-2-post-服务器提交（攻击）"><a href="#3-2-post-服务器提交（攻击）" class="headerlink" title="3.2 post:服务器提交（攻击）"></a>3.2 post:服务器提交（攻击）</h4><pre><code class="js">const https = require(&#39;https&#39;)
const querystring = require(&#39;querystring&#39;)

const postData = querystring.stringify({
  province: &#39;上海&#39;,
  city: &#39;上海&#39;,
  district: &#39;宝山区&#39;,
  address: &#39;同济支路199号智慧七立方3号楼2-4层&#39;,
  latitude: 43.0,
  longitude: 160.0,
  message: &#39;求购一条小鱼&#39;,
  contact: &#39;13666666&#39;,
  type: &#39;sell&#39;,
  time: 1571217561
})

const options = {
  protocol: &#39;http:&#39;,
  hostname: &#39;localhost&#39;,
  method: &#39;POST&#39;,
  port: 3000,
  path: &#39;/index.php/trade/add_item&#39;,
  headers: {
    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
    &#39;Content-Length&#39;: Buffer.byteLength(postData)
  }
}

const server = http.createServer((req, res) =&gt; {
    const request = http.request(options, result =&gt; {

    })
    req.write(postData)
    req.end()

    res.end()
})
server.listen(8080, ()=&gt; {
    console.log(&#39;localhost:8080&#39;)
})

//function doPost() {
//  let data

//  let req = https.request(options, (res) =&gt; {
//    res.on(&#39;data&#39;, chunk =&gt; data += chunk)
//    res.on(&#39;end&#39;, () =&gt; {
//      console.log(data)
//    })
//  })

//  req.write(postData)
//  req.end()
//}

// setInterval(() =&gt; {
//   doPost()
// }, 1000)

</code></pre>
<h4 id="3-3-跨域：JSONP"><a href="#3-3-跨域：JSONP" class="headerlink" title="3.3 跨域：JSONP"></a>3.3 跨域：JSONP</h4><pre><code class="js">const http = require(&#39;http&#39;)
const url = require(&#39;url&#39;)

const app = http.createServer((req, res) =&gt; {
  let urlObj = url.parse(req.url, true)

  switch (urlObj.pathname) {
    case &#39;/api/user&#39;:
      res.end(`${urlObj.query.cb}({&quot;name&quot;: &quot;gp145&quot;})`)
      break
    default:
      res.end(&#39;404.&#39;)
      break
  }
})

app.listen(8080, () =&gt; {
  console.log(&#39;localhost:8080&#39;)
})

</code></pre>
<h4 id="3-4-跨域：CORS"><a href="#3-4-跨域：CORS" class="headerlink" title="3.4 跨域：CORS"></a>3.4 跨域：CORS</h4><pre><code class="js">const http = require(&#39;http&#39;)
const url = require(&#39;url&#39;)
const querystring = require(&#39;querystring&#39;)

const app = http.createServer((req, res) =&gt; {
  let data = &#39;&#39;
  let urlObj = url.parse(req.url, true)

  res.writeHead(200, {
    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;,
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;
  })

  req.on(&#39;data&#39;, (chunk) =&gt; {
    data += chunk
  })

  req.on(&#39;end&#39;, () =&gt; {
    responseResult(querystring.parse(data))
  })

  function responseResult(data) {
    switch (urlObj.pathname) {
      case &#39;/api/login&#39;:
        res.end(JSON.stringify({
          message: data
        }))
        break
      default:
        res.end(&#39;404.&#39;)
        break
    }
  }
})

app.listen(8080, () =&gt; {
  console.log(&#39;localhost:8080&#39;)
})

</code></pre>
<h4 id="3-5-跨域：middleware-http-proxy-middware"><a href="#3-5-跨域：middleware-http-proxy-middware" class="headerlink" title="3.5 跨域：middleware(http-proxy-middware)"></a>3.5 跨域：middleware(http-proxy-middware)</h4><pre><code class="js">const http = require(&#39;http&#39;)
const proxy = require(&#39;http-proxy-middleware&#39;)

http.createServer((req, res) =&gt; {
  let url = req.url

  res.writeHead(200, {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;
  })

  if (/^\/api/.test(url)) {
    let apiProxy = proxy(&#39;/api&#39;, { 
      target: &#39;https://m.lagou.com&#39;,
      changeOrigin: true,
      pathRewrite: {
        &#39;^/api&#39;: &#39;&#39;
      }
    })

    // http-proy-middleware 在Node.js中使用的方法
    apiProxy(req, res)
  } else {
    switch (url) {
      case &#39;/index.html&#39;:
        res.end(&#39;index.html&#39;)
        break
      case &#39;/search.html&#39;:
        res.end(&#39;search.html&#39;)
        break
      default:
        res.end(&#39;[404]page not found.&#39;)
    }
  }
}).listen(8080)

</code></pre>
<h4 id="3-6-爬虫"><a href="#3-6-爬虫" class="headerlink" title="3.6 爬虫"></a>3.6 爬虫</h4><pre><code class="js">const https = require(&#39;https&#39;)
const http = require(&#39;http&#39;)
const cheerio = require(&#39;cheerio&#39;)

http.createServer((request, response) =&gt; {
  response.writeHead(200, {
    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;
  })

  const options = {
    protocol: &#39;https:&#39;,
    hostname: &#39;maoyan.com&#39;,
    port: 443,
    path: &#39;/&#39;,
    method: &#39;GET&#39;
  }

  const req = https.request(options, (res) =&gt; {
    let data = &#39;&#39;
    res.on(&#39;data&#39;, (chunk) =&gt; {
      data += chunk
    })

    res.on(&#39;end&#39;, () =&gt; {
      filterData(data)
    })
  })

  function filterData(data) {
    let $ = cheerio.load(data)
    let $movieList = $(&#39;.movie-item&#39;)
    let movies = []
    $movieList.each((index, value) =&gt; {
      movies.push({
        title: $(value).find(&#39;.movie-title&#39;).attr(&#39;title&#39;),
        score: $(value).find(&#39;.movie-score i&#39;).text(),
      })
    })

    response.end(JSON.stringify(movies))
  }

  req.end()
}).listen(9000)

</code></pre>
<h3 id="4、Events"><a href="#4、Events" class="headerlink" title="4、Events"></a>4、Events</h3><pre><code class="js">const EventEmitter = require(&#39;events&#39;)

class MyEventEmitter extends EventEmitter {}

const event = new MyEventEmitter()

event.on(&#39;play&#39;, (movie) =&gt; {
  console.log(movie)
})

event.emit(&#39;play&#39;, &#39;我和我的祖国&#39;)
event.emit(&#39;play&#39;, &#39;中国机长&#39;)

</code></pre>
<h3 id="5、File-System"><a href="#5、File-System" class="headerlink" title="5、File System"></a>5、File System</h3><pre><code class="js">const fs = require(&#39;fs&#39;)
const fsP = require(&#39;fs&#39;).promises

// 创建文件夹
fs.mkdir(&#39;./logs&#39;, (err) =&gt; {
  console.log(&#39;done.&#39;)
})

// 文件夹改名
fs.rename(&#39;./logs&#39;, &#39;./log&#39;, () =&gt; {
  console.log(&#39;done&#39;)
})

// 删除文件夹
fs.rmdir(&#39;./log&#39;, () =&gt; {
  console.log(&#39;done.&#39;)
})

// 写内容到文件里
fs.writeFile(
  &#39;./logs/log1.txt&#39;,
  &#39;hello&#39;,
  // 错误优先的回调函数
  (err) =&gt; {
    if (err) {
      console.log(err.message)
    } else {
      console.log(&#39;文件创建成功&#39;)
    }
  }
)

// 给文件追加内容
fs.appendFile(&#39;./logs/log1.txt&#39;, &#39;\nworld&#39;, () =&gt; {
  console.log(&#39;done.&#39;)
})

// 读取文件内容
fs.readFile(&#39;./logs/log1.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; {
  console.log(data)
})

// 删除文件
fs.unlink(&#39;./logs/log1.txt&#39;, (err) =&gt; {
  console.log(&#39;done.&#39;)
})

// 批量写文件
for (var i = 0; i &lt; 10; i++) {
  fs.writeFile(`./logs/log-${i}.txt`, `log-${i}`, (err) =&gt; {
    console.log(&#39;done.&#39;)
  })
}

// 读取文件/目录信息
fs.readdir(&#39;./&#39;, (err, data) =&gt; {
  data.forEach((value, index) =&gt; {
    fs.stat(`./${value}`, (err, stats) =&gt; {
      // console.log(value + &#39;:&#39; + stats.size)
      console.log(value + &#39; is &#39; + (stats.isDirectory() ? &#39;directory&#39; : &#39;file&#39;))
    })
  })
})

// 同步读取文件
try {
  const content = fs.readFileSync(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;)
  console.log(content)
  console.log(0)
} catch (e) {
  console.log(e.message)
}

console.log(1)

// 异步读取文件：方法一
fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; {
  console.log(content)
  console.log(0)
})
console.log(1)

// 异步读取文件：方法二
fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;).then(result =&gt; {
  console.log(result)
})

// 异步读取文件：方法三
function getFile() {
  return new Promise((resolve) =&gt; {
    fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; {
      resolve(data)
    })
  })
}

;(async () =&gt; {
  console.log(await getFile())
})()

// 异步读取文件：方法四
const fsp = fsP.readFile(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;).then((result) =&gt; {
  console.log(result)
})

console.log(fsP)

// watch 监测文件变化
fs.watch(&#39;./logs/log-0.txt&#39;, () =&gt; {
  console.log(0)
})

</code></pre>
<h3 id="6、Stream"><a href="#6、Stream" class="headerlink" title="6、Stream"></a>6、Stream</h3><pre><code class="js">const fs = require(&#39;fs&#39;)

const readstream = fs.createReadStream(&#39;./note.txt&#39;)
const writestream = fs.createWriteStream(&#39;./note2.txt&#39;)

writestream.write(readstream)

</code></pre>
<h3 id="7、Zlib"><a href="#7、Zlib" class="headerlink" title="7、Zlib"></a>7、Zlib</h3><pre><code class="js">const fs = require(&#39;fs&#39;)
const zlib = require(&#39;zlib&#39;)

const gzip = zlib.createGzip()

const readstream = fs.createReadStream(&#39;./note.txt&#39;)
const writestream = fs.createWriteStream(&#39;./note2.txt&#39;)

readstream
  .pipe(gzip)
  .pipe(writestream)

writestream.write(readstream)

</code></pre>
<h3 id="8、ReadLine"><a href="#8、ReadLine" class="headerlink" title="8、ReadLine"></a>8、ReadLine</h3><pre><code class="js">const readline = require(&#39;readline&#39;)

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})

rl.question(&#39;What do you think of Node.js? &#39;, (answer) =&gt; {
  // TODO: Log the answer in a database
  console.log(`Thank you for your valuable feedback: ${answer}`)

  rl.close()
})

</code></pre>
<h3 id="9、Crypto"><a href="#9、Crypto" class="headerlink" title="9、Crypto"></a>9、Crypto</h3><pre><code class="js">const crypto = require(&#39;crypto&#39;)

const secret = &#39;abcdefg&#39;
const hash = crypto.createHmac(&#39;sha256&#39;, secret)
                   .update(&#39;I love you&#39;)
                   .digest(&#39;hex&#39;)
console.log(hash)

</code></pre>
<h2 id="五、路由"><a href="#五、路由" class="headerlink" title="五、路由"></a>五、路由</h2><pre><code class="js">var http = require(&#39;http&#39;)
var fs = require(&#39;fs&#39;)

http.createServer( function ( req, res ) {

  switch ( req.url ) {
    case &#39;/home&#39;:
      res.write(&#39;home&#39;)
      res.end()
      break
    case &#39;/mine&#39;:
      res.write(&#39;mine&#39;)
      res.end()
      break
    case &#39;/login&#39;: 
      fs.readFile( &#39;./static/login.html&#39;,function ( error , data ) {
        if ( error ) throw error  
        res.write( data )
        res.end()
      })
      break
    case &#39;/fulian.jpg&#39;:
      fs.readFile( &#39;./static/fulian.jpg&#39;, &#39;binary&#39;, function( error , data ) {
        if( error ) throw error 
        res.write( data, &#39;binary&#39; )
        res.end()
      })
      break
    default: 
      break
   }

 }).listen( 8000, &#39;localhost&#39;, function () {
   console.log( &#39;服务器运行在： http://localhost:8000&#39; )
 })

</code></pre>
<h2 id="六、静态资源服务"><a href="#六、静态资源服务" class="headerlink" title="六、静态资源服务"></a>六、静态资源服务</h2><h3 id="6-1-readStaticFile"><a href="#6-1-readStaticFile" class="headerlink" title="6.1 readStaticFile"></a>6.1 readStaticFile</h3><p><code>/modules/readStaticFile.js</code></p>
<pre><code class="js">// 引入依赖的模块
var path = require(&#39;path&#39;)
var fs = require(&#39;fs&#39;)
var mime = require(&#39;mime&#39;)

function readStaticFile(res, filePathname) {

  var ext = path.parse(filePathname).ext
  var mimeType = mime.getType(ext)

  // 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 
  if (ext) {
    // 根据传入的目标文件路径来读取对应文件
    fs.readFile(filePathname, (err, data) =&gt; {
    // 错误处理
      if (err) {
        res.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; })
        res.write(&quot;404 - NOT FOUND&quot;)
        res.end()
      } else {
        res.writeHead(200, { &quot;Content-Type&quot;: mimeType })
        res.write(data)
        res.end()
      }
    });
    // 返回 true 表示, 客户端想要的 是 静态文件
    return true
  } else {
    // 返回 false 表示, 客户端想要的 不是 静态文件
    return false
  }
}

// 导出函数
module.exports = readStaticFile

</code></pre>
<h3 id="6-2-server"><a href="#6-2-server" class="headerlink" title="6.2 server"></a>6.2 server</h3><p><code>/server.js</code></p>
<pre><code class="js">// 引入相关模块
var http = require(&#39;http&#39;);
var url = require(&#39;url&#39;);
var path = require(&#39;path&#39;);
var readStaticFile = require(&#39;./modules/readStaticFile&#39;);

// 搭建 HTTP 服务器
var server = http.createServer(function(req, res) {
  var urlObj = url.parse(req.url);
  var urlPathname = urlObj.pathname;
  var filePathname = path.join(__dirname, &quot;/public&quot;, urlPathname);

  // 读取静态文件
  readStaticFile(res, filePathname);
});

// 在 3000 端口监听请求
server.listen(3000, function() {
  console.log(&quot;服务器运行中.&quot;);
  console.log(&quot;正在监听 3000 端口:&quot;)
})

</code></pre>
<h3 id="6-3-最终目录结构"><a href="#6-3-最终目录结构" class="headerlink" title="6.3 最终目录结构"></a>6.3 最终目录结构</h3><p><img src="https://lurongtao.gitee.io/felixbooks-gp19-node.js/images/dir.jpg" alt></p>
<h1 id="02-Express"><a href="#02-Express" class="headerlink" title="02-Express"></a>02-Express</h1><p>基于Node.js平台，快速、开放、极简的web开发框架。</p>
<pre><code>$ npm install express --save

</code></pre><h2 id="一、特色"><a href="#一、特色" class="headerlink" title="一、特色"></a>一、特色</h2><h3 id="1、Web应用"><a href="#1、Web应用" class="headerlink" title="1、Web应用"></a>1、Web应用</h3><p>Express是一个基于Node.js平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种Web和移动设备应用。</p>
<h3 id="2、API"><a href="#2、API" class="headerlink" title="2、API"></a>2、API</h3><p>丰富的HTTP快捷方法和任意排列组合的Connect中间件，让你创建健壮、友好的API变得既快速又简单。</p>
<h3 id="3、性能"><a href="#3、性能" class="headerlink" title="3、性能"></a>3、性能</h3><p>Express不对Node.js已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的基本性能。</p>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>首先假定你已经安装了Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p>
<pre><code>$ mkdir myapp
$ cd myapp

</code></pre><p>通过<code>npm init</code>命令为你的应用创建一个<code>package.json</code>文件。欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。</p>
<pre><code>$ npm init

</code></pre><p>此命令将要求你输入几个参数，例如此应用的名称和版本。你可以直接按“回车”键接受默认设置即可，下面这个除外：</p>
<pre><code>entry point: (index.js)

</code></pre><p>键入app.js或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的<code>index.js</code>文件名，只需按“回车”键即可。</p>
<p>接下来安装Express并将其保存到依赖列表中：</p>
<pre><code>$ npm install express --save

</code></pre><p>如果只是临时安装Express，不想将它添加到依赖列表中，只需略去--save参数即可：</p>
<pre><code>$ npm install express

</code></pre><blockquote>
<p>安装Node模块时，如果指定了<code>--save</code> 参数，那么此模块将被添加到<code>package.json</code>文件中<code>dependencies</code>依赖列表中。然后通过<code>npm install</code> 命令即可</p>
</blockquote>
<h2 id="三、Hello-World实例"><a href="#三、Hello-World实例" class="headerlink" title="三、Hello World实例"></a>三、Hello World实例</h2><p>接下来，我们一起创建一个基本的Express应用。</p>
<p>注意：这里所创建的是一个最最简单的Express应用，并且仅仅只有一个文件 - 和通过Express应用生成器所创建的应用完全不一样，Express应用生成器所创建的应用框架包含多JavaScript文件、Jade模板和针对不同用途的子目录。</p>
<p>进入myapp目录，创建一个名为app.js的文件，然后将下列代码复制进去：</p>
<pre><code class="js">var express = require(&#39;express&#39;);
var app = express();

app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;);
});

var server = app.listen(3000, function () {
  var host = server.address().address;
  var port = server.address().port;

  console.log(&#39;Example app listening at http://%s:%s&#39;, host, port);
});

</code></pre>
<p>上面的代码启动一个服务并监听从3000端口进入的所有连接请求。他将对所有(/)URL或 路由返回“Hello World！”字符串。对于其他所有路径全部返回 404 Not Found。</p>
<blockquote>
<p>req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on(&#39;data&#39;, callback) 以及任何 Node 提供的方法。</p>
</blockquote>
<p>通过如下命令启动此应用：</p>
<pre><code>$ node app.js

</code></pre><p>然后在浏览器中打开 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 并查看输出结果。</p>
<h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><p>路由是指如何定义应用的端点（URls）以及如何响应客户端的请求。</p>
<p>路由是由一个URI、HTTP请求（GET、POST等）和若干个句柄组成，它的结构如下：app.METHOD(path, [callback..], callback)， app 是 express 对象的一个实例，METHOD是一个 HTTP 请求方法，path 是服务器上的路径， callback 是当路由匹配时要执行的函数。</p>
<p>下面是一个基本的路由示例：</p>
<pre><code class="js">var express = require(&#39;express&#39;);
var app = express();

// respond with &quot;hello world&quot; when a GET request is made to the homepage
app.get(&#39;/&#39;, function(req, res) {
  res.send(&#39;hello world&#39;);
});

</code></pre>
<h3 id="1、路由方法"><a href="#1、路由方法" class="headerlink" title="1、路由方法"></a>1、路由方法</h3><p>路由方法源于 HTTP 请求方法，和 express 实例相关联。</p>
<p>下面这个例子展示了为应用跟路径定义的 GET 和 POST 请求：</p>
<pre><code class="js">// GET method route
// 对网站首页的访问返回 &quot;Hello World!&quot; 字样
app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;)
})

// 网站首页接受 POST 请求
app.post(&#39;/&#39;, function (req, res) {
  res.send(&#39;Got a POST request&#39;)
})

// /user 节点接受 PUT 请求
app.put(&#39;/user&#39;, function (req, res) {
  res.send(&#39;Got a PUT request at /user&#39;)
})

// /user 节点接受 DELETE 请求
app.delete(&#39;/user&#39;, function (req, res) {
  res.send(&#39;Got a DELETE request at /user&#39;)
})

</code></pre>
<p>Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。</p>
<blockquote>
<p>有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如：<code>app[&#39;m-search&#39;](&#39;/&#39;, function ...)</code></p>
</blockquote>
<p>app.all()是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。</p>
<p>在下面的例子中，来自&quot;/secret&quot;的请求，不管使用 GET、POST、PUT、DELETE或其他任何http模块支持的HTTP请求，句柄都会得到执行。</p>
<pre><code class="js">app.all(&#39;/secret&#39;, function (req, res, next) {
  console.log(&#39;Accessing the secret section ...&#39;)
  next(); // pass control to the next handler
})

</code></pre>
<h3 id="2、路由路径"><a href="#2、路由路径" class="headerlink" title="2、路由路径"></a>2、路由路径</h3><p>路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。</p>
<p>Express使用<code>path-to-regexp</code>匹配路由路径，请参考文档查阅所有定义路由路径的方法。Express Route Tester是测试基本Express路径的好工具，但不支持模式匹配。</p>
<blockquote>
<p>查询字符串不是路由路径的一部分。</p>
</blockquote>
<p>使用字符串的路由路径示例：</p>
<pre><code class="js">// 匹配根路径的请求
app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;root&#39;);
});

// 匹配 /about 路径的请求
app.get(&#39;/about&#39;, function (req, res) {
  res.send(&#39;about&#39;);
});

// 匹配 /random.text 路径的请求
app.get(&#39;/random.text&#39;, function (req, res) {
  res.send(&#39;random.text&#39;);
});

</code></pre>
<p>使用字符串模式的路由路径示例：</p>
<pre><code class="js">// 匹配 acd 和 abcd
app.get(&#39;/ab?cd&#39;, function(req, res) {
  res.send(&#39;ab?cd&#39;);
});

// 匹配 abcd、abbcd、abbbcd等
app.get(&#39;/ab+cd&#39;, function(req, res) {
  res.send(&#39;ab+cd&#39;);
});

// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等
app.get(&#39;/ab*cd&#39;, function(req, res) {
  res.send(&#39;ab*cd&#39;);
});

// 匹配 /abe 和 /abcde
app.get(&#39;/ab(cd)?e&#39;, function(req, res) {
 res.send(&#39;ab(cd)?e&#39;);
});

</code></pre>
<blockquote>
<p>字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。</p>
</blockquote>
<p>使用正则表达式的路由路径示例：</p>
<pre><code class="js">// 匹配任何路径中含有 a 的路径：
app.get(/a/, function(req, res) {
  res.send(&#39;/a/&#39;);
});

// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等
app.get(/.*fly$/, function(req, res) {
  res.send(&#39;/.*fly$/&#39;);
});

</code></pre>
<h3 id="3、路由句柄"><a href="#3、路由句柄" class="headerlink" title="3、路由句柄"></a>3、路由句柄</h3><p>可以为请求处理提供多个回调函数，其行为类似中间件。唯一的区别是这些回调函数有可能调用<code>next(&#39;route&#39;)</code>方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。</p>
<p>路由句柄有多种形式，可以是一个函数、一个函数数组、或者是两者混合，如下所示。</p>
<p>使用一个回调函数处理路由：</p>
<pre><code class="js">app.get(&#39;/example/a&#39;, function(req, res) {
    res.send(&#39;Hello from A!&#39;)
})

</code></pre>
<p>使用多个回调函数处理路由（记得指定next对象）：</p>
<pre><code class="js">app.get(&#39;/example/b&#39;, function (req, res, next) {
  console.log(&#39;response will be sent by the next function ...&#39;);
  next();
}, function (req, res) {
  res.send(&#39;Hello from B!&#39;);
});

</code></pre>
<p>使用回调函数数组处理路由：</p>
<pre><code class="js">var cb0 = function (req, res, next) {
  console.log(&#39;CB0&#39;)
  next()
}

var cb1 = function (req, res, next) {
  console.log(&#39;CB1&#39;)
  next()
}

var cb2 = function (req, res) {
  res.send(&#39;Hello from C!&#39;)
}

app.get(&#39;/example/c&#39;, [cb0, cb1, cb2])

</code></pre>
<p>混合使用函数和函数数组处理路由：</p>
<pre><code class="js">var cb0 = function (req, res, next) {
  console.log(&#39;CB0&#39;)
  next()
}

var cb1 = function (req, res, next) {
  console.log(&#39;CB1&#39;)
  next()
}

app.get(&#39;/example/d&#39;, [cb0, cb1], function (req, res, next) {
  console.log(&#39;response will be sent by the next function ...&#39;)
  next()
}, function (req, res) {
  res.send(&#39;Hello from D!&#39;)
})

</code></pre>
<h3 id="4、响应方法"><a href="#4、响应方法" class="headerlink" title="4、响应方法"></a>4、响应方法</h3><p>下表中响应对象(res)的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">res.download()</td>
<td style="text-align:center">提示下载文件</td>
</tr>
<tr>
<td style="text-align:center">res.end()</td>
<td style="text-align:center">终结响应处理流程</td>
</tr>
<tr>
<td style="text-align:center">res.json()</td>
<td style="text-align:center">发送一个JSON格式的响应</td>
</tr>
<tr>
<td style="text-align:center">res.jsonp()</td>
<td style="text-align:center">发送一个支持JSONP的JSON格式的响应</td>
</tr>
<tr>
<td style="text-align:center">res.direct()</td>
<td style="text-align:center">重定向请求</td>
</tr>
<tr>
<td style="text-align:center">res.render()</td>
<td style="text-align:center">渲染视图模板</td>
</tr>
<tr>
<td style="text-align:center">res.send()</td>
<td style="text-align:center">发送各种类型的响应</td>
</tr>
<tr>
<td style="text-align:center">res.sendFile()</td>
<td style="text-align:center">以八位字节流的形式发送文件</td>
</tr>
<tr>
<td style="text-align:center">res.sendStatus()</td>
<td style="text-align:center">设置响应状态代码，并将其以字符串形式作为响应体的一部分发送</td>
</tr>
</tbody>
</table>
<h3 id="5、app-route"><a href="#5、app-route" class="headerlink" title="5、app.route()"></a>5、app.route()</h3><p>可使用app.route()创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。</p>
<p>下面这个示例程序使用app.route()定义了链式路由句柄。</p>
<pre><code class="js">app.route(&#39;/book&#39;)
  .get(function(req, res) {
    res.send(&#39;Get a random book&#39;);
  })
  .post(function(req, res) {
    res.send(&#39;Add a book&#39;);
  })
  .put(function(req, res) {
    res.send(&#39;Update the book&#39;);
  });

</code></pre>
<h3 id="6、express-Router"><a href="#6、express-Router" class="headerlink" title="6、express.Router"></a>6、express.Router</h3><p>可使用express.Router类创建模块化、可挂载的路由句柄。Router实例是一个完整的中间件和路由系统，因此常称其为一个&#39;mini-app&#39;。</p>
<p>下面的实例程序创建了一个路由模块，并加载 了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。</p>
<p>在app目录下创建名为bird.js的文件，内容如下：</p>
<pre><code class="js">var express = require(&#39;express&#39;);
var router = express.Router();

// 该路由使用的中间件
router.use(function timeLog(req, res, next) {
  console.log(&#39;Time: &#39;, Date.now());
  next();
});
// 定义网站主页的路由
router.get(&#39;/&#39;, function(req, res) {
  res.send(&#39;Birds home page&#39;);
});
// 定义 about 页面的路由
router.get(&#39;/about&#39;, function(req, res) {
  res.send(&#39;About birds&#39;);
});

module.exports = router;

</code></pre>
<p>然后在应用中加载路由模块：</p>
<pre><code class="js">var birds = require(&#39;./birds&#39;)
...
app.use(&#39;/birds&#39;, birds)

</code></pre>
<p>应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。</p>
<h2 id="五、利用Express托管静态文件"><a href="#五、利用Express托管静态文件" class="headerlink" title="五、利用Express托管静态文件"></a>五、利用Express托管静态文件</h2><p>通过Express内置的<code>express.static</code>可以方便地托管静态文件，例如图片、CSS、JavaScript文件等。</p>
<p>将静态资源文件所在的目录作为参数传递给<code>express.static</code>中间件就可以提供静态资源文件的访问了。例如，假设在public目录放置了图片、CSS和JavaScript文件，你就可以：</p>
<pre><code class="js">app.use(express.static(&#39;public&#39;))

</code></pre>
<p>现在，public目录下面的文件就可以访问了。</p>
<pre><code>http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html

</code></pre><blockquote>
<p>所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在URL中。</p>
</blockquote>
<p>如果你的静态资源存放在多个目录下面，你可以多次调用<code>express.static</code>中间件：</p>
<pre><code class="js">app.use(express.static(&#39;public&#39;))
app.use(express.static(&#39;files&#39;))

</code></pre>
<p>访问静态资源文件时，<code>express.static</code>中间件会根据目录添加的顺序查找所需的文件。</p>
<p>如果你希望所有通过<code>express.static</code>访问的文件都存放在一个”虚拟(virtual)“目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：</p>
<pre><code class="js">app.use(&#39;/static&#39;, express.static(&#39;public&#39;))

</code></pre>
<p>现在，你就可以通过带有”/static“前缀的地址来访问public目录下面的文件了。</p>
<pre><code class="js">http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html

</code></pre>
<h2 id="六、使用中间件"><a href="#六、使用中间件" class="headerlink" title="六、使用中间件"></a>六、使用中间件</h2><p>Express是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。</p>
<p>中间件（Middleware）是一个函数，它可以访问请求对象（request object(req)），响应对象(response object(res))，和web应用中处于请求-响应循环流程中的中间件，一般被命名为next的变量。</p>
<p>中间件的功能包括：</p>
<ul>
<li>执行任何代码</li>
<li>修改请求和响应对象</li>
<li>终结请求-响应循环</li>
<li>调用堆栈中的下一个中间件</li>
</ul>
<p>如果当前中间件没有终结请求-响应循环，则必须调用<code>next()</code>方法将控制权交给下一个中间件，否则请求就会挂起。</p>
<p>Express应用可使用如下几种中间件：</p>
<ul>
<li>应用级中间件</li>
<li>路由级中间件</li>
<li>错误处理中间件</li>
<li>内置中间件</li>
<li>第三方中间件</li>
</ul>
<p>使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。</p>
<h3 id="1、应用级中间件"><a href="#1、应用级中间件" class="headerlink" title="1、应用级中间件"></a>1、应用级中间件</h3><p>应用级中间件绑定到app对象，使用<code>app.use()</code>和<code>app.METHOD()</code>，其中，<code>METHOD</code>是需要处理的HTTP请求的方法，例如GET,PUT,POST等等，全部小写。例如：</p>
<pre><code class="js">var app = express()

// 没有挂载路径的中间件，应用的每个请求都会执行该中间件
app.use(function (req, res, next) {
    console.log(&#39;Time:&#39;, Date.now())
    next()
})

// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它
app.use(&#39;/user/:id&#39;, function(req, res, next) {
    console.log(&#39;Request Type:&#39;, req.method)
    next()
})

// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求
app.get(&#39;/user/:id&#39;, function(req, res, next) {
    res.send(&#39;USER&#39;)
})

</code></pre>
<p>下面这个例子展示了在一个挂载点装载一组中间件。</p>
<pre><code class="js">// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息
app.use(&#39;/user/:id&#39;, function(req, res, next) {
    console.log(&#39;Request URL:&#39;, req.originalUrl)
    next()
}, function(req, res, next) {
    console.log(&#39;Request Type:&#39;, req.method)
    next()
})

</code></pre>
<p>作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。 第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。</p>
<pre><code class="js">// 一个中间件栈，处理指向 /user/:id 的 GET请求
app.get(&#39;/user/:id&#39;, function(req, res, next) {
    console.log(&#39;ID:&#39;, req.params.id)
    next()
}, function(req, res, next) {
    res.send(&#39;User Info&#39;)
})

// 处理 /user/:id, 打印出用户id
app.get(&#39;/user/:id&#39;, function(req, res, next) {
    res.end(req.params.id)
})

</code></pre>
<p>如果需要在中间件栈中跳过剩余中间件，调用 <code>next(&#39;route&#39;)</code>方法将控制权交给下一个路由。注意：<code>next(&#39;route&#39;)</code>只对使用 <code>app.VERB()</code>  或 <code>router.VERB()</code>加载的中间件有效。</p>
<pre><code class="js">// 一个中间件栈，处理指向 /user/:id 的 GET 请求
app.get(&#39;/user/:id&#39;, function(req, res, next) {
    // 如果 user id 为0，跳到下一个路由
    if (req.params.id === 0) next(&#39;route&#39;)
    // 否则将控制权交给栈中下一个中间件
    else next()
}, function(req, res, next) {
    // 渲染常规页面
    res.render(&#39;regular&#39;)
})

// 处理 /user/:id, 渲染一个特殊页面
app.get(&#39;/user/:id&#39;, function(req, res, next) {
    res.render(&#39;special&#39;)
})

</code></pre>
<h3 id="2、路由级中间件"><a href="#2、路由级中间件" class="headerlink" title="2、路由级中间件"></a>2、路由级中间件</h3><p>路由级中间件和应用级中间件一样，只是它绑定的对象为 <code>express.Router()</code>。</p>
<pre><code>var router = express.Router()

</code></pre><p>路由级使用<code>router.use()</code>或<code>router.VERB()</code>加载。</p>
<p> 上述在应用级创建的中间件系统，可通过如下代码改写为路由级。</p>
<pre><code class="js">var app = express()
var router = express.Router()

// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件
router.use(function (req, res, next) {
  console.log(&#39;Time:&#39;, Date.now())
  next()
})

// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息
router.use(&#39;/user/:id&#39;, function(req, res, next) {
  console.log(&#39;Request URL:&#39;, req.originalUrl)
  next()
}, function (req, res, next) {
  console.log(&#39;Request Type:&#39;, req.method)
  next()
})

// 一个中间件栈，处理指向 /user/:id 的 GET 请求
router.get(&#39;/user/:id&#39;, function (req, res, next) {
  // 如果 user id 为 0, 跳到下一个路由
  if (req.params.id == 0) next(&#39;route&#39;)
  // 负责将控制权交给栈中下一个中间件
  else next() //
}, function (req, res, next) {
  // 渲染常规页面
  res.render(&#39;regular&#39;)
})

// 处理 /user/:id， 渲染一个特殊页面
router.get(&#39;/user/:id&#39;, function (req, res, next) {
  console.log(req.params.id)
  res.render(&#39;special&#39;)
})

// 将路由挂载至应用
app.use(&#39;/&#39;, router)

</code></pre>
<h3 id="3、错误处理中间件"><a href="#3、错误处理中间件" class="headerlink" title="3、错误处理中间件"></a>3、错误处理中间件</h3><blockquote>
<p>错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。</p>
</blockquote>
<p>错误处理中间件和其他中间件定义类似，只是要使用4个参数，而不是3个，其签名如下：(err,req,res,next)。</p>
<pre><code class="js">app.use(function(err, req, res, next) {
  console.error(err.stack)
  res.status(500).send(&#39;Something broke!&#39;)
})

</code></pre>
<h3 id="4、内置中间件"><a href="#4、内置中间件" class="headerlink" title="4、内置中间件"></a>4、内置中间件</h3><p>从4.x版本开始，Express已经不再依赖Connect了。除了express.static，Express以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。</p>
<p><code>express.static(root, [options])</code></p>
<p>express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在Express应用中提托管静态资源。</p>
<p>参数 root 指提供静态资源的根目录。</p>
<p>可选的 options 参数拥有如下属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>类型</th>
<th>缺省值</th>
</tr>
</thead>
<tbody>
<tr>
<td>dotfiles</td>
<td>是否对外输出文件名以点（.）开头的文件。可选值为”allow“，”deny“和”ignore“。</td>
<td>String</td>
<td>”ignore“</td>
</tr>
<tr>
<td>etag</td>
<td>是否启用etag生成</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>extensions</td>
<td>设置文件扩展名备份选项</td>
<td>Array</td>
<td>[]</td>
</tr>
<tr>
<td>index</td>
<td>发送目录索引文件，设置为false禁用目录索引</td>
<td>Mixed</td>
<td>&quot;index.html&quot;</td>
</tr>
<tr>
<td>lastModified</td>
<td>设置Last-Modified头为文件在操作系统上的最后修改日期。可能值为true或false</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>maxAge</td>
<td>以毫秒或者其字符串格式设置Cache-Control头的max-age属性。</td>
<td>Number</td>
<td>0</td>
</tr>
<tr>
<td>redirect</td>
<td>当路径为目录时，重定向至”/“</td>
<td>Boolean</td>
<td>true</td>
</tr>
<tr>
<td>setHeaders</td>
<td>设置HTTP头以提供文件的函数</td>
<td>Function</td>
</tr>
</tbody>
</table>
<p>下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。</p>
<pre><code class="js">var options = {
  dotfiles: &#39;ignore&#39;,
  etag: false,
  extensions: [&#39;htm&#39;, &#39;html&#39;],
  index: false,
  maxAge: &#39;1d&#39;,
  redirect: false,
  setHeaders: function (res, path, stat) {
    res.set(&#39;x-timestamp&#39;, Date.now())
  }
}

app.use(express.static(&#39;public&#39;, options))

</code></pre>
<p>每个应用可有多个静态目录。</p>
<pre><code class="js">app.use(express.static(&#39;public&#39;))
app.use(express.static(&#39;uploads&#39;))
app.use(express.static(&#39;files&#39;))

</code></pre>
<h3 id="5、第三方中间件"><a href="#5、第三方中间件" class="headerlink" title="5、第三方中间件"></a>5、第三方中间件</h3><p>通过使用第三方中间件从而为 Express 应用增加更多功能。</p>
<p>安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。</p>
<p>下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser</p>
<pre><code>$ npm install cookie-parser

</code></pre><pre><code class="js">var express = require(&#39;express&#39;)
var app = express()
var cookieParser = require(&#39;cookie-parser&#39;)

// 加载用于解析 cookie 的中间件
app.use(cookieParser())

</code></pre>
<h2 id="七、在Express中使用模板引擎"><a href="#七、在Express中使用模板引擎" class="headerlink" title="七、在Express中使用模板引擎"></a>七、在Express中使用模板引擎</h2><p>需要在应用中进行如下设置才能让Express渲染模板文件：</p>
<ul>
<li><code>views</code>，放模板文件的目录，比如：<code>app.set(&#39;views&#39;, &#39;./views&#39;)</code></li>
<li><code>view engine</code>，模板引擎，比如：<code>app.set(&#39;view engine&#39;, &#39;ejs&#39;)</code></li>
</ul>
<p><strong>art-template</strong></p>
<p>art-template for express 4.x.</p>
<ul>
<li><p>1、Install</p>
<pre><code>npm install --save art-template
npm install --save express-art-template

</code></pre></li>
</ul>
<ul>
<li><p>2、Example</p>
<pre><code class="js">var express = require(&#39;express&#39;)
var app = express()

// view engine setup
app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;))
app.set(&#39;view&#39;, {
    debug: process.env.NODE_ENV !== &#39;production&#39;
})
app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;))
app.set(&#39;view engine&#39;, &#39;art&#39;)

// routes
app.get(&#39;/&#39;, function (req, res) {
    res.render(&#39;index.art&#39;, {
        user: {
            name: &#39;aui&#39;,
            tags: [&#39;art&#39;, &#39;template&#39;, &#39;nodejs&#39;]
        }
    })
})

</code></pre>
</li>
</ul>
<h1 id="03-Koa2"><a href="#03-Koa2" class="headerlink" title="03-Koa2"></a>03-Koa2</h1><h2 id="一、koa2快速开始"><a href="#一、koa2快速开始" class="headerlink" title="一、koa2快速开始"></a>一、koa2快速开始</h2><p>因为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以上node.js环境 版本v7.6以上 npm 版本3.x以上</p>

        </div>
        <!-- .entry-content -->
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2021/08/13/amazing/" rel="prev">
              <div class="background">
                <img class="lazyload" src="/images/bg1.jpg" data-src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                新鲜玩意</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2018/12/12/Hexo-Theme-Sakura/" rel="next">
              <div class="background">
                <img class="lazyload" src="/images/bg1.jpg" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                Hexo-Theme-Sakura</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "zMhFPcMIscDyGbtxHjYFffkx-gzGzoHsz",
        appKey: "c4XBymCm0OmYWLklOAKbUlhE",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="hojun.cn" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg" itemprop="image" alt="DarkStrand" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="hojun.cn" itemprop="url" rel="author">DarkStrand</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>一个神奇的小伙</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 DarkStrand<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2021</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by &<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">DarkStrand</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Bazinga.mp4","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Bazinga.mp4","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/touxiang.JPG">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">FLのBlog</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://gitee.com/darkstranded" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/资源/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="2660651585"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>