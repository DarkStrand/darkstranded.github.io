<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">JavaScript | DarkStrand</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "FLのBlog";
  mashiro_option.author_name = "Blog";
  mashiro_option.site_url = "";
  mashiro_option.v_appId = "zMhFPcMIscDyGbtxHjYFffkx-gzGzoHsz";
  mashiro_option.v_appKey = "c4XBymCm0OmYWLklOAKbUlhE";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/pexels-designecologist-1779487.jpg,https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/pexels-serpstat-572056.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
  
  <!--自定义看板娘-->
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="">
          <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/touxiang.JPG">
        </a>
      </div>
      <div class="header-info">
        <p>Live your life with passion! With some drive!</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://gitee.com/darkstranded" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/github.jpeg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/wechat.jpeg">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/qrwechat.png">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">FLの</span>
            <span class="shironeko">Blog</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/资源/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg);" src="/images/bg1.jpg" data-src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      JavaScript</h1>
      <p class="entry-census">
        <span>
          <a href="DarkStrand.cn">
            <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="DarkStrand.cn">DarkStrand</a>
        </span>
        <span class="bull">
        ·</span>
        2021-8-18<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>js全称javascript，是一门运行在浏览器端的脚本语言，现在也可以运行在服务器端（node.js）</p>
<h2 id="2、组成"><a href="#2、组成" class="headerlink" title="2、组成"></a>2、组成</h2><p>现在说的javasript包含3个组成部分</p>
<ol>
<li><strong>ECMAScript</strong> 语法标准，语法规则</li>
<li><strong>DOM</strong> 专门用于操作页面元素的方法</li>
<li><strong>BOM</strong> 专门用于操作浏览器的方法</li>
</ol>
<p><code>webapi</code>有时用来统称1和2</p>
<h2 id="3、js书写位置"><a href="#3、js书写位置" class="headerlink" title="3、js书写位置"></a>3、js书写位置</h2><ol>
<li>直接将内容编写在script标签中</li>
<li>可以直接在一个单独的js文件中编写，需要引入</li>
</ol>
<blockquote>
<p>注意点：只要script标签，设置了src属性，标签内的内容将被忽略</p>
</blockquote>
<h2 id="4、js的注释"><a href="#4、js的注释" class="headerlink" title="4、js的注释"></a>4、js的注释</h2><p>注释给开发者看的，浏览器不会执行，方便维护</p>
<ul>
<li>单行注释// 快捷键<code>ctrl+/</code></li>
<li>多行注释/**/ 快捷键<code>alt+shift+a</code></li>
</ul>
<h2 id="5、js的输出语句"><a href="#5、js的输出语句" class="headerlink" title="5、js的输出语句"></a>5、js的输出语句</h2><blockquote>
<p>指的就是往页面中输出的方式</p>
<ul>
<li><code>alert</code> 警告框</li>
<li><code>confirm</code> 确认框（可以选择的）</li>
<li><code>prompt</code> 输入框，可以让用户输入内容</li>
<li><code>document.write</code> 往页面中追加输入内容</li>
<li>支持标签的解析（识别标签）</li>
<li><code>console.log</code> 在控制台打印内容，专门用于调试的，给开发者看</li>
</ul>
</blockquote>
<h2 id="6、变量（就是可以变化的量）"><a href="#6、变量（就是可以变化的量）" class="headerlink" title="6、变量（就是可以变化的量）"></a>6、变量（就是可以变化的量）</h2><h3 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6.1 作用"></a>6.1 作用</h3><p>存储数据，为了将来可以运算使用</p>
<ol>
<li>先声明，后赋值<pre><code class="javascript">var age;
age = 18;
</code></pre>
</li>
<li>同时声明和赋值<pre><code class="javascript"> var age1 = 18;
 console.log(age1);
</code></pre>
</li>
<li>只声明，不赋值（<code>undefined</code>未定义，只要变量声明了但是未赋值，默认值就是undefined）</li>
<li>不声明，直接赋值(<strong>不推荐</strong>，变量一定要声明了，再使用)<pre><code class="javascript">age3=30;
console.log(age3);
</code></pre>
</li>
<li>不声明，不赋值，直接用  xxx is not defined 一定是没有声明赋值的变量直接用了，会报错</li>
<li>可以同时声明赋值多个变量（本质上，只是省略了var）</li>
</ol>
<h3 id="6-2-变量命名规则和规范"><a href="#6-2-变量命名规则和规范" class="headerlink" title="6.2 变量命名规则和规范"></a>6.2 变量命名规则和规范</h3><h4 id="6-2-1-规则"><a href="#6-2-1-规则" class="headerlink" title="6.2.1 规则"></a>6.2.1 规则</h4><ul>
<li>变量名必须由字母 数字 下划线和 $组成，不能以数字开头（后来也引入中文，但是不要这么做）</li>
<li>变量名不能是关键字或者是保留字</li>
<li>变量区分大小写</li>
</ul>
<h4 id="6-2-2-规范"><a href="#6-2-2-规范" class="headerlink" title="6.2.2 规范"></a>6.2.2 规范</h4><ul>
<li>声明的变量要有意义</li>
<li>声明的变量，如果很长，遵循驼峰命名（从第二个字母开始，首字母大写，用于分割单词，可读性高）</li>
</ul>
<h3 id="6-3-变量的作用域（变量起作用的区域）"><a href="#6-3-变量的作用域（变量起作用的区域）" class="headerlink" title="6.3 变量的作用域（变量起作用的区域）"></a>6.3 变量的作用域（变量起作用的区域）</h3><ul>
<li>全局作用域（在script标签内，在函数外的区域）<br>  声明在全局作用域的变量，就叫全局变量<br>  特征：在任何地方都可以使用</li>
<li>局部作用域（函数内部的区域，就是局部作用域）<br>  声明在函数内部的变量，就叫局部变量<br>  特征：只在当前函数内可以使用，出了函数，就不能用了</li>
</ul>
<h3 id="6-4-变量的访问规则"><a href="#6-4-变量的访问规则" class="headerlink" title="6.4 变量的访问规则"></a>6.4 变量的访问规则</h3><p>如果自己的作用域内有这个变量，直接用，改自己的<br>如果没有，才会往外面找（找全局）,用外面的，改外面的 </p>
<h3 id="6-5-隐式全局变量"><a href="#6-5-隐式全局变量" class="headerlink" title="6.5 隐式全局变量"></a>6.5 隐式全局变量</h3><p>如果一个没有声明过的变量，直接赋值，就叫隐式全局变量（将来要避免）</p>
<h3 id="6-6-预解析（预先解析，浏览器会先查看有多少的变量和函数）"><a href="#6-6-预解析（预先解析，浏览器会先查看有多少的变量和函数）" class="headerlink" title="6.6 预解析（预先解析，浏览器会先查看有多少的变量和函数）"></a>6.6 预解析（预先解析，浏览器会先查看有多少的变量和函数）</h3><ol>
<li>所有的变量声明，都会提升到最顶部，只提升声明，不提升赋值</li>
<li>所有的函数声明，都会提升到最顶部，只提升声明，不提升调用<blockquote>
<p>补充说明:</p>
<ol>
<li>多个重名的var声明，后面的var将被忽略<ol start="2">
<li>多个重名的函数声明，后面的将前面的覆盖</li>
<li>如果出现了同名的变量和函数，函数优先，函数的优先级&gt;变量</li>
<li>函数内部也会进行预解析</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ol>
<p>预解析，虽然可以提升我们的声明，但是我们开发时，还是要<strong>先声明，后使用</strong>！！！</p>
<h2 id="7、js的数据类型"><a href="#7、js的数据类型" class="headerlink" title="7、js的数据类型"></a>7、js的数据类型</h2><p>分为：<code>简单数据类型</code>和<code>复杂数据类型</code> （数组、函数、对象）</p>
<h3 id="7-1-简单数据类型"><a href="#7-1-简单数据类型" class="headerlink" title="7.1 简单数据类型"></a>7.1 简单数据类型</h3><h4 id="7-1-1-number类型（数字类型）"><a href="#7-1-1-number类型（数字类型）" class="headerlink" title="7.1.1 number类型（数字类型）"></a>7.1.1 number类型（数字类型）</h4><ol>
<li><p>整数（一般使用的是十进制  逢十进一）</p>
<p> <code>八进制，逢八进一，0开头</code></p>
<pre><code class="javascript"> var num3 = 011  //就是1*8+1 为9;
 var num4 = 022  //2*8+2 为18
</code></pre>
<p> <code>十六进制，逢16进一，0x开头的数字  0-9abcdef</code></p>
<pre><code class="javascript"> var num2 = 0x11  //1*16+1 为17;
 var num3 = 0x1a  //16+10为26;
</code></pre>
</li>
<li><p>浮点数（小数）</p>
</li>
<li><p>科学计数法 </p>
<pre><code class="javascript">var num1 = 1e4 就是1*10^4
</code></pre>
<blockquote>
<p>注意点：计算机对于小数的运算是不准确的，会有很小很小的误差，所以尽量不要用  小数进行比较运算</p>
</blockquote>
</li>
</ol>
<h4 id="7-1-2-string类型-字符串类型"><a href="#7-1-2-string类型-字符串类型" class="headerlink" title="7.1.2 string类型 字符串类型"></a>7.1.2 string类型 字符串类型</h4><ul>
<li>通过 &#39;&#39; 或者 &quot;&quot; 包裹的就是字符串，js中单双引号，没有区别，推荐&#39;&#39;.</li>
<li><p>字符串通过length，可以获取长度</p>
<pre><code>  console.log（str.length）;
</code></pre></li>
<li><p>转义字符<br><code>\&#39;</code> 表示一个普通的单引号<br>  <code>\&quot;</code> 表示一个普通的双引号<br>  <code>\n</code> 表示换行</p>
</li>
<li><p>拼串（拼接字符串）</p>
<blockquote>
<p><code>+</code> 有拼接字符串的功能，也有运算的功能</p>
</blockquote>
</li>
</ul>
<p><code>+</code> 的规则：</p>
<ol>
<li>只要两边有字符串（黑色），进行的就是拼串</li>
<li>只有两边都是数字（蓝色），才进行运算</li>
</ol>
<h4 id="7-1-3-boolean类型-布尔类型"><a href="#7-1-3-boolean类型-布尔类型" class="headerlink" title="7.1.3 boolean类型 布尔类型"></a>7.1.3 boolean类型 布尔类型</h4><p>只有两个值，true真 false假<br>一般用于比较</p>
<h4 id="7-1-4-undefined-未定义的，变量声明了，但是未赋值，默认值就是underfined"><a href="#7-1-4-undefined-未定义的，变量声明了，但是未赋值，默认值就是underfined" class="headerlink" title="7.1.4 undefined 未定义的，变量声明了，但是未赋值，默认值就是underfined"></a>7.1.4 undefined 未定义的，变量声明了，但是未赋值，默认值就是underfined</h4><h4 id="7-1-5-null-空对象"><a href="#7-1-5-null-空对象" class="headerlink" title="7.1.5 null 空对象"></a>7.1.5 null 空对象</h4><h3 id="7-2-复杂数据类型"><a href="#7-2-复杂数据类型" class="headerlink" title="7.2 复杂数据类型"></a>7.2 复杂数据类型</h3><h2 id="8、变量与简单数据类型的说明"><a href="#8、变量与简单数据类型的说明" class="headerlink" title="8、变量与简单数据类型的说明"></a>8、变量与简单数据类型的说明</h2><ul>
<li>对于简单数据类型，浏览器直接认识（直接量 或者 字面量）</li>
<li>若是将字符串当成了变量（未声明，未赋值的变量直接使用，会报错）</li>
<li>字符串需要引号包裹</li>
</ul>
<h2 id="9、运算符（操作符）"><a href="#9、运算符（操作符）" class="headerlink" title="9、运算符（操作符）"></a>9、运算符（操作符）</h2><h3 id="9-1-算术运算符-取余"><a href="#9-1-算术运算符-取余" class="headerlink" title="9.1 算术运算符 + - * / %(取余)"></a>9.1 算术运算符 <code>+ - * / %(取余)</code></h3><ul>
<li><code>+</code> 不仅有拼串的功能，还可以运算</li>
<li>其他算数运算符，只有运算的功能，如果遇到了字符串，也会转成数字运算<pre><code class="javascript">&quot;2&quot; - 1 = &gt;1
</code></pre>
<h3 id="9-2-赋值运算符"><a href="#9-2-赋值运算符" class="headerlink" title="9.2 赋值运算符 ="></a>9.2 赋值运算符 =</h3>=（就是赋值）   +=   -=   *=   /=   %=<pre><code class="javascript">var num = 10;
num += 10; //等价 num = num + 10
</code></pre>
</li>
</ul>
<h3 id="9-3-自增或自减运算符（一元运算符）"><a href="#9-3-自增或自减运算符（一元运算符）" class="headerlink" title="9.3 自增或自减运算符（一元运算符）"></a>9.3 自增或自减运算符（一元运算符）</h3><h4 id="9-3-1-自增：让变量的值，在原来的基础上-1"><a href="#9-3-1-自增：让变量的值，在原来的基础上-1" class="headerlink" title="9.3.1 自增：让变量的值，在原来的基础上+1"></a>9.3.1 自增：让变量的值，在原来的基础上+1</h4><ul>
<li><p>语法：<br><code>++num</code> 前自增，规则：先让值+1，再返回这个值<br><code>num++</code> 后自增，规则：先返回这个值，再让值+1</p>
</li>
<li><p>注意点： </p>
<ul>
<li>不管是++num 还是num++ 从功能的角度一样的，都是让变量的值+1</li>
<li>虽然++num 或 num++ 都能让变量值+1，但是++num 和 num++这个式子的结果是不一样的</li>
</ul>
</li>
</ul>
<h4 id="9-3-2-自减：让变量的值，在原来的基础上-1"><a href="#9-3-2-自减：让变量的值，在原来的基础上-1" class="headerlink" title="9.3.2 自减：让变量的值，在原来的基础上-1"></a>9.3.2 自减：让变量的值，在原来的基础上-1</h4><p>*语法：<br><code>--num</code><br><code>num--</code></p>
<h3 id="9-4-逻辑运算符（与或非）"><a href="#9-4-逻辑运算符（与或非）" class="headerlink" title="9.4 逻辑运算符（与或非）"></a>9.4 逻辑运算符（与或非）</h3><p><code>&amp;&amp;</code> 并且 两边都要成立，结果才是 true，只要有一个不成立，就是false<br><code>||</code> 或 两边只要有一个成立，结果就是true<br><code>!</code> 取反</p>
<h3 id="9-5-比较运算符-gt-lt-gt-lt"><a href="#9-5-比较运算符-gt-lt-gt-lt" class="headerlink" title="9.5 比较运算符 &gt;  &lt;  &gt;=  &lt;=  ==   !=  ===   !=="></a>9.5 比较运算符 &gt;  &lt;  &gt;=  &lt;=  ==   !=  ===   !==</h3><p><code>==</code> 规则：只看值，不看类型（只要值相等，就是相等）<br><code>===</code> 规则：看值，又看类型（值和类型都要相等）<br><code>!=</code> 规则：只看值，不看类型（只要值不等，就是true）<br><code>!==</code> 规则：看值，又看类型（只要值或者类型有一个不等，就是不等，返回true）</p>
<blockquote>
<p>==有一定规则（如果类型不同，转换成相同类型，然后比较）</p>
<ol>
<li>NaN，不等于任何值，包括他自己</li>
<li>null，不等于任何值，除了null和undefined</li>
<li>undefined，不等于任何值 ，除了null和undefined</li>
<li>看是否有数字或布尔，如果有，转成数字比较<br>   true：1，false:0<br>   [ ]:0, { }:NaN，&#39;&#39;:0</li>
<li>再看是否有字符串，（字符串和复杂数据类型），转成字符串比较<br> [ ].toString()---&gt;&quot;&quot;<br> obj.toString()---&gt;&#39;[object Object]&#39;</li>
<li>都是复杂数据类型，比较的是内存地址</li>
</ol>
</blockquote>
<h3 id="9-6-运算符优先级"><a href="#9-6-运算符优先级" class="headerlink" title="9.6 运算符优先级"></a>9.6 运算符优先级</h3><ol>
<li>括号的优先级最高</li>
<li>一元运算符 ++  --  !</li>
<li>算数运算符  先乘除%，后加减</li>
<li>比较运算符</li>
<li>逻辑运算符  &amp;&amp;  ||</li>
</ol>
<blockquote>
<p>记忆：（1）括号的优先级最高，逻辑运算符的优先级最低<br>         （2）先乘除，后加减</p>
</blockquote>
<h2 id="10、如何判断数据的类型"><a href="#10、如何判断数据的类型" class="headerlink" title="10、如何判断数据的类型"></a>10、如何判断数据的类型</h2><h3 id="10-1-直接打印看颜色（调试，看颜色）"><a href="#10-1-直接打印看颜色（调试，看颜色）" class="headerlink" title="10.1 直接打印看颜色（调试，看颜色）"></a>10.1 直接打印看颜色（调试，看颜色）</h3><p>蓝色的数字，number<br>黑色         string<br>蓝色的布尔值 boolean<br>灰色        undefined和null</p>
<h3 id="10-2-typeof-变量-它的返回值，也是一个字符串类型"><a href="#10-2-typeof-变量-它的返回值，也是一个字符串类型" class="headerlink" title="10.2 typeof 变量    它的返回值，也是一个字符串类型"></a>10.2 typeof 变量    它的返回值，也是一个字符串类型</h3><ol>
<li>number</li>
<li>string</li>
<li>boolean</li>
</ol>
<blockquote>
<p>bug: typeof null = object;</p>
</blockquote>
<h2 id="11、数据类型转换"><a href="#11、数据类型转换" class="headerlink" title="11、数据类型转换"></a>11、数据类型转换</h2><h3 id="11-1-转成数字"><a href="#11-1-转成数字" class="headerlink" title="11.1 转成数字"></a>11.1 转成数字</h3><ul>
<li><code>Number（xx）</code> 如果拿到的是一个非数字，浏览器也不会报错，返回 <code>NaN</code>,not  a number </li>
<li><code>parseInt（xx）</code> 从第一个字符开始解析，一直解析到第一个非数字为止</li>
<li><code>parseFloat（xx）</code> 从第一个字符开始解析，可以识别一个<code>.</code>  然后解析到非数字为止</li>
<li>直接运算 -  *  /  %    +正号（用的最多，例如+age）  -负号        </li>
</ul>
<h3 id="11-2-转成字符串"><a href="#11-2-转成字符串" class="headerlink" title="11.2 转成字符串"></a>11.2 转成字符串</h3><ul>
<li>String（xx）</li>
<li>xx.toString()</li>
<li>直接拼串 （常用）<br>  console.log(age+ &quot;&quot;);</li>
</ul>
<h3 id="11-3-转成布尔类型"><a href="#11-3-转成布尔类型" class="headerlink" title="11.3 转成布尔类型"></a>11.3 转成布尔类型</h3><p><strong>所有的值，都可以转成布尔类型</strong></p>
<p><strong>规则</strong>：只有这6种情况， 0  &quot;&quot;  NaN  null  undefined   false  可以转成false，其他所有值，都是true</p>
<ul>
<li>Boolean（）</li>
<li>!!</li>
</ul>
<h3 id="11-4-NaN的说明（表示非数字，指一个无法用数字表示的数字，not-a-number）"><a href="#11-4-NaN的说明（表示非数字，指一个无法用数字表示的数字，not-a-number）" class="headerlink" title="11.4 NaN的说明（表示非数字，指一个无法用数字表示的数字，not a number）"></a>11.4 NaN的说明（表示非数字，指一个无法用数字表示的数字，not a number）</h3><ul>
<li>如果浏览器遇到了一个无法用数字表示的数值，就用NaN表示</li>
<li>只要看到了NaN，说明代码的执行有问题</li>
<li>NaN的类型是number类型</li>
<li>NaN不等于任何值，包括他自己</li>
</ul>
<h2 id="12、流程控制"><a href="#12、流程控制" class="headerlink" title="12、流程控制"></a>12、流程控制</h2><h3 id="12-1-顺序结构（从上到下执行的，默认）"><a href="#12-1-顺序结构（从上到下执行的，默认）" class="headerlink" title="12.1 顺序结构（从上到下执行的，默认）"></a>12.1 顺序结构（从上到下执行的，默认）</h3><h3 id="12-2-分支结构（选择结构）"><a href="#12-2-分支结构（选择结构）" class="headerlink" title="12.2 分支结构（选择结构）"></a>12.2 分支结构（选择结构）</h3><h4 id="12-2-1-if语句"><a href="#12-2-1-if语句" class="headerlink" title="12.2.1 if语句"></a>12.2.1 if语句</h4><ul>
<li><p>语法1</p>
<pre><code class="javascript">if（条件）{
语句1;
}
</code></pre>
<p>如果条件成立，执行语句1</p>
</li>
<li><p>语法2</p>
<pre><code>if（条件）{
语句1;
}
else {
语句2;
}
</code></pre><p>如果条件成立，执行语句1，否则执行语句2</p>
</li>
<li><p>语法3</p>
<pre><code>if（条件1）{
语句1;
}
else if（条件2） {
语句2;
}
else {
语句3;
}
</code></pre></li>
</ul>
<p>如果条件1成立，执行语句1<br>如果条件1不成立，看条件2，如果条件2成立，执行语句2<br>如果都不成立，执行语句3</p>
<h4 id="12-2-2-三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）"><a href="#12-2-2-三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）" class="headerlink" title="12.2.2 三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）"></a>12.2.2 三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）</h4><p>语法  var 结果 = 条件 ？ A ：B；（如果条件满足，就是A 否则B）</p>
<h4 id="12-2-3-switch-case（根据变量的具体，进行判断）"><a href="#12-2-3-switch-case（根据变量的具体，进行判断）" class="headerlink" title="12.2.3 switch-case（根据变量的具体，进行判断）"></a>12.2.3 switch-case（根据变量的具体，进行判断）</h4><pre><code class="javascript">switch（变量）{
  case 值1:
      语句1;
      break;（break表示跳出switch，接着往下执行）
  case 值2:
      语句2;
      break;（break表示跳出switch，接着往下执行）
  case 值3:
      语句3;
      break;（break表示跳出switch，接着往下执行）
  default:
      默认语句;
}
</code></pre>
<p><strong>判断变量的值</strong><br>    如果值，等于值1，执行语句1<br>    如果值，等于值2，执行语句2<br>    。。。<br>    如果都不满足，执行默认语句</p>
<p><strong>注意点</strong>：<br>    （1）进行的值的比较，进行的是全等比较<br>    （2）养成写break的习惯（不写break，会一直往下执行）</p>
<h4 id="12-2-4-三种分支结构的使用场景："><a href="#12-2-4-三种分支结构的使用场景：" class="headerlink" title="12.2.4 三种分支结构的使用场景："></a>12.2.4 三种分支结构的使用场景：</h4><ul>
<li>if else            适用于范围形的判断</li>
<li>三元运算符        只适用于比较简单的判断，条件只能写一个，但是简洁</li>
<li>switch。。 case。。适用于具体值的判断</li>
</ul>
<h3 id="12-3-循环结构"><a href="#12-3-循环结构" class="headerlink" title="12.3 循环结构"></a>12.3 循环结构</h3><h4 id="12-3-1-while（当条件成立时，循环执行某件事）"><a href="#12-3-1-while（当条件成立时，循环执行某件事）" class="headerlink" title="12.3.1 while（当条件成立时，循环执行某件事）"></a>12.3.1 while（当条件成立时，循环执行某件事）</h4><pre><code class="javascript">while（条件）{
  循环体; //循环执行的内容
}
</code></pre>
<p>条件成立，执行循环体<br>判断条件，条案件成立，继续执行循环体<br>。。。<br>条件不成立，跳出循环<br>死循环，永远都没有结束的一个循环，开发中需要避免</p>
<ul>
<li>while循环一定要有条件，不然就死循环了</li>
<li>i++一般放在{..}的最后面</li>
<li>while循环可以用于实现不明确循环次数的循环</li>
</ul>
<h4 id="12-3-2-do-while"><a href="#12-3-2-do-while" class="headerlink" title="12.3.2 do while"></a>12.3.2 do while</h4><pre><code class="javascript">do {
  循环体; //重复执行的内容
}while（条件)
</code></pre>
<p>一上来，直接执行循环体<br>再判断条件，如果条件成立，再执行循环体<br>。。。<br>直到条件不成立，跳出循环</p>
<blockquote>
<p>do while一般只适合：不管条件成立不成立，都执行一次<br>while 和 do while的区别：<br>    while 如果条件不成立，一次都不执行<br>    do while不管条件成立与否，至少执行一次</p>
</blockquote>
<h4 id="12-3-3-for（适用于明确范围的循环）"><a href="#12-3-3-for（适用于明确范围的循环）" class="headerlink" title="12.3.3 for（适用于明确范围的循环）"></a>12.3.3 for（适用于明确范围的循环）</h4><pre><code>for（初始化语句;判断条件;自增或自减）{
  循环体;
}
</code></pre><p>例：</p>
<pre><code class="javascript">for（var i = 1；i &lt; 5; i++）{
  console.log(1);
}
</code></pre>
<p>执行语句：</p>
<ol>
<li>初始化语句<ol start="2">
<li>判断条件</li>
<li>自增或自减</li>
<li>循环体</li>
</ol>
</li>
</ol>
<p>执行流程分析：1243 243 243 243...<br>执行流程：<br>  先初始化语句，判断条件，执行循环体，自增或自减；<br>    判断条件，执行循环体，自增或自减；<br>    。。。<br>    条件不成立，跳出循环；</p>
<h4 id="12-3-4-双重for循环，就是在for循环的外面再套一个for循环"><a href="#12-3-4-双重for循环，就是在for循环的外面再套一个for循环" class="headerlink" title="12.3.4 双重for循环，就是在for循环的外面再套一个for循环"></a>12.3.4 双重for循环，就是在for循环的外面再套一个for循环</h4><ul>
<li>外层控制行数</li>
<li><p>内层控制一行打印多少个</p>
<p>  break：如果循环遇到了break，跳出整个循环，整个循环就结束了，后面的次数都不执行了<br>  continue：如果循环遇到了continue，跳出本次循环，执行下一次循环</p>
</li>
</ul>
<h4 id="12-3-5-循环的使用场景："><a href="#12-3-5-循环的使用场景：" class="headerlink" title="12.3.5 循环的使用场景："></a>12.3.5 循环的使用场景：</h4><ul>
<li>while比较适合不明确执行次数的循环（循环表白案例）</li>
<li>do while（少用）只适用于不管成立与否，至少执行一次循环体的情况</li>
<li>for比较适合于明确范围的循环</li>
</ul>
<h2 id="13、断点调试"><a href="#13、断点调试" class="headerlink" title="13、断点调试"></a>13、断点调试</h2><p>（1）F12打开控制台，sources,点开对应的文件<br>（2）在对应行的行号上，点击打断点，刷新后，浏览器会自动执行停留在断点的位置<br>操作：<br>（1）watch监视，监视变量的变化<br>（2）F10，让代码往下一步执行<br>（3）F8，从当前位置，执行到下一个断点的位置，如果后面没有断点了，就会一直执行完</p>
<h2 id="14、数组（是一个有序的值的集合，可以存储大量的数据）"><a href="#14、数组（是一个有序的值的集合，可以存储大量的数据）" class="headerlink" title="14、数组（是一个有序的值的集合，可以存储大量的数据）"></a>14、数组（是一个有序的值的集合，可以存储大量的数据）</h2><p>简单数据类型，在存储大量数据时，一个一个的存，非常的浪费</p>
<h3 id="14-1-创建数组的方式"><a href="#14-1-创建数组的方式" class="headerlink" title="14.1 创建数组的方式"></a>14.1 创建数组的方式</h3><ol>
<li><p>字面量的方式（字面量，直接量，从字面上直接就能看出是什么值的量）</p>
<pre><code> 123  false  &#39;abc&#39;  undefined  null  [ ]:表示数组
</code></pre><p><code>var arr =[ ]</code>创建一个空数组</p>
<blockquote>
<p>注意点：数组里面可以存任意类型的数据，但是规范是存储同类型的数据</p>
</blockquote>
</li>
<li><p>构造函数的方式</p>
<pre><code class="javascript"> var arr = new Array(); ---创建一个空数组
 var arr = new Array(5);---浪费空间，五个空的位置，没有具体值
</code></pre>
<h3 id="14-2-数组的长度-arr-length"><a href="#14-2-数组的长度-arr-length" class="headerlink" title="14.2 数组的长度 arr.length"></a>14.2 数组的长度 arr.length</h3><h3 id="14-3-数组的下标（索引）：数组中的每一项，都会有一个唯一的下标"><a href="#14-3-数组的下标（索引）：数组中的每一项，都会有一个唯一的下标" class="headerlink" title="14.3 数组的下标（索引）：数组中的每一项，都会有一个唯一的下标"></a>14.3 数组的下标（索引）：数组中的每一项，都会有一个唯一的下标</h3></li>
</ol>
<ul>
<li>从0开始，最大下标arr.length-1</li>
<li>数组中下标的范围：0 -----&gt; arr.length-1</li>
</ul>
<h3 id="14-4-数组的取值和存值"><a href="#14-4-数组的取值和存值" class="headerlink" title="14.4 数组的取值和存值"></a>14.4 数组的取值和存值</h3><ul>
<li><p>取值：<br><strong>语法：数组名[下标]</strong></p>
<ol>
<li>如果下标存在，直接返回对应项的值</li>
<li>如果下标不存在，返回undefined</li>
</ol>
</li>
<li><p>存值（改值）<br><strong>语法：数组名[下标] = ‘新的值’</strong></p>
<ol>
<li>如果下标存在，直接用新的值覆盖</li>
<li>如果下标不存在，新建一个项，进行赋值</li>
</ol>
</li>
<li><p>往数组最后添加项</p>
<ol>
<li>arr[arr.length] = &#39;值&#39;;</li>
<li>arr.push(&#39;值&#39;)；</li>
</ol>
</li>
</ul>
<h3 id="14-5-数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项"><a href="#14-5-数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项" class="headerlink" title="14.5 数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项"></a>14.5 数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项</h3><ul>
<li><p>数组正序遍历</p>
<pre><code class="javascript">for (var i = 0; i &lt; arr.length; i++) {
`console.log(arr[i]);
}
</code></pre>
</li>
<li><p>数组倒叙遍历</p>
<pre><code>for (var i = arr.length-1; i &gt;=0; i--) {
console.log(arr[i]);
}
</code></pre></li>
</ul>
<h3 id="14-6-冒泡排序"><a href="#14-6-冒泡排序" class="headerlink" title="14.6 冒泡排序"></a>14.6 冒泡排序</h3><ol>
<li>冒泡（指得是排序的方式）</li>
<li>排序（就是讲一组没有按照顺序排列的数，经过排列后，按照一定的顺序排列）<br> 价格排序，成绩排序<br> 编程界，有十大排序</li>
</ol>
<h3 id="14-7-初级版"><a href="#14-7-初级版" class="headerlink" title="14.7 初级版"></a>14.7 初级版</h3><ol>
<li>先排出一趟，排出一个最大值<ol>
<li>遍历数组</li>
<li>让arr[i] 和 arr[i+1] 比较</li>
<li>如果arr[i] &gt; arr[i+1] ，交换位置</li>
</ol>
</li>
<li>双重for循环，多排几次，就排好了</li>
</ol>
<h3 id="14-8-中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次"><a href="#14-8-中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次" class="headerlink" title="14.8 中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次"></a>14.8 中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次</h3><pre><code>    内循环-j
</code></pre><h3 id="14-9-高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了"><a href="#14-9-高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了" class="headerlink" title="14.9 高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了"></a>14.9 高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了</h3><ol>
<li>在每趟排列前，先假设，已经排好了</li>
<li>一趟下来，如果一次交换都没有发生，flag值就是true<pre><code class="javascript">var arr = [7, 6, 5, 4, 3, 2, 1];
// 外层控制趟数, 一趟可以比出一个最大值, 7个数, 比6趟即可
for (var j = 0; j &lt; arr.length-1; j++) {
// 在每趟排列前, 先假设, 已经排好了
var flag = true;
for (var i = 0; i &lt; arr.length-1-j; i++) {
 if (arr[i] &gt; arr[i + 1]) {
   var temp = arr[i];
   arr[i] = arr[i + 1];
   arr[i+1] = temp;
   // 发生了交换, 说明没有排好
   flag = false;
 }
}
// 一趟下来, 如果一次交换都没有发生, flag值就是 true
if (flag) {
 break; 
}
}
console.log(arr);
</code></pre>
</li>
</ol>
<h2 id="15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）"><a href="#15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）" class="headerlink" title="15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）"></a>15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）</h2><p><strong>好处</strong>：可维护性高</p>
<h3 id="15-1-声明函数"><a href="#15-1-声明函数" class="headerlink" title="15.1 声明函数"></a>15.1 声明函数</h3><p><strong>函数名的规范</strong>：一般都是动词+名词（一般函数都是要做某一件事情）</p>
<pre><code>function 函数名(){
  函数体;
}
</code></pre><blockquote>
<p>函数光声明，是不会执行的。</p>
</blockquote>
<h4 id="15-1-1-调用函数"><a href="#15-1-1-调用函数" class="headerlink" title="15.1.1 调用函数"></a>15.1.1 调用函数</h4><pre><code>函数();
</code></pre><p>函数一次声明，可以多次调用！！！</p>
<h4 id="15-1-2-函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）"><a href="#15-1-2-函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）" class="headerlink" title="15.1.2 函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）"></a>15.1.2 函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）</h4><ul>
<li><p>形参---形式参数（函数在声明时，函数名括号内的参数）<br>  形参默认没有值或类型！！！只在函数调用时，形参才会有具体的值或类型<br>  作用：占位置</p>
</li>
<li><p>实参---实际参数（函数调用时传递给函数的参数）<br>  实参有具体的值或者类型<br>  作用：在函数调用时将数据传递给形参</p>
</li>
</ul>
<blockquote>
<p>注意点：形参和实参一一对应！！！</p>
</blockquote>
<h4 id="15-1-3-函数的声明和调用进阶写法"><a href="#15-1-3-函数的声明和调用进阶写法" class="headerlink" title="15.1.3 函数的声明和调用进阶写法"></a>15.1.3 函数的声明和调用进阶写法</h4><pre><code class="javascript">function 函数名（形参1，形参2，形参3...）{
  函数体;
}
</code></pre>
<h4 id="15-1-4-函数的返回值"><a href="#15-1-4-函数的返回值" class="headerlink" title="15.1.4 函数的返回值"></a>15.1.4 函数的返回值</h4><p>函数内部声明的变量 或者 形参，只能在函数内使用，出了函数就用不了了<br>如果希望函数的执行，有结果，需要通过<code>return</code>返回内容</p>
<blockquote>
<p>函数的三要素---决定了一个函数怎么去使用</p>
<ol>
<li><code>函数名</code>：一个函数一次声明，可以多次调用（规范：动词+名词）</li>
<li><code>函数参数</code>：可有可无，但是如果有需要变化的值，一般需要提取成形参</li>
<li><code>返回值</code>：可有可无，但是如果需要拿到函数的执行结果，就必须要return</li>
</ol>
</blockquote>
<h4 id="15-1-5-函数参数与返回值的说明"><a href="#15-1-5-函数参数与返回值的说明" class="headerlink" title="15.1.5 函数参数与返回值的说明"></a>15.1.5 函数参数与返回值的说明</h4><ul>
<li><p>开发的时候，函数的参数要一一对应</p>
<ol>
<li>传递的参数，如果少了，没接收到值的形参，值就是undefined（数字和undefined加起来就是NaN）</li>
<li>传递的参数，如果多了，多传的参数，会被忽略</li>
</ol>
</li>
<li><p>返回值的问题<br>  1.return的值，就是函数的执行结果<br>  2.return后面的代码，不执行了！return表示函数的结束！！</p>
</li>
</ul>
<h4 id="15-1-6-函数调试说明"><a href="#15-1-6-函数调试说明" class="headerlink" title="15.1.6 函数调试说明"></a>15.1.6 函数调试说明</h4><ul>
<li>函数可以在内部调用函数</li>
<li>F10 让代码往下一步执行，如果遇到了函数调用，会跳过函数的执行过程，直接看结果</li>
<li>F11让代码往下一步执行，如果遇到了函数调用，会进入函数一步步执行</li>
<li>shift + F11 跳出函数的执行（将当前函数的调用的剩余代码全部执行完，直接看结果）</li>
</ul>
<h4 id="15-1-7-声明函数的两种方式"><a href="#15-1-7-声明函数的两种方式" class="headerlink" title="15.1.7 声明函数的两种方式"></a>15.1.7 声明函数的两种方式</h4><ol>
<li><p><code>函数声明式</code>（可以先调用，后声明---预解析，会提升函数的声明）</p>
<pre><code class="javascript">function fn( ) {
console.log(&#39;嘿嘿&#39;);
}
</code></pre>
</li>
<li><p><code>函数表达式</code>（只可以先声明赋值，后调用）---写法相对严格</p>
<pre><code>var fn = function( ){
console.log(&#39;哈哈&#39;);
};
</code></pre></li>
</ol>
<h3 id="15-2-匿名函数（没有名字的函数，不能直接使用）"><a href="#15-2-匿名函数（没有名字的函数，不能直接使用）" class="headerlink" title="15.2 匿名函数（没有名字的函数，不能直接使用）"></a>15.2 匿名函数（没有名字的函数，不能直接使用）</h3><p>使用场景：</p>
<ol>
<li>函数表达式 var fn = function(){...}</li>
<li>匿名函数自调用（自执行)<blockquote>
<p>直接自调用会报错，可以给整个函数包一个( ),包成了一个整体，就可以调用了</p>
<pre><code class="javascript">(function ( ) {
 console.log(123);
})( );
</code></pre>
</blockquote>
</li>
</ol>
<p><strong>沙箱模式--匿名函数自调用的应用=&gt;可以用于解决全局变量污染问题</strong><br>由于全局变量，可以在任何地方都可以访问，所以不能乱用<br>一般都会用函数自调用包裹起来</p>
<pre><code>（function() {...}）
</code></pre><h2 id="16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）"><a href="#16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）" class="headerlink" title="16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）"></a>16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）</h2><h3 id="16-1-概念：无序的键值对的集合"><a href="#16-1-概念：无序的键值对的集合" class="headerlink" title="16.1 概念：无序的键值对的集合"></a>16.1 概念：无序的键值对的集合</h3><h3 id="16-2-创建对象的方式"><a href="#16-2-创建对象的方式" class="headerlink" title="16.2 创建对象的方式"></a>16.2 创建对象的方式</h3><ol>
<li>字面量<br>1 ‘abc’ true undefined null [ ] { }<br><code>var obj = { }</code>创建空对象</li>
</ol>
<p>键值对的集合，多个键值对通过&quot;，&quot;隔开<br>特征：对象的属性<br>行为：对象的方法---对象的函数</p>
<ol start="2">
<li>构造函数的方式（了解）<br>var obj = new Object({...});</li>
</ol>
<h3 id="16-3-取值和赋值（点语法）"><a href="#16-3-取值和赋值（点语法）" class="headerlink" title="16.3 取值和赋值（点语法）"></a>16.3 取值和赋值（点语法）</h3><ul>
<li><p>取值：<br>语法：对象名.属性名  对象名.方法名( );---方法的调用，得到整个函数</p>
<ul>
<li>有这个属性名，返回对应值</li>
<li>如果没有这个属性名，返回undefined</li>
</ul>
</li>
<li><p>赋值：<br>语法：对象名.属性名 = &#39;新的值&#39;</p>
<ul>
<li>如果有这个属性名，覆盖</li>
<li>如果没有这个属性名，新建一个属性并赋值</li>
</ul>
</li>
</ul>
<h4 id="16-3-1-点语法（简洁方便，不支持变量）"><a href="#16-3-1-点语法（简洁方便，不支持变量）" class="headerlink" title="16.3.1 点语法（简洁方便，不支持变量）"></a>16.3.1 点语法（简洁方便，不支持变量）</h4><p>对象名.属性名</p>
<h4 id="16-3-2-中括号语法（支持字符串或变量，更加的灵活）"><a href="#16-3-2-中括号语法（支持字符串或变量，更加的灵活）" class="headerlink" title="16.3.2 中括号语法（支持字符串或变量，更加的灵活）"></a>16.3.2 中括号语法（支持字符串或变量，更加的灵活）</h4><p>对象的取值：对象名[&#39;属性名&#39;]<br>对象的赋值：对象名[&#39;属性名&#39;] = &quot;新的值&quot;<br><strong>只要访问对象属性时，需要用到变量，只能用中括号语法</strong></p>
<h3 id="16-4-对象的遍历（访问对象的所有属性）"><a href="#16-4-对象的遍历（访问对象的所有属性）" class="headerlink" title="16.4 对象的遍历（访问对象的所有属性）"></a>16.4 对象的遍历（访问对象的所有属性）</h3><p>固定语法 （key就是键，属性名）</p>
<pre><code class="javascript">for （var key in obj）{
  console.log(key);
  console.log(obj[key]);---打印属性值
}
</code></pre>
<h3 id="16-5-批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）"><a href="#16-5-批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）" class="headerlink" title="16.5 批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）"></a>16.5 批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）</h3><p>设计模式（工厂模式、单例模式、观察者模式）<br>在对象的方法中，this指代当前对象（对象名）</p>
<h4 id="16-5-1-工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）"><a href="#16-5-1-工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）" class="headerlink" title="16.5.1 工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）"></a>16.5.1 工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）</h4><p>通过工厂函数创建的对象，没有具体的类型，都是Object</p>
<pre><code class="javascript">function Student(sno,name,gender,major){
    obj=new Object();
    obj.sno=sno;
    obj.name=name;
    obj.gender=gender;
    obj.major=major;
    obj.say=function(){
      console.log(&quot;hello!&quot;);
    }
    return obj;
}
var s=new Student(&quot;123&quot;,&quot;张三&quot;,&quot;男&quot;,&quot;数学&quot;);
for(var i in s){
    document.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);
}
</code></pre>
<p>这里Student()函数相当于一个工厂，在其内部生产对象。这种方式简化了代码，但是无法细分对象，也会造成共有方法和属性的内存浪费。无法细分对象就是生产出的对象的constructor是Object，而不是自定义的</p>
<pre><code>console.log(s.constructor);
</code></pre><p><img src="https://img-blog.csdnimg.cn/20200831171959364.png#" alt><br>内存浪费就是因为方法声明在了对象的内部，每一个对象都有同一个方法，造成了浪费。</p>
<h4 id="16-5-2-构造函数（给新建的对象，添加属性和方法-实例化对象）"><a href="#16-5-2-构造函数（给新建的对象，添加属性和方法-实例化对象）" class="headerlink" title="16.5.2 构造函数（给新建的对象，添加属性和方法----实例化对象）"></a>16.5.2 构造函数（给新建的对象，添加属性和方法----实例化对象）</h4><ol>
<li>就是一个函数</li>
<li>首字母大写</li>
<li>js中，内置了一些构造函数，比如：<code>Object</code>，<code>Array</code></li>
<li>构造函数可以自定义</li>
</ol>
<ul>
<li>构造函数的使用步骤<ul>
<li>自己声明一个构造函数</li>
<li>结合new一起使用，创建一个有类型的对象<pre><code class="javascript">function Student(sno,name,gender,major){
this.sno=sno;
this.name=name;
this.gender=gender;
this.major=major;
this.say=function(){
    console.log(&quot;hello!&quot;);
}
}
var s=new Student(&quot;1234&quot;,&quot;李四&quot;,&quot;男&quot;,&quot;物理&quot;);
for(var i in s){
document.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);
}
</code></pre>
这种模式解决了对象不能细分问题，此时s的constructor就是Student()构造函数了。<pre><code>console.log(s.constructor);
</code></pre><img src="https://img-blog.csdnimg.cn/20200831184528158.png#" alt><br>但是还是没有解决公有方法造成的内存浪费问题。</li>
</ul>
</li>
</ul>
<h4 id="16-5-3-构造函数-原型对象模式"><a href="#16-5-3-构造函数-原型对象模式" class="headerlink" title="16.5.3 构造函数+原型对象模式"></a>16.5.3 构造函数+原型对象模式</h4><pre><code class="javascript">function Student(sno,name,gender,major){
    this.sno=sno;
    this.name=name;
    this.gender=gender;
    this.major=major;
}
Student.prototype.say=function(){
    console.log(&quot;hello!&quot;);
}
var s=new Student(&quot;12345&quot;,&quot;王五&quot;,&quot;男&quot;,&quot;化学&quot;);
for(var i in s){
    document.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);
}
</code></pre>
<p>这种模式和构造函模式类似，不同点是该模式把公有的属性和方法声明到构造函数的原型对象中，解决了内存浪费。</p>
<h4 id="16-5-4-new的作用（创建对象）"><a href="#16-5-4-new的作用（创建对象）" class="headerlink" title="16.5.4 new的作用（创建对象）"></a>16.5.4 new的作用（创建对象）</h4><ul>
<li>会新建一个对象，指定对象的类型</li>
<li>让构造函数的this，指向新创建的对象----this.name = &#39;张三&#39;;</li>
<li>执行构造函数（给新建的对象，添加属性和方法）</li>
<li>将新创建的对象返回</li>
</ul>
<h3 id="16-6-内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）"><a href="#16-6-内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）" class="headerlink" title="16.6 内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）"></a>16.6 内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）</h3><h4 id="16-6-1-Math对象（提供了一系列和数学相关的属性和方法）"><a href="#16-6-1-Math对象（提供了一系列和数学相关的属性和方法）" class="headerlink" title="16.6.1 Math对象（提供了一系列和数学相关的属性和方法）"></a>16.6.1 Math对象（提供了一系列和数学相关的属性和方法）</h4><ol>
<li>PI Math.PI</li>
<li>求最大最小值 max min<br>var max = Math.max(3,5,6,110);<br>console.log(max);</li>
<li>取整 ceil floor round<br>（1）ceil向上取整，取大的那个数---天花板函数<br>（2）floor向下取整，取小的那个数---地板函数<br>（3）round四舍五入，离哪个近取哪个</li>
<li>随机数random <code>[0,1)</code>可以取到0，取不到1<br>公式：求一个整数范围0~N，parseInt(Math.random()*(N+1))</li>
<li>绝对值abs</li>
<li>求次方pow</li>
<li>求开方sqrt</li>
</ol>
<h4 id="16-6-2-Date日期对象"><a href="#16-6-2-Date日期对象" class="headerlink" title="16.6.2 Date日期对象"></a>16.6.2 Date日期对象</h4><p>js中提供的Date构造函数，可以创建日期对象</p>
<ol>
<li><p>如何创建日期对象</p>
<pre><code class="javascript">var now = new Date(); // 构造函数不传参，创建的是当前时间
var date = new Date(&#39;2019-4-22 16:00:00&#39;); // 构造函数传日期字符串，指定具体的日期
</code></pre>
</li>
<li><p>日期格式化 （不用）---一般日期格式都是自定义的</p>
<pre><code class="javascript">var now = new Date();---当前时间
console.log(now.toString()); // 让日期以标准化的日期字符串格式化输出,&#39;Thu Apr 08 2021 11:13:41 GMT+0800 (GMT+08:00)&#39;
console.log(now.toLocaleString()); // 本地化日期字符串格式输出,&#39;2021-4-8 11:13:41&#39;
console.log(now.toLocaleDateString()); //只显示日期,&#39;2021-4-8&#39;
console.log(now.toLocaleTimeString()); //只显示时间,&#39;11:13:41&#39;
</code></pre>
</li>
<li><p>日期格式的自定义，xx年xx月xx日--获取日期里面的各个组成部分<br>可以封装一个函数，专门给小于10的数，前面加上0</p>
<pre><code class="javascript">function addZero（n）{
if(n&lt;10) {
 return &#39;0&#39; + n;
}
else {
 return n;
}
}
var now = new Date(); // 当前时间
var year = now.getFullYear(); // 年
var month = now.getMonth()+1; // 获取月，getMonth从0开始，范围0-11
month = addZero(month);
// 获取日getDate
// 获取一周中的第几天，getDay,范围0-6，周日0，周一1
var hours = now.getHours(); // 时，getHours
var minutes = now.getMinutes(); // 分，getMinutes
var seconds = now.getSeconds(); // 秒，getSeconds
// now.getMilliseconds毫秒
</code></pre>
</li>
<li><p>时间戳（就是数字格式的日期，便于运算，一般用于求时间差）---距离1970年1月1日 0时0分0秒，所过去的毫秒数</p>
<pre><code class="javascript">var now = new Date();
console.log(+now);
</code></pre>
</li>
</ol>
<p><strong>应用</strong></p>
<ul>
<li>统计一段代码的执行时间---性能优化<pre><code class="javascript">var begin = new Date();
var end = new Date();
console.log(end - begin);
</code></pre>
</li>
<li>用于秒杀倒计时</li>
</ul>
<h2 id="17、数组对象Array"><a href="#17、数组对象Array" class="headerlink" title="17、数组对象Array"></a>17、数组对象Array</h2><ol>
<li><p><code>.join(分隔符)</code>：将数组中的值拼接成一个字符串，返回这个字符串<br>默认分隔符&quot; , &quot;</p>
</li>
<li><p>数组的增删操作<code>push</code> <code>pop</code> <code>unshift</code>  <code>shift</code> <strong><em>会更改原数组</em></strong><br>.push在数组的最后面，添加一个或多个项，返回数组的长度<br>.pop在数组的最后面，删除一个项，返回删除的项<br>.unshift在数组的最前面，添加一个或多个项，返回数组的长度<br>.shift在数组的最前面，删除一项，返回删除的项</p>
</li>
<li><p>翻转<code>reverse</code> <strong><em>会更改原数组</em></strong></p>
</li>
<li><p>排序<code>sort</code>（默认按照字符串的方式进行排序，先比较第一个字符）<strong><em>会更改原数组</em></strong><br> <strong>如果要制定排序规则，是需要传参的（参数：一个函数）</strong> </p>
<pre><code class="javascript">arr.sort(function(a,b) {
 return a-b;---从小往大
 return b-a;---从大往小
})
</code></pre>
<blockquote>
<p>a表示前一项，b表示后一项<br>函数的返回值&gt;0,a和b交换位置<br>函数的返回值=0，不换位置<br>函数的返回值&lt;0,不换位置</p>
</blockquote>
</li>
<li><p>合并 <code>arr.concat(arr2,arr3....)</code>，返回合并后的新数组</p>
</li>
<li><p>截取<code>arr.slice</code>（从数组中，截取一部分出来，返回一个新数组）</p>
<ul>
<li>arr.slice();从开始一直截取到最后（将整个数组截取，复制一份）</li>
<li>arr.slice(begin)从begin（下标）开始一直截取到最后    </li>
<li>arr.slice(begin,end)从begin（下标）开始一直截取到end结束（<strong>包括begin,不包括end</strong>）</li>
</ul>
</li>
<li><p><code>splice</code>方法，可以在数组的任意位置添加、删除、替换任意项---会更改原数组</p>
<pre><code> splice（从哪开始删，删几个，添加的项1，添加的项2...）
 splice(begin,deleteCounts,item1,item2...)
</code></pre></li>
<li><p><code>indexOf</code>查找值在数组中第一次出现的下标（可以用来查重）<br> <code>lastIndexOf</code>查找值在数组中最后一次出现的下标<br>如果值在数组中不存在，返回 <code>-1</code></p>
</li>
<li><p>清空一个数组</p>
<pre><code class="javascript">arr = [ ];
arr.length = 0;
arr.splice(0,arr.length)
</code></pre>
</li>
</ol>
<h2 id="18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）"><a href="#18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）" class="headerlink" title="18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）"></a>18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）</h2><p><strong>js内部，对于除了undefined和null的简单数据类型，都提供了一个对应的复杂数据类型</strong></p>
<p>简答数据类型：没有属性和方法，只有值<br>复杂数据类型：可以有多个属性和方法</p>
<ul>
<li>在js中，如果简单数据类型，在访问复杂数据类型的属性或方法时</li>
<li>为了方便，自动将简单数据类型，包装成复杂数据类型，然后获取对应的值</li>
<li>会将值变回简单数据类型    </li>
</ul>
<h3 id="18-1-Number"><a href="#18-1-Number" class="headerlink" title="18.1 Number"></a>18.1 Number</h3><pre><code>通过new Number()创建的对象，``toString``   ``toFixed``两个方法
num.toFixed(3) 保留3位小数
</code></pre><h3 id="18-2-Boolean"><a href="#18-2-Boolean" class="headerlink" title="18.2 Boolean"></a>18.2 Boolean</h3><pre><code>    通过new Boolean()创建的对象，toString
</code></pre><h3 id="18-3-String"><a href="#18-3-String" class="headerlink" title="18.3 String"></a>18.3 String</h3><ol>
<li>字符串可以和数组一样，进行遍历，字符串不是数组，不能混用方法</li>
<li><code>indexOf</code>和<code>lastIndexOf</code> 查找值在字符串中第一次/最后一次出现的下标</li>
<li><code>trim</code>去除字符串<code>首尾</code>的空格</li>
<li>转大小写<br><code>toUpperCase</code>转大写<br><code>toLowerCase</code>转小写</li>
<li>拼接<code>.concat</code>将字符串进行拼接，返回新的字符串）<br>一般用<code>+</code></li>
<li><p>截取</p>
<ul>
<li>slice(begin,end) <blockquote>
<p>从begin开始截取，截取到end结束，包括begin，不包括end<br>begin（必需）：规定从何处开始选取。如果是负数，那么它规定从字符串尾部开始算起的位置。也就是说，-1 指最后一个字符，-2 指倒数第二个字符，以此类推。<br>end（可选）：规定从何处结束选取，即结束处的字符下标。如果没有指定该参数，那么截取的字符串包含从 start 到结束的所有字符。如果这个参数是负数，那么它规定的是从数组尾部开始算起的字符。</p>
<pre><code class="javascript"> var str = &quot;0123456789&quot;;
 console.log(&quot;原始字符串：&quot;, str);
 console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.slice(3));  //3456789
 console.log(&quot;从倒数第3个字符起一直到结束：&quot;, str.slice(-3));  //789
 console.log(&quot;从开始一直到索引为5的前一个字符：&quot;, str.slice(0,5));  //01234
 console.log(&quot;从开始一直到倒数第3个字符的前一个字符：&quot;, str.slice(0,-3));  //0123456
 console.log(&quot;从索引为3的字符起到索引为5的前一个字符：&quot;, str.slice(3,5));  //34
 console.log(&quot;从索引为3的字符起到倒数第3个字符的前一个字符：&quot;, str.slice(3,-3));  //3456
</code></pre>
</blockquote>
</li>
<li>substring(begin,end) 从begin开始截取，截取到end结束，包括begin，不包括end<pre><code class="javascript"> var str = &quot;0123456789&quot;;
 console.log(&quot;原始字符串：&quot;, str);
 console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.substring(3));  //3456789
 console.log(&quot;从索引为20的字符起一直到结束：&quot;, str.substring(20));  //
 console.log(&quot;从索引为3的字符起到索引为5的前一个字符结束：&quot;, str.substring(3,5));  //34
 console.log(&quot;start比end大会自动交换，结果同上：&quot;, str.substring(5,3));  //34
 console.log(&quot;从索引为3的字符起到索引为20的前一个字符结束：&quot;, str.substring(3,20));  //3456789
 console.log(&quot;substring将负数转化为0:&quot;, str.substring(-3)); //
</code></pre>
</li>
<li>substr(begin,length) 从begin开始截取，截取length个<pre><code class="javascript"> var str = &quot;0123456789&quot;;
 console.log(&quot;原始字符串：&quot;, str);
 console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.substr(3));  //3456789
 console.log(&quot;从索引为20的字符起一直到结束：&quot;, str.substr(20));  //
 console.log(&quot;从索引为3的字符起截取长度为5的字符串：&quot;, str.substr(3,5));  //34567
 console.log(&quot;从索引为3的字符起截取长度为20的字符串：&quot;, str.substr(3,20));  //3456789
</code></pre>
</li>
<li><p>三者比较<br><code>`</code>javascript<br>var str = &#39;中华人民共和国万岁&#39;<br>// 一，start为负数，end不传<br>str.slice(-3) // &#39;国万岁&#39;<br>str.substring(-3) // &#39;中华人民共和国万岁&#39;<br>str.substr(-3) // &#39;国万岁&#39;<br>// 说明： 1，slice与substr第一个参数为负数时，将从字符串反方向开始计数，末位记为-1,等同于str.slice(6)，str.substr(6)<br>//       2，substring将负数转化为0，既str.substring(0)</p>
<p>// 二，start为负数，end为负数时<br>str.slice(-3,-1) // &#39;国万&#39;<br>str.substring(-3,-1) // &#39;&#39;<br>str.substr(-3,-1) // &#39;&#39;<br>// 说明：<br>//    1，slice正常截取字符串，相比substring灵活很多<br>//    2，substring将所有参数转化为0，既str.substring(0,0)<br>//    3，substr end参数不能为负数</p>
<p>// 三，start与end均大于零，且start &gt; end<br>str.slice(5,3) // &#39;&#39;<br>str.substring(5,3) // &#39;民共&#39;<br>str.substr(5,3) // &#39;和国万&#39;<br>// 说明：<br>//   1，substr正常截取字符串，代表从第五位开始，截取字符串长度为3<br>//   2，当start&gt;end时，substring在提取子串之前会先交换这两个参数，既转换为substring(3,5)；而slice不能进行此转换，所以截取的为空字符串</p>
<p>// 四，start与end均大于零，且start &lt; end<br>str.slice(3,5) //&#39;民共&#39;<br>str.substring(3,5) // &#39;民共&#39;<br>str.substr(3,5) // &#39;民共和国万&#39;<br>// 说明：三种方法均正常截取字符串，只是substr第二个参数含义不同，代表截取的字符串长度而不是终止位置。</p>
</li>
</ul>
<p><code>`</code></p>
</li>
<li><p>通过.split(分隔符):可以将字符串拆分成数组，会返回一个拆分得到的数组<br> 通过join:可以将数组的值，拼成字符串，会返回一个拼接成的字符串</p>
</li>
<li><p>replace替换，会返回替换的结果</p>
<pre><code class="javascript">str.replace(&#39;aa&#39;,&#39;bb&#39;); // 将字符串中的第一个aa替换成bb
</code></pre>
</li>
</ol>
<p>想要全部替换，需要用到正则<code>str.replace(/aa/g,&#39;bb&#39;)</code>;</p>
<h2 id="19、值类型和引用类型"><a href="#19、值类型和引用类型" class="headerlink" title="19、值类型和引用类型"></a>19、值类型和引用类型</h2><p>从内存的存储角度，分成了<code>值类型</code>和<code>引用类型</code>（内存是可以释放，可以重复利用的）</p>
<p><strong>值类型（简单数据类型）</strong>：存储在变量中，存的是值本身<br><strong>引用类型（复杂数据类型）</strong>：存储在变量中，存的是<code>内存地址</code>----会单独在内存中开辟一块空间存储</p>
<h3 id="19-1-值类型和引用类型的赋值类型"><a href="#19-1-值类型和引用类型的赋值类型" class="headerlink" title="19.1 值类型和引用类型的赋值类型"></a>19.1 值类型和引用类型的赋值类型</h3><ul>
<li>值类型：存储在变量中 ，存的是<code>值本身</code>，所以在赋值给其他变量时，赋值的是<code>值本身</code></li>
<li>引用类型：存储在变量中，存的是<code>内存地址</code>，所以在赋值给其他变量时，赋值的是<code>内存地址</code></li>
</ul>
<h3 id="19-2-值类型和引用类型的值传递（让值作为函数的参数进行传递）"><a href="#19-2-值类型和引用类型的值传递（让值作为函数的参数进行传递）" class="headerlink" title="19.2 值类型和引用类型的值传递（让值作为函数的参数进行传递）"></a>19.2 值类型和引用类型的值传递（让值作为函数的参数进行传递）</h3><ul>
<li>值类型：存储在变量中，存的是值本身，所以在值传递时，传的也是值本身</li>
<li>引用类型：存储在变量中，存的是内存地址，所以在值传递时，传的也是内存地址</li>
</ul>
<h2 id="20、typeof-关键字"><a href="#20、typeof-关键字" class="headerlink" title="20、typeof 关键字"></a>20、typeof 关键字</h2><ol>
<li>typeof获取简单数据类型，可以直接返回对应的类型<br><strong><em>特例</em></strong>：typeof null  返回object</li>
<li>typeof获取复杂数据类型，一般返回object<br><strong><em>特例</em></strong>：typeof 函数  返回function    函数是js的一等公民</li>
</ol>
<h2 id="21、逻辑中断（短路运算）-amp-amp"><a href="#21、逻辑中断（短路运算）-amp-amp" class="headerlink" title="21、逻辑中断（短路运算）&amp;&amp; ||"></a>21、逻辑中断（短路运算）&amp;&amp; ||</h2><p>&amp;&amp;找假值，只要遇到了假值，就中断短路（后面的不看了）<br>||找真值，只要看到了真值，就中断短路（后面的不看了）</p>
<pre><code class="javascript">function demo(fn){
  fn&amp;&amp;fn(); //fn存在，才去调用
}    
demo(function(){
  console.log(111);
});
demo();
</code></pre>
<p><strong>逻辑<code>或</code>，一般可以用于设置默认值,也可以解决兼容性</strong></p>
<pre><code class="javascript">function getSum(a,b){
  a=a || 0;
  b=b || 0;
  var sum = a+b;
  return sum;
}
</code></pre>
<h2 id="22、如何拷贝一个对象"><a href="#22、如何拷贝一个对象" class="headerlink" title="22、如何拷贝一个对象"></a>22、如何拷贝一个对象</h2><p>封装一个方法，可以拷贝一个对象，返回（浅拷贝，只拷贝了 一层）</p>
<pre><code class="javascript">function copy(obj){
  var newObj = {};
  for (var k in obj){
    newObj[k] = obj[k];
  }
}
</code></pre>
<ul>
<li>浅拷贝，只拷贝了一层，如果全是简单类型的属性，没有问题<br>  但是如果有复杂类型的属性（对象），此时拷贝的只是地址，需要处理的</li>
<li>深拷贝<pre><code>  newObj[k] = typeof obj[k] === &#39;object&#39; ? copy(obj[k]) : obj[k];
</code></pre></li>
</ul>
<pre><code class="javascript">// 1.遍历+递归
function deepClone(obj){
  let newObj =  {}
  for(let key in obj){
      if(obj.hasOwnProperty(key)){
          if(typeof(obj[key]) === &#39;object&#39; &amp;&amp; obj[key] !== null){
            newObj[key] = (Array.isArray(obj[key])  ? [] : {})
            newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : deepClone(obj[key]));  
          }else{
              newObj[key] = obj[key];
          }
      }
  }
  return newObj;
}

// 2.Object.assign + 递归
function deepClone(obj){
  let newObj = {}
  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      newObj[key] = (typeof obj[key] === &#39;object&#39; ? Object.assign(obj[key]) : obj[key])
    }
  }
  return newObj
}

// 3.对象扩展+递归
function deepClone(obj){
  var newObj ={}
  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      if(typeof obj[key] === &#39;object&#39;){
        newObj[key] = (Array.isArray(obj[key]) ? [] : {})
        newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : {...obj[key]}) 
      } 
      else{
        newObj[key] = obj[key]
      }
    }
  }
  return newObj
}

// 4.JSON复制（对NaN和undefined无法正确复制，会丢失）
function deepClone(obj) {
  var newObj = JSON.parse(JSON.stringify(obj))
  return newObj
}
</code></pre>
<h2 id="23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！"><a href="#23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！" class="headerlink" title="23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！"></a>23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！</h2><h2 id="24、面向对象：关注的是找一个对象，去做某件事"><a href="#24、面向对象：关注的是找一个对象，去做某件事" class="headerlink" title="24、面向对象：关注的是找一个对象，去做某件事"></a>24、面向对象：关注的是找一个对象，去做某件事</h2><p><strong><em>面向对象不是面向过程的替代，是面向过程的封装</em></strong></p>
<h3 id="24-1-特性："><a href="#24-1-特性：" class="headerlink" title="24.1 特性："></a>24.1 特性：</h3><ol>
<li>封装性</li>
<li>继承性</li>
<li>多态性（js中没有）</li>
</ol>
<h2 id="25、原型"><a href="#25、原型" class="headerlink" title="25、原型"></a>25、原型</h2><p>JavaScript是一门基于原型的语言，在软件设计模式中，有一种模式叫做原型模式，JavaScript正是利用这种模式而被创建出来</p>
<h3 id="25-1-原型模式"><a href="#25-1-原型模式" class="headerlink" title="25.1 原型模式"></a>25.1 原型模式</h3><p>原型模式是用于创建重复的对象，同时又能保证性能，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。<br>原型模式的<code>目的</code>是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，也就是说利用已有的一个原型对象，可以快速地生成和原型对象一样的新对象实例</p>
<h3 id="25-2-原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板"><a href="#25-2-原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板" class="headerlink" title="25.2 原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板"></a>25.2 原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板</h3><ol>
<li>原型是定义了一些公用的属性和方法，利用原型创建出来的新对象实例会共享原型的所有属性和方法<br>实例代码：<br><code>`</code>javascript<br>// 创建原型<br>var Person = function(name){<br> this.name = name;<br>};</li>
</ol>
<p>// 原型的方法<br>Person.prototype.sayHello = function(){<br>    console.log(this.name+&quot;,hello&quot;);<br>};</p>
<p>// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法<br>var person1 = new Person(&quot;zhangsan&quot;);<br>var person2 = new Person(&quot;lisi&quot;);</p>
<p>// zhangsan,hello<br>person1.sayHello();<br>// lisi,hello<br>person2.sayHello();</p>
<pre><code>
2. 严格模式下，原型的属性和方法还是会被原型实例所共享的
实例代码：
```javascript
// 开启严格模式，原型的属性和方法还是会被原型实例所共享的
&quot;use strict&quot;;

// 创建原型
var Person = function(name){
    this.name = name;
};

// 原型的方法
Person.prototype.sayHello = function(){
    console.log(this.name+&quot;,hello&quot;);
};

// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法
var person1 = new Person(&quot;zhangsan&quot;);
var person2 = new Person(&quot;lisi&quot;);

// zhangsan,hello
person1.sayHello();
// lisi,hello
person2.sayHello();
</code></pre><ol start="3">
<li>通过原型创建的新对象实例是相互独立的，为新对象实例添加的方法只有该实例拥有这个方法，其它实例是没有这个方法的<br>实例代码：<br><code>`</code>javascript<br>// 创建原型<br>var Person = function(name){<br>this.name = name;<br>};</li>
</ol>
<p>// 原型的方法<br>Person.prototype.sayHello = function(){<br>  console.log(this.name+&quot;,hello&quot;);<br>};</p>
<p>// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法<br>var person1 = new Person(&quot;zhangsan&quot;);<br>var person2 = new Person(&quot;lisi&quot;);</p>
<p>// zhangsan,hello<br>person1.sayHello();<br>// lisi,hello<br>person2.sayHello();</p>
<p>// 为新对象实例添加方法<br>// 通过原型创建的新对象实例是相互独立的<br>person1.getName = function(){<br>    console.log(this.name);<br>}</p>
<p>// zhangsan<br>person1.getName();<br>// Uncaught TypeError: person2.getName is not a function<br>person2.getName();</p>
<pre><code>
4. 原型的总结：

* 所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象
* 所有函数都有一个prototype(原型)属性，属性值是一个普通的对象
* 所有引用类型的__proto__属性指向它构造函数的prototype

5. 函数的原型prototype：函数才有prototype，prototype是一个对象，指向了当前构造函数的引用地址
6. 函数的原型对象__proto__：所有对象都有__proto__属性， 当用构造函数实例化（new）一个对象时，会将新对象的__proto__属性指向 构造函数的prototype

7. 原型对象和函数的原型的关系
![原型对象和函数的原型的关系](https://img-blog.csdnimg.cn/20190623221321362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)

&gt; 说明：
&gt; * 所有函数的__proto__都是指向Function的prototype
&gt; * 构造函数new出来的对象__proto__指向构造函数的prototype
&gt; * 非构造函数实例化出的对象或者对象的prototype的__proto__指向Object的prototype
&gt;   Object的prototype指向null

8. 所有的原型对象都会自动获得一个``constructor``（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）
9. 实例的构造函数属性（constructor）指向构造函数 ：person1.constructor == Person
10. 原型对象（Person.prototype）是 构造函数（Person）的一个实例
11. 原型的分类：
* ``隐式原型（_proto_）``：上面说的这个原型是JavaScript中的内置属性[[prototype]]，此属性继承自object对象，在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_，隐式原型的作用是用来构成原型链，实现基于原型的继承
* ``显示原型``（prototype）``：每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享
12. 原型的使用方式：
通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型
在赋值原型prototype的时候使用function立即执行的表达式来赋值，可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果

#### 25.2.1 原型链
原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构

#### 25.2.2 原型设计的问题
当查找一个对象的属性时，JavaScript 会根据原型链向上遍历对象的原型，直到找到给定名称的属性为止，直到到达原型链的顶部仍然没有找到指定的属性，就会返回 undefined
也可以理解为原型链继承时查找属性的过程是先查找自身属性，当自身属性不存在时，会在原型链中逐级查找

#### 25.2.3 hasOwnProperty 函数：
可以用来检查对象自身是否含有某个属性，返回值是布尔值，当属性不存在时不会向上查找对象原型链，*hasOwnProperty是 JavaScript 中``唯一一个``处理属性但是不查找原型链的函数*

#### 25.2.4 getOwnPropertyNames 函数
可以获取对象所有的自身属性，返回值是由对象自身属性名称组成的数组，同样不会向上查找对象原型链

#### 25.2.5 原型链的小结：
一直往上层查找，直到到null还没有找到，则返回undefined
Object.prototype.__proto__ === null
所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象

6）JavaScript的原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法

#### 25.2.6 常见面试题

* 谈谈你对原型的理解？
在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法

* 什么是原型链？原型链解决的是什么问题？
 1. 原型链解决的主要是继承问题
 2. 每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法
 3. 构造函数 Parent、Parent.prototype 和 实例 p 的关系如下:(p.__proto__ === Parent.prototype)
![](https://img-blog.csdnimg.cn/20190623221912165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)

* prototype 和 proto 区别是什么？
 1. prototype是构造函数的属性
 2. __proto__是每个实例都有的属性，可以访问 [[prototype]] 属性
 3. 实例的__proto__与其构造函数的prototype指向的是同一个对象

### 25.3 补充（原先的）
#### 25.3.1 属性搜索原则：自己有就访问自己的，自己没有，去原型链中就近查找
1. 如果自己有这个属性，就访问自己的
2. 如果自己没有这个属性，会到原型中找，如果找到，不找了，直接返回
3. 如果原型中也没有，会到原型的原型中找...
4. 一直找到Object.prototype，如果老祖宗也没有，返回undefined

#### 25.3.2 设置属性：
如果有这个属性，直接修改赋值
如果自己没有这个属性，给自己添加一个新属性（不会改到原型）

#### 25.3.3 Object.prototype的成员
1. ``hasOwnProperty``
    语法：``对象.hasOwnProperty(&#39;属性名&#39;)`` ---判断属性是否是自己的，而不是原型的（不是继承来的）
    for in 遍历，不仅自己的属性可以遍历，原型上的属性也会遍历到（对于constructor等浏览器内置的属性，被浏览器进行来了处理，不会被for in便利出来）
    遍历时，只打印自身的（用hasOwnProperty进行判断）
    in操作符：判断属性是否可以被对象所访问（只要能够访问到这个属性，就返回true）---这个不是成员
    语法：&#39;属性名&#39; in 对象

2. ``A.isPrototypeOf(B)``:判断A是不是B的原型

3. ``对象.propertyIsEnumerable(&#39;属性名&#39;)`` 判断属性是否可以遍历（可枚举）
4. toSting()
5. valueof()

6. instanceof运算符
    语法：A instanceof B（判断A是否是B的实例，B构造函数）
    进阶原理：判断B.prototype在不在A的原型链上
    使用typeof无法区分具体的对象类型！！！

```javascript
console.log(p.constructor.name)---可以用来打印类型
Object.prototype.toString.call([]) ---可以用来获取复杂数据是什么类型 ---[object Array]
</code></pre><h2 id="26、js数据类型"><a href="#26、js数据类型" class="headerlink" title="26、js数据类型"></a>26、js数据类型</h2><p>堆和栈（只是将Java中概念，拿过来类比了）<br>js中没有特别明确的堆和栈的概念，而且js的实现，也不需要堆和栈的概念<br>java中堆内存和栈内存<br>1.所有的<code>简单数据</code>类型，存在<code>栈</code>中<br>2.所有的<code>复杂数据</code>类型，存在<code>堆</code>中---真实存在变量中的，也是地址</p>
<h2 id="27、this的规则："><a href="#27、this的规则：" class="headerlink" title="27、this的规则："></a>27、this的规则：</h2><p>xx.fn();---fn函数调用时里面的this，指向调用者（谁调用的，this就指向谁）</p>
<ol>
<li>如果是直接调用的方法，this指向window<pre><code> （1）function fn(){console.log(this)}
          fn();
 （2）setInterval(function(){console.log(this)},2000)---定时器中的this指向window
</code></pre></li>
<li>如果对象中的方法，被调用了，this指向调用者，谁调用的，指向谁</li>
<li>特例，构造函数中执行的this，this指向新创建的对象</li>
</ol>
<p>全局的var a = 123;  等价于 window.a = 123;</p>
<h2 id="28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️"><a href="#28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️" class="headerlink" title="28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️"></a>28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️</h2><h3 id="28-1-原型链继承"><a href="#28-1-原型链继承" class="headerlink" title="28.1 原型链继承"></a>28.1 原型链继承</h3><pre><code class="javascript">function Person() {
  this.name = &#39;Hello World&#39;;
}
Person.prototype.getName = function() {
  console.log(this.name)
}
function Child() {

}
Child.prototype = new Person()
var child1 = new Child()
child1.getName() // Hello World
</code></pre>
<p><strong><em>重点：</em></strong><br>让新实例的原型等于父类的实例。</p>
<p><strong><em>优点：</em></strong><br>实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的 属性！）</p>
<p><strong><em>缺点：</em></strong></p>
<ol>
<li>新实例无法向父类构造函数传参。</li>
<li>继承单一。</li>
<li>所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性 也会被修改！）</li>
</ol>
<h3 id="28-2-构造函数继承"><a href="#28-2-构造函数继承" class="headerlink" title="28.2 构造函数继承"></a>28.2 构造函数继承</h3><pre><code class="javascript">function Person(){
  this.name = &#39;xiaoming&#39;;
  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];
}

Person.prototype.getName = function(){
  console.log(this.name);
}

function Child(age){
  Person.call(this);
  this.age = age
}

var child1 = new Child(23);
var child2 = new Child(12);
child1.colors.push(&#39;yellow&#39;);
console.log(child1.name); // xiaoming
console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]
console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]
</code></pre>
<p><strong><em>重点：</em></strong><br>用.call()和.apply()将父类构造函数引入子类函数（在子类 函数中做了父类函数的自执行（复制））</p>
<p><strong><em>优点：</em></strong></p>
<ol>
<li>只继承了父类构造函数的属性，没有继承父类原型的属性。</li>
<li>解决了原型链继承缺点1、2、3。</li>
<li>可以继承多个构造函数属性（call多个）。</li>
<li>在子实例中可向父实例传参。</li>
</ol>
<p><strong><em>缺点：</em></strong></p>
<ol>
<li>只能继承父类构造函数的属性。</li>
<li>无法实现构造函数的复用。（每次用每次都要重新调用）</li>
<li>每个新实例都有父类构造函数的副本，臃肿。</li>
</ol>
<h3 id="28-3-组合继承（组合原型链继承和借用构造函数继承）（常用）"><a href="#28-3-组合继承（组合原型链继承和借用构造函数继承）（常用）" class="headerlink" title="28.3 组合继承（组合原型链继承和借用构造函数继承）（常用）"></a>28.3 组合继承（组合原型链继承和借用构造函数继承）（常用）</h3><pre><code class="javascript">function Parent(name){
    this.name = name;
    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];
}

Parent.prototype.getName = function(){
    console.log(this.name);
}

function Child(name,age){
    Parent.call(this,name);// 第二次调用 Parent()
    this.age = age;
}

Child.prototype = new Parent(); // 第一次调用 Parent()

var child1 = new Child(&#39;xiaopao&#39;,18);
var child2 = new Child(&#39;lulu&#39;,19);
</code></pre>
<p><strong><em>重点：</em></strong><br>结合了两种模式的优点，传参和复用</p>
<p><strong><em>优点：</em></strong></p>
<ol>
<li>可以继承父类原型上的属性，可以传参，可复用。<br>2、每个新实例引入的构造函数属性是私有的。</li>
</ol>
<p><strong><em>缺点：</em></strong><br>调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p>
<h3 id="28-4-原型式继承"><a href="#28-4-原型式继承" class="headerlink" title="28.4 原型式继承"></a>28.4 原型式继承</h3><pre><code class="javascript">function CreateObj(o){
    function F(){}
    F.prototype = o;
    console.log(o.__proto__ === Object.prototype);
    console.log(F.prototype.constructor === Object); // true
    return new F();
}

var person = {
    name: &#39;xiaopao&#39;,
    friend: [&#39;daisy&#39;,&#39;kelly&#39;]
}

var person1 = CreateObj(person);

// var person2 = CreateObj(person);

person1.name = &#39;person1&#39;;
// console.log(person2.name); // xiaopao
person1.friend.push(&#39;taylor&#39;);
// console.log(person2.friend); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]
// console.log(person); // {name: &quot;xiaopao&quot;, friend: Array(3)}
person1.friend = [&#39;lulu&#39;];
// console.log(person1.friend); // [&quot;lulu&quot;]
// console.log(person.friend); //  [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]
// 注意： 这里修改了person1.name的值，person2.name的值并未改变，并不是因为person1和person2有独立的name值，而是person1.name=&#39;person1&#39;是给person1添加了name值，并非修改了原型上的name值
// 因为我们找对象上的属性时，总是先找实例上对象，没有找到的话再去原型对象上的属性。实例对象和原型对象上如果有同名属性，总是先取实例对象上的值
</code></pre>
<p><strong><em>重点：</em></strong><br>用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</p>
<p><strong><em>优点：</em></strong><br>类似于复制一个对象，用函数来包装。</p>
<p><strong><em>缺点：</em></strong></p>
<ol>
<li>所有实例都会继承原型上的属性。</li>
<li>无法实现复用。（新实例属性都是后面添加的）</li>
</ol>
<h3 id="28-5-寄生式继承"><a href="#28-5-寄生式继承" class="headerlink" title="28.5 寄生式继承"></a>28.5 寄生式继承</h3><pre><code class="javascript">var ob = {
    name: &#39;xiaopao&#39;,
    friends: [&#39;lulu&#39;,&#39;huahua&#39;]
}

function CreateObj(o){
    function F(){};  // 创建一个构造函数F
    F.prototype = o;
    return new F();
}

// 上面CreateObj函数 在ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的 , 看下面代码
var ob1 = CreateObj(ob);
var ob2 = Object.create(ob);
console.log(ob1.name); // xiaopao
console.log(ob2.name); // xiaopao

function CreateChild(o){
    var newob = CreateObj(o); // 创建对象 或者用 var newob = Object.create(ob)
    newob.sayName = function(){ // 增强对象
        console.log(this.name);
    }
    return newob; // 指定对象
}

var p1 = CreateChild(ob);
p1.sayName(); // xiaopao 
</code></pre>
<p><strong><em>重点：</em></strong><br>就是给原型式继承外面套了个壳子。</p>
<p><strong><em>优点：</em></strong><br>没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</p>
<p><strong><em>缺点：</em></strong><br>没用到原型，无法复用。</p>
<h3 id="28-6-寄生组合式继承（常用）"><a href="#28-6-寄生组合式继承（常用）" class="headerlink" title="28.6 寄生组合式继承（常用）"></a>28.6 寄生组合式继承（常用）</h3><pre><code class="javascript">function Parent(name){
    this.name = name;
    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];
}

Parent.prototype.sayName = function(){
    console.log(this.name);
}

function Child(name,age){
    Parent.call(this,name); 
    this.age = age;
}

function CreateObj(o){
    function F(){};
    F.prototype = o;
    return new F();
}

// Child.prototype = new Parent(); // 这里换成下面
function prototype(child,parent){
    var prototype = CreateObj(parent.prototype);
    prototype.constructor = child;
    child.prototype = prototype;
}
prototype(Child,Parent);

var child1 = new Child(&#39;xiaopao&#39;, 18);
console.log(child1); 
</code></pre>
<p><strong><em>重点：</em></strong><br>修复了组合继承的问题</p>
<h3 id="28-7-class继承"><a href="#28-7-class继承" class="headerlink" title="28.7 class继承"></a>28.7 class继承</h3><pre><code class="javascript">class Parent5 {
  constructor() {
    this.name = [&#39;super5&#39;]
  }
  reName() {
    this.name.push(&#39;new 5&#39;)
  }
}
class Child5 extends Parent5 {
  constructor() {
    super()
  }
}
var child51 = new Child5()
var child52 = new Child5()
</code></pre>
<h2 id="29、定义函数的三种方式"><a href="#29、定义函数的三种方式" class="headerlink" title="29、定义函数的三种方式"></a>29、定义函数的三种方式</h2><h3 id="29-1-函数声明式"><a href="#29-1-函数声明式" class="headerlink" title="29.1 函数声明式"></a>29.1 函数声明式</h3><pre><code>function fn(){}
fn();
</code></pre><h3 id="29-2-函数表达式"><a href="#29-2-函数表达式" class="headerlink" title="29.2 函数表达式"></a>29.2 函数表达式</h3><pre><code>var fn = function(){};
fn();
</code></pre><h3 id="29-3-构造函数的方式"><a href="#29-3-构造函数的方式" class="headerlink" title="29.3 构造函数的方式"></a>29.3 构造函数的方式</h3><pre><code>new Function(...)
</code></pre><p>作用：可以直接执行字符串<br>参数：都是字符串类型，最后一个参数是函数体，前面其他所有参数是定义的形参<br>         只有一个参数，就会当成函数体</p>
<pre><code class="javascript">var fn = new Function(&#39;a&#39; , &#39;b&#39; , &#39;console.log(a+b)&#39;);
fn(1,2);
</code></pre>
<h2 id="30、try和catch"><a href="#30、try和catch" class="headerlink" title="30、try和catch"></a>30、try和catch</h2><ul>
<li>try和catch必须一起使用</li>
<li>try表示尝试执行某段代码，就算发生了错误，js也会继续执行</li>
<li>catch，只要try中代码发生了错误，就会执行catch中的代码</li>
<li>finally:不管try中的代码执行是否成功，都会执行finally的代码<pre><code class="javascript">try {  ----尝试执行某段代码
   var fn = new Function(value);
   fn();
}
catch（e）{ ---- 抓取，可以抓取到try执行中的错误，可以进行处理，可以不处理
   console.log(e)
}
finally{
}    
</code></pre>
</li>
</ul>
<h2 id="31、eval-str-可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）"><a href="#31、eval-str-可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）" class="headerlink" title="31、eval(str)可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）"></a>31、eval(str)可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）</h2><pre><code class="javascript">var a = 100;
var str = &#39;var a = 1; var b = 2; console.log(a + b)&#39;;
eval(str); 
</code></pre>
<h2 id="32、四种调用模式"><a href="#32、四种调用模式" class="headerlink" title="32、四种调用模式"></a>32、四种调用模式</h2><ul>
<li>函数：指的是普通的，不属于任何对象的函数</li>
<li>方法：作为对象的属性存在的函数（对象中的函数）</li>
<li>函数内的this指向谁，只跟怎么调用有关系，跟函数定义在什么地方，没有任何关系</li>
</ul>
<h3 id="32-1-函数调用模式"><a href="#32-1-函数调用模式" class="headerlink" title="32.1 函数调用模式"></a>32.1 函数调用模式</h3><pre><code class="javascript">fn( );   // this指向window
</code></pre>
<h3 id="32-2-方法调用模式"><a href="#32-2-方法调用模式" class="headerlink" title="32.2 方法调用模式"></a>32.2 方法调用模式</h3><pre><code class="javascript">obj.fn();  // this指向obj，谁调用指向谁
</code></pre>
<blockquote>
<p>可以把数组当成一个对象，访问0属性，就是方法，方法调用模式，指向arr</p>
</blockquote>
<h3 id="32-3-构造函数调用模式"><a href="#32-3-构造函数调用模式" class="headerlink" title="32.3 构造函数调用模式"></a>32.3 构造函数调用模式</h3><pre><code class="javascript">var p = new Person();  // this指向实例p---new改变了this的指向，让this指向了新的实例
</code></pre>
<h3 id="32-4-上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）"><a href="#32-4-上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）" class="headerlink" title="32.4 上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）"></a>32.4 上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）</h3><ol>
<li><p>call</p>
<ul>
<li>任何函数（都可以看成一个特殊的对象，也可以设置属性和方法）都有一个call方法</li>
<li>call方法也可以用于调用函数,还可以指定函数执行的this的指向---fn.call(this指向);</li>
<li>如果不传参，默认this指向window，如果传递第一个参数，那么就会指定this的指向</li>
</ul>
<p><strong><em>使用call来调用函数和普通调用函数的方式，唯一的区别，就是多了一个参数，call的第一个参数用于指定this指向</em></strong></p>
</li>
</ol>
<p><code>数组</code>：有着数组的方法，可以遍历<br><code>伪数组</code>，本质上是对象，不是数组，数组的方法不能直接调用，但是伪数组是可以遍历的<br>常见的伪数组：<code>arguments</code> <code>document.querySelector()</code>  <code>jQuery</code></p>
<blockquote>
<p>小结：学习call方法，fn.call(this指向,x,y,z);<br>          call方法调用函数和普通函数调用的唯一区别，在于多了一个参数，第一个参数，用于指定this<br>          call方法，可以用于函数借调（借用别人的函数，借来调用）<br>          别人.方法.call(自己)；将this改成自己，借用别人的方法</p>
</blockquote>
<ol start="2">
<li><p>apply</p>
<ul>
<li>apply的功能和call的功能是一样的，只是调用的方法不同了</li>
<li>每个函数，都有一个apply方法，可以用于调用函数，且可以指定this指向</li>
<li><strong><em>apply的语法：fn.apply(this指向，[x,y,z]);</em></strong></li>
<li>参数1：用于指定this的指向</li>
<li><p>参数2：接收一个数组，里面存放着所有传递的参数</p>
<blockquote>
<p>如果参数比较少，一般使用call，比较简单<br>如果参数比较多，一般使用apply，可以将所有需要传递的参数，放在一个数组中，一次性传递</p>
</blockquote>
</li>
</ul>
</li>
<li><p>bind（复制一个新函数，并且将新函数的this固定死指向传入的this值）</p>
<pre><code class="javascript">     var newFn = fn.bind(this指向)
</code></pre>
</li>
<li><p>arguments</p>
</li>
</ol>
<ul>
<li>任何一个函数，都有一个对象，arguments，是一个伪数组，用于收集所有传递的参数（实参）</li>
<li><p>一般用于参数不确定的情况</p>
<p>new会和最近的 函数名() 结合，是一个整体，new fn()</p>
</li>
</ul>
<blockquote>
<p>补充：（1）定时器中的this ，指向window<br>      (2）事件处理函数中，浏览器让this指向了事件源</p>
</blockquote>
<h2 id="33、函数也是对象"><a href="#33、函数也是对象" class="headerlink" title="33、函数也是对象"></a>33、函数也是对象</h2><p>函数也是一种特殊的对象，可以添加属性和方法</p>
<h2 id="34、js的规则："><a href="#34、js的规则：" class="headerlink" title="34、js的规则："></a>34、js的规则：</h2><ol>
<li>任何<code>函数</code>，都是由<code>Function</code>创建出来的，包括他自己，包括Object函数</li>
<li>任何的<code>原型对象</code>，都是直接由<code>Object</code>创建出来的</li>
</ol>
<p>js中的作用域：词法作用域，静态作用域，函数的作用域在函数声明时，就已经确定好了，跟调用没有关系<br>作用域链：每个函数都有自己的作用域，如果是定义在函数内的函数，里面的函数又会有自己的作用域（一层套一层，形成了作用域链）<br>变量的查询规则：先看自己作用域有没有这个变量，如果没有，往外一层一层的就近查找，如果一直找到全局都没有找到，就会报错</p>
<h2 id="35、递归函数：在一个函数内部，自己调用自己"><a href="#35、递归函数：在一个函数内部，自己调用自己" class="headerlink" title="35、递归函数：在一个函数内部，自己调用自己"></a>35、递归函数：在一个函数内部，自己调用自己</h2><p>函数在调用时，其实是占用内存，函数在调用时，会开辟一块内存，进行执行</p>
<p><strong>特点：</strong></p>
<ol>
<li>自己调用自己</li>
<li>必须要有结束条件，要有出口</li>
</ol>
<p><em>递归：是一种算法，一种思想 ，化归思想，复杂的问题简单化</em></p>
<h3 id="35-1-斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和"><a href="#35-1-斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和" class="headerlink" title="35.1 斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和"></a>35.1 斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和</h3><pre><code class="javascript">// 直接这么写会有性能问题
function getFib(n) {
  if (n === 1 || n === 2) {
    return 1;
  }
  return getFib(n-1) + getFib(n-2);
}
</code></pre>
<p><strong><em>为什么会有性能问题？</em></strong><br>一个函数内部，调用了两次自己，真正执行时进行了大量的重复运算</p>
<p><strong><em>如何优化：将已经算过的第n个斐波那契数列存起来</em></strong><br>运算过程中：</p>
<ol>
<li>先判断这个数，有没有算过，如果算过了，直接用</li>
<li><p>如果没有算过，接着自己算，算完，存起来</p>
<pre><code class="javascript">// 找规律: getFib(n) = getFib(n-1) + getFib(n-2);
var arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数
function getFib(n) {
if (n === 1 || n === 2) {
return 1;
}

if (arr[n]) {
return arr[n];
}
else {
arr[n] = getFib(n-1) + getFib(n-2);
return arr[n];
}
}
</code></pre>
</li>
</ol>
<p><strong><em>利用闭包解决斐波那契数列</em></strong></p>
<pre><code class="javascript">// 省去了外部的函数名, 利用函数自调用

var result = (function() {
  var arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数
  function getFib(n) {
    if (n === 1 || n === 2) {
      return 1;
    }

    if (arr[n]) {
      return arr[n];
    }
    else {
      arr[n] = getFib(n - 1) + getFib(n - 2);
      return arr[n];
    }
  }
  return getFib;
})();
</code></pre>
<h2 id="36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包"><a href="#36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包" class="headerlink" title="36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包"></a>36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包</h2><ul>
<li>作用：保护变量（变量私有化）</li>
<li>闭包的内存，不会直接释放（会占用内存）</li>
<li>函数执行调用时，必然会开辟一快内存空间，一般来说，执行完就会释放</li>
</ul>
<p><strong><em>闭包的基本模型：</em></strong></p>
<ol>
<li>outer里面包inner</li>
<li>匿名函数自调用<pre><code class="javascript">var result = (function(){
var count = 0;
return function(){
 count++;
 console.log(count);
}
})();
</code></pre>
</li>
</ol>
<h2 id="37、js垃圾回收机制（会将一些不用的内存空间，释放掉）"><a href="#37、js垃圾回收机制（会将一些不用的内存空间，释放掉）" class="headerlink" title="37、js垃圾回收机制（会将一些不用的内存空间，释放掉）"></a>37、js垃圾回收机制（会将一些不用的内存空间，释放掉）</h2><p><strong>内存泄漏：</strong>如果一块内存空间，一直得不到释放，就认为这块内存泄漏了<br><strong>机制：</strong></p>
<ol>
<li>引用计数：如果一块空间的引用次数，最终变成0，就会被释放掉<pre><code>bug：如果两个对象，互相引用，形成了循环引用，使用引用计数，就会得不到释放（内存泄漏）
</code></pre></li>
<li>标记清除：如果一块内存空间，可以访问到，就不释放；如果访问不到了，就会释放掉<pre><code>闭包用完了，只需要将指向函数内部的引用干掉，此时内存就会释放了
</code></pre></li>
</ol>
<h2 id="38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）"><a href="#38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）" class="headerlink" title="38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）"></a>38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）</h2><h3 id="38-1-创建正则表达式："><a href="#38-1-创建正则表达式：" class="headerlink" title="38.1 创建正则表达式："></a>38.1 创建正则表达式：</h3><ol>
<li>通过构造函数 <pre><code class="javascript">var reg = new RegExp(//);
</code></pre>
\d 表示数字，0-9，/\d/可以匹配所有的数字<br>通过 <code>test</code> 方法，判断字符串，是否符合正则规则</li>
<li>字面量<pre><code class="javascript">var reg = /\d/;
</code></pre>
</li>
</ol>
<h3 id="38-2-正则-元字符"><a href="#38-2-正则-元字符" class="headerlink" title="38.2 正则-元字符"></a>38.2 正则-元字符</h3><h4 id="38-2-1-普通字符：a-b-c"><a href="#38-2-1-普通字符：a-b-c" class="headerlink" title="38.2.1 普通字符：a b c"></a>38.2.1 普通字符：a b c</h4><h4 id="38-2-2-元字符：有特殊含义的"><a href="#38-2-2-元字符：有特殊含义的" class="headerlink" title="38.2.2 元字符：有特殊含义的"></a>38.2.2 元字符：有特殊含义的</h4><ol>
<li><code>\d</code> 数字，0-9</li>
<li><code>\D</code> 非数字</li>
<li><code>\w</code> 匹配单词字符（字母数字下划线），0-9  a-z  A-Z  _</li>
<li><code>\W</code> 非\w（只要不是\w中的字符，都匹配）</li>
<li><code>\s</code> 匹配不可见字符（换行<code>\n</code> <code>空格</code> ）</li>
<li><code>\S</code> 匹配可见字符</li>
<li><code>.</code> 匹配任意字符（除了<code>\n</code>）----a.b可以匹配acb  aab a1b......<br>有时，就需要匹配点，需要转义 .--&gt;表示普通的点</li>
</ol>
<h3 id="38-3-正则表达式的优先级"><a href="#38-3-正则表达式的优先级" class="headerlink" title="38.3 正则表达式的优先级"></a>38.3 正则表达式的优先级</h3><p><code>|</code> 表示或，优先级最低<br><code>()</code> 优先级最高，一般用于提升优先级</p>
<h3 id="38-4-正则表达式的字符"><a href="#38-4-正则表达式的字符" class="headerlink" title="38.4 正则表达式的字符"></a>38.4 正则表达式的字符</h3><p><code>[ ]</code>这个位置，可以出现的字符---[abc]，这个位置，可以出现a或者b或者c<br><code>[a-z]</code>，这个位置，可以出现a-z的所有小写字符<br><code>[a-zA-Z0-9_]</code>，这个位置，可以出现所有的字母、数字、下划线<br>[ ]内的 ^ 表示非</p>
<h3 id="38-5-正则的边界（严格匹配）"><a href="#38-5-正则的边界（严格匹配）" class="headerlink" title="38.5 正则的边界（严格匹配）"></a>38.5 正则的边界（严格匹配）</h3><p><code>^</code>必须以...开头<br><code>$</code> 必须以...结尾<br>console.log(/^$/);---严格匹配，严格到字符数都是确定的</p>
<h3 id="38-6-正则的量词"><a href="#38-6-正则的量词" class="headerlink" title="38.6 正则的量词"></a>38.6 正则的量词</h3><p><code>*</code> 出现0次或多次<br><code>+</code> 出现1次或多次<br><code>?</code> 出现0次或1次<br><code>{m,n}</code> 表示可以出现m次到n次<br><code>{m,}</code> 表示至少出现m次<br><code>{m}</code> 出现m次<br>汉字也是字符的一种，也有范围[\u4e00-u9fa5]---一 yu</p>
<h3 id="38-7-正则的replace（不严格的替换）"><a href="#38-7-正则的replace（不严格的替换）" class="headerlink" title="38.7 正则的replace（不严格的替换）"></a>38.7 正则的replace（不严格的替换）</h3><p>正则也比较懒，不加参数，只替换一次（加上g，表示 全局替换）</p>
<pre><code class="javascript">str.replace(/aa/g,&#39;xx&#39;)
</code></pre>
<h2 id="39、js校正计算"><a href="#39、js校正计算" class="headerlink" title="39、js校正计算"></a>39、js校正计算</h2><p>/<strong>
 </strong> 加法函数，用来得到精确的加法结果<br> <strong> 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。
 </strong> 调用：accAdd(arg1,arg2)<br> <strong> 返回值：arg1加上arg2的精确结果
 </strong>/</p>
<pre><code class="javascript">function accAdd(arg1, arg2) {
    var r1, r2, m, c;
    try {
        r1 = arg1.toString().split(&quot;.&quot;)[1].length;
    }
    catch (e) {
        r1 = 0;
    }
    try {
        r2 = arg2.toString().split(&quot;.&quot;)[1].length;
    }
    catch (e) {
        r2 = 0;
    }
    c = Math.abs(r1 - r2);
    m = Math.pow(10, Math.max(r1, r2));
    if (c &gt; 0) {
        var cm = Math.pow(10, c);
        if (r1 &gt; r2) {
            arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));
            arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;)) * cm;
        } else {
            arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;)) * cm;
            arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));
        }
    } else {
        arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));
        arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));
    }
    return (arg1 + arg2) / m;
}

//给Number类型增加一个add方法，调用起来更加方便。
Number.prototype.add = function (arg) {
    return accAdd(arg, this);
};
</code></pre>
<p>/<strong>
 </strong> 减法函数，用来得到精确的减法结果<br> <strong> 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。
 </strong> 调用：accSub(arg1,arg2)<br> <strong> 返回值：arg1加上arg2的精确结果
 </strong>/</p>
<pre><code class="javascript">function accSub(arg1, arg2) {
    var r1, r2, m, n;
    try {
        r1 = arg1.toString().split(&quot;.&quot;)[1].length;
    }
    catch (e) {
        r1 = 0;
    }
    try {
        r2 = arg2.toString().split(&quot;.&quot;)[1].length;
    }
    catch (e) {
        r2 = 0;
    }
    m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度
    n = (r1 &gt;= r2) ? r1 : r2;
    return ((arg2 * m - arg1 * m) / m).toFixed(n);
}

// 给Number类型增加一个mul方法，调用起来更加方便。
Number.prototype.sub = function (arg) {
    return accSub(arg, this);
};
</code></pre>
<p>/<strong>
 </strong> 乘法函数，用来得到精确的乘法结果<br> <strong> 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。
 </strong> 调用：accMul(arg1,arg2)<br> <strong> 返回值：arg1乘以 arg2的精确结果
 </strong>/</p>
<pre><code class="javascript">function accMul(arg1, arg2) {
    var m = 0, s1 = arg1.toString(), s2 = arg2.toString();
    try {
        m += s1.split(&quot;.&quot;)[1].length;
    }
    catch (e) {
    }
    try {
        m += s2.split(&quot;.&quot;)[1].length;
    }
    catch (e) {
    }
    return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) / Math.pow(10, m);
}

// 给Number类型增加一个mul方法，调用起来更加方便。
Number.prototype.mul = function (arg) {
    return accMul(arg, this);
};
</code></pre>
<p>/<strong> 
 </strong> 除法函数，用来得到精确的除法结果<br> <strong> 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。
 </strong> 调用：accDiv(arg1,arg2)<br> <strong> 返回值：arg1除以arg2的精确结果
 </strong>/</p>
<pre><code class="javascript">function accDiv(arg1, arg2) {
    var t1 = 0, t2 = 0, r1, r2;
    try {
        t1 = arg1.toString().split(&quot;.&quot;)[1].length;
    }
    catch (e) {
    }
    try {
        t2 = arg2.toString().split(&quot;.&quot;)[1].length;
    }
    catch (e) {
    }
    with (Math) {
        r1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));
        r2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));
        return (r1 / r2) * pow(10, t2 - t1);
    }
}

//给Number类型增加一个div方法，调用起来更加方便。
Number.prototype.div = function (arg) {
    return accDiv(this, arg);
};
</code></pre>

        </div>
        <!-- .entry-content -->
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2021/08/25/vue-conclusion/" rel="prev">
              <div class="background">
                <img class="lazyload" src="/images/bg1.jpg" data-src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                vue面试题总结</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2021/08/13/canvas/" rel="next">
              <div class="background">
                <img class="lazyload" src="/images/bg1.jpg" data-src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/3.jpeg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/3.jpeg">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                canvas</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "zMhFPcMIscDyGbtxHjYFffkx-gzGzoHsz",
        appKey: "c4XBymCm0OmYWLklOAKbUlhE",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="DarkStrand.cn" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg" itemprop="image" alt="DarkStrand" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="DarkStrand.cn" itemprop="url" rel="author">DarkStrand</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>一个神奇的小伙</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 DarkStrand<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2021</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by &<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">DarkStrand</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Bazinga.mp4","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Bazinga.mp4","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/touxiang.JPG">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">FLのBlog</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://gitee.com/darkstranded" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/资源/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="2660651585"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>