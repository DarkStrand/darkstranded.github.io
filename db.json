{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Sakura/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/Sakura/source/warn.html","path":"warn.html","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/APlayer.min.css","path":"css/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/insight.styl","path":"css/insight.styl","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/bangumi.css","path":"css/bangumi.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/font.css","path":"css/font.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/jquery.fancybox.min.css","path":"css/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/sharejs.css","path":"css/sharejs.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/zoom.css","path":"css/zoom.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/Sakura/source/js/InsightSearch.js","path":"js/InsightSearch.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/js/APlayer.min.js","path":"js/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/js/zoom.min.js","path":"js/zoom.min.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/js/sakura-app.js","path":"js/sakura-app.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/README.md","path":"live2d-widget/README.md","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/LICENSE","path":"live2d-widget/LICENSE","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/autoload.js","path":"live2d-widget/autoload.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/waifu-tips.json","path":"live2d-widget/waifu-tips.json","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/waifu-tips.js","path":"live2d-widget/waifu-tips.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/waifu.css","path":"live2d-widget/waifu.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/lib.min.css","path":"css/lib.min.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/Sakura/source/js/botui.js","path":"js/botui.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/js/jquery.fancybox.min.js","path":"js/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/icon.css","path":"fonts/SAKURASO.old/icon.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.eot","path":"fonts/SAKURASO.old/sakuraso.eot","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.svg","path":"fonts/SAKURASO.old/sakuraso.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso-symbol.svg","path":"fonts/SAKURASO.old/sakuraso-symbol.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.ttf","path":"fonts/SAKURASO.old/sakuraso.ttf","modified":1,"renderable":1},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.woff","path":"fonts/SAKURASO.old/sakuraso.woff","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/alipay.svg","path":"images/donate/alipay.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/bitcoin.svg","path":"images/donate/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/github.svg","path":"images/donate/github.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/BTCQR.png","path":"images/donate/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/paypal.svg","path":"images/donate/paypal.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/wechat.svg","path":"images/donate/wechat.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/like.svg","path":"images/donate/like.svg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/assets/screenshot-1.png","path":"live2d-widget/assets/screenshot-1.png","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/demo/demo.html","path":"live2d-widget/demo/demo.html","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/demo/login.html","path":"live2d-widget/demo/login.html","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/live2d.min.js","path":"live2d-widget/live2d.min.js","modified":1,"renderable":1},{"_id":"themes/Sakura/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(8).jpg.webp","path":"images/cover/(8).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(7).jpg.webp","path":"images/cover/(7).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/WeChanSQ.jpg","path":"images/donate/WeChanSQ.jpg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(1).jpg.webp","path":"images/cover/(1).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(2).jpg.webp","path":"images/cover/(2).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(5).jpg.webp","path":"images/cover/(5).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(4).jpg.webp","path":"images/cover/(4).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(6).jpg.webp","path":"images/cover/(6).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/WeChanQR.jpg","path":"images/donate/WeChanQR.jpg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/donate/AliPayQR.jpg","path":"images/donate/AliPayQR.jpg","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(3).jpg.webp","path":"images/cover/(3).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/images/cover/(0).jpg.webp","path":"images/cover/(0).jpg.webp","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/assets/screenshot-2.png","path":"live2d-widget/assets/screenshot-2.png","modified":1,"renderable":1},{"_id":"themes/Sakura/source/live2d-widget/assets/screenshot-3.png","path":"live2d-widget/assets/screenshot-3.png","modified":1,"renderable":1},{"_id":"themes/Sakura/source/js/lib.min.js","path":"js/lib.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Sakura/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628736048576},{"_id":"themes/Sakura/README.zhCN.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628736048576},{"_id":"themes/Sakura/.gitignore","hash":"8a27dbc2899378d9b63a768d2b15be8e1b65887d","modified":1628736048574},{"_id":"themes/Sakura/.travis.yml","hash":"59da7c4691ba01d4c05bd64e058551171fe649b6","modified":1628736048575},{"_id":"themes/Sakura/CNAME","hash":"6b332d1ef5947dadc6e394dd1445eb3596eddfe6","modified":1628736048575},{"_id":"themes/Sakura/LICENSE","hash":"e84291eaaeb4a02004d4aa6a504cbf9475f5c562","modified":1628736048575},{"_id":"themes/Sakura/_config.yml","hash":"19a9d1573cd786ab7efa43c71799f2bb326b8b8e","modified":1629197693715},{"_id":"themes/Sakura/package.json","hash":"ec5fa23203039ece9acda53dfac3710b371bd401","modified":1628736048582},{"_id":"source/_posts/Authorized-authentication.md","hash":"c5e509fd71e52051484c8fb8b29acb8407cd9e3b","modified":1630290617059},{"_id":"source/_posts/CodeStandards.md","hash":"3ce3119c6d438036087ae566cbbfb80268e70a17","modified":1632398879499},{"_id":"source/_posts/Hexo-Theme-Sakura.md","hash":"99742473e0880f0677129d0369b05afb70200c6b","modified":1628765050293},{"_id":"source/_posts/leancloud.md","hash":"f5aec846d3b7fee66ff179737c6359512157b121","modified":1632462736195},{"_id":"source/_posts/canvas.md","hash":"db87497e8ab1bfa644b96e01b3beff385baa058e","modified":1628842112209},{"_id":"source/_posts/mac.md","hash":"b09410bc4226e75b6639595c0bf07f4df6956506","modified":1629966464395},{"_id":"source/_posts/middle-front.md","hash":"75c960c2a6540f336e87abcba47638e478767288","modified":1632728327072},{"_id":"source/_posts/plugins.md","hash":"c63606c6f5c349e86dcb9918a4c4851e26a6c1d0","modified":1632366868818},{"_id":"source/_posts/vue-conclusion.md","hash":"b741567f4081d4ad5842124b7e2ad41cfda56654","modified":1629878116560},{"_id":"source/_posts/workTips.md","hash":"faeac2730458ebf1a5a75b8abce8132c907cf934","modified":1632398842004},{"_id":"source/_posts/nodejs.md","hash":"0c9712f3972c4046936a484b869808f5d7c62c82","modified":1628817782628},{"_id":"source/about/index.md","hash":"1839bceb1edc2bdef38d3c0a3d61c9bc72f0a472","modified":1628736048567},{"_id":"source/client/index.md","hash":"3f1803e810d91a6a9badd8e407d451b8204c2037","modified":1628736048568},{"_id":"source/bangumi/index.md","hash":"936d8ec17fcf15e45fa1e04da5076ceddf465d59","modified":1628736048568},{"_id":"source/comment/index.md","hash":"3305ddf380f7a3b05505a3e2d8811e0007ef71b4","modified":1628736048569},{"_id":"source/donate/index.md","hash":"d3299dc74ac555eca9909be3503bc0cef52162c3","modified":1628736048570},{"_id":"source/lab/index.md","hash":"15a8dee0753689f7fce3bca8265cc6bc15064aff","modified":1628736048571},{"_id":"source/links/index.md","hash":"34e64c5ffeaa22be5542af3aaa4aa8ec5997699c","modified":1628736048571},{"_id":"source/rss/index.md","hash":"9743b6bf5f76c0edc68cd6d6bc5d368f8499905d","modified":1628736048572},{"_id":"source/music/index.md","hash":"c1b75a51fe005fc693449c4e42acb4275f10d124","modified":1628772892145},{"_id":"source/tags/index.md","hash":"cfcd3fc7a28589a246456936ef261ed4bf2bb85d","modified":1628736048573},{"_id":"source/theme-sakura/index.md","hash":"79398f2bd5c1d03d605327de81b5d82ef51f67eb","modified":1628736048573},{"_id":"source/video/index.md","hash":"e387a6a406eec70998293846d371072a1c5a60cb","modified":1628736048574},{"_id":"themes/Sakura/languages/zh-cn.yml","hash":"4996257bafcf6c8403d7fef4cba35d22423ea7b8","modified":1629965994235},{"_id":"themes/Sakura/languages/en.yml","hash":"38044728f53054310a9061bdd385d6b524f46e78","modified":1628736048576},{"_id":"themes/Sakura/layout/archive.ejs","hash":"5793d8e23173f5a3308bf6718788b34def54eb1a","modified":1628736048580},{"_id":"themes/Sakura/layout/bangumi.ejs","hash":"c51b5bd3cae5211e6902dadaf3b40969b584e84f","modified":1628736048580},{"_id":"themes/Sakura/layout/category.ejs","hash":"b76d8c1db402ea875c24898ef35f797e75e2b20c","modified":1628736048581},{"_id":"themes/Sakura/layout/donate.ejs","hash":"35b3031bc92319ccfbd8530ff7a0c061e84fd20c","modified":1628765927430},{"_id":"themes/Sakura/layout/index.ejs","hash":"4746cbd731c7c6e3cbd135b9bb4b9fa69b27acba","modified":1628736048581},{"_id":"themes/Sakura/layout/layout.ejs","hash":"cb3d816e42e422909893615374b6eb578dfec404","modified":1628736048581},{"_id":"themes/Sakura/layout/page.ejs","hash":"4a2ddc7c5868279d368a527a340a7d7fddeb975c","modified":1628736048581},{"_id":"themes/Sakura/layout/links.ejs","hash":"e44d2f0f4e88616ba03cae89b464551897b56b5b","modified":1628766189616},{"_id":"themes/Sakura/layout/post.ejs","hash":"32457bc480205dd9be7c3bebbd9b04beb2a60992","modified":1628736048581},{"_id":"themes/Sakura/layout/tag.ejs","hash":"42150204315951aff03fc14d0dda6f0400313260","modified":1628736048582},{"_id":"themes/Sakura/source/404.html","hash":"ca4a7dd580b78c43cd17f99df448d338c14a9acb","modified":1628769388176},{"_id":"themes/Sakura/source/warn.html","hash":"1a2e9b6013fdf6b22f3790feffcc72533be385dd","modified":1628736048615},{"_id":"source/_posts/javascript.md","hash":"63668dc02d926d684761a2280b1a4be2e8485a36","modified":1629274886755},{"_id":"source/_posts/amazing.md","hash":"953175975307126f9dc4ed22ca0602fef23aa42a","modified":1628817934880},{"_id":"themes/Sakura/layout/_partial/_page.ejs","hash":"c438ab0fb6d3310e3c568e3944a770af746e6d59","modified":1628736048577},{"_id":"themes/Sakura/layout/_partial/_post.ejs","hash":"ba480fd3b4c6997acf10c14f489c55f5ccc6da22","modified":1628736048577},{"_id":"themes/Sakura/layout/_partial/archive.ejs","hash":"280bf7a2996d71dafc62e4fe9ee2defb57ed8b12","modified":1628736048577},{"_id":"themes/Sakura/layout/_partial/aplayer.ejs","hash":"05324cecb38f94609b298a1168bc7d8630255c4d","modified":1628736048577},{"_id":"themes/Sakura/layout/_partial/category-archive.ejs","hash":"6c18fb5641fd12d9ebc56814bbfae0d075aa0cd2","modified":1628736048578},{"_id":"themes/Sakura/layout/_partial/comment.ejs","hash":"881846e8e5a73495e7ebe307854d3ad5eeabde84","modified":1628736048578},{"_id":"themes/Sakura/layout/_partial/header.ejs","hash":"66943be8bf726c5215120a744f451579a540d439","modified":1628736048578},{"_id":"themes/Sakura/layout/_partial/footer.ejs","hash":"bf256906aabeae0089f70e9be955cda0e1dd1809","modified":1628766127412},{"_id":"themes/Sakura/layout/_partial/head.ejs","hash":"da9e3d7fcfd16184de4acaa824f01bf42bc107bc","modified":1629198195246},{"_id":"themes/Sakura/layout/_partial/headertop.ejs","hash":"b4b219ae6808505b2ee49a9dd77ac6919f5a13dd","modified":1628736048579},{"_id":"themes/Sakura/layout/_partial/startdash.ejs","hash":"fbe37f81c05d7acb48416be3c04a951eccad484a","modified":1628736048579},{"_id":"themes/Sakura/layout/_partial/mheader.ejs","hash":"de10fa51ddd773d469e36bbb6ea21b583708e5b4","modified":1628736048579},{"_id":"themes/Sakura/layout/_widget/common-article.ejs","hash":"8bf11607756f8ee436ccab9ee7977ecc19d782ee","modified":1628765978142},{"_id":"themes/Sakura/layout/_widget/category-items.ejs","hash":"4b19b5c40c8558307e091716539303013feb9fda","modified":1628736048579},{"_id":"themes/Sakura/layout/_widget/common-page.ejs","hash":"b9eb9b50f18f523f5585382f646e537589865013","modified":1628765987402},{"_id":"themes/Sakura/layout/_widget/index-items.ejs","hash":"22fdb8ec1e2276e2fdab4e9b08d82cc43dd9dec5","modified":1628736048580},{"_id":"themes/Sakura/source/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1628736048582},{"_id":"themes/Sakura/source/css/insight.styl","hash":"5c330fa26c0c2c7326f3093f17625c7de0181795","modified":1628736048583},{"_id":"themes/Sakura/source/css/bangumi.css","hash":"4d30d793a8813b14c55cee12d4a5adbb1cc7c535","modified":1628736048583},{"_id":"themes/Sakura/source/css/donate.css","hash":"fb5b21bae281772ea4e1df250d1d118edd8fe3ec","modified":1628736048583},{"_id":"themes/Sakura/source/css/font.css","hash":"714d3b9fbd98fdc398ce9aa60ec1d60d50628933","modified":1628736048583},{"_id":"themes/Sakura/source/css/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1628736048584},{"_id":"themes/Sakura/source/css/sharejs.css","hash":"62b3ea2384cdf4f9dbce34e17f660856d51a605c","modified":1628736048584},{"_id":"themes/Sakura/source/css/zoom.css","hash":"e6feedd50deaf58cd27b33ed99f04f479c9fba31","modified":1628736048586},{"_id":"themes/Sakura/source/fonts/iconfont.svg","hash":"f469a7fe346fc3665d70dde9e4eb81331f504b5f","modified":1628736048590},{"_id":"themes/Sakura/source/fonts/iconfont.woff","hash":"7222cdc09d819e340fd8cea8498d36270b0400b1","modified":1628736048591},{"_id":"themes/Sakura/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1628746682008},{"_id":"themes/Sakura/source/js/InsightSearch.js","hash":"3acae0bd3b55b16b93006466942de81b2a27b011","modified":1628736048608},{"_id":"themes/Sakura/source/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1628736048608},{"_id":"themes/Sakura/source/js/zoom.min.js","hash":"0b377c432d448cfc09c9e451128a48810a250926","modified":1628736048614},{"_id":"themes/Sakura/source/js/sakura-app.js","hash":"46dc2e5334ac8b5a556382b0705e1a99ca97b857","modified":1628736048614},{"_id":"themes/Sakura/source/live2d-widget/README.md","hash":"cee888d08bc5af46e6b0e9fa6a9afe11abb5cdca","modified":1624796589000},{"_id":"themes/Sakura/source/live2d-widget/LICENSE","hash":"31a3d460bb3c7d98845187c716a30db81c44b615","modified":1624796589000},{"_id":"themes/Sakura/source/live2d-widget/autoload.js","hash":"e4d1768dfa4e2efb656dfbd5887961770bcb9d2a","modified":1629198129169},{"_id":"themes/Sakura/source/live2d-widget/waifu-tips.json","hash":"d431623808875bb338f73d4c2d9d7fe7fbb430cb","modified":1629199855789},{"_id":"themes/Sakura/source/live2d-widget/waifu-tips.js","hash":"f8bdc91fa1e51d46dc18e04174c63034d68299bf","modified":1624796589000},{"_id":"themes/Sakura/source/live2d-widget/waifu.css","hash":"736036cbc5ede7a8f3261e0cd53b3580382a8153","modified":1629199765542},{"_id":"themes/Sakura/source/css/lib.min.css","hash":"3c4c8e1006dcc8e57e4a02e9d735a52c2a95cc72","modified":1628736048584},{"_id":"themes/Sakura/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1628736048589},{"_id":"themes/Sakura/source/fonts/iconfont.eot","hash":"a6d4a6cbd2e7e0ece89973f4c848c7209b062120","modified":1628736048590},{"_id":"themes/Sakura/source/fonts/iconfont.ttf","hash":"5454ae941eeeda1fee8a1b9ef608dae39f58288e","modified":1628736048590},{"_id":"themes/Sakura/source/js/botui.js","hash":"7fd0a8b3a214c7840d4b1297195f3e9282b5cbb9","modified":1628736048609},{"_id":"themes/Sakura/source/js/jquery.fancybox.min.js","hash":"9e2b205a88c949fc8e6a7550d502dabe2b1ab4c0","modified":1628736048609},{"_id":"themes/Sakura/layout/_widget/search/insight.ejs","hash":"072cc5dbd9d3c818a353cfd55ad7ec0e535155b6","modified":1628736048580},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/icon.css","hash":"cca92568d623792d63db3706a705d3c77412d025","modified":1628736048587},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.eot","hash":"509315fee1cbfcbfd9beec880032f75532df38af","modified":1628736048587},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.svg","hash":"6eb5c281f77452342361ed3352f62e2dec0f3b5c","modified":1628736048587},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso-symbol.svg","hash":"dd2a3d764889d23575a33251ff64761fb4bbb317","modified":1628736048587},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.ttf","hash":"91025ed91b9a317ddc835cc88d660c193a6c0228","modified":1628736048588},{"_id":"themes/Sakura/source/fonts/SAKURASO.old/sakuraso.woff","hash":"00856819a670a578f78ffa2cae66717e21b24b36","modified":1628736048588},{"_id":"themes/Sakura/source/images/donate/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1628736048605},{"_id":"themes/Sakura/source/images/donate/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1628736048606},{"_id":"themes/Sakura/source/images/donate/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1628736048606},{"_id":"themes/Sakura/source/images/donate/BTCQR.png","hash":"1abc7fa494a5bb9765dee1004f544ad962d46c91","modified":1628736048602},{"_id":"themes/Sakura/source/images/donate/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1628736048606},{"_id":"themes/Sakura/source/images/donate/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1628736048607},{"_id":"themes/Sakura/source/images/donate/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1628736048606},{"_id":"themes/Sakura/source/live2d-widget/assets/screenshot-1.png","hash":"4bd4d97a1fcaa5deb3cea1c0a102a895a15af32f","modified":1624796589000},{"_id":"themes/Sakura/source/live2d-widget/demo/demo.html","hash":"2617b8aa4c4728d38a8f062465304e5433056abc","modified":1624796589000},{"_id":"themes/Sakura/source/live2d-widget/demo/login.html","hash":"9512df47f6516c0013153095693cba1992744f4b","modified":1624796589000},{"_id":"themes/Sakura/source/live2d-widget/live2d.min.js","hash":"94383fb61de815c3f806ae3f11026bbcfe384082","modified":1624796589000},{"_id":"themes/Sakura/source/css/style.css","hash":"37d00b721fc6675f733cd5988e9e89e0cc42af89","modified":1629189514056},{"_id":"themes/Sakura/source/images/cover/(8).jpg.webp","hash":"4ffcfb8c695294e8d84cee0e7b5be0c024e5dfa7","modified":1628736048599},{"_id":"themes/Sakura/source/images/cover/(7).jpg.webp","hash":"280a5c05256dca4fbea5af1bae208c19efce73a4","modified":1628736048598},{"_id":"themes/Sakura/source/images/donate/WeChanSQ.jpg","hash":"27a05e1012dde94e06d711d3c868ef8e1bf50af0","modified":1628736048605},{"_id":"themes/Sakura/source/images/cover/(1).jpg.webp","hash":"007d0c26d29a48d7ce45a5dfe91b496d41f771da","modified":1628736048593},{"_id":"themes/Sakura/source/images/cover/(2).jpg.webp","hash":"a28c79979c8a3950a8a53fec07cd1a6ff446615c","modified":1628736048594},{"_id":"themes/Sakura/source/images/cover/(5).jpg.webp","hash":"ad0f06e40504f4b86b3b12f6b2c86e9f07da01ea","modified":1628736048597},{"_id":"themes/Sakura/source/images/cover/(4).jpg.webp","hash":"22bc8dfdcba509032f270fb68f9168efb39bb373","modified":1628736048595},{"_id":"themes/Sakura/source/images/cover/(6).jpg.webp","hash":"25267df7614e852d8c4ba229e9c77c5453e744bb","modified":1628736048598},{"_id":"themes/Sakura/source/images/donate/WeChanQR.jpg","hash":"a3d79bd57a41945603816d071b6c965146d693dc","modified":1628736048604},{"_id":"themes/Sakura/source/images/donate/AliPayQR.jpg","hash":"315df35efab2584bc427914865bdc31ec90eaa99","modified":1628736048601},{"_id":"themes/Sakura/source/images/cover/(3).jpg.webp","hash":"96ff977ce087a71a020e4a75a7e3516ade3fee19","modified":1628736048595},{"_id":"themes/Sakura/source/images/cover/(0).jpg.webp","hash":"007d0c26d29a48d7ce45a5dfe91b496d41f771da","modified":1628736048592},{"_id":"themes/Sakura/source/live2d-widget/assets/screenshot-2.png","hash":"76b844653136184c573b3632e12296e008a7ff5c","modified":1624796589000},{"_id":"themes/Sakura/source/live2d-widget/assets/screenshot-3.png","hash":"f89c6fdf44008e7d3c7a1aafe65dc39b212edb6c","modified":1624796589000},{"_id":"themes/Sakura/source/js/lib.min.js","hash":"28f7ece281fef37370c561b7bca5285776ae8fd9","modified":1628736048613},{"_id":"public/atom.xml","hash":"58279dd36cd42043bc8cc01368a022a1b41880a4","modified":1632729185842},{"_id":"public/content.json","hash":"5a9fce07dab1e0146fcfeac57868b9663b42a5ad","modified":1632729185843},{"_id":"public/donate/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632729186168},{"_id":"public/about/index.html","hash":"36434d7321983096e0e59097ab43701e27cbeffe","modified":1632729186168},{"_id":"public/client/index.html","hash":"bc4ef38fecb5e3f0d1175f74814457a7a2dff069","modified":1632729186168},{"_id":"public/bangumi/index.html","hash":"bc0363f3621ff6fddaf6c14d89b0dbd0aa5cf937","modified":1632729186168},{"_id":"public/comment/index.html","hash":"ded21b9a582b81f4f8090ec2f3f9ae4cbfba15c8","modified":1632729186168},{"_id":"public/lab/index.html","hash":"56e808bb6ba06881ab5507c38d05d282a4e4081b","modified":1632729186168},{"_id":"public/links/index.html","hash":"a9d727ca818e7704938dd27d6a9360cae768be46","modified":1632729186168},{"_id":"public/rss/index.html","hash":"ba2e67ceb4958ea98fe9e1e77bb8f177723afe84","modified":1632729186169},{"_id":"public/music/index.html","hash":"063ae3c3d2ad2222f424c93da6f9907b931aa3c3","modified":1632729186169},{"_id":"public/tags/index.html","hash":"0af943044eaffd9836af3d2d313ef48ebacb631a","modified":1632729186169},{"_id":"public/theme-sakura/index.html","hash":"55f91be39bece994c18145656e844fd161af7566","modified":1632729186169},{"_id":"public/video/index.html","hash":"2897a573e79e839b93aff98ef61ac8858dd911f2","modified":1632729186169},{"_id":"public/2021/09/24/leancloud/index.html","hash":"8778a74b18c0748e725026f974f22f619aa3cdfb","modified":1632729186169},{"_id":"public/2021/09/23/plugins/index.html","hash":"1bf482c95327060ee4587c510b94027561711e51","modified":1632729186169},{"_id":"public/2021/09/18/middle-front/index.html","hash":"d9650a0772af1ed7ad2eb520769cf3f2ca36ebd4","modified":1632729186169},{"_id":"public/2021/08/30/Authorized-authentication/index.html","hash":"bdbb1646d607dabae38a51ef7b501f1e405eb09c","modified":1632729186170},{"_id":"public/2021/08/26/mac/index.html","hash":"c06356c4eb1a4dce5d61e5d69724387aad86f640","modified":1632729186170},{"_id":"public/2021/08/17/vue-conclusion/index.html","hash":"4cc651e9624be4e9863198bfd10b1295be7e689f","modified":1632729186170},{"_id":"public/2021/08/17/javascript/index.html","hash":"5c6b04a6912c439c22e2257afd87c2dcbd60bf08","modified":1632729186170},{"_id":"public/2021/08/13/canvas/index.html","hash":"a67971fd708100866910acc9a54a0e384dcba880","modified":1632729186171},{"_id":"public/2021/08/13/amazing/index.html","hash":"d3ca62d5ae1a177abbf8442d0a0b47477101ddf0","modified":1632729186171},{"_id":"public/2021/08/12/nodejs/index.html","hash":"6361792b8d534af72a55b189d033d98ca9b34650","modified":1632729186171},{"_id":"public/2021/07/27/workTips/index.html","hash":"dfde5cbfefec4b94df7c2b514df99507994c4d42","modified":1632729186171},{"_id":"public/2021/07/15/CodeStandards/index.html","hash":"c59621ab74413aa654e57fd50d68c602e17ce741","modified":1632729186171},{"_id":"public/2018/12/12/Hexo-Theme-Sakura/index.html","hash":"ee349a9271ef0168b23c1dc97aa0dd3b20860187","modified":1632729186171},{"_id":"public/categories/技术/index.html","hash":"a51630886ec1163f4afb9505dde292abe074f8b8","modified":1632729186172},{"_id":"public/categories/技术/page/2/index.html","hash":"deb254095f407b2e994a94fbf82a694812a25752","modified":1632729186172},{"_id":"public/categories/front/index.html","hash":"dd986bdcbb00a2ed8ec2d5b8cd413d3c339cb25c","modified":1632729186172},{"_id":"public/archives/index.html","hash":"a1108a8cee181fba0c99b8a1ccf0b36fba245138","modified":1632729186172},{"_id":"public/archives/page/2/index.html","hash":"a1108a8cee181fba0c99b8a1ccf0b36fba245138","modified":1632729186172},{"_id":"public/archives/2018/index.html","hash":"1a9343e8472866fa4d5a71f7d7c459030fe922d8","modified":1632729186173},{"_id":"public/archives/2018/12/index.html","hash":"64f0f98c142422aca15bdfb8e15b8076d27d839c","modified":1632729186173},{"_id":"public/archives/2021/index.html","hash":"ee0902999f10241058b4960d3b965c4d6274aad4","modified":1632729186173},{"_id":"public/archives/2021/page/2/index.html","hash":"ee0902999f10241058b4960d3b965c4d6274aad4","modified":1632729186173},{"_id":"public/archives/2021/07/index.html","hash":"f62f00bceceb2133eff33eefdde6010d6c3c727a","modified":1632729186173},{"_id":"public/archives/2021/08/index.html","hash":"ae042b58494109cd207a16d8e34a93ba171b73cf","modified":1632729186173},{"_id":"public/archives/2021/09/index.html","hash":"66e2e3e0d79085dc6c8f8549720207abf3fb82e1","modified":1632729186173},{"_id":"public/index.html","hash":"6428f16c08b6e3e3984236ab4c89a2222d62e06d","modified":1632729186174},{"_id":"public/page/2/index.html","hash":"6ec5f41d05ae46a0d778aae6e673cc022ae8bc51","modified":1632729186174},{"_id":"public/tags/web/index.html","hash":"8e872a6fdd3afaddee59558fc1127e30111b2685","modified":1632729186174},{"_id":"public/tags/mac/index.html","hash":"b8a586d984a43d8353b7d7ea0cb0f1e064c3aebc","modified":1632729186174},{"_id":"public/tags/悦读/index.html","hash":"dbe6a92e78b23f5e74039722ce11b3b498b9076a","modified":1632729186174},{"_id":"public/tags/前端/index.html","hash":"5b94c7e5c13990715a969f9645470651ea50506c","modified":1632729186174},{"_id":"public/tags/后端/index.html","hash":"03f6b1ed5f66ddd9c593df1f0777475d230e8474","modified":1632729186174},{"_id":"public/fonts/iconfont.svg","hash":"f469a7fe346fc3665d70dde9e4eb81331f504b5f","modified":1632729186190},{"_id":"public/fonts/iconfont.woff","hash":"7222cdc09d819e340fd8cea8498d36270b0400b1","modified":1632729186190},{"_id":"public/live2d-widget/LICENSE","hash":"31a3d460bb3c7d98845187c716a30db81c44b615","modified":1632729186191},{"_id":"public/fonts/iconfont.eot","hash":"a6d4a6cbd2e7e0ece89973f4c848c7209b062120","modified":1632729186191},{"_id":"public/fonts/iconfont.ttf","hash":"5454ae941eeeda1fee8a1b9ef608dae39f58288e","modified":1632729186191},{"_id":"public/fonts/SAKURASO.old/sakuraso.eot","hash":"509315fee1cbfcbfd9beec880032f75532df38af","modified":1632729186191},{"_id":"public/fonts/SAKURASO.old/sakuraso.svg","hash":"6eb5c281f77452342361ed3352f62e2dec0f3b5c","modified":1632729186191},{"_id":"public/fonts/SAKURASO.old/sakuraso-symbol.svg","hash":"dd2a3d764889d23575a33251ff64761fb4bbb317","modified":1632729186191},{"_id":"public/fonts/SAKURASO.old/sakuraso.ttf","hash":"91025ed91b9a317ddc835cc88d660c193a6c0228","modified":1632729186191},{"_id":"public/fonts/SAKURASO.old/sakuraso.woff","hash":"00856819a670a578f78ffa2cae66717e21b24b36","modified":1632729186191},{"_id":"public/images/donate/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1632729186191},{"_id":"public/images/donate/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1632729186191},{"_id":"public/images/donate/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1632729186191},{"_id":"public/images/donate/BTCQR.png","hash":"1abc7fa494a5bb9765dee1004f544ad962d46c91","modified":1632729186192},{"_id":"public/images/donate/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1632729186192},{"_id":"public/images/donate/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1632729186192},{"_id":"public/images/donate/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1632729186192},{"_id":"public/live2d-widget/assets/screenshot-1.png","hash":"4bd4d97a1fcaa5deb3cea1c0a102a895a15af32f","modified":1632729186192},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1632729186541},{"_id":"public/images/cover/(8).jpg.webp","hash":"4ffcfb8c695294e8d84cee0e7b5be0c024e5dfa7","modified":1632729186545},{"_id":"public/images/donate/WeChanSQ.jpg","hash":"27a05e1012dde94e06d711d3c868ef8e1bf50af0","modified":1632729186545},{"_id":"public/images/cover/(7).jpg.webp","hash":"280a5c05256dca4fbea5af1bae208c19efce73a4","modified":1632729186545},{"_id":"public/images/cover/(1).jpg.webp","hash":"007d0c26d29a48d7ce45a5dfe91b496d41f771da","modified":1632729186545},{"_id":"public/images/cover/(3).jpg.webp","hash":"96ff977ce087a71a020e4a75a7e3516ade3fee19","modified":1632729186546},{"_id":"public/images/cover/(0).jpg.webp","hash":"007d0c26d29a48d7ce45a5dfe91b496d41f771da","modified":1632729186546},{"_id":"public/css/insight.css","hash":"e3edf9f215f8b4bf6131a781edf2634df039796c","modified":1632729186576},{"_id":"public/css/bangumi.css","hash":"4d30d793a8813b14c55cee12d4a5adbb1cc7c535","modified":1632729186579},{"_id":"public/css/donate.css","hash":"fb5b21bae281772ea4e1df250d1d118edd8fe3ec","modified":1632729186579},{"_id":"public/css/sharejs.css","hash":"62b3ea2384cdf4f9dbce34e17f660856d51a605c","modified":1632729186579},{"_id":"public/css/zoom.css","hash":"e6feedd50deaf58cd27b33ed99f04f479c9fba31","modified":1632729186579},{"_id":"public/js/zoom.min.js","hash":"0b377c432d448cfc09c9e451128a48810a250926","modified":1632729186580},{"_id":"public/live2d-widget/autoload.js","hash":"e4d1768dfa4e2efb656dfbd5887961770bcb9d2a","modified":1632729186580},{"_id":"public/live2d-widget/waifu.css","hash":"736036cbc5ede7a8f3261e0cd53b3580382a8153","modified":1632729186580},{"_id":"public/fonts/SAKURASO.old/icon.css","hash":"cca92568d623792d63db3706a705d3c77412d025","modified":1632729186580},{"_id":"public/404.html","hash":"cf5659da4d57031b468be6563ec7fc62001d754e","modified":1632729186580},{"_id":"public/warn.html","hash":"b9e793ed41f353f85bb32612e0b44448b9feb9d5","modified":1632729186580},{"_id":"public/live2d-widget/demo/demo.html","hash":"4bb8c58d72a5aaa1a473ec37a4aa42fd77b08da7","modified":1632729186580},{"_id":"public/live2d-widget/demo/login.html","hash":"681202affdc03456b2978c634d14cb5def72db55","modified":1632729186580},{"_id":"public/images/cover/(2).jpg.webp","hash":"a28c79979c8a3950a8a53fec07cd1a6ff446615c","modified":1632729186580},{"_id":"public/images/cover/(5).jpg.webp","hash":"ad0f06e40504f4b86b3b12f6b2c86e9f07da01ea","modified":1632729186581},{"_id":"public/images/cover/(4).jpg.webp","hash":"22bc8dfdcba509032f270fb68f9168efb39bb373","modified":1632729186581},{"_id":"public/images/cover/(6).jpg.webp","hash":"25267df7614e852d8c4ba229e9c77c5453e744bb","modified":1632729186582},{"_id":"public/images/donate/WeChanQR.jpg","hash":"a3d79bd57a41945603816d071b6c965146d693dc","modified":1632729186582},{"_id":"public/images/donate/AliPayQR.jpg","hash":"315df35efab2584bc427914865bdc31ec90eaa99","modified":1632729186583},{"_id":"public/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1632729186593},{"_id":"public/css/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1632729186594},{"_id":"public/js/InsightSearch.js","hash":"3acae0bd3b55b16b93006466942de81b2a27b011","modified":1632729186594},{"_id":"public/live2d-widget/waifu-tips.json","hash":"dbbde424c7decf028b1ed9f890ade6afd5b33799","modified":1632729186595},{"_id":"public/live2d-widget/waifu-tips.js","hash":"f8bdc91fa1e51d46dc18e04174c63034d68299bf","modified":1632729186596},{"_id":"public/live2d-widget/README.html","hash":"9112e00fe1ba8480a26be08064c40a9656fe5db0","modified":1632729186596},{"_id":"public/css/font.css","hash":"714d3b9fbd98fdc398ce9aa60ec1d60d50628933","modified":1632729186604},{"_id":"public/live2d-widget/assets/screenshot-3.png","hash":"f89c6fdf44008e7d3c7a1aafe65dc39b212edb6c","modified":1632729186612},{"_id":"public/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1632729186755},{"_id":"public/js/sakura-app.js","hash":"46dc2e5334ac8b5a556382b0705e1a99ca97b857","modified":1632729186755},{"_id":"public/css/lib.min.css","hash":"3c4c8e1006dcc8e57e4a02e9d735a52c2a95cc72","modified":1632729186766},{"_id":"public/js/jquery.fancybox.min.js","hash":"9e2b205a88c949fc8e6a7550d502dabe2b1ab4c0","modified":1632729186767},{"_id":"public/live2d-widget/assets/screenshot-2.png","hash":"76b844653136184c573b3632e12296e008a7ff5c","modified":1632729186767},{"_id":"public/js/botui.js","hash":"7fd0a8b3a214c7840d4b1297195f3e9282b5cbb9","modified":1632729186774},{"_id":"public/live2d-widget/live2d.min.js","hash":"94383fb61de815c3f806ae3f11026bbcfe384082","modified":1632729186778},{"_id":"public/css/style.css","hash":"37d00b721fc6675f733cd5988e9e89e0cc42af89","modified":1632729186788},{"_id":"public/js/lib.min.js","hash":"28f7ece281fef37370c561b7bca5285776ae8fd9","modified":1632729186861}],"Category":[{"name":"技术","_id":"cku2cstop00044v9kje35v5k8"},{"name":"front","_id":"cku2cstr800194v9kfdthtt4k"}],"Data":[],"Page":[{"title":"about","date":"2018-12-12T14:14:36.000Z","keywords":"关于","description":null,"comments":0,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/about.jpg","_content":"{% raw %}\n<!-- 因为vue和botui更新导至bug,现将对话移至js下的botui中配置 -->\n<div class=\"entry-content\">\n  <div class=\"moe-mashiro\" style=\"text-align:center; font-size: 50px; margin-bottom: 20px;\">[さくら荘のhojun]</div>\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与&nbsp;<ruby>\n    Mashiro&nbsp;<rp>\n    （</rp>\n    <rt>\n    真（ま）白（しろ）</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui></botui>\n  </div>\n</div>\n<script src=\"/js/botui.js\"></script>\n<script>\nbot_ui_ini()\n</script>\n{% endraw %}","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-12-12 22:14:36\nkeywords: 关于\ndescription: \ncomments: false\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/about.jpg\n---\n{% raw %}\n<!-- 因为vue和botui更新导至bug,现将对话移至js下的botui中配置 -->\n<div class=\"entry-content\">\n  <div class=\"moe-mashiro\" style=\"text-align:center; font-size: 50px; margin-bottom: 20px;\">[さくら荘のhojun]</div>\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与&nbsp;<ruby>\n    Mashiro&nbsp;<rp>\n    （</rp>\n    <rt>\n    真（ま）白（しろ）</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui></botui>\n  </div>\n</div>\n<script src=\"/js/botui.js\"></script>\n<script>\nbot_ui_ini()\n</script>\n{% endraw %}","updated":"2021-08-12T02:40:48.567Z","path":"about/index.html","layout":"page","_id":"cku2cstol00014v9kvfm15mb9","content":"\n<!-- 因为vue和botui更新导至bug,现将对话移至js下的botui中配置 -->\n<div class=\"entry-content\">\n  <div class=\"moe-mashiro\" style=\"text-align:center; font-size: 50px; margin-bottom: 20px;\">[さくら荘のhojun]</div>\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与&nbsp;<ruby>\n    Mashiro&nbsp;<rp>\n    （</rp>\n    <rt>\n    真（ま）白（しろ）</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui>\n  </bot-ui></div>\n</div>\n<script src=\"/js/botui.js\"></script>\n<script>\nbot_ui_ini()\n</script>\n","site":{"data":{}},"excerpt":"","more":"\n<!-- 因为vue和botui更新导至bug,现将对话移至js下的botui中配置 -->\n<div class=\"entry-content\">\n  <div class=\"moe-mashiro\" style=\"text-align:center; font-size: 50px; margin-bottom: 20px;\">[さくら荘のhojun]</div>\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与&nbsp;<ruby>\n    Mashiro&nbsp;<rp>\n    （</rp>\n    <rt>\n    真（ま）白（しろ）</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui>\n  </bot-ui></div>\n</div>\n<script src=\"/js/botui.js\"></script>\n<script>\nbot_ui_ini()\n</script>\n"},{"title":"client","date":"2018-12-20T15:13:35.000Z","keywords":"Android客户端","description":null,"comments":0,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/client.jpg","_content":"直接下载 or 扫码下载：\n{% raw %}\n<div style=\"text-align: center;\">\n<img class=\"lazyload\" data-src=\"https://view.moezx.cc/images/2018/06/08/app-download.png#in-center#width-50\" style=\"width: 200px; height: 200px;\" alt=\"\">\n</div>\n{% endraw %}","source":"client/index.md","raw":"---\ntitle: client\ndate: 2018-12-20 23:13:35\nkeywords: Android客户端\ndescription: \ncomments: false\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/client.jpg\n---\n直接下载 or 扫码下载：\n{% raw %}\n<div style=\"text-align: center;\">\n<img class=\"lazyload\" data-src=\"https://view.moezx.cc/images/2018/06/08/app-download.png#in-center#width-50\" style=\"width: 200px; height: 200px;\" alt=\"\">\n</div>\n{% endraw %}","updated":"2021-08-12T02:40:48.568Z","path":"client/index.html","layout":"page","_id":"cku2cstoo00034v9kq0qzp9kk","content":"<p>直接下载 or 扫码下载：<br>\n<div style=\"text-align: center;\">\n<img class=\"lazyload\" data-src=\"https://view.moezx.cc/images/2018/06/08/app-download.png#in-center#width-50\" style=\"width: 200px; height: 200px;\" alt>\n</div>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<p>直接下载 or 扫码下载：<br>\n<div style=\"text-align: center;\">\n<img class=\"lazyload\" data-src=\"https://view.moezx.cc/images/2018/06/08/app-download.png#in-center#width-50\" style=\"width: 200px; height: 200px;\" alt>\n</div>\n</p>\n"},{"layout":"bangumi","title":"bangumi","comments":0,"date":"2019-02-10T13:32:48.000Z","keywords":null,"description":null,"bangumis":[{"img":"https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg","title":"朝花夕誓——于离别之朝束起约定之花","status":"已追完","progress":100,"jp":"さよならの朝に約束の花をかざろう","time":"2018-02-24 SUN.","desc":"住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。"},{"img":"https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg","title":"朝花夕誓——于离别之朝束起约定之花","status":"已追完","progress":50,"jp":"さよならの朝に約束の花をかざろう","time":"2018-02-24 SUN.","desc":"住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。"}],"_content":"","source":"bangumi/index.md","raw":"---\nlayout: bangumi\ntitle: bangumi\ncomments: false\ndate: 2019-02-10 21:32:48\nkeywords:\ndescription:\nbangumis:\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n    title: 朝花夕誓——于离别之朝束起约定之花\n    status: 已追完\n    progress: 100\n    jp: さよならの朝に約束の花をかざろう\n    time: 2018-02-24 SUN.\n    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n    title: 朝花夕誓——于离别之朝束起约定之花\n    status: 已追完\n    progress: 50\n    jp: さよならの朝に約束の花をかざろう\n    time: 2018-02-24 SUN.\n    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n---\n","updated":"2021-08-12T02:40:48.568Z","path":"bangumi/index.html","_id":"cku2cstot00074v9knj2ue2r7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","keywords":"留言板","description":null,"comments":1,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg","_content":"{% raw %}\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n{% endraw %}","source":"comment/index.md","raw":"---\ntitle: comment\ndate: 2018-12-20 23:13:48\nkeywords: 留言板\ndescription: \ncomments: true\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg\n---\n{% raw %}\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n{% endraw %}","updated":"2021-08-12T02:40:48.569Z","path":"comment/index.html","layout":"page","_id":"cku2cstov00094v9kjg1mv7mc","content":"\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n","site":{"data":{}},"excerpt":"","more":"\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n"},{"layout":"donate","title":"donate","date":"2018-12-20T15:13:05.000Z","keywords":"谢谢饲主了喵~","description":null,"comments":0,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/donate.jpg","_content":"","source":"donate/index.md","raw":"---\nlayout: donate\ntitle: donate\ndate: 2018-12-20 23:13:05\nkeywords: 谢谢饲主了喵~\ndescription: \ncomments: false\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/donate.jpg\n---\n","updated":"2021-08-12T02:40:48.570Z","path":"donate/index.html","_id":"cku2cstp0000d4v9kpl9ax8hq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"lab","comments":0,"date":"2019-01-05T13:47:59.000Z","keywords":"Lab实验室","description":null,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/lab.jpg","_content":"\n## sakura主题\nbalabala","source":"lab/index.md","raw":"---\ntitle: lab\ncomments: false\ndate: 2019-01-05 21:47:59\nkeywords: Lab实验室\ndescription: \nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/lab.jpg\n---\n\n## sakura主题\nbalabala","updated":"2021-08-12T02:40:48.571Z","path":"lab/index.html","layout":"page","_id":"cku2cstp5000f4v9kbhhfas71","content":"<h2 id=\"sakura主题\"><a href=\"#sakura主题\" class=\"headerlink\" title=\"sakura主题\"></a>sakura主题</h2><p>balabala</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"sakura主题\"><a href=\"#sakura主题\" class=\"headerlink\" title=\"sakura主题\"></a>sakura主题</h2><p>balabala</p>\n"},{"layout":"links","title":"links","date":"2018-12-19T15:11:06.000Z","keywords":"友人帐","description":null,"comments":1,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg","links":[{"group":"个人项目","desc":"充分说明这家伙是条咸鱼 < (￣︶￣)>","items":[{"url":"https://shino.cc/fgvf","img":"https://cloud.moezx.cc/Picture/svg/landscape/fields.svg","name":"Google","desc":"Google 镜像"},{"url":"https://shino.cc/fgvf","img":"https://cloud.moezx.cc/Picture/svg/landscape/fields.svg","name":"Google","desc":"Google 镜像"}]},{"group":"小伙伴们","desc":"欢迎交换友链 ꉂ(ˊᗜˋ)","items":[{"url":"https://shino.cc/fgvf","img":"https://cloud.moezx.cc/Picture/svg/landscape/fields.svg","name":"Google","desc":"Google 镜像"},{"url":"https://shino.cc/fgvf","img":"https://cloud.moezx.cc/Picture/svg/landscape/fields.svg","name":"Google","desc":"Google 镜像"}]}],"_content":"","source":"links/index.md","raw":"---\nlayout: links\ntitle: links\ndate: 2018-12-19 23:11:06\nkeywords: 友人帐\ndescription: \ncomments: true\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg\nlinks:\n  - group: 个人项目\n    desc: 充分说明这家伙是条咸鱼 < (￣︶￣)>\n    items:\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n  - group: 小伙伴们\n    desc: 欢迎交换友链 ꉂ(ˊᗜˋ)\n    items:\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n---\n","updated":"2021-08-12T02:40:48.571Z","path":"links/index.html","_id":"cku2cstp6000k4v9kf8wzowet","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","photos":null,"_content":"","source":"rss/index.md","raw":"---\ntitle: rss\ndate: 2018-12-20 23:09:03\nphotos:\n---\n","updated":"2021-08-12T02:40:48.572Z","path":"rss/index.html","comments":1,"layout":"page","_id":"cku2cstp8000n4v9k1ialsmnj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","keywords":"喜欢的音乐","description":null,"comments":0,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/music.jpg","_content":"{% raw %}\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"571919785\"\n  mutex=\"true\">\n</meting-js>\n\n<!-- <meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"419239189\"\n  mutex=\"true\">\n</meting-js> -->\n{% endraw %}","source":"music/index.md","raw":"---\ntitle: music\ndate: 2018-12-20 23:14:28\nkeywords: 喜欢的音乐\ndescription: \ncomments: false\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/music.jpg\n---\n{% raw %}\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"571919785\"\n  mutex=\"true\">\n</meting-js>\n\n<!-- <meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"419239189\"\n  mutex=\"true\">\n</meting-js> -->\n{% endraw %}","updated":"2021-08-12T12:54:52.145Z","path":"music/index.html","layout":"page","_id":"cku2cstpa000q4v9keuary2sa","content":"\n<meting-js server=\"netease\" type=\"playlist\" id=\"571919785\" mutex=\"true\">\n</meting-js>\n\n<!-- <meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"419239189\"\n  mutex=\"true\">\n</meting-js> -->\n","site":{"data":{}},"excerpt":"","more":"\n<meting-js server=\"netease\" type=\"playlist\" id=\"571919785\" mutex=\"true\">\n</meting-js>\n\n<!-- <meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"419239189\"\n  mutex=\"true\">\n</meting-js> -->\n"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-12-12 22:14:16\n---\n","updated":"2021-08-12T02:40:48.573Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cku2cstpb000t4v9k5gffbq5q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"theme-sakura","comments":0,"date":"2019-01-04T14:53:25.000Z","keywords":"Hexo 主题 Sakura 🌸","description":null,"photos":"https://static.2heng.xin/wp-content/uploads//2018/05/sakura2.jpeg","_content":"Hexo主题Sakura修改自WordPress主题[Sakura](https://github.com/mashirozx/Sakura/)，感谢原作者[Mashiro](https://2heng.xin/)","source":"theme-sakura/index.md","raw":"---\ntitle: theme-sakura\ncomments: false\ndate: 2019-01-04 22:53:25\nkeywords: Hexo 主题 Sakura 🌸\ndescription:\nphotos: https://static.2heng.xin/wp-content/uploads//2018/05/sakura2.jpeg\n---\nHexo主题Sakura修改自WordPress主题[Sakura](https://github.com/mashirozx/Sakura/)，感谢原作者[Mashiro](https://2heng.xin/)","updated":"2021-08-12T02:40:48.573Z","path":"theme-sakura/index.html","layout":"page","_id":"cku2cstpd000v4v9k6gprmhf9","content":"<p>Hexo主题Sakura修改自WordPress主题<a href=\"https://github.com/mashirozx/Sakura/\" target=\"_blank\" rel=\"noopener\">Sakura</a>，感谢原作者<a href=\"https://2heng.xin/\" target=\"_blank\" rel=\"noopener\">Mashiro</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Hexo主题Sakura修改自WordPress主题<a href=\"https://github.com/mashirozx/Sakura/\" target=\"_blank\" rel=\"noopener\">Sakura</a>，感谢原作者<a href=\"https://2heng.xin/\" target=\"_blank\" rel=\"noopener\">Mashiro</a></p>\n"},{"title":"video","date":"2018-12-20T15:14:38.000Z","keywords":"B站","description":null,"comments":0,"photos":null,"_content":"{% raw %}\n<script>\n  var videos = [\n    {\n      img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '放送时间: 2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    },\n    {\n      img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    }\n  ]\n</script>\n{% endraw %}\n\n{% raw %}\n  <style>.should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}\n  </style>\n  <header class=\"page-header\"><h1 class=\"cat-title\">番组计划</h1> <span class=\"cat-des\"><p>这里将是永远的回忆</p> </span></header>\n  <div class=\"bangumi\">\n    <div class=\"row\" id=\"rootRow\">\n    </div>\n  </div>\n  <script>\n  window.onload = function(){\n    videos.forEach(function(video, i){\n      $('#rootRow').append(`<div class=\"col s12 m6\" id=\"bangumi-218971\">\n        <div class=\"card hoverable\" style=\"overflow: visible;\">\n          <div class=\"card-image waves-effect waves-block waves-light\">\n            <div class=\"activator itempic lazyload\" style=\"background-image: url(${video.img});\" data-src=\"${video.img}\">\n            </div>\n          </div>\n          <div class=\"card-content\">\n            <div class=\"card-title should-ellipsis activator grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-commenting-o right\"></i>\n            </div>\n            <p class=\"should-ellipsis-full\">\n            ${video.jp}</p>\n            <ul class=\"skill-list\">\n              <li class=\"skill\">\n                <div>\n                ${video.status}</div>\n                <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                </progress>\n              </li>\n            </ul>\n          </div>\n          <div class=\"card-reveal\" style=\"display: none; transform: translateY(0%);\">\n            <span class=\"card-title grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-close right\"></i>\n            </span>\n            <span>\n              ${video.jp}<br>\n            </span>\n            <span>\n              放送时间: ${video.time}<span>\n                <p>${video.desc}</p>\n                <ul class=\"skill-list\">\n                  <li class=\"skill\">\n                    <div>\n                    ${video.status}</div>\n                    <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                    </progress>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>`)\n    })\n  }\n  </script>\n{% endraw %}","source":"video/index.md","raw":"---\ntitle: video\ndate: 2018-12-20 23:14:38\nkeywords: B站\ndescription: \ncomments: false\nphotos: \n---\n{% raw %}\n<script>\n  var videos = [\n    {\n      img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '放送时间: 2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    },\n    {\n      img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    }\n  ]\n</script>\n{% endraw %}\n\n{% raw %}\n  <style>.should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}\n  </style>\n  <header class=\"page-header\"><h1 class=\"cat-title\">番组计划</h1> <span class=\"cat-des\"><p>这里将是永远的回忆</p> </span></header>\n  <div class=\"bangumi\">\n    <div class=\"row\" id=\"rootRow\">\n    </div>\n  </div>\n  <script>\n  window.onload = function(){\n    videos.forEach(function(video, i){\n      $('#rootRow').append(`<div class=\"col s12 m6\" id=\"bangumi-218971\">\n        <div class=\"card hoverable\" style=\"overflow: visible;\">\n          <div class=\"card-image waves-effect waves-block waves-light\">\n            <div class=\"activator itempic lazyload\" style=\"background-image: url(${video.img});\" data-src=\"${video.img}\">\n            </div>\n          </div>\n          <div class=\"card-content\">\n            <div class=\"card-title should-ellipsis activator grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-commenting-o right\"></i>\n            </div>\n            <p class=\"should-ellipsis-full\">\n            ${video.jp}</p>\n            <ul class=\"skill-list\">\n              <li class=\"skill\">\n                <div>\n                ${video.status}</div>\n                <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                </progress>\n              </li>\n            </ul>\n          </div>\n          <div class=\"card-reveal\" style=\"display: none; transform: translateY(0%);\">\n            <span class=\"card-title grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-close right\"></i>\n            </span>\n            <span>\n              ${video.jp}<br>\n            </span>\n            <span>\n              放送时间: ${video.time}<span>\n                <p>${video.desc}</p>\n                <ul class=\"skill-list\">\n                  <li class=\"skill\">\n                    <div>\n                    ${video.status}</div>\n                    <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                    </progress>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>`)\n    })\n  }\n  </script>\n{% endraw %}","updated":"2021-08-12T02:40:48.574Z","path":"video/index.html","layout":"page","_id":"cku2cstqj00124v9k3jcaeyvj","content":"\n<script>\n  var videos = [\n    {\n      img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '放送时间: 2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    },\n    {\n      img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    }\n  ]\n</script>\n\n\n  <style>.should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}\n  </style>\n  <header class=\"page-header\"><h1 class=\"cat-title\">番组计划</h1> <span class=\"cat-des\"><p>这里将是永远的回忆</p> </span></header>\n  <div class=\"bangumi\">\n    <div class=\"row\" id=\"rootRow\">\n    </div>\n  </div>\n  <script>\n  window.onload = function(){\n    videos.forEach(function(video, i){\n      $('#rootRow').append(`<div class=\"col s12 m6\" id=\"bangumi-218971\">\n        <div class=\"card hoverable\" style=\"overflow: visible;\">\n          <div class=\"card-image waves-effect waves-block waves-light\">\n            <div class=\"activator itempic lazyload\" style=\"background-image: url(${video.img});\" data-src=\"${video.img}\">\n            </div>\n          </div>\n          <div class=\"card-content\">\n            <div class=\"card-title should-ellipsis activator grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-commenting-o right\"></i>\n            </div>\n            <p class=\"should-ellipsis-full\">\n            ${video.jp}</p>\n            <ul class=\"skill-list\">\n              <li class=\"skill\">\n                <div>\n                ${video.status}</div>\n                <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                </progress>\n              </li>\n            </ul>\n          </div>\n          <div class=\"card-reveal\" style=\"display: none; transform: translateY(0%);\">\n            <span class=\"card-title grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-close right\"></i>\n            </span>\n            <span>\n              ${video.jp}<br>\n            </span>\n            <span>\n              放送时间: ${video.time}<span>\n                <p>${video.desc}</p>\n                <ul class=\"skill-list\">\n                  <li class=\"skill\">\n                    <div>\n                    ${video.status}</div>\n                    <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                    </progress>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>`)\n    })\n  }\n  </script>\n","site":{"data":{}},"excerpt":"","more":"\n<script>\n  var videos = [\n    {\n      img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '放送时间: 2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    },\n    {\n      img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg',\n      title: '朝花夕誓——于离别之朝束起约定之花',\n      status: '已追完',\n      progress: 100,\n      jp: 'さよならの朝に約束の花をかざろう',\n      time: '2018-02-24 SUN.',\n      desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。'\n    }\n  ]\n</script>\n\n\n  <style>.should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}\n  </style>\n  <header class=\"page-header\"><h1 class=\"cat-title\">番组计划</h1> <span class=\"cat-des\"><p>这里将是永远的回忆</p> </span></header>\n  <div class=\"bangumi\">\n    <div class=\"row\" id=\"rootRow\">\n    </div>\n  </div>\n  <script>\n  window.onload = function(){\n    videos.forEach(function(video, i){\n      $('#rootRow').append(`<div class=\"col s12 m6\" id=\"bangumi-218971\">\n        <div class=\"card hoverable\" style=\"overflow: visible;\">\n          <div class=\"card-image waves-effect waves-block waves-light\">\n            <div class=\"activator itempic lazyload\" style=\"background-image: url(${video.img});\" data-src=\"${video.img}\">\n            </div>\n          </div>\n          <div class=\"card-content\">\n            <div class=\"card-title should-ellipsis activator grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-commenting-o right\"></i>\n            </div>\n            <p class=\"should-ellipsis-full\">\n            ${video.jp}</p>\n            <ul class=\"skill-list\">\n              <li class=\"skill\">\n                <div>\n                ${video.status}</div>\n                <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                </progress>\n              </li>\n            </ul>\n          </div>\n          <div class=\"card-reveal\" style=\"display: none; transform: translateY(0%);\">\n            <span class=\"card-title grey-text text-darken-4\">\n              ${video.title}<i class=\"fa fa-close right\"></i>\n            </span>\n            <span>\n              ${video.jp}<br>\n            </span>\n            <span>\n              放送时间: ${video.time}<span>\n                <p>${video.desc}</p>\n                <ul class=\"skill-list\">\n                  <li class=\"skill\">\n                    <div>\n                    ${video.status}</div>\n                    <progress class=\"skill-1\" max=\"100\" value=\"${video.progress}\">\n                    </progress>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>`)\n    })\n  }\n  </script>\n"}],"Post":[{"title":"前端代码规范","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-07-15T01:10:58.637Z","comments":1,"keywords":"前端代码规范","description":"前端代码规范","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg"],"_content":"\n[原文](https://www.yuque.com/docs/share/332b7c4f-c991-41a1-8822-d5edc7ef153f)\n\n***前端编码规范***\n\n## 序言\n编码风格没有太多的好坏之分, 最重要的是风格保持一致，编码规范有助于规范我们编码的风格，使代码具有更好的可读性。本文档风格约定部分可能跟你的喜好有冲突，请尽量用包容的心态来阅读。有任何问题或建议，欢迎跟我们讨论。\n\n## 一、通用规范\n\n### 1.1 `强制` 所有代码统一缩进两个空格\n\n### 1.2 `强制` 使用UTF-8编码\n\n## 二、VUE编码规范\n\n### 2.1 `强制` 所有单文件组件命名统一首字母大写示例：MyComponent.vue\n\n### 2.2 `强制`指令缩写 (统一用 : 表示 v-bind: 和用 @ 表示 v-on:)\n\n示例：\n```html\n<input\n  :value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n><input\n  @input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n### 2.3 `强制`使用 v-for 时配合 key 使用\n示例：<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>[强制]单文件组件页的私有样式使用 scoped 锁定作用域避免污染到全局样式示例：<style lang=\"scss\" scoped>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n</style>[建议]组件名应该倾向于完整单词而不是缩写编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。示例：components/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue[建议]组件名以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。示例：components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue[建议]在声明 prop 的时候，命名用驼峰命名，在模板和 JSX中用短横线拼接命名。示例：props: {\n  greetingText: String\n}\n\n<welcome-message greeting-text=\"hi\"/>三、Javascript编码规范空格与符号[强制]二元运算符的两侧统一加一个空格，一元运算符与操作对象之间不要空格示例：var a = !arr.length;\na++;\na = b + c;[强制]用作代码块起始的左花括号 { 前必须有一个空格，并且与前面的代码写在同一行，右花括号 } 换第二行。示例：// good\nif (condition) {\n}\n\n// bad\nif (condition){\n}\nif (condition) \n{\n}[强制]花括号 { 之间需要加一个空格// good\nimport { button, popup } from 'vant';\n\n// bad\nimport {button, popup} from 'vant';[强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格示例：// good\nif (condition) {\n}\n\n// bad\nif(condition) {\n}\n[强制]在对象创建时，属性中的冒号 : 之后必须有空格，冒号 : 之前不允许有空格示例：// good\nvar obj = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\n// bad\nvar obj = {\n  a : 1,\n  b:2,\n  c :3\n};[强制]在函数声明、具名函数表达式、函数调用中，函数名和左圆括号 ( 之间不允许有空格。示例：// good\nfunction funcName() {\n}\nvar funcName = function funcName() {\n};\nfuncName();\n\n// bad\nfunction funcName () {\n}\nvar funcName = function funcName () {\n};\nfuncName ();[强制] 逗号 , 和分号 ; 前不允许有空格，逗号 , 之后统一加一个空格示例：// good\ncallFunc(a, b);\n\n// bad\ncallFunc(a , b) ;\ncallFunc(a,b) ;[强制] () 和 [] 内紧贴括号部分不允许有空格示例：// good\nsave(this.list[this.indexes[i]]);\n\n// bad\ncallFunc( param1, param2, param3 );\nsave( this.list[ this.indexes[ i ] ] );[强制] 语句结束统一加分号 ; 函数结束统一不加分号（函数表达式除外）注释[强制] 函数注释统一使用 /**/ 的写法并且标明参数与返回值（如果有返回值的话）参数需要标明参数的数据类型返回值尽量标明值、类型及描述示例：/**\n * @param {string} id 参数描述\n * @param {boolean} isTrue 参数描述\n * @return {objtct} 返回值描述\n */[建议] 单行注释使用 // 尽量独占一行，如果有多行注释尽量使用多个单行注释进行其他[强制]变量、函数的命名统一使用驼峰命名[建议]每行代码尽量不超过120个字符四、HTML编码规范[强制]标签需要对齐，必须有开始标签和结束标签，如果是空标签要加/示例：// good\n<tr>\n  <td>A</td>\n  <td>Description of A</td>\n</tr>[强制]标签与属性使用小写英文字母[强制]class的命名使用短括号连接方式示例<div class=\"button-add\"></div>[强制]html标签中使用双引号引入属性示例：// good\n<div class=\"button-add\"></div>\n\n//bad\n<div class='button-add'></div>\n<div class=button></div>[建议]图片尽量添加 alt 属性添加 alt 属性，在图片不能显示时，它能替代图片显示五、CSS编码规范[强制]选择器 与 { 之间必须包含空格示例：// good\n.selector {\n}\n\n// bad\n.selector{\n}[强制]当长度单位为0时后面不加px示例：// good\nmargin: 0;\n\n// bad\nmargin: 0px;[强制]每行样式结尾统一加分号示例：// good\nmargin: 0;\n\n// bad\nmargin: 0若有收获，就点个赞吧陈宇鑫05-21 09:42180投诉加入语雀，参与知识分享与交流注册 或 登录 语雀进行评论立即加入回复注册 或 登录 语雀进行评论关于语雀使用帮助数据安全服务协议English快速注册","source":"_posts/CodeStandards.md","raw":"---\ntitle: 前端代码规范\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 08：38：25\ncomments: true\ntags: \n - web\nkeywords: 前端代码规范\ndescription: 前端代码规范\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg\n---\n\n[原文](https://www.yuque.com/docs/share/332b7c4f-c991-41a1-8822-d5edc7ef153f)\n\n***前端编码规范***\n\n## 序言\n编码风格没有太多的好坏之分, 最重要的是风格保持一致，编码规范有助于规范我们编码的风格，使代码具有更好的可读性。本文档风格约定部分可能跟你的喜好有冲突，请尽量用包容的心态来阅读。有任何问题或建议，欢迎跟我们讨论。\n\n## 一、通用规范\n\n### 1.1 `强制` 所有代码统一缩进两个空格\n\n### 1.2 `强制` 使用UTF-8编码\n\n## 二、VUE编码规范\n\n### 2.1 `强制` 所有单文件组件命名统一首字母大写示例：MyComponent.vue\n\n### 2.2 `强制`指令缩写 (统一用 : 表示 v-bind: 和用 @ 表示 v-on:)\n\n示例：\n```html\n<input\n  :value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n><input\n  @input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n### 2.3 `强制`使用 v-for 时配合 key 使用\n示例：<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>[强制]单文件组件页的私有样式使用 scoped 锁定作用域避免污染到全局样式示例：<style lang=\"scss\" scoped>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n</style>[建议]组件名应该倾向于完整单词而不是缩写编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。示例：components/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue[建议]组件名以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。示例：components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue[建议]在声明 prop 的时候，命名用驼峰命名，在模板和 JSX中用短横线拼接命名。示例：props: {\n  greetingText: String\n}\n\n<welcome-message greeting-text=\"hi\"/>三、Javascript编码规范空格与符号[强制]二元运算符的两侧统一加一个空格，一元运算符与操作对象之间不要空格示例：var a = !arr.length;\na++;\na = b + c;[强制]用作代码块起始的左花括号 { 前必须有一个空格，并且与前面的代码写在同一行，右花括号 } 换第二行。示例：// good\nif (condition) {\n}\n\n// bad\nif (condition){\n}\nif (condition) \n{\n}[强制]花括号 { 之间需要加一个空格// good\nimport { button, popup } from 'vant';\n\n// bad\nimport {button, popup} from 'vant';[强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格示例：// good\nif (condition) {\n}\n\n// bad\nif(condition) {\n}\n[强制]在对象创建时，属性中的冒号 : 之后必须有空格，冒号 : 之前不允许有空格示例：// good\nvar obj = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\n// bad\nvar obj = {\n  a : 1,\n  b:2,\n  c :3\n};[强制]在函数声明、具名函数表达式、函数调用中，函数名和左圆括号 ( 之间不允许有空格。示例：// good\nfunction funcName() {\n}\nvar funcName = function funcName() {\n};\nfuncName();\n\n// bad\nfunction funcName () {\n}\nvar funcName = function funcName () {\n};\nfuncName ();[强制] 逗号 , 和分号 ; 前不允许有空格，逗号 , 之后统一加一个空格示例：// good\ncallFunc(a, b);\n\n// bad\ncallFunc(a , b) ;\ncallFunc(a,b) ;[强制] () 和 [] 内紧贴括号部分不允许有空格示例：// good\nsave(this.list[this.indexes[i]]);\n\n// bad\ncallFunc( param1, param2, param3 );\nsave( this.list[ this.indexes[ i ] ] );[强制] 语句结束统一加分号 ; 函数结束统一不加分号（函数表达式除外）注释[强制] 函数注释统一使用 /**/ 的写法并且标明参数与返回值（如果有返回值的话）参数需要标明参数的数据类型返回值尽量标明值、类型及描述示例：/**\n * @param {string} id 参数描述\n * @param {boolean} isTrue 参数描述\n * @return {objtct} 返回值描述\n */[建议] 单行注释使用 // 尽量独占一行，如果有多行注释尽量使用多个单行注释进行其他[强制]变量、函数的命名统一使用驼峰命名[建议]每行代码尽量不超过120个字符四、HTML编码规范[强制]标签需要对齐，必须有开始标签和结束标签，如果是空标签要加/示例：// good\n<tr>\n  <td>A</td>\n  <td>Description of A</td>\n</tr>[强制]标签与属性使用小写英文字母[强制]class的命名使用短括号连接方式示例<div class=\"button-add\"></div>[强制]html标签中使用双引号引入属性示例：// good\n<div class=\"button-add\"></div>\n\n//bad\n<div class='button-add'></div>\n<div class=button></div>[建议]图片尽量添加 alt 属性添加 alt 属性，在图片不能显示时，它能替代图片显示五、CSS编码规范[强制]选择器 与 { 之间必须包含空格示例：// good\n.selector {\n}\n\n// bad\n.selector{\n}[强制]当长度单位为0时后面不加px示例：// good\nmargin: 0;\n\n// bad\nmargin: 0px;[强制]每行样式结尾统一加分号示例：// good\nmargin: 0;\n\n// bad\nmargin: 0若有收获，就点个赞吧陈宇鑫05-21 09:42180投诉加入语雀，参与知识分享与交流注册 或 登录 语雀进行评论立即加入回复注册 或 登录 语雀进行评论关于语雀使用帮助数据安全服务协议English快速注册","slug":"CodeStandards","published":1,"updated":"2021-09-23T12:07:59.499Z","layout":"post","link":"","_id":"cku2cstoc00004v9kz6ppx3ie","content":"<p><a href=\"https://www.yuque.com/docs/share/332b7c4f-c991-41a1-8822-d5edc7ef153f\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<p><strong><em>前端编码规范</em></strong></p>\n<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>编码风格没有太多的好坏之分, 最重要的是风格保持一致，编码规范有助于规范我们编码的风格，使代码具有更好的可读性。本文档风格约定部分可能跟你的喜好有冲突，请尽量用包容的心态来阅读。有任何问题或建议，欢迎跟我们讨论。</p>\n<h2 id=\"一、通用规范\"><a href=\"#一、通用规范\" class=\"headerlink\" title=\"一、通用规范\"></a>一、通用规范</h2><h3 id=\"1-1-强制-所有代码统一缩进两个空格\"><a href=\"#1-1-强制-所有代码统一缩进两个空格\" class=\"headerlink\" title=\"1.1 强制 所有代码统一缩进两个空格\"></a>1.1 <code>强制</code> 所有代码统一缩进两个空格</h3><h3 id=\"1-2-强制-使用UTF-8编码\"><a href=\"#1-2-强制-使用UTF-8编码\" class=\"headerlink\" title=\"1.2 强制 使用UTF-8编码\"></a>1.2 <code>强制</code> 使用UTF-8编码</h3><h2 id=\"二、VUE编码规范\"><a href=\"#二、VUE编码规范\" class=\"headerlink\" title=\"二、VUE编码规范\"></a>二、VUE编码规范</h2><h3 id=\"2-1-强制-所有单文件组件命名统一首字母大写示例：MyComponent-vue\"><a href=\"#2-1-强制-所有单文件组件命名统一首字母大写示例：MyComponent-vue\" class=\"headerlink\" title=\"2.1 强制 所有单文件组件命名统一首字母大写示例：MyComponent.vue\"></a>2.1 <code>强制</code> 所有单文件组件命名统一首字母大写示例：MyComponent.vue</h3><h3 id=\"2-2-强制指令缩写-统一用-表示-v-bind-和用-表示-v-on\"><a href=\"#2-2-强制指令缩写-统一用-表示-v-bind-和用-表示-v-on\" class=\"headerlink\" title=\"2.2 强制指令缩写 (统一用 : 表示 v-bind: 和用 @ 表示 v-on:)\"></a>2.2 <code>强制</code>指令缩写 (统一用 : 表示 v-bind: 和用 @ 表示 v-on:)</h3><p>示例：</p>\n<pre><code class=\"html\">&lt;input\n  :value=&quot;newTodoText&quot;\n  :placeholder=&quot;newTodoInstructions&quot;\n&gt;&lt;input\n  @input=&quot;onInput&quot;\n  @focus=&quot;onFocus&quot;\n&gt;\n</code></pre>\n<h3 id=\"2-3-强制使用-v-for-时配合-key-使用\"><a href=\"#2-3-强制使用-v-for-时配合-key-使用\" class=\"headerlink\" title=\"2.3 强制使用 v-for 时配合 key 使用\"></a>2.3 <code>强制</code>使用 v-for 时配合 key 使用</h3><p>示例：<ul><br>  &lt;li<br>    v-for=&quot;todo in todos&quot;<br>    :key=&quot;todo.id&quot;</ul></p>\n<blockquote>\n</blockquote>\n<pre><code>{{ todo.text }}\n</code></pre><p>  <br>[强制]单文件组件页的私有样式使用 scoped 锁定作用域避免污染到全局样式示例：<style lang=\"scss\" scoped><br>.button {<br>  border: none;<br>  border-radius: 2px;<br>}<br></style>[建议]组件名应该倾向于完整单词而不是缩写编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。示例：components/<br>|- StudentDashboardSettings.vue<br>|- UserProfileOptions.vue[建议]组件名以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。示例：components/<br>|- SearchButtonClear.vue<br>|- SearchButtonRun.vue<br>|- SearchInputQuery.vue<br>|- SearchInputExcludeGlob.vue<br>|- SettingsCheckboxTerms.vue<br>|- SettingsCheckboxLaunchOnStartup.vue[建议]在声明 prop 的时候，命名用驼峰命名，在模板和 JSX中用短横线拼接命名。示例：props: {<br>  greetingText: String<br>}</p>\n<p><welcome-message greeting-text=\"hi\">三、Javascript编码规范空格与符号[强制]二元运算符的两侧统一加一个空格，一元运算符与操作对象之间不要空格示例：var a = !arr.length;<br>a++;<br>a = b + c;[强制]用作代码块起始的左花括号 { 前必须有一个空格，并且与前面的代码写在同一行，右花括号 } 换第二行。示例：// good<br>if (condition) {<br>}</welcome-message></p>\n<p>// bad<br>if (condition){<br>}<br>if (condition)<br>{<br>}[强制]花括号 { 之间需要加一个空格// good<br>import { button, popup } from &#39;vant&#39;;</p>\n<p>// bad<br>import {button, popup} from &#39;vant&#39;;[强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格示例：// good<br>if (condition) {<br>}</p>\n<p>// bad<br>if(condition) {<br>}<br>[强制]在对象创建时，属性中的冒号 : 之后必须有空格，冒号 : 之前不允许有空格示例：// good<br>var obj = {<br>  a: 1,<br>  b: 2,<br>  c: 3<br>};</p>\n<p>// bad<br>var obj = {<br>  a : 1,<br>  b:2,<br>  c :3<br>};[强制]在函数声明、具名函数表达式、函数调用中，函数名和左圆括号 ( 之间不允许有空格。示例：// good<br>function funcName() {<br>}<br>var funcName = function funcName() {<br>};<br>funcName();</p>\n<p>// bad<br>function funcName () {<br>}<br>var funcName = function funcName () {<br>};<br>funcName ();[强制] 逗号 , 和分号 ; 前不允许有空格，逗号 , 之后统一加一个空格示例：// good<br>callFunc(a, b);</p>\n<p>// bad<br>callFunc(a , b) ;<br>callFunc(a,b) ;[强制] () 和 [] 内紧贴括号部分不允许有空格示例：// good<br>save(this.list[this.indexes[i]]);</p>\n<p>// bad<br>callFunc( param1, param2, param3 );<br>save( this.list[ this.indexes[ i ] ] );[强制] 语句结束统一加分号 ; 函数结束统一不加分号（函数表达式除外）注释[强制] 函数注释统一使用 /<strong>/ 的写法并且标明参数与返回值（如果有返回值的话）参数需要标明参数的数据类型返回值尽量标明值、类型及描述示例：/</strong></p>\n<ul>\n<li>@param {string} id 参数描述</li>\n<li>@param {boolean} isTrue 参数描述</li>\n<li>@return {objtct} 返回值描述<br>*/[建议] 单行注释使用 // 尽量独占一行，如果有多行注释尽量使用多个单行注释进行其他[强制]变量、函数的命名统一使用驼峰命名[建议]每行代码尽量不超过120个字符四、HTML编码规范[强制]标签需要对齐，必须有开始标签和结束标签，如果是空标签要加/示例：// good<br><tr><br><td>A</td><br><td>Description of A</td><br></tr>[强制]标签与属性使用小写英文字母[强制]class的命名使用短括号连接方式示例<div class=\"button-add\"></div>[强制]html标签中使用双引号引入属性示例：// good<div class=\"button-add\"></div>\n\n</li>\n</ul>\n<p>//bad</p>\n<p><div class=\"button-add\"></div></p>\n<p><div class=\"button\"></div>[建议]图片尽量添加 alt 属性添加 alt 属性，在图片不能显示时，它能替代图片显示五、CSS编码规范[强制]选择器 与 { 之间必须包含空格示例：// good<br>.selector {<br>}</p>\n<p>// bad<br>.selector{<br>}[强制]当长度单位为0时后面不加px示例：// good<br>margin: 0;</p>\n<p>// bad<br>margin: 0px;[强制]每行样式结尾统一加分号示例：// good<br>margin: 0;</p>\n<p>// bad<br>margin: 0若有收获，就点个赞吧陈宇鑫05-21 09:42180投诉加入语雀，参与知识分享与交流注册 或 登录 语雀进行评论立即加入回复注册 或 登录 语雀进行评论关于语雀使用帮助数据安全服务协议English快速注册</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.yuque.com/docs/share/332b7c4f-c991-41a1-8822-d5edc7ef153f\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<p><strong><em>前端编码规范</em></strong></p>\n<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>编码风格没有太多的好坏之分, 最重要的是风格保持一致，编码规范有助于规范我们编码的风格，使代码具有更好的可读性。本文档风格约定部分可能跟你的喜好有冲突，请尽量用包容的心态来阅读。有任何问题或建议，欢迎跟我们讨论。</p>\n<h2 id=\"一、通用规范\"><a href=\"#一、通用规范\" class=\"headerlink\" title=\"一、通用规范\"></a>一、通用规范</h2><h3 id=\"1-1-强制-所有代码统一缩进两个空格\"><a href=\"#1-1-强制-所有代码统一缩进两个空格\" class=\"headerlink\" title=\"1.1 强制 所有代码统一缩进两个空格\"></a>1.1 <code>强制</code> 所有代码统一缩进两个空格</h3><h3 id=\"1-2-强制-使用UTF-8编码\"><a href=\"#1-2-强制-使用UTF-8编码\" class=\"headerlink\" title=\"1.2 强制 使用UTF-8编码\"></a>1.2 <code>强制</code> 使用UTF-8编码</h3><h2 id=\"二、VUE编码规范\"><a href=\"#二、VUE编码规范\" class=\"headerlink\" title=\"二、VUE编码规范\"></a>二、VUE编码规范</h2><h3 id=\"2-1-强制-所有单文件组件命名统一首字母大写示例：MyComponent-vue\"><a href=\"#2-1-强制-所有单文件组件命名统一首字母大写示例：MyComponent-vue\" class=\"headerlink\" title=\"2.1 强制 所有单文件组件命名统一首字母大写示例：MyComponent.vue\"></a>2.1 <code>强制</code> 所有单文件组件命名统一首字母大写示例：MyComponent.vue</h3><h3 id=\"2-2-强制指令缩写-统一用-表示-v-bind-和用-表示-v-on\"><a href=\"#2-2-强制指令缩写-统一用-表示-v-bind-和用-表示-v-on\" class=\"headerlink\" title=\"2.2 强制指令缩写 (统一用 : 表示 v-bind: 和用 @ 表示 v-on:)\"></a>2.2 <code>强制</code>指令缩写 (统一用 : 表示 v-bind: 和用 @ 表示 v-on:)</h3><p>示例：</p>\n<pre><code class=\"html\">&lt;input\n  :value=&quot;newTodoText&quot;\n  :placeholder=&quot;newTodoInstructions&quot;\n&gt;&lt;input\n  @input=&quot;onInput&quot;\n  @focus=&quot;onFocus&quot;\n&gt;\n</code></pre>\n<h3 id=\"2-3-强制使用-v-for-时配合-key-使用\"><a href=\"#2-3-强制使用-v-for-时配合-key-使用\" class=\"headerlink\" title=\"2.3 强制使用 v-for 时配合 key 使用\"></a>2.3 <code>强制</code>使用 v-for 时配合 key 使用</h3><p>示例：<ul><br>  &lt;li<br>    v-for=&quot;todo in todos&quot;<br>    :key=&quot;todo.id&quot;</ul></p>\n<blockquote>\n</blockquote>\n<pre><code>{{ todo.text }}\n</code></pre><p>  <br>[强制]单文件组件页的私有样式使用 scoped 锁定作用域避免污染到全局样式示例：<style lang=\"scss\" scoped><br>.button {<br>  border: none;<br>  border-radius: 2px;<br>}<br></style>[建议]组件名应该倾向于完整单词而不是缩写编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。示例：components/<br>|- StudentDashboardSettings.vue<br>|- UserProfileOptions.vue[建议]组件名以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。示例：components/<br>|- SearchButtonClear.vue<br>|- SearchButtonRun.vue<br>|- SearchInputQuery.vue<br>|- SearchInputExcludeGlob.vue<br>|- SettingsCheckboxTerms.vue<br>|- SettingsCheckboxLaunchOnStartup.vue[建议]在声明 prop 的时候，命名用驼峰命名，在模板和 JSX中用短横线拼接命名。示例：props: {<br>  greetingText: String<br>}</p>\n<p><welcome-message greeting-text=\"hi\">三、Javascript编码规范空格与符号[强制]二元运算符的两侧统一加一个空格，一元运算符与操作对象之间不要空格示例：var a = !arr.length;<br>a++;<br>a = b + c;[强制]用作代码块起始的左花括号 { 前必须有一个空格，并且与前面的代码写在同一行，右花括号 } 换第二行。示例：// good<br>if (condition) {<br>}</welcome-message></p>\n<p>// bad<br>if (condition){<br>}<br>if (condition)<br>{<br>}[强制]花括号 { 之间需要加一个空格// good<br>import { button, popup } from &#39;vant&#39;;</p>\n<p>// bad<br>import {button, popup} from &#39;vant&#39;;[强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格示例：// good<br>if (condition) {<br>}</p>\n<p>// bad<br>if(condition) {<br>}<br>[强制]在对象创建时，属性中的冒号 : 之后必须有空格，冒号 : 之前不允许有空格示例：// good<br>var obj = {<br>  a: 1,<br>  b: 2,<br>  c: 3<br>};</p>\n<p>// bad<br>var obj = {<br>  a : 1,<br>  b:2,<br>  c :3<br>};[强制]在函数声明、具名函数表达式、函数调用中，函数名和左圆括号 ( 之间不允许有空格。示例：// good<br>function funcName() {<br>}<br>var funcName = function funcName() {<br>};<br>funcName();</p>\n<p>// bad<br>function funcName () {<br>}<br>var funcName = function funcName () {<br>};<br>funcName ();[强制] 逗号 , 和分号 ; 前不允许有空格，逗号 , 之后统一加一个空格示例：// good<br>callFunc(a, b);</p>\n<p>// bad<br>callFunc(a , b) ;<br>callFunc(a,b) ;[强制] () 和 [] 内紧贴括号部分不允许有空格示例：// good<br>save(this.list[this.indexes[i]]);</p>\n<p>// bad<br>callFunc( param1, param2, param3 );<br>save( this.list[ this.indexes[ i ] ] );[强制] 语句结束统一加分号 ; 函数结束统一不加分号（函数表达式除外）注释[强制] 函数注释统一使用 /<strong>/ 的写法并且标明参数与返回值（如果有返回值的话）参数需要标明参数的数据类型返回值尽量标明值、类型及描述示例：/</strong></p>\n<ul>\n<li>@param {string} id 参数描述</li>\n<li>@param {boolean} isTrue 参数描述</li>\n<li>@return {objtct} 返回值描述<br>*/[建议] 单行注释使用 // 尽量独占一行，如果有多行注释尽量使用多个单行注释进行其他[强制]变量、函数的命名统一使用驼峰命名[建议]每行代码尽量不超过120个字符四、HTML编码规范[强制]标签需要对齐，必须有开始标签和结束标签，如果是空标签要加/示例：// good<br><tr><br><td>A</td><br><td>Description of A</td><br></tr>[强制]标签与属性使用小写英文字母[强制]class的命名使用短括号连接方式示例<div class=\"button-add\"></div>[强制]html标签中使用双引号引入属性示例：// good<div class=\"button-add\"></div>\n\n</li>\n</ul>\n<p>//bad</p>\n<p><div class=\"button-add\"></div></p>\n<p><div class=\"button\"></div>[建议]图片尽量添加 alt 属性添加 alt 属性，在图片不能显示时，它能替代图片显示五、CSS编码规范[强制]选择器 与 { 之间必须包含空格示例：// good<br>.selector {<br>}</p>\n<p>// bad<br>.selector{<br>}[强制]当长度单位为0时后面不加px示例：// good<br>margin: 0;</p>\n<p>// bad<br>margin: 0px;[强制]每行样式结尾统一加分号示例：// good<br>margin: 0;</p>\n<p>// bad<br>margin: 0若有收获，就点个赞吧陈宇鑫05-21 09:42180投诉加入语雀，参与知识分享与交流注册 或 登录 语雀进行评论立即加入回复注册 或 登录 语雀进行评论关于语雀使用帮助数据安全服务协议English快速注册</p>\n"},{"title":"leancloud部署项目","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-09-24T03:12:37.861Z","comments":1,"keywords":"leancloud","description":"leancloud部署项目","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg"],"_content":"\n\n\n[教程](https://blog.csdn.net/okboy519/article/details/107337459/)\n\n\n\n# 安装命令行工具\n\n[leancloud官网](https://leancloud.cn/docs/leanengine_cli.html#hash103652211)\n\n\n\n> macOS使用homebrew\n\n```\nbrew update\nbrew install lean-cli\n```\n\n\n\n查看是否安装好\n\n```\nlean -v\n```\n\n\n\n# 登录\n\n","source":"_posts/leancloud.md","raw":"---\ntitle: leancloud部署项目\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 08：38：25\ncomments: true\ntags: \n - web\nkeywords: leancloud\ndescription: leancloud部署项目\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg\n---\n\n\n\n[教程](https://blog.csdn.net/okboy519/article/details/107337459/)\n\n\n\n# 安装命令行工具\n\n[leancloud官网](https://leancloud.cn/docs/leanengine_cli.html#hash103652211)\n\n\n\n> macOS使用homebrew\n\n```\nbrew update\nbrew install lean-cli\n```\n\n\n\n查看是否安装好\n\n```\nlean -v\n```\n\n\n\n# 登录\n\n","slug":"leancloud","published":1,"updated":"2021-09-24T05:52:16.195Z","layout":"post","link":"","_id":"cku2cstom00024v9kow4bcp2e","content":"<p><a href=\"https://blog.csdn.net/okboy519/article/details/107337459/\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<h1 id=\"安装命令行工具\"><a href=\"#安装命令行工具\" class=\"headerlink\" title=\"安装命令行工具\"></a>安装命令行工具</h1><p><a href=\"https://leancloud.cn/docs/leanengine_cli.html#hash103652211\" target=\"_blank\" rel=\"noopener\">leancloud官网</a></p>\n<blockquote>\n<p>macOS使用homebrew</p>\n</blockquote>\n<pre><code>brew update\nbrew install lean-cli\n</code></pre><p>查看是否安装好</p>\n<pre><code>lean -v\n</code></pre><h1 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h1>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/okboy519/article/details/107337459/\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<h1 id=\"安装命令行工具\"><a href=\"#安装命令行工具\" class=\"headerlink\" title=\"安装命令行工具\"></a>安装命令行工具</h1><p><a href=\"https://leancloud.cn/docs/leanengine_cli.html#hash103652211\" target=\"_blank\" rel=\"noopener\">leancloud官网</a></p>\n<blockquote>\n<p>macOS使用homebrew</p>\n</blockquote>\n<pre><code>brew update\nbrew install lean-cli\n</code></pre><p>查看是否安装好</p>\n<pre><code>lean -v\n</code></pre><h1 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h1>"},{"title":"mac系统遇到的各种问题","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-08-26T08:27:40.000Z","comments":1,"keywords":"mac","description":"mac","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg"],"_content":"\n## brew启动mongodb时报错\n\n> Error: Formula `mongodb-community` has not implemented #plist, #service or installed a locatable service file\n\n1. 首先使用`brew update`更新brew\n2. 如果这时候意外按下`control+z`，再次执行`brew update`会提示\n  ```\n    Error: Another active Homebrew update process is already in progress.Please wait for it to finish or terminate it to continue.\n  ```\n\n  解决办法\n  ```\n    rm -rf /usr/local/var/homebrew/locks\n  ```\n3. 再次更新，并启动发现成功了\n","source":"_posts/mac.md","raw":"---\ntitle: mac系统遇到的各种问题\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-26 16:27:40\ncomments: true\ntags: \n - mac\nkeywords: mac\ndescription: mac\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg\n---\n\n## brew启动mongodb时报错\n\n> Error: Formula `mongodb-community` has not implemented #plist, #service or installed a locatable service file\n\n1. 首先使用`brew update`更新brew\n2. 如果这时候意外按下`control+z`，再次执行`brew update`会提示\n  ```\n    Error: Another active Homebrew update process is already in progress.Please wait for it to finish or terminate it to continue.\n  ```\n\n  解决办法\n  ```\n    rm -rf /usr/local/var/homebrew/locks\n  ```\n3. 再次更新，并启动发现成功了\n","slug":"mac","published":1,"updated":"2021-08-26T08:27:44.395Z","layout":"post","link":"","_id":"cku2cstos00064v9k17pp3pd1","content":"<h2 id=\"brew启动mongodb时报错\"><a href=\"#brew启动mongodb时报错\" class=\"headerlink\" title=\"brew启动mongodb时报错\"></a>brew启动mongodb时报错</h2><blockquote>\n<p>Error: Formula <code>mongodb-community</code> has not implemented #plist, #service or installed a locatable service file</p>\n</blockquote>\n<ol>\n<li>首先使用<code>brew update</code>更新brew</li>\n<li><p>如果这时候意外按下<code>control+z</code>，再次执行<code>brew update</code>会提示</p>\n<pre><code> Error: Another active Homebrew update process is already in progress.Please wait for it to finish or terminate it to continue.\n</code></pre><p>解决办法</p>\n<pre><code> rm -rf /usr/local/var/homebrew/locks\n</code></pre></li>\n<li>再次更新，并启动发现成功了</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"brew启动mongodb时报错\"><a href=\"#brew启动mongodb时报错\" class=\"headerlink\" title=\"brew启动mongodb时报错\"></a>brew启动mongodb时报错</h2><blockquote>\n<p>Error: Formula <code>mongodb-community</code> has not implemented #plist, #service or installed a locatable service file</p>\n</blockquote>\n<ol>\n<li>首先使用<code>brew update</code>更新brew</li>\n<li><p>如果这时候意外按下<code>control+z</code>，再次执行<code>brew update</code>会提示</p>\n<pre><code> Error: Another active Homebrew update process is already in progress.Please wait for it to finish or terminate it to continue.\n</code></pre><p>解决办法</p>\n<pre><code> rm -rf /usr/local/var/homebrew/locks\n</code></pre></li>\n<li>再次更新，并启动发现成功了</li>\n</ol>\n"},{"title":"插件","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-09-23T03:11:15.837Z","comments":1,"keywords":"插件","description":"各种插件","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg"],"_content":"\n# vue-count-to\n> 数字滚动插件\n\n# typed.js\n> 打字效果\n[typed.js](https://mattboldt.com/demos/typed-js/)","source":"_posts/plugins.md","raw":"---\ntitle: 插件\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 08：38：25\ncomments: true\ntags: \n - web\nkeywords: 插件\ndescription: 各种插件\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg\n---\n\n# vue-count-to\n> 数字滚动插件\n\n# typed.js\n> 打字效果\n[typed.js](https://mattboldt.com/demos/typed-js/)","slug":"plugins","published":1,"updated":"2021-09-23T03:14:28.818Z","layout":"post","link":"","_id":"cku2cstou00084v9k8g2y1fhu","content":"<h1 id=\"vue-count-to\"><a href=\"#vue-count-to\" class=\"headerlink\" title=\"vue-count-to\"></a>vue-count-to</h1><blockquote>\n<p>数字滚动插件</p>\n</blockquote>\n<h1 id=\"typed-js\"><a href=\"#typed-js\" class=\"headerlink\" title=\"typed.js\"></a>typed.js</h1><blockquote>\n<p>打字效果<br><a href=\"https://mattboldt.com/demos/typed-js/\" target=\"_blank\" rel=\"noopener\">typed.js</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue-count-to\"><a href=\"#vue-count-to\" class=\"headerlink\" title=\"vue-count-to\"></a>vue-count-to</h1><blockquote>\n<p>数字滚动插件</p>\n</blockquote>\n<h1 id=\"typed-js\"><a href=\"#typed-js\" class=\"headerlink\" title=\"typed.js\"></a>typed.js</h1><blockquote>\n<p>打字效果<br><a href=\"https://mattboldt.com/demos/typed-js/\" target=\"_blank\" rel=\"noopener\">typed.js</a></p>\n</blockquote>\n"},{"title":"日常小知识点","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-07-27T01:27:11.583Z","comments":1,"keywords":"js","description":"js","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg"],"_content":"\n## 包含数字字母字符串，6-12位\n```javascript\n/^(?=.*[a-zA-Z])(?=.*\\d)(?=.*[~!@#$%^&*()_+`\\-={}:\";'<>?,.\\/]).{6,12}$/\n```\n\n## 对中文进行排序\n```javascript\nlet arr = [\n  {name: 'zs', age: 1},\n  {name: 'zs', age: 2},\n  {name: 'ls', age: 3},\n  {name: 'ww', age: 4},\n  {name: 'zs', age: 5},\n  {name: 'ww', age: 6},\n  {name: 'ls', age: 7},\n  {name: 'zs', age: 8}\n]\nlet new_arr = arr.sort((a,b) => {\n  return b.name.charCodeAt(0) - a.name.charCodeAt(0)\n})\n```\n\n## post请求不希望url拼接参数，但参数形式Query String Parameters\n\n希望是：\n![](https://segmentfault.com/img/bVbAFBd)\n\n现实是：\n![](https://segmentfault.com/img/bVbAFBz)\n\n> 使用params作参数名会自动拼接到url上面，去axios那里把参数名设置为data就好了\n\n\n\n## ??,?.,??=\n\n###  `?.`（可选链）\n\n> 举例\n\n```javascript\nlet a;\nlet b = a.name;\n```\n\n![](https://img-blog.csdnimg.cn/20210319202635609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9tYXN0ZXI=,size_16,color_FFFFFF,t_70)\n\n\n\n这种情况就相当于直接在`undefined`上面访问`name`属性。`undefined`和`null`是两个比较特殊的数据类型，是不能用点操作符去访问属性的。那么在一个变量可能为`null`、或者`undefined`的时候，恰巧我又需要访问这个变量的一个属性，那我们应该这样做\n\n```js\nlet a;\nlet b;\nif (!!a) {\n\tb = a.name;\n} else {\n\tb = undefined;\n}\n```\n\n> 简单的方法\n\n```js\nlet a;\nlet b = a?.name;\n```\n\n\n\n###  `??`（空值合并运算符）\n\n> 举例\n\n```js\nlet b;\nlet a = 0;\nlet c = { name:'buzhimingqianduan' }\n\nif (!!a || a === 0 ){\n\tb = a;\n} else {\n\tb = c;\n}\n```\n\n当我们想判断一个值存在，但是它等于0的时候，我们也需要当作它存在，于是就有上面的例子，其实我们可以这样做\n\n```js\nlet b;\nlet a = 0;\nlet c = { name: 'aa' };\n\nb = a ?? c;\n```\n\n上面的例子中，当`a`除了`undefined`、或者`null`之外的任何值，`b`都会等于`a`，否则就等于`c`。\n\n\n\n### `??=`（空值赋值运算符）\n\n```js\nlet b = '你好';\nlet a = 0\nlet c = null;\nlet d = ’123‘\nb ??= a;  // b = “你好”\nc ??= d  // c = '123'\n\n```\n\n当`??=`左侧的值为`null`、`undefined`的时候，才会将右侧变量的值赋值给左侧变量。其他所有值都不会进行赋值。同样在一些场景下，可以省略很多代码。\n\n\n\n\n\n","source":"_posts/workTips.md","raw":"---\ntitle: 日常小知识点\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 08：38：25\ncomments: true\ntags: \n - web\nkeywords: js\ndescription: js\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg\n---\n\n## 包含数字字母字符串，6-12位\n```javascript\n/^(?=.*[a-zA-Z])(?=.*\\d)(?=.*[~!@#$%^&*()_+`\\-={}:\";'<>?,.\\/]).{6,12}$/\n```\n\n## 对中文进行排序\n```javascript\nlet arr = [\n  {name: 'zs', age: 1},\n  {name: 'zs', age: 2},\n  {name: 'ls', age: 3},\n  {name: 'ww', age: 4},\n  {name: 'zs', age: 5},\n  {name: 'ww', age: 6},\n  {name: 'ls', age: 7},\n  {name: 'zs', age: 8}\n]\nlet new_arr = arr.sort((a,b) => {\n  return b.name.charCodeAt(0) - a.name.charCodeAt(0)\n})\n```\n\n## post请求不希望url拼接参数，但参数形式Query String Parameters\n\n希望是：\n![](https://segmentfault.com/img/bVbAFBd)\n\n现实是：\n![](https://segmentfault.com/img/bVbAFBz)\n\n> 使用params作参数名会自动拼接到url上面，去axios那里把参数名设置为data就好了\n\n\n\n## ??,?.,??=\n\n###  `?.`（可选链）\n\n> 举例\n\n```javascript\nlet a;\nlet b = a.name;\n```\n\n![](https://img-blog.csdnimg.cn/20210319202635609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9tYXN0ZXI=,size_16,color_FFFFFF,t_70)\n\n\n\n这种情况就相当于直接在`undefined`上面访问`name`属性。`undefined`和`null`是两个比较特殊的数据类型，是不能用点操作符去访问属性的。那么在一个变量可能为`null`、或者`undefined`的时候，恰巧我又需要访问这个变量的一个属性，那我们应该这样做\n\n```js\nlet a;\nlet b;\nif (!!a) {\n\tb = a.name;\n} else {\n\tb = undefined;\n}\n```\n\n> 简单的方法\n\n```js\nlet a;\nlet b = a?.name;\n```\n\n\n\n###  `??`（空值合并运算符）\n\n> 举例\n\n```js\nlet b;\nlet a = 0;\nlet c = { name:'buzhimingqianduan' }\n\nif (!!a || a === 0 ){\n\tb = a;\n} else {\n\tb = c;\n}\n```\n\n当我们想判断一个值存在，但是它等于0的时候，我们也需要当作它存在，于是就有上面的例子，其实我们可以这样做\n\n```js\nlet b;\nlet a = 0;\nlet c = { name: 'aa' };\n\nb = a ?? c;\n```\n\n上面的例子中，当`a`除了`undefined`、或者`null`之外的任何值，`b`都会等于`a`，否则就等于`c`。\n\n\n\n### `??=`（空值赋值运算符）\n\n```js\nlet b = '你好';\nlet a = 0\nlet c = null;\nlet d = ’123‘\nb ??= a;  // b = “你好”\nc ??= d  // c = '123'\n\n```\n\n当`??=`左侧的值为`null`、`undefined`的时候，才会将右侧变量的值赋值给左侧变量。其他所有值都不会进行赋值。同样在一些场景下，可以省略很多代码。\n\n\n\n\n\n","slug":"workTips","published":1,"updated":"2021-09-23T12:07:22.004Z","layout":"post","link":"","_id":"cku2cstoz000a4v9kaif0k2o3","content":"<h2 id=\"包含数字字母字符串，6-12位\"><a href=\"#包含数字字母字符串，6-12位\" class=\"headerlink\" title=\"包含数字字母字符串，6-12位\"></a>包含数字字母字符串，6-12位</h2><pre><code class=\"javascript\">/^(?=.*[a-zA-Z])(?=.*\\d)(?=.*[~!@#$%^&amp;*()_+`\\-={}:&quot;;&#39;&lt;&gt;?,.\\/]).{6,12}$/\n</code></pre>\n<h2 id=\"对中文进行排序\"><a href=\"#对中文进行排序\" class=\"headerlink\" title=\"对中文进行排序\"></a>对中文进行排序</h2><pre><code class=\"javascript\">let arr = [\n  {name: &#39;zs&#39;, age: 1},\n  {name: &#39;zs&#39;, age: 2},\n  {name: &#39;ls&#39;, age: 3},\n  {name: &#39;ww&#39;, age: 4},\n  {name: &#39;zs&#39;, age: 5},\n  {name: &#39;ww&#39;, age: 6},\n  {name: &#39;ls&#39;, age: 7},\n  {name: &#39;zs&#39;, age: 8}\n]\nlet new_arr = arr.sort((a,b) =&gt; {\n  return b.name.charCodeAt(0) - a.name.charCodeAt(0)\n})\n</code></pre>\n<h2 id=\"post请求不希望url拼接参数，但参数形式Query-String-Parameters\"><a href=\"#post请求不希望url拼接参数，但参数形式Query-String-Parameters\" class=\"headerlink\" title=\"post请求不希望url拼接参数，但参数形式Query String Parameters\"></a>post请求不希望url拼接参数，但参数形式Query String Parameters</h2><p>希望是：<br><img src=\"https://segmentfault.com/img/bVbAFBd\" alt></p>\n<p>现实是：<br><img src=\"https://segmentfault.com/img/bVbAFBz\" alt></p>\n<blockquote>\n<p>使用params作参数名会自动拼接到url上面，去axios那里把参数名设置为data就好了</p>\n</blockquote>\n<h2 id><a href=\"#\" class=\"headerlink\" title=\"??,?.,??=\"></a>??,?.,??=</h2><h3 id=\"（可选链）\"><a href=\"#（可选链）\" class=\"headerlink\" title=\"?.（可选链）\"></a><code>?.</code>（可选链）</h3><blockquote>\n<p>举例</p>\n</blockquote>\n<pre><code class=\"javascript\">let a;\nlet b = a.name;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20210319202635609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9tYXN0ZXI=,size_16,color_FFFFFF,t_70\" alt></p>\n<p>这种情况就相当于直接在<code>undefined</code>上面访问<code>name</code>属性。<code>undefined</code>和<code>null</code>是两个比较特殊的数据类型，是不能用点操作符去访问属性的。那么在一个变量可能为<code>null</code>、或者<code>undefined</code>的时候，恰巧我又需要访问这个变量的一个属性，那我们应该这样做</p>\n<pre><code class=\"js\">let a;\nlet b;\nif (!!a) {\n    b = a.name;\n} else {\n    b = undefined;\n}\n</code></pre>\n<blockquote>\n<p>简单的方法</p>\n</blockquote>\n<pre><code class=\"js\">let a;\nlet b = a?.name;\n</code></pre>\n<h3 id=\"（空值合并运算符）\"><a href=\"#（空值合并运算符）\" class=\"headerlink\" title=\"??（空值合并运算符）\"></a><code>??</code>（空值合并运算符）</h3><blockquote>\n<p>举例</p>\n</blockquote>\n<pre><code class=\"js\">let b;\nlet a = 0;\nlet c = { name:&#39;buzhimingqianduan&#39; }\n\nif (!!a || a === 0 ){\n    b = a;\n} else {\n    b = c;\n}\n</code></pre>\n<p>当我们想判断一个值存在，但是它等于0的时候，我们也需要当作它存在，于是就有上面的例子，其实我们可以这样做</p>\n<pre><code class=\"js\">let b;\nlet a = 0;\nlet c = { name: &#39;aa&#39; };\n\nb = a ?? c;\n</code></pre>\n<p>上面的例子中，当<code>a</code>除了<code>undefined</code>、或者<code>null</code>之外的任何值，<code>b</code>都会等于<code>a</code>，否则就等于<code>c</code>。</p>\n<h3 id=\"（空值赋值运算符）\"><a href=\"#（空值赋值运算符）\" class=\"headerlink\" title=\"??=（空值赋值运算符）\"></a><code>??=</code>（空值赋值运算符）</h3><pre><code class=\"js\">let b = &#39;你好&#39;;\nlet a = 0\nlet c = null;\nlet d = ’123‘\nb ??= a;  // b = “你好”\nc ??= d  // c = &#39;123&#39;\n\n</code></pre>\n<p>当<code>??=</code>左侧的值为<code>null</code>、<code>undefined</code>的时候，才会将右侧变量的值赋值给左侧变量。其他所有值都不会进行赋值。同样在一些场景下，可以省略很多代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"包含数字字母字符串，6-12位\"><a href=\"#包含数字字母字符串，6-12位\" class=\"headerlink\" title=\"包含数字字母字符串，6-12位\"></a>包含数字字母字符串，6-12位</h2><pre><code class=\"javascript\">/^(?=.*[a-zA-Z])(?=.*\\d)(?=.*[~!@#$%^&amp;*()_+`\\-={}:&quot;;&#39;&lt;&gt;?,.\\/]).{6,12}$/\n</code></pre>\n<h2 id=\"对中文进行排序\"><a href=\"#对中文进行排序\" class=\"headerlink\" title=\"对中文进行排序\"></a>对中文进行排序</h2><pre><code class=\"javascript\">let arr = [\n  {name: &#39;zs&#39;, age: 1},\n  {name: &#39;zs&#39;, age: 2},\n  {name: &#39;ls&#39;, age: 3},\n  {name: &#39;ww&#39;, age: 4},\n  {name: &#39;zs&#39;, age: 5},\n  {name: &#39;ww&#39;, age: 6},\n  {name: &#39;ls&#39;, age: 7},\n  {name: &#39;zs&#39;, age: 8}\n]\nlet new_arr = arr.sort((a,b) =&gt; {\n  return b.name.charCodeAt(0) - a.name.charCodeAt(0)\n})\n</code></pre>\n<h2 id=\"post请求不希望url拼接参数，但参数形式Query-String-Parameters\"><a href=\"#post请求不希望url拼接参数，但参数形式Query-String-Parameters\" class=\"headerlink\" title=\"post请求不希望url拼接参数，但参数形式Query String Parameters\"></a>post请求不希望url拼接参数，但参数形式Query String Parameters</h2><p>希望是：<br><img src=\"https://segmentfault.com/img/bVbAFBd\" alt></p>\n<p>现实是：<br><img src=\"https://segmentfault.com/img/bVbAFBz\" alt></p>\n<blockquote>\n<p>使用params作参数名会自动拼接到url上面，去axios那里把参数名设置为data就好了</p>\n</blockquote>\n<h2 id><a href=\"#\" class=\"headerlink\" title=\"??,?.,??=\"></a>??,?.,??=</h2><h3 id=\"（可选链）\"><a href=\"#（可选链）\" class=\"headerlink\" title=\"?.（可选链）\"></a><code>?.</code>（可选链）</h3><blockquote>\n<p>举例</p>\n</blockquote>\n<pre><code class=\"javascript\">let a;\nlet b = a.name;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20210319202635609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9tYXN0ZXI=,size_16,color_FFFFFF,t_70\" alt></p>\n<p>这种情况就相当于直接在<code>undefined</code>上面访问<code>name</code>属性。<code>undefined</code>和<code>null</code>是两个比较特殊的数据类型，是不能用点操作符去访问属性的。那么在一个变量可能为<code>null</code>、或者<code>undefined</code>的时候，恰巧我又需要访问这个变量的一个属性，那我们应该这样做</p>\n<pre><code class=\"js\">let a;\nlet b;\nif (!!a) {\n    b = a.name;\n} else {\n    b = undefined;\n}\n</code></pre>\n<blockquote>\n<p>简单的方法</p>\n</blockquote>\n<pre><code class=\"js\">let a;\nlet b = a?.name;\n</code></pre>\n<h3 id=\"（空值合并运算符）\"><a href=\"#（空值合并运算符）\" class=\"headerlink\" title=\"??（空值合并运算符）\"></a><code>??</code>（空值合并运算符）</h3><blockquote>\n<p>举例</p>\n</blockquote>\n<pre><code class=\"js\">let b;\nlet a = 0;\nlet c = { name:&#39;buzhimingqianduan&#39; }\n\nif (!!a || a === 0 ){\n    b = a;\n} else {\n    b = c;\n}\n</code></pre>\n<p>当我们想判断一个值存在，但是它等于0的时候，我们也需要当作它存在，于是就有上面的例子，其实我们可以这样做</p>\n<pre><code class=\"js\">let b;\nlet a = 0;\nlet c = { name: &#39;aa&#39; };\n\nb = a ?? c;\n</code></pre>\n<p>上面的例子中，当<code>a</code>除了<code>undefined</code>、或者<code>null</code>之外的任何值，<code>b</code>都会等于<code>a</code>，否则就等于<code>c</code>。</p>\n<h3 id=\"（空值赋值运算符）\"><a href=\"#（空值赋值运算符）\" class=\"headerlink\" title=\"??=（空值赋值运算符）\"></a><code>??=</code>（空值赋值运算符）</h3><pre><code class=\"js\">let b = &#39;你好&#39;;\nlet a = 0\nlet c = null;\nlet d = ’123‘\nb ??= a;  // b = “你好”\nc ??= d  // c = &#39;123&#39;\n\n</code></pre>\n<p>当<code>??=</code>左侧的值为<code>null</code>、<code>undefined</code>的时候，才会将右侧变量的值赋值给左侧变量。其他所有值都不会进行赋值。同样在一些场景下，可以省略很多代码。</p>\n"},{"title":"Hexo-Theme-Sakura","author":"hojun","avatar":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg","authorLink":"hojun.cn","authorAbout":"一个好奇的人","authorDesc":"一个好奇的人","date":"2018-12-12T14:16:01.000Z","comments":1,"keywords":"Sakura","description":"hexo-sakura主题使用教程","_content":"hexo-theme-sakura主题 [English document](https://github.com/honjun/hexo-theme-sakura/blob/master/README.md)\n\n基于WordPress主题[Sakura](https://github.com/mashirozx/Sakura/)修改成Hexo的主题。\n\n[demo预览](https://sakura.hojun.cn)\n\n正在开发中......\n\n![](https://wx3.sinaimg.cn/large/006bYVyvly1g069tuf42oj312w0m8ndq.jpg)\n\n## 交流群\n若你是使用者，加群QQ: 801511924\n\n若你是创作者，加群QQ: 194472590\n\n\n## 主题特性\n\n - 首页大屏视频\n - 首页随机封面\n - 图片懒加载\n - valine评论\n - fancy-box相册\n - pjax支持，音乐不间断\n - aplayer音乐播放器\n - 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了）\n\n\n## 赞赏作者\n如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！\n\n[paypal](https://www.paypal.me/hojuncn) | [Alipay 支付宝](https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/AliPayQR.jpg) | [WeChat Pay 微信支付](https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanSQ.jpg)\n\n## 未完善的使用教程\n\n那啥？老实说我目前也不是很有条理233333333~\n\n## 1、主题下载安装\n\n[hexo-theme-sakura](https://github.com/honjun/hexo-theme-sakura)建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。\n\n下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行`npm i`安装依赖。\n\n## 2、主题配置\n\n### 博客根目录下的_config配置\n\n站点\n```yml\n# Site\ntitle: 你的站点名\nsubtitle:\ndescription: 站点简介\nkeywords:\nauthor: 作者名\nlanguage: zh-cn\ntimezone:\n```\n\n部署\n```yml\ndeploy:\n  type: git\n  repo: \n    github: 你的github仓库地址\n    # coding: 你的coding仓库地址\n  branch: master\n```\n\n备份 （使用hexo b发布备份到远程仓库）\n```yml\nbackup:\n  type: git\n  message: backup my blog of https://honjun.github.io/\n  repository:\n    # 你的github仓库地址,备份分支名  （建议新建backup分支）\n    github: https://github.com/honjun/honjun.github.io.git,backup\n    # coding: https://git.coding.net/hojun/hojun.git,backup\n\n```\n\n### 主题目录下的_config配置\n\n其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分\n```yml\n# site name\n# 站点名 【改】\nprefixName: さくら荘その\nsiteName: hojun\n\n# favicon and site master avatar\n# 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】\nfavicon: /images/favicon.ico\navatar: /img/custom/avatar.jpg\n\n# 站点url 【改】\nurl: https://sakura.hojun.cn\n\n# 站点介绍（或者说是个人签名）【改】\ndescription: Live your life with passion! With some drive!\n\n# 站点cdn，没有就为空 【改】  若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg\ncdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6\n\n# 开启pjax 【选】\npjax: 1\n\n# 站点首页的公告信息 【改】\nnotice: hexo-Sakura主题已经开源，目前正在开发中...\n\n# 懒加载的加载中图片 【选】\nlazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg\n\n# 站点菜单配置 【选】\nmenus:\n  首页: { path: /, fa: fa-fort-awesome faa-shake }\n  归档: { path: /archives, fa: fa-archive faa-shake, submenus: { \n    技术: {path: /categories/技术/, fa: fa-code }, \n    生活: {path: /categories/生活/, fa: fa-file-text-o }, \n    资源: {path: /categories/资源/, fa: fa-cloud-download }, \n    随想: {path: /categories/随想/, fa: fa-commenting-o },\n    转载: {path: /categories/转载/, fa: fa-book }\n  } }\n  清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { \n    书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, \n    番组: {path: /bangumi/, fa: fa-film faa-vertical }, \n    歌单: {path: /music/, fa: fa-headphones },\n    图集: {path: /tags/图集/, fa: fa-photo }\n  } }\n  留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada }\n  友人帐: { path: /links/, fa: fa-link faa-shake }\n  赞赏: { path: /donate/, fa: fa-heart faa-pulse }\n  关于: { path: /, fa: fa-leaf faa-wrench , submenus: { \n    我？: {path: /about/, fa: fa-meetup}, \n    主题: {path: /theme-sakura/, fa: iconfont icon-sakura },\n    Lab: {path: /lab/, fa: fa-cogs },\n  } }\n  客户端: { path: /client/, fa: fa-android faa-vertical }\n  RSS: { path: /atom.xml, fa: fa-rss faa-pulse }\n\n# Home page sort type: -1: newer first，1: older first. 【非】\nhomePageSortType: -1\n\n# Home page article shown number) 【非】\nhomeArticleShown: 10\n\n# 背景图片 【选】\nbgn: 8\n\n# startdash面板 url, title, desc img 【改】\nstartdash: \n  - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png}\n  - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg}\n  - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg}\n\n\n# your site build time or founded date\n# 你的站点建立日期 【改】\nsiteBuildingTime: 07/17/2018\n\n\n# 社交按钮(social)  url, img PC端配置 【改】\nsocial:\n  github: {url: http://github.com/honjun, img: /img/social/github.png}\n  sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png}\n  wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png}\n  zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png}\n  email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg}\n  wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png}\n\n# 社交按钮(msocial)  url, img 移动端配置 【改】\nmsocial:\n  github: {url: http://github.com/honjun, fa: fa-github, color: 333}\n  weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39}\n  qq: {url: https://wpa.qq.com/msgrd?v=3&uin=954655431&site=qq&menu=yes, fa: fa-qq, color: 25c6fe}\n\n# 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】\ndonate:\n  alipay: /img/custom/donate/AliPayQR.jpg\n  wechat: /img/custom/donate/WeChanQR.jpg\n  wechatSQ: /img/custom/donate/WeChanSQ.jpg\n\n# 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】\nmovies:\n  url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2\n  # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用\n  name: Unbroken.mp4\n\n# 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】\naplayer: \n  id: 2660651585\n  server: netease\n  type: playlist\n  fixed: true\n  mini: false\n  autoplay: false\n  loop: all\n  order: random\n  preload: auto\n  volume: 0.7\n  mutex: true\n\n# Valine评论配置【改】\nvaline: true\nv_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz\nv_appKey: mgOpfzbkHYqU92CV4IDlAUHQ\n```\n\n## 分类页和标签页配置\n\n### 分类页\n![](https://ws3.sinaimg.cn/large/006bYVyvly1g07b0gucy9j31060jih76.jpg)\n### 标签页\n![](https://wx2.sinaimg.cn/large/006bYVyvly1g07azb2399j31040jgazs.jpg)\n\n配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。\n```yml\n#category\n# 按分类名创建\n技术:\n    #中文标题\n    zh: 野生技术协会 \n    # 英文标题\n    en: Geek – Only for Love\n    # 封面图片\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg\n生活:\n    zh: 生活\n    en: live\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg\n\n#tag\n# 标签名即是标题\n悦读:\n    # 封面图片\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg\n```\n\n## 单页面封面配置\n\n![](https://ws3.sinaimg.cn/large/006bYVyvly1g07b1pi619j31080jge4u.jpg)\n如留言板页面页面，位于source下的comment下，打开index.md如下：\n```md\n---\ntitle: comment\ndate: 2018-12-20 23:13:48\nkeywords: 留言板\ndescription: \ncomments: true\n# 在这里配置单页面头部图片，自定义替换哦~\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg\n---\n```\n\n\n## 单页面配置\n\n### 番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\n![](https://wx2.sinaimg.cn/large/006bYVyvly1g07b2gyx60j31090jjahj.jpg)\n\n```yml\n---\nlayout: bangumi\ntitle: bangumi\ncomments: false\ndate: 2019-02-10 21:32:48\nkeywords:\ndescription:\nbangumis:\n  # 番组图片\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n  # 番组名\n    title: 朝花夕誓——于离别之朝束起约定之花\n  # 追番状态 （追番ing/已追完）\n    status: 已追完\n  # 追番进度\n    progress: 100\n  # 番剧日文名称\n    jp: さよならの朝に約束の花をかざろう\n  # 放送时间\n    time: 放送时间: 2018-02-24 SUN.\n  # 番剧介绍\n    desc:  住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n    title: 朝花夕誓——于离别之朝束起约定之花\n    status: 已追完\n    progress: 50\n    jp: さよならの朝に約束の花をかざろう\n    time: 放送时间: 2018-02-24 SUN.\n    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n---\n```\n\n### 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\n![](https://ws3.sinaimg.cn/large/006bYVyvly1g07b39tleej31080jhjv1.jpg)\n\n```yml\n---\nlayout: links\ntitle: links\n# 创建日期，可以改下\ndate: 2018-12-19 23:11:06 \n# 图片上的标题，自定义修改\nkeywords: 友人帐 \ndescription: \n# true/false 开启/关闭评论\ncomments: true \n# 页面头部图片，自定义修改\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg \n# 友链配置\nlinks: \n  # 类型分组\n  - group: 个人项目\n    # 类型简介\n    desc: 充分说明这家伙是条咸鱼 < (￣︶￣)>\n    items:\n    # 友链链接\n    - url: https://shino.cc/fgvf\n    # 友链头像\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n    # 友链站点名\n      name: Google\n    # 友链介绍  下面雷同\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n  # 类型分组...\n  - group: 小伙伴们\n    desc: 欢迎交换友链 ꉂ(ˊᗜˋ)\n    items:\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n---\n```\n\n## 写文章配置\n\n主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下：\n```md\n{% bili video_id [page] %}\n```\n详细使用教程详见[hexo-tag-bili](https://github.com/honjun/hexo-tag-bili/blob/master/README-zh_cn.md)。\n\nhexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下：\n```md\n{% fb_img src [caption] %}\n```\n详细使用教程详见[hexo-tag-fancybox_img](https://github.com/honjun/hexo-tag-fancybox_img/blob/master/README-zh_cn.md)\n\n## 还有啥，一时想不起来......\n\nTo be continued...","source":"_posts/Hexo-Theme-Sakura.md","raw":"---\ntitle: Hexo-Theme-Sakura\nauthor: hojun\navatar: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg\nauthorLink: hojun.cn\nauthorAbout: 一个好奇的人\nauthorDesc: 一个好奇的人\ncategories: 技术\ndate: 2018-12-12 22:16:01\ncomments: true\ntags: \n - web\n - 悦读\nkeywords: Sakura\ndescription: hexo-sakura主题使用教程\n# photos: https://static.2heng.xin/wp-content/uploads//2019/02/wallhaven-672007-1-1024x576.png\n---\nhexo-theme-sakura主题 [English document](https://github.com/honjun/hexo-theme-sakura/blob/master/README.md)\n\n基于WordPress主题[Sakura](https://github.com/mashirozx/Sakura/)修改成Hexo的主题。\n\n[demo预览](https://sakura.hojun.cn)\n\n正在开发中......\n\n![](https://wx3.sinaimg.cn/large/006bYVyvly1g069tuf42oj312w0m8ndq.jpg)\n\n## 交流群\n若你是使用者，加群QQ: 801511924\n\n若你是创作者，加群QQ: 194472590\n\n\n## 主题特性\n\n - 首页大屏视频\n - 首页随机封面\n - 图片懒加载\n - valine评论\n - fancy-box相册\n - pjax支持，音乐不间断\n - aplayer音乐播放器\n - 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了）\n\n\n## 赞赏作者\n如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！\n\n[paypal](https://www.paypal.me/hojuncn) | [Alipay 支付宝](https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/AliPayQR.jpg) | [WeChat Pay 微信支付](https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanSQ.jpg)\n\n## 未完善的使用教程\n\n那啥？老实说我目前也不是很有条理233333333~\n\n## 1、主题下载安装\n\n[hexo-theme-sakura](https://github.com/honjun/hexo-theme-sakura)建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。\n\n下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行`npm i`安装依赖。\n\n## 2、主题配置\n\n### 博客根目录下的_config配置\n\n站点\n```yml\n# Site\ntitle: 你的站点名\nsubtitle:\ndescription: 站点简介\nkeywords:\nauthor: 作者名\nlanguage: zh-cn\ntimezone:\n```\n\n部署\n```yml\ndeploy:\n  type: git\n  repo: \n    github: 你的github仓库地址\n    # coding: 你的coding仓库地址\n  branch: master\n```\n\n备份 （使用hexo b发布备份到远程仓库）\n```yml\nbackup:\n  type: git\n  message: backup my blog of https://honjun.github.io/\n  repository:\n    # 你的github仓库地址,备份分支名  （建议新建backup分支）\n    github: https://github.com/honjun/honjun.github.io.git,backup\n    # coding: https://git.coding.net/hojun/hojun.git,backup\n\n```\n\n### 主题目录下的_config配置\n\n其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分\n```yml\n# site name\n# 站点名 【改】\nprefixName: さくら荘その\nsiteName: hojun\n\n# favicon and site master avatar\n# 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】\nfavicon: /images/favicon.ico\navatar: /img/custom/avatar.jpg\n\n# 站点url 【改】\nurl: https://sakura.hojun.cn\n\n# 站点介绍（或者说是个人签名）【改】\ndescription: Live your life with passion! With some drive!\n\n# 站点cdn，没有就为空 【改】  若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg\ncdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6\n\n# 开启pjax 【选】\npjax: 1\n\n# 站点首页的公告信息 【改】\nnotice: hexo-Sakura主题已经开源，目前正在开发中...\n\n# 懒加载的加载中图片 【选】\nlazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg\n\n# 站点菜单配置 【选】\nmenus:\n  首页: { path: /, fa: fa-fort-awesome faa-shake }\n  归档: { path: /archives, fa: fa-archive faa-shake, submenus: { \n    技术: {path: /categories/技术/, fa: fa-code }, \n    生活: {path: /categories/生活/, fa: fa-file-text-o }, \n    资源: {path: /categories/资源/, fa: fa-cloud-download }, \n    随想: {path: /categories/随想/, fa: fa-commenting-o },\n    转载: {path: /categories/转载/, fa: fa-book }\n  } }\n  清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { \n    书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, \n    番组: {path: /bangumi/, fa: fa-film faa-vertical }, \n    歌单: {path: /music/, fa: fa-headphones },\n    图集: {path: /tags/图集/, fa: fa-photo }\n  } }\n  留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada }\n  友人帐: { path: /links/, fa: fa-link faa-shake }\n  赞赏: { path: /donate/, fa: fa-heart faa-pulse }\n  关于: { path: /, fa: fa-leaf faa-wrench , submenus: { \n    我？: {path: /about/, fa: fa-meetup}, \n    主题: {path: /theme-sakura/, fa: iconfont icon-sakura },\n    Lab: {path: /lab/, fa: fa-cogs },\n  } }\n  客户端: { path: /client/, fa: fa-android faa-vertical }\n  RSS: { path: /atom.xml, fa: fa-rss faa-pulse }\n\n# Home page sort type: -1: newer first，1: older first. 【非】\nhomePageSortType: -1\n\n# Home page article shown number) 【非】\nhomeArticleShown: 10\n\n# 背景图片 【选】\nbgn: 8\n\n# startdash面板 url, title, desc img 【改】\nstartdash: \n  - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png}\n  - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg}\n  - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg}\n\n\n# your site build time or founded date\n# 你的站点建立日期 【改】\nsiteBuildingTime: 07/17/2018\n\n\n# 社交按钮(social)  url, img PC端配置 【改】\nsocial:\n  github: {url: http://github.com/honjun, img: /img/social/github.png}\n  sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png}\n  wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png}\n  zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png}\n  email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg}\n  wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png}\n\n# 社交按钮(msocial)  url, img 移动端配置 【改】\nmsocial:\n  github: {url: http://github.com/honjun, fa: fa-github, color: 333}\n  weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39}\n  qq: {url: https://wpa.qq.com/msgrd?v=3&uin=954655431&site=qq&menu=yes, fa: fa-qq, color: 25c6fe}\n\n# 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】\ndonate:\n  alipay: /img/custom/donate/AliPayQR.jpg\n  wechat: /img/custom/donate/WeChanQR.jpg\n  wechatSQ: /img/custom/donate/WeChanSQ.jpg\n\n# 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】\nmovies:\n  url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2\n  # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用\n  name: Unbroken.mp4\n\n# 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】\naplayer: \n  id: 2660651585\n  server: netease\n  type: playlist\n  fixed: true\n  mini: false\n  autoplay: false\n  loop: all\n  order: random\n  preload: auto\n  volume: 0.7\n  mutex: true\n\n# Valine评论配置【改】\nvaline: true\nv_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz\nv_appKey: mgOpfzbkHYqU92CV4IDlAUHQ\n```\n\n## 分类页和标签页配置\n\n### 分类页\n![](https://ws3.sinaimg.cn/large/006bYVyvly1g07b0gucy9j31060jih76.jpg)\n### 标签页\n![](https://wx2.sinaimg.cn/large/006bYVyvly1g07azb2399j31040jgazs.jpg)\n\n配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。\n```yml\n#category\n# 按分类名创建\n技术:\n    #中文标题\n    zh: 野生技术协会 \n    # 英文标题\n    en: Geek – Only for Love\n    # 封面图片\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg\n生活:\n    zh: 生活\n    en: live\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg\n\n#tag\n# 标签名即是标题\n悦读:\n    # 封面图片\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg\n```\n\n## 单页面封面配置\n\n![](https://ws3.sinaimg.cn/large/006bYVyvly1g07b1pi619j31080jge4u.jpg)\n如留言板页面页面，位于source下的comment下，打开index.md如下：\n```md\n---\ntitle: comment\ndate: 2018-12-20 23:13:48\nkeywords: 留言板\ndescription: \ncomments: true\n# 在这里配置单页面头部图片，自定义替换哦~\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg\n---\n```\n\n\n## 单页面配置\n\n### 番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\n![](https://wx2.sinaimg.cn/large/006bYVyvly1g07b2gyx60j31090jjahj.jpg)\n\n```yml\n---\nlayout: bangumi\ntitle: bangumi\ncomments: false\ndate: 2019-02-10 21:32:48\nkeywords:\ndescription:\nbangumis:\n  # 番组图片\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n  # 番组名\n    title: 朝花夕誓——于离别之朝束起约定之花\n  # 追番状态 （追番ing/已追完）\n    status: 已追完\n  # 追番进度\n    progress: 100\n  # 番剧日文名称\n    jp: さよならの朝に約束の花をかざろう\n  # 放送时间\n    time: 放送时间: 2018-02-24 SUN.\n  # 番剧介绍\n    desc:  住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n    title: 朝花夕誓——于离别之朝束起约定之花\n    status: 已追完\n    progress: 50\n    jp: さよならの朝に約束の花をかざろう\n    time: 放送时间: 2018-02-24 SUN.\n    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n---\n```\n\n### 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\n![](https://ws3.sinaimg.cn/large/006bYVyvly1g07b39tleej31080jhjv1.jpg)\n\n```yml\n---\nlayout: links\ntitle: links\n# 创建日期，可以改下\ndate: 2018-12-19 23:11:06 \n# 图片上的标题，自定义修改\nkeywords: 友人帐 \ndescription: \n# true/false 开启/关闭评论\ncomments: true \n# 页面头部图片，自定义修改\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg \n# 友链配置\nlinks: \n  # 类型分组\n  - group: 个人项目\n    # 类型简介\n    desc: 充分说明这家伙是条咸鱼 < (￣︶￣)>\n    items:\n    # 友链链接\n    - url: https://shino.cc/fgvf\n    # 友链头像\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n    # 友链站点名\n      name: Google\n    # 友链介绍  下面雷同\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n  # 类型分组...\n  - group: 小伙伴们\n    desc: 欢迎交换友链 ꉂ(ˊᗜˋ)\n    items:\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n---\n```\n\n## 写文章配置\n\n主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下：\n```md\n{% bili video_id [page] %}\n```\n详细使用教程详见[hexo-tag-bili](https://github.com/honjun/hexo-tag-bili/blob/master/README-zh_cn.md)。\n\nhexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下：\n```md\n{% fb_img src [caption] %}\n```\n详细使用教程详见[hexo-tag-fancybox_img](https://github.com/honjun/hexo-tag-fancybox_img/blob/master/README-zh_cn.md)\n\n## 还有啥，一时想不起来......\n\nTo be continued...","slug":"Hexo-Theme-Sakura","published":1,"updated":"2021-08-12T10:44:10.293Z","layout":"post","photos":[],"link":"","_id":"cku2cstpx000w4v9kbz3gu4u3","content":"<p>hexo-theme-sakura主题 <a href=\"https://github.com/honjun/hexo-theme-sakura/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">English document</a></p>\n<p>基于WordPress主题<a href=\"https://github.com/mashirozx/Sakura/\" target=\"_blank\" rel=\"noopener\">Sakura</a>修改成Hexo的主题。</p>\n<p><a href=\"https://sakura.hojun.cn\" target=\"_blank\" rel=\"noopener\">demo预览</a></p>\n<p>正在开发中......</p>\n<p><img src=\"https://wx3.sinaimg.cn/large/006bYVyvly1g069tuf42oj312w0m8ndq.jpg\" alt></p>\n<h2 id=\"交流群\"><a href=\"#交流群\" class=\"headerlink\" title=\"交流群\"></a>交流群</h2><p>若你是使用者，加群QQ: 801511924</p>\n<p>若你是创作者，加群QQ: 194472590</p>\n<h2 id=\"主题特性\"><a href=\"#主题特性\" class=\"headerlink\" title=\"主题特性\"></a>主题特性</h2><ul>\n<li>首页大屏视频</li>\n<li>首页随机封面</li>\n<li>图片懒加载</li>\n<li>valine评论</li>\n<li>fancy-box相册</li>\n<li>pjax支持，音乐不间断</li>\n<li>aplayer音乐播放器</li>\n<li>多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了）</li>\n</ul>\n<h2 id=\"赞赏作者\"><a href=\"#赞赏作者\" class=\"headerlink\" title=\"赞赏作者\"></a>赞赏作者</h2><p>如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！</p>\n<p><a href=\"https://www.paypal.me/hojuncn\" target=\"_blank\" rel=\"noopener\">paypal</a> | <a href=\"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/AliPayQR.jpg\" target=\"_blank\" rel=\"noopener\">Alipay 支付宝</a> | <a href=\"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanSQ.jpg\" target=\"_blank\" rel=\"noopener\">WeChat Pay 微信支付</a></p>\n<h2 id=\"未完善的使用教程\"><a href=\"#未完善的使用教程\" class=\"headerlink\" title=\"未完善的使用教程\"></a>未完善的使用教程</h2><p>那啥？老实说我目前也不是很有条理233333333~</p>\n<h2 id=\"1、主题下载安装\"><a href=\"#1、主题下载安装\" class=\"headerlink\" title=\"1、主题下载安装\"></a>1、主题下载安装</h2><p><a href=\"https://github.com/honjun/hexo-theme-sakura\" target=\"_blank\" rel=\"noopener\">hexo-theme-sakura</a>建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。</p>\n<p>下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行<code>npm i</code>安装依赖。</p>\n<h2 id=\"2、主题配置\"><a href=\"#2、主题配置\" class=\"headerlink\" title=\"2、主题配置\"></a>2、主题配置</h2><h3 id=\"博客根目录下的-config配置\"><a href=\"#博客根目录下的-config配置\" class=\"headerlink\" title=\"博客根目录下的_config配置\"></a>博客根目录下的_config配置</h3><p>站点</p>\n<pre><code class=\"yml\"># Site\ntitle: 你的站点名\nsubtitle:\ndescription: 站点简介\nkeywords:\nauthor: 作者名\nlanguage: zh-cn\ntimezone:\n</code></pre>\n<p>部署</p>\n<pre><code class=\"yml\">deploy:\n  type: git\n  repo: \n    github: 你的github仓库地址\n    # coding: 你的coding仓库地址\n  branch: master\n</code></pre>\n<p>备份 （使用hexo b发布备份到远程仓库）</p>\n<pre><code class=\"yml\">backup:\n  type: git\n  message: backup my blog of https://honjun.github.io/\n  repository:\n    # 你的github仓库地址,备份分支名  （建议新建backup分支）\n    github: https://github.com/honjun/honjun.github.io.git,backup\n    # coding: https://git.coding.net/hojun/hojun.git,backup\n\n</code></pre>\n<h3 id=\"主题目录下的-config配置\"><a href=\"#主题目录下的-config配置\" class=\"headerlink\" title=\"主题目录下的_config配置\"></a>主题目录下的_config配置</h3><p>其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分</p>\n<pre><code class=\"yml\"># site name\n# 站点名 【改】\nprefixName: さくら荘その\nsiteName: hojun\n\n# favicon and site master avatar\n# 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】\nfavicon: /images/favicon.ico\navatar: /img/custom/avatar.jpg\n\n# 站点url 【改】\nurl: https://sakura.hojun.cn\n\n# 站点介绍（或者说是个人签名）【改】\ndescription: Live your life with passion! With some drive!\n\n# 站点cdn，没有就为空 【改】  若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg\ncdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6\n\n# 开启pjax 【选】\npjax: 1\n\n# 站点首页的公告信息 【改】\nnotice: hexo-Sakura主题已经开源，目前正在开发中...\n\n# 懒加载的加载中图片 【选】\nlazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg\n\n# 站点菜单配置 【选】\nmenus:\n  首页: { path: /, fa: fa-fort-awesome faa-shake }\n  归档: { path: /archives, fa: fa-archive faa-shake, submenus: { \n    技术: {path: /categories/技术/, fa: fa-code }, \n    生活: {path: /categories/生活/, fa: fa-file-text-o }, \n    资源: {path: /categories/资源/, fa: fa-cloud-download }, \n    随想: {path: /categories/随想/, fa: fa-commenting-o },\n    转载: {path: /categories/转载/, fa: fa-book }\n  } }\n  清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { \n    书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, \n    番组: {path: /bangumi/, fa: fa-film faa-vertical }, \n    歌单: {path: /music/, fa: fa-headphones },\n    图集: {path: /tags/图集/, fa: fa-photo }\n  } }\n  留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada }\n  友人帐: { path: /links/, fa: fa-link faa-shake }\n  赞赏: { path: /donate/, fa: fa-heart faa-pulse }\n  关于: { path: /, fa: fa-leaf faa-wrench , submenus: { \n    我？: {path: /about/, fa: fa-meetup}, \n    主题: {path: /theme-sakura/, fa: iconfont icon-sakura },\n    Lab: {path: /lab/, fa: fa-cogs },\n  } }\n  客户端: { path: /client/, fa: fa-android faa-vertical }\n  RSS: { path: /atom.xml, fa: fa-rss faa-pulse }\n\n# Home page sort type: -1: newer first，1: older first. 【非】\nhomePageSortType: -1\n\n# Home page article shown number) 【非】\nhomeArticleShown: 10\n\n# 背景图片 【选】\nbgn: 8\n\n# startdash面板 url, title, desc img 【改】\nstartdash: \n  - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png}\n  - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg}\n  - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg}\n\n\n# your site build time or founded date\n# 你的站点建立日期 【改】\nsiteBuildingTime: 07/17/2018\n\n\n# 社交按钮(social)  url, img PC端配置 【改】\nsocial:\n  github: {url: http://github.com/honjun, img: /img/social/github.png}\n  sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png}\n  wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png}\n  zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png}\n  email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg}\n  wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png}\n\n# 社交按钮(msocial)  url, img 移动端配置 【改】\nmsocial:\n  github: {url: http://github.com/honjun, fa: fa-github, color: 333}\n  weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39}\n  qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe}\n\n# 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】\ndonate:\n  alipay: /img/custom/donate/AliPayQR.jpg\n  wechat: /img/custom/donate/WeChanQR.jpg\n  wechatSQ: /img/custom/donate/WeChanSQ.jpg\n\n# 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】\nmovies:\n  url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2\n  # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用\n  name: Unbroken.mp4\n\n# 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】\naplayer: \n  id: 2660651585\n  server: netease\n  type: playlist\n  fixed: true\n  mini: false\n  autoplay: false\n  loop: all\n  order: random\n  preload: auto\n  volume: 0.7\n  mutex: true\n\n# Valine评论配置【改】\nvaline: true\nv_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz\nv_appKey: mgOpfzbkHYqU92CV4IDlAUHQ\n</code></pre>\n<h2 id=\"分类页和标签页配置\"><a href=\"#分类页和标签页配置\" class=\"headerlink\" title=\"分类页和标签页配置\"></a>分类页和标签页配置</h2><h3 id=\"分类页\"><a href=\"#分类页\" class=\"headerlink\" title=\"分类页\"></a>分类页</h3><p><img src=\"https://ws3.sinaimg.cn/large/006bYVyvly1g07b0gucy9j31060jih76.jpg\" alt></p>\n<h3 id=\"标签页\"><a href=\"#标签页\" class=\"headerlink\" title=\"标签页\"></a>标签页</h3><p><img src=\"https://wx2.sinaimg.cn/large/006bYVyvly1g07azb2399j31040jgazs.jpg\" alt></p>\n<p>配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。</p>\n<pre><code class=\"yml\">#category\n# 按分类名创建\n技术:\n    #中文标题\n    zh: 野生技术协会 \n    # 英文标题\n    en: Geek – Only for Love\n    # 封面图片\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg\n生活:\n    zh: 生活\n    en: live\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg\n\n#tag\n# 标签名即是标题\n悦读:\n    # 封面图片\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg\n</code></pre>\n<h2 id=\"单页面封面配置\"><a href=\"#单页面封面配置\" class=\"headerlink\" title=\"单页面封面配置\"></a>单页面封面配置</h2><p><img src=\"https://ws3.sinaimg.cn/large/006bYVyvly1g07b1pi619j31080jge4u.jpg\" alt><br>如留言板页面页面，位于source下的comment下，打开index.md如下：</p>\n<pre><code class=\"md\">---\ntitle: comment\ndate: 2018-12-20 23:13:48\nkeywords: 留言板\ndescription: \ncomments: true\n# 在这里配置单页面头部图片，自定义替换哦~\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg\n---\n</code></pre>\n<h2 id=\"单页面配置\"><a href=\"#单页面配置\" class=\"headerlink\" title=\"单页面配置\"></a>单页面配置</h2><h3 id=\"番组计划页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\"><a href=\"#番组计划页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\" class=\"headerlink\" title=\"番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\"></a>番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）</h3><p><img src=\"https://wx2.sinaimg.cn/large/006bYVyvly1g07b2gyx60j31090jjahj.jpg\" alt></p>\n<pre><code class=\"yml\">---\nlayout: bangumi\ntitle: bangumi\ncomments: false\ndate: 2019-02-10 21:32:48\nkeywords:\ndescription:\nbangumis:\n  # 番组图片\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n  # 番组名\n    title: 朝花夕誓——于离别之朝束起约定之花\n  # 追番状态 （追番ing/已追完）\n    status: 已追完\n  # 追番进度\n    progress: 100\n  # 番剧日文名称\n    jp: さよならの朝に約束の花をかざろう\n  # 放送时间\n    time: 放送时间: 2018-02-24 SUN.\n  # 番剧介绍\n    desc:  住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n    title: 朝花夕誓——于离别之朝束起约定之花\n    status: 已追完\n    progress: 50\n    jp: さよならの朝に約束の花をかざろう\n    time: 放送时间: 2018-02-24 SUN.\n    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n---\n</code></pre>\n<h3 id=\"友链页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\"><a href=\"#友链页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\" class=\"headerlink\" title=\"友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\"></a>友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）</h3><p><img src=\"https://ws3.sinaimg.cn/large/006bYVyvly1g07b39tleej31080jhjv1.jpg\" alt></p>\n<pre><code class=\"yml\">---\nlayout: links\ntitle: links\n# 创建日期，可以改下\ndate: 2018-12-19 23:11:06 \n# 图片上的标题，自定义修改\nkeywords: 友人帐 \ndescription: \n# true/false 开启/关闭评论\ncomments: true \n# 页面头部图片，自定义修改\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg \n# 友链配置\nlinks: \n  # 类型分组\n  - group: 个人项目\n    # 类型简介\n    desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt;\n    items:\n    # 友链链接\n    - url: https://shino.cc/fgvf\n    # 友链头像\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n    # 友链站点名\n      name: Google\n    # 友链介绍  下面雷同\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n  # 类型分组...\n  - group: 小伙伴们\n    desc: 欢迎交换友链 ꉂ(ˊᗜˋ)\n    items:\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n---\n</code></pre>\n<h2 id=\"写文章配置\"><a href=\"#写文章配置\" class=\"headerlink\" title=\"写文章配置\"></a>写文章配置</h2><p>主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下：</p>\n<pre><code class=\"md\">{% bili video_id [page] %}\n</code></pre>\n<p>详细使用教程详见<a href=\"https://github.com/honjun/hexo-tag-bili/blob/master/README-zh_cn.md\" target=\"_blank\" rel=\"noopener\">hexo-tag-bili</a>。</p>\n<p>hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下：</p>\n<pre><code class=\"md\">{% fb_img src [caption] %}\n</code></pre>\n<p>详细使用教程详见<a href=\"https://github.com/honjun/hexo-tag-fancybox_img/blob/master/README-zh_cn.md\" target=\"_blank\" rel=\"noopener\">hexo-tag-fancybox_img</a></p>\n<h2 id=\"还有啥，一时想不起来\"><a href=\"#还有啥，一时想不起来\" class=\"headerlink\" title=\"还有啥，一时想不起来......\"></a>还有啥，一时想不起来......</h2><p>To be continued...</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hexo-theme-sakura主题 <a href=\"https://github.com/honjun/hexo-theme-sakura/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">English document</a></p>\n<p>基于WordPress主题<a href=\"https://github.com/mashirozx/Sakura/\" target=\"_blank\" rel=\"noopener\">Sakura</a>修改成Hexo的主题。</p>\n<p><a href=\"https://sakura.hojun.cn\" target=\"_blank\" rel=\"noopener\">demo预览</a></p>\n<p>正在开发中......</p>\n<p><img src=\"https://wx3.sinaimg.cn/large/006bYVyvly1g069tuf42oj312w0m8ndq.jpg\" alt></p>\n<h2 id=\"交流群\"><a href=\"#交流群\" class=\"headerlink\" title=\"交流群\"></a>交流群</h2><p>若你是使用者，加群QQ: 801511924</p>\n<p>若你是创作者，加群QQ: 194472590</p>\n<h2 id=\"主题特性\"><a href=\"#主题特性\" class=\"headerlink\" title=\"主题特性\"></a>主题特性</h2><ul>\n<li>首页大屏视频</li>\n<li>首页随机封面</li>\n<li>图片懒加载</li>\n<li>valine评论</li>\n<li>fancy-box相册</li>\n<li>pjax支持，音乐不间断</li>\n<li>aplayer音乐播放器</li>\n<li>多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了）</li>\n</ul>\n<h2 id=\"赞赏作者\"><a href=\"#赞赏作者\" class=\"headerlink\" title=\"赞赏作者\"></a>赞赏作者</h2><p>如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！</p>\n<p><a href=\"https://www.paypal.me/hojuncn\" target=\"_blank\" rel=\"noopener\">paypal</a> | <a href=\"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/AliPayQR.jpg\" target=\"_blank\" rel=\"noopener\">Alipay 支付宝</a> | <a href=\"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanSQ.jpg\" target=\"_blank\" rel=\"noopener\">WeChat Pay 微信支付</a></p>\n<h2 id=\"未完善的使用教程\"><a href=\"#未完善的使用教程\" class=\"headerlink\" title=\"未完善的使用教程\"></a>未完善的使用教程</h2><p>那啥？老实说我目前也不是很有条理233333333~</p>\n<h2 id=\"1、主题下载安装\"><a href=\"#1、主题下载安装\" class=\"headerlink\" title=\"1、主题下载安装\"></a>1、主题下载安装</h2><p><a href=\"https://github.com/honjun/hexo-theme-sakura\" target=\"_blank\" rel=\"noopener\">hexo-theme-sakura</a>建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。</p>\n<p>下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行<code>npm i</code>安装依赖。</p>\n<h2 id=\"2、主题配置\"><a href=\"#2、主题配置\" class=\"headerlink\" title=\"2、主题配置\"></a>2、主题配置</h2><h3 id=\"博客根目录下的-config配置\"><a href=\"#博客根目录下的-config配置\" class=\"headerlink\" title=\"博客根目录下的_config配置\"></a>博客根目录下的_config配置</h3><p>站点</p>\n<pre><code class=\"yml\"># Site\ntitle: 你的站点名\nsubtitle:\ndescription: 站点简介\nkeywords:\nauthor: 作者名\nlanguage: zh-cn\ntimezone:\n</code></pre>\n<p>部署</p>\n<pre><code class=\"yml\">deploy:\n  type: git\n  repo: \n    github: 你的github仓库地址\n    # coding: 你的coding仓库地址\n  branch: master\n</code></pre>\n<p>备份 （使用hexo b发布备份到远程仓库）</p>\n<pre><code class=\"yml\">backup:\n  type: git\n  message: backup my blog of https://honjun.github.io/\n  repository:\n    # 你的github仓库地址,备份分支名  （建议新建backup分支）\n    github: https://github.com/honjun/honjun.github.io.git,backup\n    # coding: https://git.coding.net/hojun/hojun.git,backup\n\n</code></pre>\n<h3 id=\"主题目录下的-config配置\"><a href=\"#主题目录下的-config配置\" class=\"headerlink\" title=\"主题目录下的_config配置\"></a>主题目录下的_config配置</h3><p>其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分</p>\n<pre><code class=\"yml\"># site name\n# 站点名 【改】\nprefixName: さくら荘その\nsiteName: hojun\n\n# favicon and site master avatar\n# 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】\nfavicon: /images/favicon.ico\navatar: /img/custom/avatar.jpg\n\n# 站点url 【改】\nurl: https://sakura.hojun.cn\n\n# 站点介绍（或者说是个人签名）【改】\ndescription: Live your life with passion! With some drive!\n\n# 站点cdn，没有就为空 【改】  若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg\ncdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6\n\n# 开启pjax 【选】\npjax: 1\n\n# 站点首页的公告信息 【改】\nnotice: hexo-Sakura主题已经开源，目前正在开发中...\n\n# 懒加载的加载中图片 【选】\nlazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg\n\n# 站点菜单配置 【选】\nmenus:\n  首页: { path: /, fa: fa-fort-awesome faa-shake }\n  归档: { path: /archives, fa: fa-archive faa-shake, submenus: { \n    技术: {path: /categories/技术/, fa: fa-code }, \n    生活: {path: /categories/生活/, fa: fa-file-text-o }, \n    资源: {path: /categories/资源/, fa: fa-cloud-download }, \n    随想: {path: /categories/随想/, fa: fa-commenting-o },\n    转载: {path: /categories/转载/, fa: fa-book }\n  } }\n  清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { \n    书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, \n    番组: {path: /bangumi/, fa: fa-film faa-vertical }, \n    歌单: {path: /music/, fa: fa-headphones },\n    图集: {path: /tags/图集/, fa: fa-photo }\n  } }\n  留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada }\n  友人帐: { path: /links/, fa: fa-link faa-shake }\n  赞赏: { path: /donate/, fa: fa-heart faa-pulse }\n  关于: { path: /, fa: fa-leaf faa-wrench , submenus: { \n    我？: {path: /about/, fa: fa-meetup}, \n    主题: {path: /theme-sakura/, fa: iconfont icon-sakura },\n    Lab: {path: /lab/, fa: fa-cogs },\n  } }\n  客户端: { path: /client/, fa: fa-android faa-vertical }\n  RSS: { path: /atom.xml, fa: fa-rss faa-pulse }\n\n# Home page sort type: -1: newer first，1: older first. 【非】\nhomePageSortType: -1\n\n# Home page article shown number) 【非】\nhomeArticleShown: 10\n\n# 背景图片 【选】\nbgn: 8\n\n# startdash面板 url, title, desc img 【改】\nstartdash: \n  - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png}\n  - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg}\n  - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg}\n\n\n# your site build time or founded date\n# 你的站点建立日期 【改】\nsiteBuildingTime: 07/17/2018\n\n\n# 社交按钮(social)  url, img PC端配置 【改】\nsocial:\n  github: {url: http://github.com/honjun, img: /img/social/github.png}\n  sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png}\n  wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png}\n  zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png}\n  email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg}\n  wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png}\n\n# 社交按钮(msocial)  url, img 移动端配置 【改】\nmsocial:\n  github: {url: http://github.com/honjun, fa: fa-github, color: 333}\n  weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39}\n  qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe}\n\n# 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】\ndonate:\n  alipay: /img/custom/donate/AliPayQR.jpg\n  wechat: /img/custom/donate/WeChanQR.jpg\n  wechatSQ: /img/custom/donate/WeChanSQ.jpg\n\n# 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】\nmovies:\n  url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2\n  # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用\n  name: Unbroken.mp4\n\n# 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】\naplayer: \n  id: 2660651585\n  server: netease\n  type: playlist\n  fixed: true\n  mini: false\n  autoplay: false\n  loop: all\n  order: random\n  preload: auto\n  volume: 0.7\n  mutex: true\n\n# Valine评论配置【改】\nvaline: true\nv_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz\nv_appKey: mgOpfzbkHYqU92CV4IDlAUHQ\n</code></pre>\n<h2 id=\"分类页和标签页配置\"><a href=\"#分类页和标签页配置\" class=\"headerlink\" title=\"分类页和标签页配置\"></a>分类页和标签页配置</h2><h3 id=\"分类页\"><a href=\"#分类页\" class=\"headerlink\" title=\"分类页\"></a>分类页</h3><p><img src=\"https://ws3.sinaimg.cn/large/006bYVyvly1g07b0gucy9j31060jih76.jpg\" alt></p>\n<h3 id=\"标签页\"><a href=\"#标签页\" class=\"headerlink\" title=\"标签页\"></a>标签页</h3><p><img src=\"https://wx2.sinaimg.cn/large/006bYVyvly1g07azb2399j31040jgazs.jpg\" alt></p>\n<p>配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。</p>\n<pre><code class=\"yml\">#category\n# 按分类名创建\n技术:\n    #中文标题\n    zh: 野生技术协会 \n    # 英文标题\n    en: Geek – Only for Love\n    # 封面图片\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg\n生活:\n    zh: 生活\n    en: live\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg\n\n#tag\n# 标签名即是标题\n悦读:\n    # 封面图片\n    img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg\n</code></pre>\n<h2 id=\"单页面封面配置\"><a href=\"#单页面封面配置\" class=\"headerlink\" title=\"单页面封面配置\"></a>单页面封面配置</h2><p><img src=\"https://ws3.sinaimg.cn/large/006bYVyvly1g07b1pi619j31080jge4u.jpg\" alt><br>如留言板页面页面，位于source下的comment下，打开index.md如下：</p>\n<pre><code class=\"md\">---\ntitle: comment\ndate: 2018-12-20 23:13:48\nkeywords: 留言板\ndescription: \ncomments: true\n# 在这里配置单页面头部图片，自定义替换哦~\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg\n---\n</code></pre>\n<h2 id=\"单页面配置\"><a href=\"#单页面配置\" class=\"headerlink\" title=\"单页面配置\"></a>单页面配置</h2><h3 id=\"番组计划页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\"><a href=\"#番组计划页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\" class=\"headerlink\" title=\"番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\"></a>番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）</h3><p><img src=\"https://wx2.sinaimg.cn/large/006bYVyvly1g07b2gyx60j31090jjahj.jpg\" alt></p>\n<pre><code class=\"yml\">---\nlayout: bangumi\ntitle: bangumi\ncomments: false\ndate: 2019-02-10 21:32:48\nkeywords:\ndescription:\nbangumis:\n  # 番组图片\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n  # 番组名\n    title: 朝花夕誓——于离别之朝束起约定之花\n  # 追番状态 （追番ing/已追完）\n    status: 已追完\n  # 追番进度\n    progress: 100\n  # 番剧日文名称\n    jp: さよならの朝に約束の花をかざろう\n  # 放送时间\n    time: 放送时间: 2018-02-24 SUN.\n  # 番剧介绍\n    desc:  住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n    title: 朝花夕誓——于离别之朝束起约定之花\n    status: 已追完\n    progress: 50\n    jp: さよならの朝に約束の花をかざろう\n    time: 放送时间: 2018-02-24 SUN.\n    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n---\n</code></pre>\n<h3 id=\"友链页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\"><a href=\"#友链页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\" class=\"headerlink\" title=\"友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）\"></a>友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）</h3><p><img src=\"https://ws3.sinaimg.cn/large/006bYVyvly1g07b39tleej31080jhjv1.jpg\" alt></p>\n<pre><code class=\"yml\">---\nlayout: links\ntitle: links\n# 创建日期，可以改下\ndate: 2018-12-19 23:11:06 \n# 图片上的标题，自定义修改\nkeywords: 友人帐 \ndescription: \n# true/false 开启/关闭评论\ncomments: true \n# 页面头部图片，自定义修改\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg \n# 友链配置\nlinks: \n  # 类型分组\n  - group: 个人项目\n    # 类型简介\n    desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt;\n    items:\n    # 友链链接\n    - url: https://shino.cc/fgvf\n    # 友链头像\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n    # 友链站点名\n      name: Google\n    # 友链介绍  下面雷同\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n  # 类型分组...\n  - group: 小伙伴们\n    desc: 欢迎交换友链 ꉂ(ˊᗜˋ)\n    items:\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n    - url: https://shino.cc/fgvf\n      img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n      name: Google\n      desc: Google 镜像\n---\n</code></pre>\n<h2 id=\"写文章配置\"><a href=\"#写文章配置\" class=\"headerlink\" title=\"写文章配置\"></a>写文章配置</h2><p>主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下：</p>\n<pre><code class=\"md\">{% bili video_id [page] %}\n</code></pre>\n<p>详细使用教程详见<a href=\"https://github.com/honjun/hexo-tag-bili/blob/master/README-zh_cn.md\" target=\"_blank\" rel=\"noopener\">hexo-tag-bili</a>。</p>\n<p>hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下：</p>\n<pre><code class=\"md\">{% fb_img src [caption] %}\n</code></pre>\n<p>详细使用教程详见<a href=\"https://github.com/honjun/hexo-tag-fancybox_img/blob/master/README-zh_cn.md\" target=\"_blank\" rel=\"noopener\">hexo-tag-fancybox_img</a></p>\n<h2 id=\"还有啥，一时想不起来\"><a href=\"#还有啥，一时想不起来\" class=\"headerlink\" title=\"还有啥，一时想不起来......\"></a>还有啥，一时想不起来......</h2><p>To be continued...</p>\n"},{"title":"授权认证","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-08-30T02:29:03.612Z","comments":1,"keywords":"授权认证","description":"授权认证","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/3.jpg"],"_content":"\n[原文](https://blog.csdn.net/huangpb123/article/details/103933400)\n\n\n\n# 一、先了解几个基础概念\n\n## 1.1 什么是认证（Authentication）\n\n通俗地讲就是验证当前用户的身份。\n\n\n\n互联网中的认证：\n\n- 用户名密码登录\n- 邮箱发送登录链接\n- 手机号接收验证码\n- 只要你能收到邮箱/验证码，就默认你是账号的主人\n\n\n\n## 1.2 什么是授权（Authorization）\n\n用户授予第三方应用访问该用户某些资源的权限。\n\n\n\n实现授权的方式有：cookie、session、token、OAuth。\n\n\n\n## 1.3 什么是凭证（Credentials）\n\n实现认证和授权的前提是需要一种媒介（证书）来标记访问者的身份。\n\n\n\n在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。\n\n\n\n# 二、Cookie\n\n[原文](https://blog.csdn.net/huangpb123/article/details/109107461)\n\n\n\n## 2.1 了解Cookie\n\n- Cookie最开始被设计出来是为了弥补HTTP在状态管理上的不足。HTTP协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种情况下，就产生了Cookie。\n- cookie存储在客户端：cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。因此，服务端脚本就可以读、写存储在客户端的cookie的值。\n- cookie是不可跨域的：每个cookie都会绑定单一的域名（绑定域名下的子域都是有效的），无法在别的域名下获取使用，**同域名不同端口也是允许共享使用的**。\n\n\n\n服务器向客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要向客户端发送的cookie，cookie格式如下：\n\n```js\nSet-Cookie: \"name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure\"\n```\n\n\n\n## 2.2 检测cookie是否启用\n\n有些用户为了避免隐私泄露会在它们的浏览器中禁用cookie。因此，在js代码使用cookie前，首先要确保cookie是启用的。可以用`navigator.cookieEnabled`属性来判断，如果值为true，则当前cookie是启用的；反之则是禁用的（但是，只具备“当前浏览器会话生命周期”的非持久化cookie仍然是启用的）。\n\n\n\n## 2.3 cookie属性：有效期和作用域\n\ncookie默认的有效期很短暂，它只能维持在Web浏览器的会话期间，一旦用户关闭浏览器，cookie保存的数据就丢失了。要注意的是，这与sessionStorage的有效期还是有区别的：cookie的作用域不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。如果想要延长cookie的有效期，可以通过设置max-age属性。一旦设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。\n\n和localStorage和sessionStorage类似，cookie的作用域是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性也是可配置的。默认情况下，cookie和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。比如，Web页面 http://www.example.com/catalog/index.html 页面创建了一个cookie，那么该cookie对 http://www.example.com/catalog/order.html 页面和 http://www.example.com/catalog/widgets/index.html 页面都是可见的，但它对 http://www.example.com/about.html 页面不可见。\n\ncookie的作用域默认由文档源限制。但是，有的大型网站想要子域之间能够互相共享cookie。比如，order.example.com 域下的服务器想要读取 catalog.example.com 域下设置的cookie值。可以将 catalog.example.com 域下的cookie的path属性设置成“/”，其domain属性设置成“.example.com”，那么该cookie就对所有 catalog.example.com，order.example.com 以及任何其他 example.com 域下的任何其他服务器都可见。如果没有为一个cookie设置域属性，那么domain属性的默认值是当前Web服务器的主机名。要注意的是，cookie的域只能设置为当前服务器的域。\n\n\n\n## 2.4 Cookie的重要属性\n\n| 属性       | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| name=value | 键值对，设置Cookie的名称及相对应的值，都必须是字符串类型（name不区分大小写）<br />- 如果值为Unicode字符，需要字符编码。<br />- 如果值为二进制数据，则需要使用BASE64编码。 |\n| domain     | 指定cookie所属域名，默认是当前域名                           |\n| path       | 指定cookie在哪个路径（路由）下生效，默认是'/'。<br />如果设置为`/abc`，则只有`/abc`下的路由可以访问到该cookie，如：`/abc/red`。 |\n| expires    | 过期时间（GMT时间格式），在设置的某个时间点后该cookie就会失效。<br />如果客户端和服务器时间不一致，使用expires就会存在偏差。<br />一般浏览器的cookie都是默认储存的，当关闭浏览器结束这个会话的时候，这个cookie也会被删除 |\n| max-age    | cookie有效期，单位秒。如果为正数，则该cookie在maxAge秒后失效。如果为负数，该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存cookie。如果为0，表示删除该cookie。默认为-1。<br />- 优先级高于expires |\n| HttpOnly   | 如果给某个cookie设置了httpOnly属性，则无法通过JS脚本读写该cookie的信息，但还是能通过Application中手动修改cookie，所以只是在一定程度上可以防止CSRF攻击，不是绝对的安全 |\n| secure     | 该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。<br />当secure值为true时，cookie在HTTP中是无效的。 |\n\ncookie集合中的每个cookie都拥有这些属性，而且每个cookie的这些属性都是独立分开的，各自控制各自的cookie。\n\n\n\n## 2.5 cookie的局限性\n\n### 2.5.1 每个域名下cookie个数限制\n\n- Chrome和Safari没有做硬件限制\n- Firefox最多50个cookie\n- IE7和之后的版本最多可以有50个cookie\n- IE6或更低版本最多20个cookie\n\nRFC 2965标准不允许浏览器保存超过300个cookie，为每个web服务器保存的cookie数不能超过20个（是对整个服务器而言，而不仅仅指服务器上的页面和站点），而且，每个cookie保存的数据不能超过4kb。实际上，现代浏览器允许cookie总数超过300个，但是部分浏览器对单个cookie大小仍有4kb的限制。\n\n\n\n## 2.6 客户端对cookie的存取\n\n### 2.6.1 读取cookie\n\n可以用`document.cookie`获取当前页面可用的cookie集合，其返回的值是一个字符串，该字符串都是由一系列键/值对组成，不同键/值对之间通过“分号和空格”分开。例如：\n\n```js\ndocument.cookie;\n// \"name1=value1; name2=value2\"\n```\n\n这些返回的cookie值并不包含键/值以外的其他cookie属性。\n\n\n\n### 2.6.2 设置cookie\n\n```js\ndocument.cookie = `name=${encodeURIComponent(name)}; max-age=1000;`;\n```\n\nname这个cookie会被添加到现有的cookie集合中。\n\n\n\n由于cookie的键/值中的值是不允许包含分号、逗号和空白符，因此，在存储前一般可以采用`encodeURIComponent()`函数对值进行编码。相应的，读取cookie值的时候要用`decodeURIComponent()`函数解码。\n\n\n\n### 2.6.3 更新cookie\n\n要改变cookie的值，需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样地，设置新`max-age`属性就可以改变原来的cookie的有效期。\n\n\n\n### 2.6.4 删除cookie\n\n要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意（非空）的值，并且将`max-age`属性指定为0，再次设置cookie。\n\n\n\n## 2.7 封装对cookie的操作\n\n由于cookie的读写非常不方便，我们可以自己封装一些函数来处理cookie。\n\n\n\n### 2.7.1 获取全部cookie，返回一个对象\n\n```js\nfunction getAllCookies() {\n  let cookies = {};\n  const all = document.cookie;\n  if (all) {\n    const list = all.split('; ');\n    list.forEach(cookie => {\n      const cookieArr = cookie.split('=');\n      const name = cookieArr[0];\n      cookies[name] = decodeURIComponent(cookieArr[1]);\n    });\n  }\n  return cookies;\n}\n```\n\n\n\n### 2.7.2 获取单个cookie，设置、删除cookie\n\n```js\nclass cookieUtils {\n  get(name) {\n    var arr,\n      reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n    if ((arr = document.cookie.match(reg))) return decodeURIComponent(arr[2]);\n    else return null;\n  }\n \n  set(name, value, daysToLive) {\n    let cookie = `${name}=${encodeURIComponent(value)}`;\n    // daysToLive指天数\n    if (typeof daysToLive === 'number') {\n      cookie += `; max-age=${daysToLive * 24 * 60 * 60}`;\n    }\n    document.cookie = cookie;\n  }\n \n  delete(name) {\n    var date = new Date();\n    date.setTime(date.getTime() - 10000);\n    document.cookie = name + \"=-1;expires=\" + date.toGMTString();\n  }\n}\n \nexport default new cookieUtils();\n```\n\n在Chrome控制台Application的Cookies里可以对cookie进行读写操作。\n\n**移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token**。\n\n\n\n## 2.8 服务器端设置cookie示例（Node）\n\n```js\nvar http = require('http');\nvar fs = require('fs');\n \nhttp.createServer(function(req, res) {\n    res.setHeader('status', '200 OK');\n    res.setHeader('Set-Cookie', 'isVisit=true;domain=.yourdomain.com;path=/;max-age=1000');\n    res.write('Hello World');\n    res.end();\n}).listen(8888);\n \nconsole.log('running localhost:8888')\n```\n\n![](https://img-blog.csdnimg.cn/20200111122509425.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n\n\n# 三、什么是Session\n\n- session是另一种记录服务器和客户端会话状态的机制\n\n- session是基于cookie实现的，session存储在服务器端，sessionid会被存储到客户端的cookie中\n\n  ![](https://img-blog.csdnimg.cn/20200111152258612.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n\n\n> session认证流程：\n\n- 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session\n- 请求返回时将此Session的唯一标识SessionID返回给浏览器\n- 浏览器接收到服务器返回的SessionID后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名\n- 当用户第二次访问服务器的时候，请求组会自动把此域名下的Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据SessionID查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。\n\n根据以上流程可知，**SessionID是连接Cookie和Session的一道桥梁**，大部分系统也是根据此原理来验证用户登录状态。\n\n\n\n# 四、Cookie和Session的区别\n\n- 安全性：Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的。\n- 存取值的类型不同：Cookie只支持存字符串数据，Session可以存任意数据类型。\n- 有效期不同：Cookie可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般失效时间较短，客户端关闭（默认情况下）或者Session超时都会失效。\n- 存储大小不同：单个Cookie保存的数据不能超过4k，Session可存储数据远高于Cookie，但是当访问量过多，会占用过多的服务器资源。\n\n\n\n# 五、什么是Token（令牌）\n\n## 5.1 Access Token\n\n- 访问资源接口（API）时所需要的资源凭证\n- 简单token的组成：uid（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串）\n\n## 5.2 服务器对token的存储方式\n\n1. 存到数据库中，每次客户端请求的时候取出来验证（服务端有状态）\n2. 存到redis中，设置过期时间，每次客户端请求的时候取出来验证（服务端有状态）\n3. 不存，每次客户端请求的时候根据之前的生成方法再生成一次来验证（JWT，服务端无状态）\n\n\n\n> 特点\n\n- 服务端无状态化、可扩展性好\n- 支持移动端设备\n- 安全\n- 支持跨程序调用\n\n\n\n> token的身份验证流程\n\n![token的身份验证流程](https://img-blog.csdnimg.cn/20200114175835320.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n1. 客户端使用用户名和密码请求登录\n2. 服务端收到请求，去验证用户名与密码\n3. 验证成功后，服务端会签发一个`token`并把这个`token`发送给客户端\n4. 客户端收到`token`以后，会把它存储起来，比如放在`cookie`里或者`localStorage`里\n5. 客户端每次向服务端请求资源的时候需要带着服务端签发的`token`\n6. 服务端收到请求，然后去验证客户端请求里面带着的`token`，如果验证成功，就向客户端返回请求的数据\n\n\n\n- 每一次请求都需要携带`token`，需要把`token`放到`HTTP`的`Header`里\n- token完全由应用管理，所以它可以避开同源策略\n\n\n\n> 注意：登录时token不宜保存在localStorage，被XSS攻击时容易泄露。所以比较好的方式是把token写在cookie里。为了保证XSS攻击时cookie不被获取，还要设置cookie的http-only。\n\n\n\n\n\n## 5.3 Refresh Token\n\n- 另外一种token——`refresh token`\n- `refresh token`是专门用于刷新`access token`的token。如果没有`refresh token`，也可以刷新`access token`，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了`refresh token`，可以减少这个麻烦，客户端直接用`refresh token`去更新`access token`，无需用户进行额外的操作。\n\n![refresh token](https://img-blog.csdnimg.cn/20200114182230452.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n\n\n- `Access Token`的有效期比较短，当`Access Token`由于过期而失效时，使用`Refresh Token`就可以获取到新的Token，如果`Refresh Token`也失效了，用户就只能重新登录了。\n- `Refresh Token`及过期时间是存储在服务器的数据库中，只有在申请新的`Access Token`时才会验证，不会对业务接口响应时间造成影响，也不需要像`Session`一样一直保持在内存中以应对大量的请求。\n\n\n\n# 六、Token和Session的区别\n\n- `Session`是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而`Token`是令牌，访问资源接口（API）时所需要的资源凭证。`Token`使服务端无状态化，不会存储会话信息。\n- `Session`和`Token`并不矛盾，作为身份认证`Token`安全性比`Session`好，因为每一个请求都有签名还能防止监听以及重复攻击，而`Session`就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加Session来在服务器端保存一些状态**。\n- 如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用`Token`。如果永远只是自己的网站，自己的App，用什么就无所谓了。\n\n\n\n# 七、什么是JWT\n\n- JSON Web Token（简称JWT）是目前最流行的跨域认证解决方案。\n- 是一种`认证授权机制`。\n- JWT是为了在网络应用环境间`传递声明`而执行的一种基于JSON的开放标准。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。\n- 可以使用HMAC算法或者是RSA的公/私秘钥对JWT进行签名。因为数字签名的存在，这些传递的信息是可信的。\n\n\n\n## 7.1 JWT的原理\n\nJWT的原理是，服务器认证以后，生成一个JSON对象，返回给用户，就像下面这样。\n\n```json\n{\n\t\"姓名\": \"张三\",\n    \"角色\": \"管理员\",\n    \"到期时间\": \"2018年7月1日0点0分\"\n}\n```\n\n以后，用户与服务端通信的时候，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。\n\n![JWT原理](https://img-blog.csdnimg.cn/20200114184248329.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n\n\n> JWT认证流程\n\n1. 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个JWT\n2. 客户端将token保存到本地（通常使用localStorage，也可以使用cookie）\n3. 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的Authorization字段中使用Bearer模式添加JWT，其内容看起来是下面这样\n\n```js\nAuthorization: Bearer <token>\n```\n\n4. 服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为\n5. 因为JWT是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要\n6. 因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域问题\n7. 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制\n\n## 7.2 JWT的数据结构\n\n实际的JWT大概就像下面这样：\n\n![jwt数据结构](https://img-blog.csdnimg.cn/20200114185248941.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n它是一个很长的字符串，中间用点(.)分割成三个部分。\n\n\n\nJWT的三个部分依次如下：\n\n- Header（头部）\n- Payload（负载）\n- Signature（签名）\n\n\n\n[JWT详细数据结构](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)\n\n\n\n## 7.3 生成JWT\n\n- https://jwt.io/\n- https://www.jsonwebtoken.io/\n\n\n\n# 八、Token和JWT的区别\n\n## 8.1 相同\n\n- 都是访问资源的令牌\n- 都可以记录用户的信息\n- 都是使服务端无状态化\n- 都是只有验证成功后，客户端才能访问服务端上受保护的资源\n\n\n\n## 8.2 区别\n\n- Token：服务端验证客户端发送过来的Token时，还需要查询数据库获取用户信息，然后验证Token是否有效。\n- JWT：将Token和Payload加密后存储于客户端，服务端只需要使用秘钥解密进行校验（校验也是JWT自己实现的）即可，不需要查询或者减少查询数据库，因为JWT自包含了用户信息和加密的数据。\n\n\n\n# 九、要注意的问题\n\n## 9.1 使用session时需要考虑的问题\n\n- 将session存储在服务器里面，当用户同时在线量比较多时，这些session会占据较多的内存，需要在服务器定期的去清理过期的session\n- 当网站采用**集群部署**的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建session的服务器，那么该服务器就无法拿到之前已经放入到session中的登录凭证之类的信息了。\n- 当多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理\n- **sessionid是存储在cookie中的，假如浏览器禁止cookie或不支持cookie怎么办？**一般会把sessinid跟在url参数后面即重写url，所以session不一定非得需要靠cookie实现\n- **移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token**\n\n\n\n## 9.2 使用JWT时需要考虑的问题\n\n- 因为JWT并不依赖Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域问题\n- JWT默认是不加密，但也是可以加密的。生成原始Token以后，可以用密钥再加密一次。\n- JWT不加密的情况下，不能将秘密数据写入JWT。\n- JWT不仅可以用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。\n- JWT最大的优势是服务器不再需要存储Session，使得服务器认证鉴权业务可以方便扩展。但这也是JWT最大的缺点：由于服务器不需要存储Session状态，因此使用过程中无法废弃某个Token或者更改Token的权限。也就是说一旦JWT签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。\n- JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些较重要的权限，使用时应该再次对用户进行认证。\n- JWT适合一次性的命令认证，颁发一个有效期极短的JWT，即使暴露了危险也很小，由于每次操作都会生成新的JWT，因此也没必要保存JWT，真正实现无状态。\n- 为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输。\n\n## 9.3 使用加密算法时需要考虑的问题\n\n- 绝不要以明文存储密码\n- **永远使用哈希算法来处理密码，绝不要使用Base64或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。**编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道，这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法，但是编码就存在解码，加密就存在解密。\n- 绝不要使用弱哈希或已被破解的哈希算法，像MD5或SHA1，只使用强密码哈希算法。\n- 绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要“忘记密码”的功能，可以随机生成一个新的**一次性**（这点很重要）密码，然后把这个密码发送给用户。\n\n\n\n## 9.4只要关闭浏览器 ，session 真的就消失了？\n\n不对。浏览器关闭时，是不会主动去通知服务器的。之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 sessionId，而关闭浏览器后这个 cookie 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 sessionId 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。\n恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。","source":"_posts/Authorized-authentication.md","raw":"---\ntitle: 授权认证\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 08：38：25\ncomments: true\ntags: \n - web\nkeywords: 授权认证\ndescription: 授权认证\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/3.jpg\n---\n\n[原文](https://blog.csdn.net/huangpb123/article/details/103933400)\n\n\n\n# 一、先了解几个基础概念\n\n## 1.1 什么是认证（Authentication）\n\n通俗地讲就是验证当前用户的身份。\n\n\n\n互联网中的认证：\n\n- 用户名密码登录\n- 邮箱发送登录链接\n- 手机号接收验证码\n- 只要你能收到邮箱/验证码，就默认你是账号的主人\n\n\n\n## 1.2 什么是授权（Authorization）\n\n用户授予第三方应用访问该用户某些资源的权限。\n\n\n\n实现授权的方式有：cookie、session、token、OAuth。\n\n\n\n## 1.3 什么是凭证（Credentials）\n\n实现认证和授权的前提是需要一种媒介（证书）来标记访问者的身份。\n\n\n\n在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。\n\n\n\n# 二、Cookie\n\n[原文](https://blog.csdn.net/huangpb123/article/details/109107461)\n\n\n\n## 2.1 了解Cookie\n\n- Cookie最开始被设计出来是为了弥补HTTP在状态管理上的不足。HTTP协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种情况下，就产生了Cookie。\n- cookie存储在客户端：cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。因此，服务端脚本就可以读、写存储在客户端的cookie的值。\n- cookie是不可跨域的：每个cookie都会绑定单一的域名（绑定域名下的子域都是有效的），无法在别的域名下获取使用，**同域名不同端口也是允许共享使用的**。\n\n\n\n服务器向客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要向客户端发送的cookie，cookie格式如下：\n\n```js\nSet-Cookie: \"name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure\"\n```\n\n\n\n## 2.2 检测cookie是否启用\n\n有些用户为了避免隐私泄露会在它们的浏览器中禁用cookie。因此，在js代码使用cookie前，首先要确保cookie是启用的。可以用`navigator.cookieEnabled`属性来判断，如果值为true，则当前cookie是启用的；反之则是禁用的（但是，只具备“当前浏览器会话生命周期”的非持久化cookie仍然是启用的）。\n\n\n\n## 2.3 cookie属性：有效期和作用域\n\ncookie默认的有效期很短暂，它只能维持在Web浏览器的会话期间，一旦用户关闭浏览器，cookie保存的数据就丢失了。要注意的是，这与sessionStorage的有效期还是有区别的：cookie的作用域不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。如果想要延长cookie的有效期，可以通过设置max-age属性。一旦设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。\n\n和localStorage和sessionStorage类似，cookie的作用域是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性也是可配置的。默认情况下，cookie和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。比如，Web页面 http://www.example.com/catalog/index.html 页面创建了一个cookie，那么该cookie对 http://www.example.com/catalog/order.html 页面和 http://www.example.com/catalog/widgets/index.html 页面都是可见的，但它对 http://www.example.com/about.html 页面不可见。\n\ncookie的作用域默认由文档源限制。但是，有的大型网站想要子域之间能够互相共享cookie。比如，order.example.com 域下的服务器想要读取 catalog.example.com 域下设置的cookie值。可以将 catalog.example.com 域下的cookie的path属性设置成“/”，其domain属性设置成“.example.com”，那么该cookie就对所有 catalog.example.com，order.example.com 以及任何其他 example.com 域下的任何其他服务器都可见。如果没有为一个cookie设置域属性，那么domain属性的默认值是当前Web服务器的主机名。要注意的是，cookie的域只能设置为当前服务器的域。\n\n\n\n## 2.4 Cookie的重要属性\n\n| 属性       | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| name=value | 键值对，设置Cookie的名称及相对应的值，都必须是字符串类型（name不区分大小写）<br />- 如果值为Unicode字符，需要字符编码。<br />- 如果值为二进制数据，则需要使用BASE64编码。 |\n| domain     | 指定cookie所属域名，默认是当前域名                           |\n| path       | 指定cookie在哪个路径（路由）下生效，默认是'/'。<br />如果设置为`/abc`，则只有`/abc`下的路由可以访问到该cookie，如：`/abc/red`。 |\n| expires    | 过期时间（GMT时间格式），在设置的某个时间点后该cookie就会失效。<br />如果客户端和服务器时间不一致，使用expires就会存在偏差。<br />一般浏览器的cookie都是默认储存的，当关闭浏览器结束这个会话的时候，这个cookie也会被删除 |\n| max-age    | cookie有效期，单位秒。如果为正数，则该cookie在maxAge秒后失效。如果为负数，该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存cookie。如果为0，表示删除该cookie。默认为-1。<br />- 优先级高于expires |\n| HttpOnly   | 如果给某个cookie设置了httpOnly属性，则无法通过JS脚本读写该cookie的信息，但还是能通过Application中手动修改cookie，所以只是在一定程度上可以防止CSRF攻击，不是绝对的安全 |\n| secure     | 该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。<br />当secure值为true时，cookie在HTTP中是无效的。 |\n\ncookie集合中的每个cookie都拥有这些属性，而且每个cookie的这些属性都是独立分开的，各自控制各自的cookie。\n\n\n\n## 2.5 cookie的局限性\n\n### 2.5.1 每个域名下cookie个数限制\n\n- Chrome和Safari没有做硬件限制\n- Firefox最多50个cookie\n- IE7和之后的版本最多可以有50个cookie\n- IE6或更低版本最多20个cookie\n\nRFC 2965标准不允许浏览器保存超过300个cookie，为每个web服务器保存的cookie数不能超过20个（是对整个服务器而言，而不仅仅指服务器上的页面和站点），而且，每个cookie保存的数据不能超过4kb。实际上，现代浏览器允许cookie总数超过300个，但是部分浏览器对单个cookie大小仍有4kb的限制。\n\n\n\n## 2.6 客户端对cookie的存取\n\n### 2.6.1 读取cookie\n\n可以用`document.cookie`获取当前页面可用的cookie集合，其返回的值是一个字符串，该字符串都是由一系列键/值对组成，不同键/值对之间通过“分号和空格”分开。例如：\n\n```js\ndocument.cookie;\n// \"name1=value1; name2=value2\"\n```\n\n这些返回的cookie值并不包含键/值以外的其他cookie属性。\n\n\n\n### 2.6.2 设置cookie\n\n```js\ndocument.cookie = `name=${encodeURIComponent(name)}; max-age=1000;`;\n```\n\nname这个cookie会被添加到现有的cookie集合中。\n\n\n\n由于cookie的键/值中的值是不允许包含分号、逗号和空白符，因此，在存储前一般可以采用`encodeURIComponent()`函数对值进行编码。相应的，读取cookie值的时候要用`decodeURIComponent()`函数解码。\n\n\n\n### 2.6.3 更新cookie\n\n要改变cookie的值，需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样地，设置新`max-age`属性就可以改变原来的cookie的有效期。\n\n\n\n### 2.6.4 删除cookie\n\n要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意（非空）的值，并且将`max-age`属性指定为0，再次设置cookie。\n\n\n\n## 2.7 封装对cookie的操作\n\n由于cookie的读写非常不方便，我们可以自己封装一些函数来处理cookie。\n\n\n\n### 2.7.1 获取全部cookie，返回一个对象\n\n```js\nfunction getAllCookies() {\n  let cookies = {};\n  const all = document.cookie;\n  if (all) {\n    const list = all.split('; ');\n    list.forEach(cookie => {\n      const cookieArr = cookie.split('=');\n      const name = cookieArr[0];\n      cookies[name] = decodeURIComponent(cookieArr[1]);\n    });\n  }\n  return cookies;\n}\n```\n\n\n\n### 2.7.2 获取单个cookie，设置、删除cookie\n\n```js\nclass cookieUtils {\n  get(name) {\n    var arr,\n      reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n    if ((arr = document.cookie.match(reg))) return decodeURIComponent(arr[2]);\n    else return null;\n  }\n \n  set(name, value, daysToLive) {\n    let cookie = `${name}=${encodeURIComponent(value)}`;\n    // daysToLive指天数\n    if (typeof daysToLive === 'number') {\n      cookie += `; max-age=${daysToLive * 24 * 60 * 60}`;\n    }\n    document.cookie = cookie;\n  }\n \n  delete(name) {\n    var date = new Date();\n    date.setTime(date.getTime() - 10000);\n    document.cookie = name + \"=-1;expires=\" + date.toGMTString();\n  }\n}\n \nexport default new cookieUtils();\n```\n\n在Chrome控制台Application的Cookies里可以对cookie进行读写操作。\n\n**移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token**。\n\n\n\n## 2.8 服务器端设置cookie示例（Node）\n\n```js\nvar http = require('http');\nvar fs = require('fs');\n \nhttp.createServer(function(req, res) {\n    res.setHeader('status', '200 OK');\n    res.setHeader('Set-Cookie', 'isVisit=true;domain=.yourdomain.com;path=/;max-age=1000');\n    res.write('Hello World');\n    res.end();\n}).listen(8888);\n \nconsole.log('running localhost:8888')\n```\n\n![](https://img-blog.csdnimg.cn/20200111122509425.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n\n\n# 三、什么是Session\n\n- session是另一种记录服务器和客户端会话状态的机制\n\n- session是基于cookie实现的，session存储在服务器端，sessionid会被存储到客户端的cookie中\n\n  ![](https://img-blog.csdnimg.cn/20200111152258612.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n\n\n> session认证流程：\n\n- 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session\n- 请求返回时将此Session的唯一标识SessionID返回给浏览器\n- 浏览器接收到服务器返回的SessionID后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名\n- 当用户第二次访问服务器的时候，请求组会自动把此域名下的Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据SessionID查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。\n\n根据以上流程可知，**SessionID是连接Cookie和Session的一道桥梁**，大部分系统也是根据此原理来验证用户登录状态。\n\n\n\n# 四、Cookie和Session的区别\n\n- 安全性：Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的。\n- 存取值的类型不同：Cookie只支持存字符串数据，Session可以存任意数据类型。\n- 有效期不同：Cookie可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般失效时间较短，客户端关闭（默认情况下）或者Session超时都会失效。\n- 存储大小不同：单个Cookie保存的数据不能超过4k，Session可存储数据远高于Cookie，但是当访问量过多，会占用过多的服务器资源。\n\n\n\n# 五、什么是Token（令牌）\n\n## 5.1 Access Token\n\n- 访问资源接口（API）时所需要的资源凭证\n- 简单token的组成：uid（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串）\n\n## 5.2 服务器对token的存储方式\n\n1. 存到数据库中，每次客户端请求的时候取出来验证（服务端有状态）\n2. 存到redis中，设置过期时间，每次客户端请求的时候取出来验证（服务端有状态）\n3. 不存，每次客户端请求的时候根据之前的生成方法再生成一次来验证（JWT，服务端无状态）\n\n\n\n> 特点\n\n- 服务端无状态化、可扩展性好\n- 支持移动端设备\n- 安全\n- 支持跨程序调用\n\n\n\n> token的身份验证流程\n\n![token的身份验证流程](https://img-blog.csdnimg.cn/20200114175835320.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n1. 客户端使用用户名和密码请求登录\n2. 服务端收到请求，去验证用户名与密码\n3. 验证成功后，服务端会签发一个`token`并把这个`token`发送给客户端\n4. 客户端收到`token`以后，会把它存储起来，比如放在`cookie`里或者`localStorage`里\n5. 客户端每次向服务端请求资源的时候需要带着服务端签发的`token`\n6. 服务端收到请求，然后去验证客户端请求里面带着的`token`，如果验证成功，就向客户端返回请求的数据\n\n\n\n- 每一次请求都需要携带`token`，需要把`token`放到`HTTP`的`Header`里\n- token完全由应用管理，所以它可以避开同源策略\n\n\n\n> 注意：登录时token不宜保存在localStorage，被XSS攻击时容易泄露。所以比较好的方式是把token写在cookie里。为了保证XSS攻击时cookie不被获取，还要设置cookie的http-only。\n\n\n\n\n\n## 5.3 Refresh Token\n\n- 另外一种token——`refresh token`\n- `refresh token`是专门用于刷新`access token`的token。如果没有`refresh token`，也可以刷新`access token`，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了`refresh token`，可以减少这个麻烦，客户端直接用`refresh token`去更新`access token`，无需用户进行额外的操作。\n\n![refresh token](https://img-blog.csdnimg.cn/20200114182230452.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n\n\n- `Access Token`的有效期比较短，当`Access Token`由于过期而失效时，使用`Refresh Token`就可以获取到新的Token，如果`Refresh Token`也失效了，用户就只能重新登录了。\n- `Refresh Token`及过期时间是存储在服务器的数据库中，只有在申请新的`Access Token`时才会验证，不会对业务接口响应时间造成影响，也不需要像`Session`一样一直保持在内存中以应对大量的请求。\n\n\n\n# 六、Token和Session的区别\n\n- `Session`是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而`Token`是令牌，访问资源接口（API）时所需要的资源凭证。`Token`使服务端无状态化，不会存储会话信息。\n- `Session`和`Token`并不矛盾，作为身份认证`Token`安全性比`Session`好，因为每一个请求都有签名还能防止监听以及重复攻击，而`Session`就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加Session来在服务器端保存一些状态**。\n- 如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用`Token`。如果永远只是自己的网站，自己的App，用什么就无所谓了。\n\n\n\n# 七、什么是JWT\n\n- JSON Web Token（简称JWT）是目前最流行的跨域认证解决方案。\n- 是一种`认证授权机制`。\n- JWT是为了在网络应用环境间`传递声明`而执行的一种基于JSON的开放标准。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。\n- 可以使用HMAC算法或者是RSA的公/私秘钥对JWT进行签名。因为数字签名的存在，这些传递的信息是可信的。\n\n\n\n## 7.1 JWT的原理\n\nJWT的原理是，服务器认证以后，生成一个JSON对象，返回给用户，就像下面这样。\n\n```json\n{\n\t\"姓名\": \"张三\",\n    \"角色\": \"管理员\",\n    \"到期时间\": \"2018年7月1日0点0分\"\n}\n```\n\n以后，用户与服务端通信的时候，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。\n\n![JWT原理](https://img-blog.csdnimg.cn/20200114184248329.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n\n\n> JWT认证流程\n\n1. 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个JWT\n2. 客户端将token保存到本地（通常使用localStorage，也可以使用cookie）\n3. 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的Authorization字段中使用Bearer模式添加JWT，其内容看起来是下面这样\n\n```js\nAuthorization: Bearer <token>\n```\n\n4. 服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为\n5. 因为JWT是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要\n6. 因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域问题\n7. 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制\n\n## 7.2 JWT的数据结构\n\n实际的JWT大概就像下面这样：\n\n![jwt数据结构](https://img-blog.csdnimg.cn/20200114185248941.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)\n\n它是一个很长的字符串，中间用点(.)分割成三个部分。\n\n\n\nJWT的三个部分依次如下：\n\n- Header（头部）\n- Payload（负载）\n- Signature（签名）\n\n\n\n[JWT详细数据结构](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)\n\n\n\n## 7.3 生成JWT\n\n- https://jwt.io/\n- https://www.jsonwebtoken.io/\n\n\n\n# 八、Token和JWT的区别\n\n## 8.1 相同\n\n- 都是访问资源的令牌\n- 都可以记录用户的信息\n- 都是使服务端无状态化\n- 都是只有验证成功后，客户端才能访问服务端上受保护的资源\n\n\n\n## 8.2 区别\n\n- Token：服务端验证客户端发送过来的Token时，还需要查询数据库获取用户信息，然后验证Token是否有效。\n- JWT：将Token和Payload加密后存储于客户端，服务端只需要使用秘钥解密进行校验（校验也是JWT自己实现的）即可，不需要查询或者减少查询数据库，因为JWT自包含了用户信息和加密的数据。\n\n\n\n# 九、要注意的问题\n\n## 9.1 使用session时需要考虑的问题\n\n- 将session存储在服务器里面，当用户同时在线量比较多时，这些session会占据较多的内存，需要在服务器定期的去清理过期的session\n- 当网站采用**集群部署**的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建session的服务器，那么该服务器就无法拿到之前已经放入到session中的登录凭证之类的信息了。\n- 当多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理\n- **sessionid是存储在cookie中的，假如浏览器禁止cookie或不支持cookie怎么办？**一般会把sessinid跟在url参数后面即重写url，所以session不一定非得需要靠cookie实现\n- **移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token**\n\n\n\n## 9.2 使用JWT时需要考虑的问题\n\n- 因为JWT并不依赖Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域问题\n- JWT默认是不加密，但也是可以加密的。生成原始Token以后，可以用密钥再加密一次。\n- JWT不加密的情况下，不能将秘密数据写入JWT。\n- JWT不仅可以用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。\n- JWT最大的优势是服务器不再需要存储Session，使得服务器认证鉴权业务可以方便扩展。但这也是JWT最大的缺点：由于服务器不需要存储Session状态，因此使用过程中无法废弃某个Token或者更改Token的权限。也就是说一旦JWT签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。\n- JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些较重要的权限，使用时应该再次对用户进行认证。\n- JWT适合一次性的命令认证，颁发一个有效期极短的JWT，即使暴露了危险也很小，由于每次操作都会生成新的JWT，因此也没必要保存JWT，真正实现无状态。\n- 为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输。\n\n## 9.3 使用加密算法时需要考虑的问题\n\n- 绝不要以明文存储密码\n- **永远使用哈希算法来处理密码，绝不要使用Base64或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。**编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道，这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法，但是编码就存在解码，加密就存在解密。\n- 绝不要使用弱哈希或已被破解的哈希算法，像MD5或SHA1，只使用强密码哈希算法。\n- 绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要“忘记密码”的功能，可以随机生成一个新的**一次性**（这点很重要）密码，然后把这个密码发送给用户。\n\n\n\n## 9.4只要关闭浏览器 ，session 真的就消失了？\n\n不对。浏览器关闭时，是不会主动去通知服务器的。之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 sessionId，而关闭浏览器后这个 cookie 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 sessionId 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。\n恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。","slug":"Authorized-authentication","published":1,"updated":"2021-08-30T02:30:17.059Z","layout":"post","link":"","_id":"cku2cstqi00114v9k1hyp65m5","content":"<p><a href=\"https://blog.csdn.net/huangpb123/article/details/103933400\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<h1 id=\"一、先了解几个基础概念\"><a href=\"#一、先了解几个基础概念\" class=\"headerlink\" title=\"一、先了解几个基础概念\"></a>一、先了解几个基础概念</h1><h2 id=\"1-1-什么是认证（Authentication）\"><a href=\"#1-1-什么是认证（Authentication）\" class=\"headerlink\" title=\"1.1 什么是认证（Authentication）\"></a>1.1 什么是认证（Authentication）</h2><p>通俗地讲就是验证当前用户的身份。</p>\n<p>互联网中的认证：</p>\n<ul>\n<li>用户名密码登录</li>\n<li>邮箱发送登录链接</li>\n<li>手机号接收验证码</li>\n<li>只要你能收到邮箱/验证码，就默认你是账号的主人</li>\n</ul>\n<h2 id=\"1-2-什么是授权（Authorization）\"><a href=\"#1-2-什么是授权（Authorization）\" class=\"headerlink\" title=\"1.2 什么是授权（Authorization）\"></a>1.2 什么是授权（Authorization）</h2><p>用户授予第三方应用访问该用户某些资源的权限。</p>\n<p>实现授权的方式有：cookie、session、token、OAuth。</p>\n<h2 id=\"1-3-什么是凭证（Credentials）\"><a href=\"#1-3-什么是凭证（Credentials）\" class=\"headerlink\" title=\"1.3 什么是凭证（Credentials）\"></a>1.3 什么是凭证（Credentials）</h2><p>实现认证和授权的前提是需要一种媒介（证书）来标记访问者的身份。</p>\n<p>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</p>\n<h1 id=\"二、Cookie\"><a href=\"#二、Cookie\" class=\"headerlink\" title=\"二、Cookie\"></a>二、Cookie</h1><p><a href=\"https://blog.csdn.net/huangpb123/article/details/109107461\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<h2 id=\"2-1-了解Cookie\"><a href=\"#2-1-了解Cookie\" class=\"headerlink\" title=\"2.1 了解Cookie\"></a>2.1 了解Cookie</h2><ul>\n<li>Cookie最开始被设计出来是为了弥补HTTP在状态管理上的不足。HTTP协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种情况下，就产生了Cookie。</li>\n<li>cookie存储在客户端：cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。因此，服务端脚本就可以读、写存储在客户端的cookie的值。</li>\n<li>cookie是不可跨域的：每个cookie都会绑定单一的域名（绑定域名下的子域都是有效的），无法在别的域名下获取使用，<strong>同域名不同端口也是允许共享使用的</strong>。</li>\n</ul>\n<p>服务器向客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要向客户端发送的cookie，cookie格式如下：</p>\n<pre><code class=\"js\">Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot;\n</code></pre>\n<h2 id=\"2-2-检测cookie是否启用\"><a href=\"#2-2-检测cookie是否启用\" class=\"headerlink\" title=\"2.2 检测cookie是否启用\"></a>2.2 检测cookie是否启用</h2><p>有些用户为了避免隐私泄露会在它们的浏览器中禁用cookie。因此，在js代码使用cookie前，首先要确保cookie是启用的。可以用<code>navigator.cookieEnabled</code>属性来判断，如果值为true，则当前cookie是启用的；反之则是禁用的（但是，只具备“当前浏览器会话生命周期”的非持久化cookie仍然是启用的）。</p>\n<h2 id=\"2-3-cookie属性：有效期和作用域\"><a href=\"#2-3-cookie属性：有效期和作用域\" class=\"headerlink\" title=\"2.3 cookie属性：有效期和作用域\"></a>2.3 cookie属性：有效期和作用域</h2><p>cookie默认的有效期很短暂，它只能维持在Web浏览器的会话期间，一旦用户关闭浏览器，cookie保存的数据就丢失了。要注意的是，这与sessionStorage的有效期还是有区别的：cookie的作用域不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。如果想要延长cookie的有效期，可以通过设置max-age属性。一旦设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。</p>\n<p>和localStorage和sessionStorage类似，cookie的作用域是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性也是可配置的。默认情况下，cookie和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。比如，Web页面 <a href=\"http://www.example.com/catalog/index.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/catalog/index.html</a> 页面创建了一个cookie，那么该cookie对 <a href=\"http://www.example.com/catalog/order.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/catalog/order.html</a> 页面和 <a href=\"http://www.example.com/catalog/widgets/index.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/catalog/widgets/index.html</a> 页面都是可见的，但它对 <a href=\"http://www.example.com/about.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/about.html</a> 页面不可见。</p>\n<p>cookie的作用域默认由文档源限制。但是，有的大型网站想要子域之间能够互相共享cookie。比如，order.example.com 域下的服务器想要读取 catalog.example.com 域下设置的cookie值。可以将 catalog.example.com 域下的cookie的path属性设置成“/”，其domain属性设置成“.example.com”，那么该cookie就对所有 catalog.example.com，order.example.com 以及任何其他 example.com 域下的任何其他服务器都可见。如果没有为一个cookie设置域属性，那么domain属性的默认值是当前Web服务器的主机名。要注意的是，cookie的域只能设置为当前服务器的域。</p>\n<h2 id=\"2-4-Cookie的重要属性\"><a href=\"#2-4-Cookie的重要属性\" class=\"headerlink\" title=\"2.4 Cookie的重要属性\"></a>2.4 Cookie的重要属性</h2><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name=value</td>\n<td>键值对，设置Cookie的名称及相对应的值，都必须是字符串类型（name不区分大小写）<br>- 如果值为Unicode字符，需要字符编码。<br>- 如果值为二进制数据，则需要使用BASE64编码。</td>\n</tr>\n<tr>\n<td>domain</td>\n<td>指定cookie所属域名，默认是当前域名</td>\n</tr>\n<tr>\n<td>path</td>\n<td>指定cookie在哪个路径（路由）下生效，默认是&#39;/&#39;。<br>如果设置为<code>/abc</code>，则只有<code>/abc</code>下的路由可以访问到该cookie，如：<code>/abc/red</code>。</td>\n</tr>\n<tr>\n<td>expires</td>\n<td>过期时间（GMT时间格式），在设置的某个时间点后该cookie就会失效。<br>如果客户端和服务器时间不一致，使用expires就会存在偏差。<br>一般浏览器的cookie都是默认储存的，当关闭浏览器结束这个会话的时候，这个cookie也会被删除</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td>cookie有效期，单位秒。如果为正数，则该cookie在maxAge秒后失效。如果为负数，该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存cookie。如果为0，表示删除该cookie。默认为-1。<br>- 优先级高于expires</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>如果给某个cookie设置了httpOnly属性，则无法通过JS脚本读写该cookie的信息，但还是能通过Application中手动修改cookie，所以只是在一定程度上可以防止CSRF攻击，不是绝对的安全</td>\n</tr>\n<tr>\n<td>secure</td>\n<td>该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。<br>当secure值为true时，cookie在HTTP中是无效的。</td>\n</tr>\n</tbody>\n</table>\n<p>cookie集合中的每个cookie都拥有这些属性，而且每个cookie的这些属性都是独立分开的，各自控制各自的cookie。</p>\n<h2 id=\"2-5-cookie的局限性\"><a href=\"#2-5-cookie的局限性\" class=\"headerlink\" title=\"2.5 cookie的局限性\"></a>2.5 cookie的局限性</h2><h3 id=\"2-5-1-每个域名下cookie个数限制\"><a href=\"#2-5-1-每个域名下cookie个数限制\" class=\"headerlink\" title=\"2.5.1 每个域名下cookie个数限制\"></a>2.5.1 每个域名下cookie个数限制</h3><ul>\n<li>Chrome和Safari没有做硬件限制</li>\n<li>Firefox最多50个cookie</li>\n<li>IE7和之后的版本最多可以有50个cookie</li>\n<li>IE6或更低版本最多20个cookie</li>\n</ul>\n<p>RFC 2965标准不允许浏览器保存超过300个cookie，为每个web服务器保存的cookie数不能超过20个（是对整个服务器而言，而不仅仅指服务器上的页面和站点），而且，每个cookie保存的数据不能超过4kb。实际上，现代浏览器允许cookie总数超过300个，但是部分浏览器对单个cookie大小仍有4kb的限制。</p>\n<h2 id=\"2-6-客户端对cookie的存取\"><a href=\"#2-6-客户端对cookie的存取\" class=\"headerlink\" title=\"2.6 客户端对cookie的存取\"></a>2.6 客户端对cookie的存取</h2><h3 id=\"2-6-1-读取cookie\"><a href=\"#2-6-1-读取cookie\" class=\"headerlink\" title=\"2.6.1 读取cookie\"></a>2.6.1 读取cookie</h3><p>可以用<code>document.cookie</code>获取当前页面可用的cookie集合，其返回的值是一个字符串，该字符串都是由一系列键/值对组成，不同键/值对之间通过“分号和空格”分开。例如：</p>\n<pre><code class=\"js\">document.cookie;\n// &quot;name1=value1; name2=value2&quot;\n</code></pre>\n<p>这些返回的cookie值并不包含键/值以外的其他cookie属性。</p>\n<h3 id=\"2-6-2-设置cookie\"><a href=\"#2-6-2-设置cookie\" class=\"headerlink\" title=\"2.6.2 设置cookie\"></a>2.6.2 设置cookie</h3><pre><code class=\"js\">document.cookie = `name=${encodeURIComponent(name)}; max-age=1000;`;\n</code></pre>\n<p>name这个cookie会被添加到现有的cookie集合中。</p>\n<p>由于cookie的键/值中的值是不允许包含分号、逗号和空白符，因此，在存储前一般可以采用<code>encodeURIComponent()</code>函数对值进行编码。相应的，读取cookie值的时候要用<code>decodeURIComponent()</code>函数解码。</p>\n<h3 id=\"2-6-3-更新cookie\"><a href=\"#2-6-3-更新cookie\" class=\"headerlink\" title=\"2.6.3 更新cookie\"></a>2.6.3 更新cookie</h3><p>要改变cookie的值，需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样地，设置新<code>max-age</code>属性就可以改变原来的cookie的有效期。</p>\n<h3 id=\"2-6-4-删除cookie\"><a href=\"#2-6-4-删除cookie\" class=\"headerlink\" title=\"2.6.4 删除cookie\"></a>2.6.4 删除cookie</h3><p>要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意（非空）的值，并且将<code>max-age</code>属性指定为0，再次设置cookie。</p>\n<h2 id=\"2-7-封装对cookie的操作\"><a href=\"#2-7-封装对cookie的操作\" class=\"headerlink\" title=\"2.7 封装对cookie的操作\"></a>2.7 封装对cookie的操作</h2><p>由于cookie的读写非常不方便，我们可以自己封装一些函数来处理cookie。</p>\n<h3 id=\"2-7-1-获取全部cookie，返回一个对象\"><a href=\"#2-7-1-获取全部cookie，返回一个对象\" class=\"headerlink\" title=\"2.7.1 获取全部cookie，返回一个对象\"></a>2.7.1 获取全部cookie，返回一个对象</h3><pre><code class=\"js\">function getAllCookies() {\n  let cookies = {};\n  const all = document.cookie;\n  if (all) {\n    const list = all.split(&#39;; &#39;);\n    list.forEach(cookie =&gt; {\n      const cookieArr = cookie.split(&#39;=&#39;);\n      const name = cookieArr[0];\n      cookies[name] = decodeURIComponent(cookieArr[1]);\n    });\n  }\n  return cookies;\n}\n</code></pre>\n<h3 id=\"2-7-2-获取单个cookie，设置、删除cookie\"><a href=\"#2-7-2-获取单个cookie，设置、删除cookie\" class=\"headerlink\" title=\"2.7.2 获取单个cookie，设置、删除cookie\"></a>2.7.2 获取单个cookie，设置、删除cookie</h3><pre><code class=\"js\">class cookieUtils {\n  get(name) {\n    var arr,\n      reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;);\n    if ((arr = document.cookie.match(reg))) return decodeURIComponent(arr[2]);\n    else return null;\n  }\n\n  set(name, value, daysToLive) {\n    let cookie = `${name}=${encodeURIComponent(value)}`;\n    // daysToLive指天数\n    if (typeof daysToLive === &#39;number&#39;) {\n      cookie += `; max-age=${daysToLive * 24 * 60 * 60}`;\n    }\n    document.cookie = cookie;\n  }\n\n  delete(name) {\n    var date = new Date();\n    date.setTime(date.getTime() - 10000);\n    document.cookie = name + &quot;=-1;expires=&quot; + date.toGMTString();\n  }\n}\n\nexport default new cookieUtils();\n</code></pre>\n<p>在Chrome控制台Application的Cookies里可以对cookie进行读写操作。</p>\n<p><strong>移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token</strong>。</p>\n<h2 id=\"2-8-服务器端设置cookie示例（Node）\"><a href=\"#2-8-服务器端设置cookie示例（Node）\" class=\"headerlink\" title=\"2.8 服务器端设置cookie示例（Node）\"></a>2.8 服务器端设置cookie示例（Node）</h2><pre><code class=\"js\">var http = require(&#39;http&#39;);\nvar fs = require(&#39;fs&#39;);\n\nhttp.createServer(function(req, res) {\n    res.setHeader(&#39;status&#39;, &#39;200 OK&#39;);\n    res.setHeader(&#39;Set-Cookie&#39;, &#39;isVisit=true;domain=.yourdomain.com;path=/;max-age=1000&#39;);\n    res.write(&#39;Hello World&#39;);\n    res.end();\n}).listen(8888);\n\nconsole.log(&#39;running localhost:8888&#39;)\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200111122509425.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt></p>\n<h1 id=\"三、什么是Session\"><a href=\"#三、什么是Session\" class=\"headerlink\" title=\"三、什么是Session\"></a>三、什么是Session</h1><ul>\n<li><p>session是另一种记录服务器和客户端会话状态的机制</p>\n</li>\n<li><p>session是基于cookie实现的，session存储在服务器端，sessionid会被存储到客户端的cookie中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200111152258612.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt></p>\n</li>\n</ul>\n<blockquote>\n<p>session认证流程：</p>\n</blockquote>\n<ul>\n<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session</li>\n<li>请求返回时将此Session的唯一标识SessionID返回给浏览器</li>\n<li>浏览器接收到服务器返回的SessionID后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名</li>\n<li>当用户第二次访问服务器的时候，请求组会自动把此域名下的Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据SessionID查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。</li>\n</ul>\n<p>根据以上流程可知，<strong>SessionID是连接Cookie和Session的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p>\n<h1 id=\"四、Cookie和Session的区别\"><a href=\"#四、Cookie和Session的区别\" class=\"headerlink\" title=\"四、Cookie和Session的区别\"></a>四、Cookie和Session的区别</h1><ul>\n<li>安全性：Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的。</li>\n<li>存取值的类型不同：Cookie只支持存字符串数据，Session可以存任意数据类型。</li>\n<li>有效期不同：Cookie可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般失效时间较短，客户端关闭（默认情况下）或者Session超时都会失效。</li>\n<li>存储大小不同：单个Cookie保存的数据不能超过4k，Session可存储数据远高于Cookie，但是当访问量过多，会占用过多的服务器资源。</li>\n</ul>\n<h1 id=\"五、什么是Token（令牌）\"><a href=\"#五、什么是Token（令牌）\" class=\"headerlink\" title=\"五、什么是Token（令牌）\"></a>五、什么是Token（令牌）</h1><h2 id=\"5-1-Access-Token\"><a href=\"#5-1-Access-Token\" class=\"headerlink\" title=\"5.1 Access Token\"></a>5.1 Access Token</h2><ul>\n<li>访问资源接口（API）时所需要的资源凭证</li>\n<li>简单token的组成：uid（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li>\n</ul>\n<h2 id=\"5-2-服务器对token的存储方式\"><a href=\"#5-2-服务器对token的存储方式\" class=\"headerlink\" title=\"5.2 服务器对token的存储方式\"></a>5.2 服务器对token的存储方式</h2><ol>\n<li>存到数据库中，每次客户端请求的时候取出来验证（服务端有状态）</li>\n<li>存到redis中，设置过期时间，每次客户端请求的时候取出来验证（服务端有状态）</li>\n<li>不存，每次客户端请求的时候根据之前的生成方法再生成一次来验证（JWT，服务端无状态）</li>\n</ol>\n<blockquote>\n<p>特点</p>\n</blockquote>\n<ul>\n<li>服务端无状态化、可扩展性好</li>\n<li>支持移动端设备</li>\n<li>安全</li>\n<li>支持跨程序调用</li>\n</ul>\n<blockquote>\n<p>token的身份验证流程</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20200114175835320.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt=\"token的身份验证流程\"></p>\n<ol>\n<li>客户端使用用户名和密码请求登录</li>\n<li>服务端收到请求，去验证用户名与密码</li>\n<li>验证成功后，服务端会签发一个<code>token</code>并把这个<code>token</code>发送给客户端</li>\n<li>客户端收到<code>token</code>以后，会把它存储起来，比如放在<code>cookie</code>里或者<code>localStorage</code>里</li>\n<li>客户端每次向服务端请求资源的时候需要带着服务端签发的<code>token</code></li>\n<li>服务端收到请求，然后去验证客户端请求里面带着的<code>token</code>，如果验证成功，就向客户端返回请求的数据</li>\n</ol>\n<ul>\n<li>每一次请求都需要携带<code>token</code>，需要把<code>token</code>放到<code>HTTP</code>的<code>Header</code>里</li>\n<li>token完全由应用管理，所以它可以避开同源策略</li>\n</ul>\n<blockquote>\n<p>注意：登录时token不宜保存在localStorage，被XSS攻击时容易泄露。所以比较好的方式是把token写在cookie里。为了保证XSS攻击时cookie不被获取，还要设置cookie的http-only。</p>\n</blockquote>\n<h2 id=\"5-3-Refresh-Token\"><a href=\"#5-3-Refresh-Token\" class=\"headerlink\" title=\"5.3 Refresh Token\"></a>5.3 Refresh Token</h2><ul>\n<li>另外一种token——<code>refresh token</code></li>\n<li><code>refresh token</code>是专门用于刷新<code>access token</code>的token。如果没有<code>refresh token</code>，也可以刷新<code>access token</code>，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了<code>refresh token</code>，可以减少这个麻烦，客户端直接用<code>refresh token</code>去更新<code>access token</code>，无需用户进行额外的操作。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20200114182230452.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt=\"refresh token\"></p>\n<ul>\n<li><code>Access Token</code>的有效期比较短，当<code>Access Token</code>由于过期而失效时，使用<code>Refresh Token</code>就可以获取到新的Token，如果<code>Refresh Token</code>也失效了，用户就只能重新登录了。</li>\n<li><code>Refresh Token</code>及过期时间是存储在服务器的数据库中，只有在申请新的<code>Access Token</code>时才会验证，不会对业务接口响应时间造成影响，也不需要像<code>Session</code>一样一直保持在内存中以应对大量的请求。</li>\n</ul>\n<h1 id=\"六、Token和Session的区别\"><a href=\"#六、Token和Session的区别\" class=\"headerlink\" title=\"六、Token和Session的区别\"></a>六、Token和Session的区别</h1><ul>\n<li><code>Session</code>是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而<code>Token</code>是令牌，访问资源接口（API）时所需要的资源凭证。<code>Token</code>使服务端无状态化，不会存储会话信息。</li>\n<li><code>Session</code>和<code>Token</code>并不矛盾，作为身份认证<code>Token</code>安全性比<code>Session</code>好，因为每一个请求都有签名还能防止监听以及重复攻击，而<code>Session</code>就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加Session来在服务器端保存一些状态</strong>。</li>\n<li>如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用<code>Token</code>。如果永远只是自己的网站，自己的App，用什么就无所谓了。</li>\n</ul>\n<h1 id=\"七、什么是JWT\"><a href=\"#七、什么是JWT\" class=\"headerlink\" title=\"七、什么是JWT\"></a>七、什么是JWT</h1><ul>\n<li>JSON Web Token（简称JWT）是目前最流行的跨域认证解决方案。</li>\n<li>是一种<code>认证授权机制</code>。</li>\n<li>JWT是为了在网络应用环境间<code>传递声明</code>而执行的一种基于JSON的开放标准。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li>\n<li>可以使用HMAC算法或者是RSA的公/私秘钥对JWT进行签名。因为数字签名的存在，这些传递的信息是可信的。</li>\n</ul>\n<h2 id=\"7-1-JWT的原理\"><a href=\"#7-1-JWT的原理\" class=\"headerlink\" title=\"7.1 JWT的原理\"></a>7.1 JWT的原理</h2><p>JWT的原理是，服务器认证以后，生成一个JSON对象，返回给用户，就像下面这样。</p>\n<pre><code class=\"json\">{\n    &quot;姓名&quot;: &quot;张三&quot;,\n    &quot;角色&quot;: &quot;管理员&quot;,\n    &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;\n}\n</code></pre>\n<p>以后，用户与服务端通信的时候，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200114184248329.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt=\"JWT原理\"></p>\n<blockquote>\n<p>JWT认证流程</p>\n</blockquote>\n<ol>\n<li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个JWT</li>\n<li>客户端将token保存到本地（通常使用localStorage，也可以使用cookie）</li>\n<li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的Authorization字段中使用Bearer模式添加JWT，其内容看起来是下面这样</li>\n</ol>\n<pre><code class=\"js\">Authorization: Bearer &lt;token&gt;\n</code></pre>\n<ol start=\"4\">\n<li>服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为</li>\n<li>因为JWT是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</li>\n<li>因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域问题</li>\n<li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li>\n</ol>\n<h2 id=\"7-2-JWT的数据结构\"><a href=\"#7-2-JWT的数据结构\" class=\"headerlink\" title=\"7.2 JWT的数据结构\"></a>7.2 JWT的数据结构</h2><p>实际的JWT大概就像下面这样：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200114185248941.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt=\"jwt数据结构\"></p>\n<p>它是一个很长的字符串，中间用点(.)分割成三个部分。</p>\n<p>JWT的三个部分依次如下：</p>\n<ul>\n<li>Header（头部）</li>\n<li>Payload（负载）</li>\n<li>Signature（签名）</li>\n</ul>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\" target=\"_blank\" rel=\"noopener\">JWT详细数据结构</a></p>\n<h2 id=\"7-3-生成JWT\"><a href=\"#7-3-生成JWT\" class=\"headerlink\" title=\"7.3 生成JWT\"></a>7.3 生成JWT</h2><ul>\n<li><a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\">https://jwt.io/</a></li>\n<li><a href=\"https://www.jsonwebtoken.io/\" target=\"_blank\" rel=\"noopener\">https://www.jsonwebtoken.io/</a></li>\n</ul>\n<h1 id=\"八、Token和JWT的区别\"><a href=\"#八、Token和JWT的区别\" class=\"headerlink\" title=\"八、Token和JWT的区别\"></a>八、Token和JWT的区别</h1><h2 id=\"8-1-相同\"><a href=\"#8-1-相同\" class=\"headerlink\" title=\"8.1 相同\"></a>8.1 相同</h2><ul>\n<li>都是访问资源的令牌</li>\n<li>都可以记录用户的信息</li>\n<li>都是使服务端无状态化</li>\n<li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li>\n</ul>\n<h2 id=\"8-2-区别\"><a href=\"#8-2-区别\" class=\"headerlink\" title=\"8.2 区别\"></a>8.2 区别</h2><ul>\n<li>Token：服务端验证客户端发送过来的Token时，还需要查询数据库获取用户信息，然后验证Token是否有效。</li>\n<li>JWT：将Token和Payload加密后存储于客户端，服务端只需要使用秘钥解密进行校验（校验也是JWT自己实现的）即可，不需要查询或者减少查询数据库，因为JWT自包含了用户信息和加密的数据。</li>\n</ul>\n<h1 id=\"九、要注意的问题\"><a href=\"#九、要注意的问题\" class=\"headerlink\" title=\"九、要注意的问题\"></a>九、要注意的问题</h1><h2 id=\"9-1-使用session时需要考虑的问题\"><a href=\"#9-1-使用session时需要考虑的问题\" class=\"headerlink\" title=\"9.1 使用session时需要考虑的问题\"></a>9.1 使用session时需要考虑的问题</h2><ul>\n<li>将session存储在服务器里面，当用户同时在线量比较多时，这些session会占据较多的内存，需要在服务器定期的去清理过期的session</li>\n<li>当网站采用<strong>集群部署</strong>的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建session的服务器，那么该服务器就无法拿到之前已经放入到session中的登录凭证之类的信息了。</li>\n<li>当多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理</li>\n<li><strong>sessionid是存储在cookie中的，假如浏览器禁止cookie或不支持cookie怎么办？</strong>一般会把sessinid跟在url参数后面即重写url，所以session不一定非得需要靠cookie实现</li>\n<li><strong>移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token</strong></li>\n</ul>\n<h2 id=\"9-2-使用JWT时需要考虑的问题\"><a href=\"#9-2-使用JWT时需要考虑的问题\" class=\"headerlink\" title=\"9.2 使用JWT时需要考虑的问题\"></a>9.2 使用JWT时需要考虑的问题</h2><ul>\n<li>因为JWT并不依赖Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域问题</li>\n<li>JWT默认是不加密，但也是可以加密的。生成原始Token以后，可以用密钥再加密一次。</li>\n<li>JWT不加密的情况下，不能将秘密数据写入JWT。</li>\n<li>JWT不仅可以用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。</li>\n<li>JWT最大的优势是服务器不再需要存储Session，使得服务器认证鉴权业务可以方便扩展。但这也是JWT最大的缺点：由于服务器不需要存储Session状态，因此使用过程中无法废弃某个Token或者更改Token的权限。也就是说一旦JWT签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li>\n<li>JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些较重要的权限，使用时应该再次对用户进行认证。</li>\n<li>JWT适合一次性的命令认证，颁发一个有效期极短的JWT，即使暴露了危险也很小，由于每次操作都会生成新的JWT，因此也没必要保存JWT，真正实现无状态。</li>\n<li>为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输。</li>\n</ul>\n<h2 id=\"9-3-使用加密算法时需要考虑的问题\"><a href=\"#9-3-使用加密算法时需要考虑的问题\" class=\"headerlink\" title=\"9.3 使用加密算法时需要考虑的问题\"></a>9.3 使用加密算法时需要考虑的问题</h2><ul>\n<li>绝不要以明文存储密码</li>\n<li><strong>永远使用哈希算法来处理密码，绝不要使用Base64或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。</strong>编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道，这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法，但是编码就存在解码，加密就存在解密。</li>\n<li>绝不要使用弱哈希或已被破解的哈希算法，像MD5或SHA1，只使用强密码哈希算法。</li>\n<li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要“忘记密码”的功能，可以随机生成一个新的<strong>一次性</strong>（这点很重要）密码，然后把这个密码发送给用户。</li>\n</ul>\n<h2 id=\"9-4只要关闭浏览器-，session-真的就消失了？\"><a href=\"#9-4只要关闭浏览器-，session-真的就消失了？\" class=\"headerlink\" title=\"9.4只要关闭浏览器 ，session 真的就消失了？\"></a>9.4只要关闭浏览器 ，session 真的就消失了？</h2><p>不对。浏览器关闭时，是不会主动去通知服务器的。之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 sessionId，而关闭浏览器后这个 cookie 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 sessionId 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。<br>恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/huangpb123/article/details/103933400\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<h1 id=\"一、先了解几个基础概念\"><a href=\"#一、先了解几个基础概念\" class=\"headerlink\" title=\"一、先了解几个基础概念\"></a>一、先了解几个基础概念</h1><h2 id=\"1-1-什么是认证（Authentication）\"><a href=\"#1-1-什么是认证（Authentication）\" class=\"headerlink\" title=\"1.1 什么是认证（Authentication）\"></a>1.1 什么是认证（Authentication）</h2><p>通俗地讲就是验证当前用户的身份。</p>\n<p>互联网中的认证：</p>\n<ul>\n<li>用户名密码登录</li>\n<li>邮箱发送登录链接</li>\n<li>手机号接收验证码</li>\n<li>只要你能收到邮箱/验证码，就默认你是账号的主人</li>\n</ul>\n<h2 id=\"1-2-什么是授权（Authorization）\"><a href=\"#1-2-什么是授权（Authorization）\" class=\"headerlink\" title=\"1.2 什么是授权（Authorization）\"></a>1.2 什么是授权（Authorization）</h2><p>用户授予第三方应用访问该用户某些资源的权限。</p>\n<p>实现授权的方式有：cookie、session、token、OAuth。</p>\n<h2 id=\"1-3-什么是凭证（Credentials）\"><a href=\"#1-3-什么是凭证（Credentials）\" class=\"headerlink\" title=\"1.3 什么是凭证（Credentials）\"></a>1.3 什么是凭证（Credentials）</h2><p>实现认证和授权的前提是需要一种媒介（证书）来标记访问者的身份。</p>\n<p>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</p>\n<h1 id=\"二、Cookie\"><a href=\"#二、Cookie\" class=\"headerlink\" title=\"二、Cookie\"></a>二、Cookie</h1><p><a href=\"https://blog.csdn.net/huangpb123/article/details/109107461\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<h2 id=\"2-1-了解Cookie\"><a href=\"#2-1-了解Cookie\" class=\"headerlink\" title=\"2.1 了解Cookie\"></a>2.1 了解Cookie</h2><ul>\n<li>Cookie最开始被设计出来是为了弥补HTTP在状态管理上的不足。HTTP协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种情况下，就产生了Cookie。</li>\n<li>cookie存储在客户端：cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。因此，服务端脚本就可以读、写存储在客户端的cookie的值。</li>\n<li>cookie是不可跨域的：每个cookie都会绑定单一的域名（绑定域名下的子域都是有效的），无法在别的域名下获取使用，<strong>同域名不同端口也是允许共享使用的</strong>。</li>\n</ul>\n<p>服务器向客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要向客户端发送的cookie，cookie格式如下：</p>\n<pre><code class=\"js\">Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot;\n</code></pre>\n<h2 id=\"2-2-检测cookie是否启用\"><a href=\"#2-2-检测cookie是否启用\" class=\"headerlink\" title=\"2.2 检测cookie是否启用\"></a>2.2 检测cookie是否启用</h2><p>有些用户为了避免隐私泄露会在它们的浏览器中禁用cookie。因此，在js代码使用cookie前，首先要确保cookie是启用的。可以用<code>navigator.cookieEnabled</code>属性来判断，如果值为true，则当前cookie是启用的；反之则是禁用的（但是，只具备“当前浏览器会话生命周期”的非持久化cookie仍然是启用的）。</p>\n<h2 id=\"2-3-cookie属性：有效期和作用域\"><a href=\"#2-3-cookie属性：有效期和作用域\" class=\"headerlink\" title=\"2.3 cookie属性：有效期和作用域\"></a>2.3 cookie属性：有效期和作用域</h2><p>cookie默认的有效期很短暂，它只能维持在Web浏览器的会话期间，一旦用户关闭浏览器，cookie保存的数据就丢失了。要注意的是，这与sessionStorage的有效期还是有区别的：cookie的作用域不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。如果想要延长cookie的有效期，可以通过设置max-age属性。一旦设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。</p>\n<p>和localStorage和sessionStorage类似，cookie的作用域是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性也是可配置的。默认情况下，cookie和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。比如，Web页面 <a href=\"http://www.example.com/catalog/index.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/catalog/index.html</a> 页面创建了一个cookie，那么该cookie对 <a href=\"http://www.example.com/catalog/order.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/catalog/order.html</a> 页面和 <a href=\"http://www.example.com/catalog/widgets/index.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/catalog/widgets/index.html</a> 页面都是可见的，但它对 <a href=\"http://www.example.com/about.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/about.html</a> 页面不可见。</p>\n<p>cookie的作用域默认由文档源限制。但是，有的大型网站想要子域之间能够互相共享cookie。比如，order.example.com 域下的服务器想要读取 catalog.example.com 域下设置的cookie值。可以将 catalog.example.com 域下的cookie的path属性设置成“/”，其domain属性设置成“.example.com”，那么该cookie就对所有 catalog.example.com，order.example.com 以及任何其他 example.com 域下的任何其他服务器都可见。如果没有为一个cookie设置域属性，那么domain属性的默认值是当前Web服务器的主机名。要注意的是，cookie的域只能设置为当前服务器的域。</p>\n<h2 id=\"2-4-Cookie的重要属性\"><a href=\"#2-4-Cookie的重要属性\" class=\"headerlink\" title=\"2.4 Cookie的重要属性\"></a>2.4 Cookie的重要属性</h2><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name=value</td>\n<td>键值对，设置Cookie的名称及相对应的值，都必须是字符串类型（name不区分大小写）<br>- 如果值为Unicode字符，需要字符编码。<br>- 如果值为二进制数据，则需要使用BASE64编码。</td>\n</tr>\n<tr>\n<td>domain</td>\n<td>指定cookie所属域名，默认是当前域名</td>\n</tr>\n<tr>\n<td>path</td>\n<td>指定cookie在哪个路径（路由）下生效，默认是&#39;/&#39;。<br>如果设置为<code>/abc</code>，则只有<code>/abc</code>下的路由可以访问到该cookie，如：<code>/abc/red</code>。</td>\n</tr>\n<tr>\n<td>expires</td>\n<td>过期时间（GMT时间格式），在设置的某个时间点后该cookie就会失效。<br>如果客户端和服务器时间不一致，使用expires就会存在偏差。<br>一般浏览器的cookie都是默认储存的，当关闭浏览器结束这个会话的时候，这个cookie也会被删除</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td>cookie有效期，单位秒。如果为正数，则该cookie在maxAge秒后失效。如果为负数，该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存cookie。如果为0，表示删除该cookie。默认为-1。<br>- 优先级高于expires</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>如果给某个cookie设置了httpOnly属性，则无法通过JS脚本读写该cookie的信息，但还是能通过Application中手动修改cookie，所以只是在一定程度上可以防止CSRF攻击，不是绝对的安全</td>\n</tr>\n<tr>\n<td>secure</td>\n<td>该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。<br>当secure值为true时，cookie在HTTP中是无效的。</td>\n</tr>\n</tbody>\n</table>\n<p>cookie集合中的每个cookie都拥有这些属性，而且每个cookie的这些属性都是独立分开的，各自控制各自的cookie。</p>\n<h2 id=\"2-5-cookie的局限性\"><a href=\"#2-5-cookie的局限性\" class=\"headerlink\" title=\"2.5 cookie的局限性\"></a>2.5 cookie的局限性</h2><h3 id=\"2-5-1-每个域名下cookie个数限制\"><a href=\"#2-5-1-每个域名下cookie个数限制\" class=\"headerlink\" title=\"2.5.1 每个域名下cookie个数限制\"></a>2.5.1 每个域名下cookie个数限制</h3><ul>\n<li>Chrome和Safari没有做硬件限制</li>\n<li>Firefox最多50个cookie</li>\n<li>IE7和之后的版本最多可以有50个cookie</li>\n<li>IE6或更低版本最多20个cookie</li>\n</ul>\n<p>RFC 2965标准不允许浏览器保存超过300个cookie，为每个web服务器保存的cookie数不能超过20个（是对整个服务器而言，而不仅仅指服务器上的页面和站点），而且，每个cookie保存的数据不能超过4kb。实际上，现代浏览器允许cookie总数超过300个，但是部分浏览器对单个cookie大小仍有4kb的限制。</p>\n<h2 id=\"2-6-客户端对cookie的存取\"><a href=\"#2-6-客户端对cookie的存取\" class=\"headerlink\" title=\"2.6 客户端对cookie的存取\"></a>2.6 客户端对cookie的存取</h2><h3 id=\"2-6-1-读取cookie\"><a href=\"#2-6-1-读取cookie\" class=\"headerlink\" title=\"2.6.1 读取cookie\"></a>2.6.1 读取cookie</h3><p>可以用<code>document.cookie</code>获取当前页面可用的cookie集合，其返回的值是一个字符串，该字符串都是由一系列键/值对组成，不同键/值对之间通过“分号和空格”分开。例如：</p>\n<pre><code class=\"js\">document.cookie;\n// &quot;name1=value1; name2=value2&quot;\n</code></pre>\n<p>这些返回的cookie值并不包含键/值以外的其他cookie属性。</p>\n<h3 id=\"2-6-2-设置cookie\"><a href=\"#2-6-2-设置cookie\" class=\"headerlink\" title=\"2.6.2 设置cookie\"></a>2.6.2 设置cookie</h3><pre><code class=\"js\">document.cookie = `name=${encodeURIComponent(name)}; max-age=1000;`;\n</code></pre>\n<p>name这个cookie会被添加到现有的cookie集合中。</p>\n<p>由于cookie的键/值中的值是不允许包含分号、逗号和空白符，因此，在存储前一般可以采用<code>encodeURIComponent()</code>函数对值进行编码。相应的，读取cookie值的时候要用<code>decodeURIComponent()</code>函数解码。</p>\n<h3 id=\"2-6-3-更新cookie\"><a href=\"#2-6-3-更新cookie\" class=\"headerlink\" title=\"2.6.3 更新cookie\"></a>2.6.3 更新cookie</h3><p>要改变cookie的值，需要使用相同的名字、路径和域，但是新的值重新设置cookie的值。同样地，设置新<code>max-age</code>属性就可以改变原来的cookie的有效期。</p>\n<h3 id=\"2-6-4-删除cookie\"><a href=\"#2-6-4-删除cookie\" class=\"headerlink\" title=\"2.6.4 删除cookie\"></a>2.6.4 删除cookie</h3><p>要删除一个cookie，需要使用相同的名字、路径和域，然后指定一个任意（非空）的值，并且将<code>max-age</code>属性指定为0，再次设置cookie。</p>\n<h2 id=\"2-7-封装对cookie的操作\"><a href=\"#2-7-封装对cookie的操作\" class=\"headerlink\" title=\"2.7 封装对cookie的操作\"></a>2.7 封装对cookie的操作</h2><p>由于cookie的读写非常不方便，我们可以自己封装一些函数来处理cookie。</p>\n<h3 id=\"2-7-1-获取全部cookie，返回一个对象\"><a href=\"#2-7-1-获取全部cookie，返回一个对象\" class=\"headerlink\" title=\"2.7.1 获取全部cookie，返回一个对象\"></a>2.7.1 获取全部cookie，返回一个对象</h3><pre><code class=\"js\">function getAllCookies() {\n  let cookies = {};\n  const all = document.cookie;\n  if (all) {\n    const list = all.split(&#39;; &#39;);\n    list.forEach(cookie =&gt; {\n      const cookieArr = cookie.split(&#39;=&#39;);\n      const name = cookieArr[0];\n      cookies[name] = decodeURIComponent(cookieArr[1]);\n    });\n  }\n  return cookies;\n}\n</code></pre>\n<h3 id=\"2-7-2-获取单个cookie，设置、删除cookie\"><a href=\"#2-7-2-获取单个cookie，设置、删除cookie\" class=\"headerlink\" title=\"2.7.2 获取单个cookie，设置、删除cookie\"></a>2.7.2 获取单个cookie，设置、删除cookie</h3><pre><code class=\"js\">class cookieUtils {\n  get(name) {\n    var arr,\n      reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;);\n    if ((arr = document.cookie.match(reg))) return decodeURIComponent(arr[2]);\n    else return null;\n  }\n\n  set(name, value, daysToLive) {\n    let cookie = `${name}=${encodeURIComponent(value)}`;\n    // daysToLive指天数\n    if (typeof daysToLive === &#39;number&#39;) {\n      cookie += `; max-age=${daysToLive * 24 * 60 * 60}`;\n    }\n    document.cookie = cookie;\n  }\n\n  delete(name) {\n    var date = new Date();\n    date.setTime(date.getTime() - 10000);\n    document.cookie = name + &quot;=-1;expires=&quot; + date.toGMTString();\n  }\n}\n\nexport default new cookieUtils();\n</code></pre>\n<p>在Chrome控制台Application的Cookies里可以对cookie进行读写操作。</p>\n<p><strong>移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token</strong>。</p>\n<h2 id=\"2-8-服务器端设置cookie示例（Node）\"><a href=\"#2-8-服务器端设置cookie示例（Node）\" class=\"headerlink\" title=\"2.8 服务器端设置cookie示例（Node）\"></a>2.8 服务器端设置cookie示例（Node）</h2><pre><code class=\"js\">var http = require(&#39;http&#39;);\nvar fs = require(&#39;fs&#39;);\n\nhttp.createServer(function(req, res) {\n    res.setHeader(&#39;status&#39;, &#39;200 OK&#39;);\n    res.setHeader(&#39;Set-Cookie&#39;, &#39;isVisit=true;domain=.yourdomain.com;path=/;max-age=1000&#39;);\n    res.write(&#39;Hello World&#39;);\n    res.end();\n}).listen(8888);\n\nconsole.log(&#39;running localhost:8888&#39;)\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200111122509425.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt></p>\n<h1 id=\"三、什么是Session\"><a href=\"#三、什么是Session\" class=\"headerlink\" title=\"三、什么是Session\"></a>三、什么是Session</h1><ul>\n<li><p>session是另一种记录服务器和客户端会话状态的机制</p>\n</li>\n<li><p>session是基于cookie实现的，session存储在服务器端，sessionid会被存储到客户端的cookie中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200111152258612.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt></p>\n</li>\n</ul>\n<blockquote>\n<p>session认证流程：</p>\n</blockquote>\n<ul>\n<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session</li>\n<li>请求返回时将此Session的唯一标识SessionID返回给浏览器</li>\n<li>浏览器接收到服务器返回的SessionID后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名</li>\n<li>当用户第二次访问服务器的时候，请求组会自动把此域名下的Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据SessionID查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。</li>\n</ul>\n<p>根据以上流程可知，<strong>SessionID是连接Cookie和Session的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p>\n<h1 id=\"四、Cookie和Session的区别\"><a href=\"#四、Cookie和Session的区别\" class=\"headerlink\" title=\"四、Cookie和Session的区别\"></a>四、Cookie和Session的区别</h1><ul>\n<li>安全性：Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的。</li>\n<li>存取值的类型不同：Cookie只支持存字符串数据，Session可以存任意数据类型。</li>\n<li>有效期不同：Cookie可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般失效时间较短，客户端关闭（默认情况下）或者Session超时都会失效。</li>\n<li>存储大小不同：单个Cookie保存的数据不能超过4k，Session可存储数据远高于Cookie，但是当访问量过多，会占用过多的服务器资源。</li>\n</ul>\n<h1 id=\"五、什么是Token（令牌）\"><a href=\"#五、什么是Token（令牌）\" class=\"headerlink\" title=\"五、什么是Token（令牌）\"></a>五、什么是Token（令牌）</h1><h2 id=\"5-1-Access-Token\"><a href=\"#5-1-Access-Token\" class=\"headerlink\" title=\"5.1 Access Token\"></a>5.1 Access Token</h2><ul>\n<li>访问资源接口（API）时所需要的资源凭证</li>\n<li>简单token的组成：uid（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li>\n</ul>\n<h2 id=\"5-2-服务器对token的存储方式\"><a href=\"#5-2-服务器对token的存储方式\" class=\"headerlink\" title=\"5.2 服务器对token的存储方式\"></a>5.2 服务器对token的存储方式</h2><ol>\n<li>存到数据库中，每次客户端请求的时候取出来验证（服务端有状态）</li>\n<li>存到redis中，设置过期时间，每次客户端请求的时候取出来验证（服务端有状态）</li>\n<li>不存，每次客户端请求的时候根据之前的生成方法再生成一次来验证（JWT，服务端无状态）</li>\n</ol>\n<blockquote>\n<p>特点</p>\n</blockquote>\n<ul>\n<li>服务端无状态化、可扩展性好</li>\n<li>支持移动端设备</li>\n<li>安全</li>\n<li>支持跨程序调用</li>\n</ul>\n<blockquote>\n<p>token的身份验证流程</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20200114175835320.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt=\"token的身份验证流程\"></p>\n<ol>\n<li>客户端使用用户名和密码请求登录</li>\n<li>服务端收到请求，去验证用户名与密码</li>\n<li>验证成功后，服务端会签发一个<code>token</code>并把这个<code>token</code>发送给客户端</li>\n<li>客户端收到<code>token</code>以后，会把它存储起来，比如放在<code>cookie</code>里或者<code>localStorage</code>里</li>\n<li>客户端每次向服务端请求资源的时候需要带着服务端签发的<code>token</code></li>\n<li>服务端收到请求，然后去验证客户端请求里面带着的<code>token</code>，如果验证成功，就向客户端返回请求的数据</li>\n</ol>\n<ul>\n<li>每一次请求都需要携带<code>token</code>，需要把<code>token</code>放到<code>HTTP</code>的<code>Header</code>里</li>\n<li>token完全由应用管理，所以它可以避开同源策略</li>\n</ul>\n<blockquote>\n<p>注意：登录时token不宜保存在localStorage，被XSS攻击时容易泄露。所以比较好的方式是把token写在cookie里。为了保证XSS攻击时cookie不被获取，还要设置cookie的http-only。</p>\n</blockquote>\n<h2 id=\"5-3-Refresh-Token\"><a href=\"#5-3-Refresh-Token\" class=\"headerlink\" title=\"5.3 Refresh Token\"></a>5.3 Refresh Token</h2><ul>\n<li>另外一种token——<code>refresh token</code></li>\n<li><code>refresh token</code>是专门用于刷新<code>access token</code>的token。如果没有<code>refresh token</code>，也可以刷新<code>access token</code>，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了<code>refresh token</code>，可以减少这个麻烦，客户端直接用<code>refresh token</code>去更新<code>access token</code>，无需用户进行额外的操作。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20200114182230452.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt=\"refresh token\"></p>\n<ul>\n<li><code>Access Token</code>的有效期比较短，当<code>Access Token</code>由于过期而失效时，使用<code>Refresh Token</code>就可以获取到新的Token，如果<code>Refresh Token</code>也失效了，用户就只能重新登录了。</li>\n<li><code>Refresh Token</code>及过期时间是存储在服务器的数据库中，只有在申请新的<code>Access Token</code>时才会验证，不会对业务接口响应时间造成影响，也不需要像<code>Session</code>一样一直保持在内存中以应对大量的请求。</li>\n</ul>\n<h1 id=\"六、Token和Session的区别\"><a href=\"#六、Token和Session的区别\" class=\"headerlink\" title=\"六、Token和Session的区别\"></a>六、Token和Session的区别</h1><ul>\n<li><code>Session</code>是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而<code>Token</code>是令牌，访问资源接口（API）时所需要的资源凭证。<code>Token</code>使服务端无状态化，不会存储会话信息。</li>\n<li><code>Session</code>和<code>Token</code>并不矛盾，作为身份认证<code>Token</code>安全性比<code>Session</code>好，因为每一个请求都有签名还能防止监听以及重复攻击，而<code>Session</code>就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加Session来在服务器端保存一些状态</strong>。</li>\n<li>如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用<code>Token</code>。如果永远只是自己的网站，自己的App，用什么就无所谓了。</li>\n</ul>\n<h1 id=\"七、什么是JWT\"><a href=\"#七、什么是JWT\" class=\"headerlink\" title=\"七、什么是JWT\"></a>七、什么是JWT</h1><ul>\n<li>JSON Web Token（简称JWT）是目前最流行的跨域认证解决方案。</li>\n<li>是一种<code>认证授权机制</code>。</li>\n<li>JWT是为了在网络应用环境间<code>传递声明</code>而执行的一种基于JSON的开放标准。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li>\n<li>可以使用HMAC算法或者是RSA的公/私秘钥对JWT进行签名。因为数字签名的存在，这些传递的信息是可信的。</li>\n</ul>\n<h2 id=\"7-1-JWT的原理\"><a href=\"#7-1-JWT的原理\" class=\"headerlink\" title=\"7.1 JWT的原理\"></a>7.1 JWT的原理</h2><p>JWT的原理是，服务器认证以后，生成一个JSON对象，返回给用户，就像下面这样。</p>\n<pre><code class=\"json\">{\n    &quot;姓名&quot;: &quot;张三&quot;,\n    &quot;角色&quot;: &quot;管理员&quot;,\n    &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;\n}\n</code></pre>\n<p>以后，用户与服务端通信的时候，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200114184248329.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt=\"JWT原理\"></p>\n<blockquote>\n<p>JWT认证流程</p>\n</blockquote>\n<ol>\n<li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个JWT</li>\n<li>客户端将token保存到本地（通常使用localStorage，也可以使用cookie）</li>\n<li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的Authorization字段中使用Bearer模式添加JWT，其内容看起来是下面这样</li>\n</ol>\n<pre><code class=\"js\">Authorization: Bearer &lt;token&gt;\n</code></pre>\n<ol start=\"4\">\n<li>服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为</li>\n<li>因为JWT是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</li>\n<li>因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域问题</li>\n<li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li>\n</ol>\n<h2 id=\"7-2-JWT的数据结构\"><a href=\"#7-2-JWT的数据结构\" class=\"headerlink\" title=\"7.2 JWT的数据结构\"></a>7.2 JWT的数据结构</h2><p>实际的JWT大概就像下面这样：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200114185248941.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70\" alt=\"jwt数据结构\"></p>\n<p>它是一个很长的字符串，中间用点(.)分割成三个部分。</p>\n<p>JWT的三个部分依次如下：</p>\n<ul>\n<li>Header（头部）</li>\n<li>Payload（负载）</li>\n<li>Signature（签名）</li>\n</ul>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\" target=\"_blank\" rel=\"noopener\">JWT详细数据结构</a></p>\n<h2 id=\"7-3-生成JWT\"><a href=\"#7-3-生成JWT\" class=\"headerlink\" title=\"7.3 生成JWT\"></a>7.3 生成JWT</h2><ul>\n<li><a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\">https://jwt.io/</a></li>\n<li><a href=\"https://www.jsonwebtoken.io/\" target=\"_blank\" rel=\"noopener\">https://www.jsonwebtoken.io/</a></li>\n</ul>\n<h1 id=\"八、Token和JWT的区别\"><a href=\"#八、Token和JWT的区别\" class=\"headerlink\" title=\"八、Token和JWT的区别\"></a>八、Token和JWT的区别</h1><h2 id=\"8-1-相同\"><a href=\"#8-1-相同\" class=\"headerlink\" title=\"8.1 相同\"></a>8.1 相同</h2><ul>\n<li>都是访问资源的令牌</li>\n<li>都可以记录用户的信息</li>\n<li>都是使服务端无状态化</li>\n<li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li>\n</ul>\n<h2 id=\"8-2-区别\"><a href=\"#8-2-区别\" class=\"headerlink\" title=\"8.2 区别\"></a>8.2 区别</h2><ul>\n<li>Token：服务端验证客户端发送过来的Token时，还需要查询数据库获取用户信息，然后验证Token是否有效。</li>\n<li>JWT：将Token和Payload加密后存储于客户端，服务端只需要使用秘钥解密进行校验（校验也是JWT自己实现的）即可，不需要查询或者减少查询数据库，因为JWT自包含了用户信息和加密的数据。</li>\n</ul>\n<h1 id=\"九、要注意的问题\"><a href=\"#九、要注意的问题\" class=\"headerlink\" title=\"九、要注意的问题\"></a>九、要注意的问题</h1><h2 id=\"9-1-使用session时需要考虑的问题\"><a href=\"#9-1-使用session时需要考虑的问题\" class=\"headerlink\" title=\"9.1 使用session时需要考虑的问题\"></a>9.1 使用session时需要考虑的问题</h2><ul>\n<li>将session存储在服务器里面，当用户同时在线量比较多时，这些session会占据较多的内存，需要在服务器定期的去清理过期的session</li>\n<li>当网站采用<strong>集群部署</strong>的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建session的服务器，那么该服务器就无法拿到之前已经放入到session中的登录凭证之类的信息了。</li>\n<li>当多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理</li>\n<li><strong>sessionid是存储在cookie中的，假如浏览器禁止cookie或不支持cookie怎么办？</strong>一般会把sessinid跟在url参数后面即重写url，所以session不一定非得需要靠cookie实现</li>\n<li><strong>移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token</strong></li>\n</ul>\n<h2 id=\"9-2-使用JWT时需要考虑的问题\"><a href=\"#9-2-使用JWT时需要考虑的问题\" class=\"headerlink\" title=\"9.2 使用JWT时需要考虑的问题\"></a>9.2 使用JWT时需要考虑的问题</h2><ul>\n<li>因为JWT并不依赖Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域问题</li>\n<li>JWT默认是不加密，但也是可以加密的。生成原始Token以后，可以用密钥再加密一次。</li>\n<li>JWT不加密的情况下，不能将秘密数据写入JWT。</li>\n<li>JWT不仅可以用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。</li>\n<li>JWT最大的优势是服务器不再需要存储Session，使得服务器认证鉴权业务可以方便扩展。但这也是JWT最大的缺点：由于服务器不需要存储Session状态，因此使用过程中无法废弃某个Token或者更改Token的权限。也就是说一旦JWT签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li>\n<li>JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些较重要的权限，使用时应该再次对用户进行认证。</li>\n<li>JWT适合一次性的命令认证，颁发一个有效期极短的JWT，即使暴露了危险也很小，由于每次操作都会生成新的JWT，因此也没必要保存JWT，真正实现无状态。</li>\n<li>为了减少盗用，JWT不应该使用HTTP协议明码传输，要使用HTTPS协议传输。</li>\n</ul>\n<h2 id=\"9-3-使用加密算法时需要考虑的问题\"><a href=\"#9-3-使用加密算法时需要考虑的问题\" class=\"headerlink\" title=\"9.3 使用加密算法时需要考虑的问题\"></a>9.3 使用加密算法时需要考虑的问题</h2><ul>\n<li>绝不要以明文存储密码</li>\n<li><strong>永远使用哈希算法来处理密码，绝不要使用Base64或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。</strong>编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道，这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法，但是编码就存在解码，加密就存在解密。</li>\n<li>绝不要使用弱哈希或已被破解的哈希算法，像MD5或SHA1，只使用强密码哈希算法。</li>\n<li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要“忘记密码”的功能，可以随机生成一个新的<strong>一次性</strong>（这点很重要）密码，然后把这个密码发送给用户。</li>\n</ul>\n<h2 id=\"9-4只要关闭浏览器-，session-真的就消失了？\"><a href=\"#9-4只要关闭浏览器-，session-真的就消失了？\" class=\"headerlink\" title=\"9.4只要关闭浏览器 ，session 真的就消失了？\"></a>9.4只要关闭浏览器 ，session 真的就消失了？</h2><p>不对。浏览器关闭时，是不会主动去通知服务器的。之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 sessionId，而关闭浏览器后这个 cookie 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 sessionId 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。<br>恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</p>\n"},{"title":"canvas","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"darkstranded.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-08-13T08:00:45.558Z","comments":1,"keywords":"canvas","description":"canvas","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/3.jpeg"],"_content":"\n\n\n\n## 一、canvas简介\n\n<kbd>canvas</kbd>是HTML5新增的，一个可以使用脚本（通常为JavaScript）在其中绘制图像的HTML元素。它可以用来制作照片或者制作简单（也不是那么简单）的动画，甚至可以进行实时视频处理和渲染。\n\n它最初由苹果内部使用自己MacOS X Webkit推出，供应用程序使用像仪表盘的构件和Safari浏览器使用。后来，有人通过Gecko内核的浏览器（尤其是Mozilla和Firefox），Opera和Chrome和超文本网络应用技术工作组建议为下一代的网络技术使用该元素。\n\nCanvas是由HTML代码配合高度和宽度属性而定义出的可绘制区域。JavaScript代码可以访问该区域，类似于其他通用的二维API，通过一套完整的绘图函数来动态生成图形。\n\nMozilla程序从Geko1.8（Firefox1.5）开始支持<kbd>canvas</kbd>，Internet Explorer从IE9开始<kbd>canvas</kbd>。Chrome和Opera9+也支持<kbd>canvas</kbd>。\n\n\n\n## 二、Canvas基本使用\n\n### 2.1canvas元素\n\n<kbd>canvas</kbd>看起来和<kbd>`<img>`</kbd>标签一样，只是<kbd>canvas</kbd>只有两个可选的属性width、height属性，而没有src、alt属性。\n\n如果不给<kbd>canvas</kbd>设置width、height属性时，则默认width为300、height为150，单位都是px。也可以使用css属性来设置宽高，但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用css属性来设置<kbd>canvas</kbd>的宽高。\n\n***替换内容***\n\n由于某些较老的浏览器（尤其是IE9之前的IE浏览器）或者浏览器不支持HTML元素<kbd>canvas</kbd>，在这些浏览器上你应该总是能展示替代内容。\n\n支持<kbd>canvas</kbd>的浏览器会只渲染<kbd>canvas</kbd>标签，而忽略其中的替代内容。不支持<kbd></kbd>canvas</kbd>的浏览器会直接渲染替代内容。\n\n用文本替换：\n\n```html\n<canvas>\n    你的浏览器不支持canvas，请升级你的浏览器。\n</canvas>\n```\n\n用<kbd>`<img>`</kbd>替换：\n\n```html\n<canvas>\n\t<img src=\"./美女.jgp\" alt=\"\">\n</canvas>\n```\n\n***结束标签</canvas>不可省略***\n\n与<kbd>`<img>`</kbd>元素不同，<kbd>canvas</kbd>元素需要结束标签（</canvas>）。如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。\n\n##2.2渲染上下文（Thre Rending Context）\n\n<kbd>canvas</kbd>会创建一个固定大小的画布，会公开一个或多个**渲染上下文**(画笔)，使用**渲染上下文**来绘制和处理要展示的内容。\n\n我们重点研究2D渲染上下文。其他的上下文我们暂不研究，比如，WebGL使用了基于OpenGLES的3D上下文。\n\n```javascript\nvar canvas = document.getElementById('tutorial');\n//获得2d上下文对象\nvar ctx = canvas.getContext('2d')\n```\n\n\n\n### 2.3检测支持性\n\n```javascript\nvar canvas = document.getElementById('tutorial');\nif(canvas.getContext) {\n\tvar ctx = canvas.getContext('2d')\n    // drawing code here\n} else {\n\t// canvas-unsupported code here\n}\n```\n\n\n\n### 2.4代码模板\n\n```html\n<canvas id=\"tutorial\" width=\"300\" height=\"300\"></canvas>\n<script type=\"text/javascript\">\n\tfunction draw() {\n\t\tvar canvas = document.getElementById('tutorial');\n        if(!canvas.getContext) return\n        var ctx = canvas.getContext('2d')\n        //开始写代码\n    }\n</script>\n```\n\n\n\n### 2.5一个简单的例子\n\n以下实例绘制两个长方形\n\n```html\n<canvas id=\"tutorial\" width=\"300\" height=\"300\"></canvas>\n<script type=\"text/javascript\">\n\tfunction draw() {\n\t\tvar canvas = document.getElementById('tutorial');\n        if(!canvas.getContext) return\n        var ctx = canvas.getContext('2d')\n        ctx.fillStyle = \"rgb(200,0,0)\"\n        //绘制矩形\n        ctx.fillRect (10,10,55,50)\n        ctx.fillStyle = \"rgb(0,0,200,0.5)\"\n        ctx.fillRect (30,30,55,50)\n    }\n    draw()\n</script>\n```\n\n\n\n## 三、绘制形状\n\n### 3.1栅格(grid)和坐标空间\n\n如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元 相当于canvas元素中的一像素。栅格的起点为左上角，坐标为(0,0)。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素，坐标为(x,y)。\n\n后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/Canvas_default_grid.png)\n\n### 3.2绘制矩形\n\n<kbd>canvas</kbd>只支持一种原生的图形绘制：***矩形***。所有其他图形都至少需要生成一种路径(path)。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。\n\ncanvas提供了三种方法绘制矩形：\n\n* fillRect(x, y, width, height)：绘制一个填充的矩形。\n* strokeRect(x, y, width, height)：绘制一个矩形的边框。\n* clearRect(x, y, width, height)：清除指定的矩形区域，然后这块区域会变的完全透明。\n\n> 说明：这3个方法具有相同的参数。\n>\n> * x,y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)\n> * width,height：指的是绘制的矩形的宽和高。\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.fillRect(10,10,100,50) //绘制矩形，填充的默认颜色为黑色\n    ctx.strokeRect(10, 70, 100 ,50) //绘制矩形边框\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2400420933-5b74dd8f80306_articlex.png)\n\n```javascript\nctx.clearRect(15, 15, 50, 25)\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2347163070-5b74dd8f813a6_articlex.png)\n\n## 四、绘制路径(path)\n\n图形的基本元素是路径。\n\n路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。\n\n一个路径，甚至一个子路径，都是闭合的。\n\n***使用路径绘制图形需要一些额外的步骤：***\n\n> 1. 创建路径起始点\n> 2. 调用绘制方法去绘制出路径\n> 3. 把路径封闭\n> 4. 一旦路径生成，通过描边或填充路径区域来渲染图形\n\n***下面是需要用到的方法：***\n\n> 1. beginPath()\n>\n> ​       新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径\n>\n> 2. moveTo(x, y)\n>\n>    把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。\n>\n> 3. closePath()\n>\n>    闭合路径之后，图形绘制命令又重新指向到上下文中\n>\n> 4. stroke()\n>\n>    通过线条来绘制图形轮廓\n>\n> 5. fill()\n>\n>    通过填充路径的内容区域生成实心的图形\n\n\n\n## 4.1绘制线段\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath() //新建一条path\n    ctx.moveTo(50,50) // 把画笔移动到指定的坐标\n    ctx.lineTo(200,50) //绘制一条从当前位置到指定坐标(200,50)的直线\n    ctx.closePath() //闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做\n    ctx.stroke() //绘制路径\n}\ndraw()\n```\n\n## 4.2绘制三角形边框\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElmentById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    ctx.lineTo(200,50)\n    ctx.lineTo(200,200)\n    ctx.closePath() //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个三角形\n    ctx.stroke() //描边。stroke不会自动closePath()\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2106846415-5b74dd8f67000_articlex.png)\n\n\n\n## 4.3填充三角形\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    ctx.lineTo(200,50)\n    ctx.lineTo(200,200)\n    ctx.fill() //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径\n}\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3457015746-5b74dd8f72860_articlex.png)\n\n\n\n## 4.4绘制圆弧\n\n有两个方法可以绘制圆弧：\n\n1. arc(x, y, r, startAngle, endAngle, anticlockwise): \n\n   以(x,y) 为圆心，以r为半径，从startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针(默认是顺时针)。\n\n   >1. 这里的度数都是弧度。\n   >\n   >2. 0弧度是指的x轴正方向。\n   >\n   >   >radians = (Math.PI/180)*degrees //角度转换成弧度\n\n2. arcTo(x1,y1,x2,y2,radius):\n\n   根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。\n\n```javascript\n//圆弧案例1\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.arc(50,50,40,0,Math.PI /2, false)\n    ctx.stroke()\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3832141455-5b74dd8f658df_articlex.png)\n\n```javascript\n//圆弧案例2\nfuncion draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.arc(50,50,50,0,Math.PI/2,false)\n    ctx.stroke()\n    \n    ctx.beginPath()\n    ctx.arc(150,50,40,0,-Math.PI/2,true)\n    ctx.closePath()\n    ctx.stroke()\n    \n    ctx.beginPath()\n    ctx.arc(50,150,40,-Math.PI/2,Math.PI/2,false)\n    ctx.fill()\n    \n    ctx.beginPath()\n    ctx.arc(150,150,40,0,Math.PI,false)\n    ctx.fill()\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2218794221-5b74dd8f43f98_articlex.png)\n\n```javascript\n//圆弧案例3\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    //参数1、2：控制点1坐标\n    //参数3、4：控制点2坐标\n    //参数5：圆弧半径\n    ctx.arcTo(200,50,200,200,100)\n    ctx.lineTo(200,200)\n    ctx.stroke()\n    \n    ctx.beginPath()\n    ctx.rect(50,50,10,10)\n    ctx.rect(200,50,10,10)\n    ctx.rect(200,200,10,10)\n    ctx.fill()\n}\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3556678928-5b74dd8f1bd2a_articlex.png)\n\n> arcTo方法的说明：\n>\n> 这个方法可以这样理解。绘制的弧形是由两条切线所决定。\n>\n> 第1条切线：起始点和控制点1决定的直线。\n>\n> 第2条切线：控制点1和控制点2决定的直线。\n>\n> 其实绘制的圆弧就是与这两条直线相切的圆弧。\n\n\n\n## 4.5绘制贝塞尔曲线\n\n### 4.5.1什么是贝塞尔曲线\n\n贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。\n\n一般的矢量图形软件通过它来精确画出曲线，贝兹曲线是由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。\n\n贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具入PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。\n\n贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau 于 1959 年运用 de Casteljau 演算法开发，以稳定数值的方法求出贝兹曲线。\n\n***一次贝塞尔曲线其实是一条直线***\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/240px-b_1_big.gif)\n\n***二次贝塞尔曲线***\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/b_2_big.gif)\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/1544764428-5713-240px-BC3A9zier-2-big.svg-.png)\n\n三次贝塞尔曲线\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/b_3_big.gif)\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/1544764428-2467-240px-BC3A9zier-3-big.svg-.png)\n\n\n\n### 4.5.2绘制贝塞尔曲线\n\n1. 绘制二次贝塞尔曲线：/kwɒ'drætɪk/\n\n```javascript\nquadraticCurveTo(cp1x,cp1y,x,y)\n```\n\n> 说明：\n>\n> * 参数1和2：控制点坐标\n> * 参数3和4：结束点坐标\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.moveTo(10,200) //起始点\n    var cp1x = 40, cp1y = 100 //控制点\n    var x = 200, y = 200 //结束点\n    //绘制二次贝塞尔曲线\n    ctx.quadraticCurveTo(cp1x, cp1y, x, y)\n    ctx.stroke()\n    \n    ctx.beginPath()\n    ctx.rect(10,200,10,10)\n    ctx.rect(cp1x,cp1y,10,10)\n    ctx.rect(x,y,10,10)\n    ctx.fill()\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/274915666-5b74dd8ecb2e2_articlex.png)\n\n2. 绘制三次贝塞尔曲线:\n\n   ```javascript\n   bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\n   ```\n\n   > 说明：\n   >\n   > * 参数1和2：控制点1的坐标\n   > * 参数3和4：控制点2的坐标\n   > * 参数5和6：结束点的坐标\n\n   \n\n   ```javascript\n   function draw() {\n   \tvar canvas = document.getElementById('tutorial')\n       if(!canvas.getContext) return\n       var ctx = canvas.getContext('2d')\n       ctx.beginPath()\n       ctx.moveTo(40,200) //起始点\n       var cp1x = 20, cp1y = 100 //控制点1\n       var cp2x = 100, cp2y = 120 //控制点2\n       var x = 200, y = 200 //结束点\n       //绘制三次贝塞尔曲线\n       ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)\n       ctx.stroke()\n       \n       ctx.beginPath();\n       ctx.rect(40, 200, 10, 10);\n       ctx.rect(cp1x, cp1y, 10, 10);\n       ctx.rect(cp2x, cp2y, 10, 10);\n       ctx.rect(x, y, 10, 10);\n       ctx.fill();\n   }\n   draw()\n   ```\n\n   \n\n   ![img](https://www.runoob.com/wp-content/uploads/2018/12/3947786617-5b74dd8ec8678_articlex.png)\n\n\n\n# 五、添加样式和颜色\n\n在前面的绘制矩形章节中，只用到了默认的线条和颜色。\n\n如果想要给图形上色，有两个重要的属性可以做到。\n\n1. fillStyle = color 设置图形的填充颜色\n2. strokeStyle = color 设置图形轮廓的颜色\n\n> 备注：\n>\n> 1. color可以是表达css颜色值的字符串、渐变对象或者图案对象\n> 2. 默认情况下，线条和填充颜色都是黑色\n> 3. 一旦您设置了strokeStyle或者fillStyle的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置fillStyle或strokeStyle的值\n\n##     fillStyle\n\n\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    for(var i = 0; i < 6; i++) {\n\t\tfor(var j = 0; j < 6; j++) {\n\t\t\tctx.fillStyle = 'rgb(' + Math.floor(255 - 42.5 * i) + ',' + Math.floor(255 - 42.5 * j) + ',0)'\n            ctx.fillRect(j * 50, i * 50, 50, 50)\n        }\n    }\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2505008676-5b74dd8ebad41_articlex.png)\n\n\n\n## strokeStyle\n\n\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    for(var i = 0; i < 6; i++) {\n\t\tfor(var j = 0;j < 6;j++) {\n\t\t\tctx.strokeStyle = `rgb(${randomInt(0,255)}, ${randomInt(0,255)}, ${randomInt(0,255)})`\n            ctx.strokeRect(j*50,i*50,40,40)\n        }\n    }\n}\ndraw()\n\n//返回随机的[from,to]之间的整数(包括from，也包括to)\nfunction randomInt(from,to) {\n\treturn parseInt(Math.random() * (to-from +1) + from)\n}\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3288535670-5b74dd8ea12d9_articlex.png)\n\n## Transparency(透明度)\n\n\n\nglobalAlpha = transparencyValue:这个属性影响到canvas里所有图形的透明度，有效的值范围是0.0（完全透明）到1.0（完全不透明），默认是1.0\n\n**globalAlpha**属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更好一些。\n\n**1. line style**\n\n线宽。只能是正值。默认是1.0\n\n起始点和终点的连线为中心，上下各占线宽的一半。\n\n```javascript\nctx.beginPath()\nctx.moveTo(10,10)\nctx.lineTo(100,10)\nctx.lineWidth = 10\nctx.stroke()\n\nctx.beginPath()\nctx.moveTo(110,10)\nctx.lineTo(160,10)\nctx.lineWidth = 20\nctx.stroke()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3410060825-5b74dd8ea12d9_articlex.png)\n\n**2. lineCap = type**\n\n线条末端样式。\n\n> 共有三个值：\n>\n> 1. butt： 线段末端以方形结束\n> 2. round：线段末端以圆形结束\n> 3. square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一般的矩形区域\n\n```javascript\nvar lineCaps = ['butt', 'round', 'square']\nfor(var i = 0;i<3;i++) {\n\tctx.beginPath()\n    ctx.moveTo(20+30*i,30)\n    ctx.lineTo(20+30*i,100)\n    ctx.lineWidth = 20\n    ctx.lineCap = lineCaps[i]\n    ctx.stroke()\n}\n\nctx.beginPath()\nctx.moveTo(0,30)\nctx.lineTo(300,30)\n\nctx.moveTo(0,100)\nctx.lineTo(300,100)\n\nctx.strokeStyle = 'red'\nctx.lineWidth = 1\nctx.stroke()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3380216230-5b74dd8e97e85_articlex.png)\n\n**3. lineJoin = type**\n\n同一个path内，设定线条与线条间接合处的样式。\n\n共有三个值round,bevel和miter：\n\n1. round通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。圆角的半径是线段的宽度。\n2. bevel在相连部分的末端填充一个额外的以三角形为底的区域，每个部分都有各自独立的矩形拐角。\n3. miter(默认)通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    \n    var lineJoin = ['round','bevel', 'miter']\n    ctx.lineWidth = 20\n    for(var i =0; i< lineJoin.length;i++) {\n\t\tctx.lineJoin = lineJoin[i]\n        ctx.beginPath()\n        ctx.moveTo(50,50+i*50)\n        ctx.lineTo(100,100+i*50)\n        ctx.lineTo(150,50+i*50)\n        ctx.lineTo(200,100+i*50)\n        ctx.lineTo(250,50+i*50)\n        ctx.stroke()\n    }\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/1584506777-5b74dd8e82768_articlex.png)\n\n\n\n**4. 虚线**\n\n用setLineDash方法和lineDashOffset属性来指定虚线样式。\n\nsetLineDash方法接收一个数组，来指定线段与间隙的交替；\n\nlineDashOffset属性设置起始偏移量。\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.setLineDash([20,5]) //[实线长度，间隙长度]\n    ctx.lineDashOffset = -0\n    ctx.strokeRect(50,50,210,210)\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/2805401035-5b74dd8e6833c_articlex.png)\n\n> 备注：getLineDash()返回一个包含当前虚线样式，长度为非偶数的数组。\n\n\n\n# 六、绘制文本\n\n***绘制文本的两个方法***\n\ncanvas提供了两种方法来渲染文本：\n\n1. fillText(text, x, y, [, maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的。\n\n2. strokeText(text, x, y, [, maxWidth])在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的。\n\n   ```javascript\n   var ctx;\n   function draw() {\n   \tvar canvas = document.getELementById('tutorial')\n       if(!canvas.getContext) return\n       ctx = canvas.getContext('2d')\n       ctx.font = '100px sans-serif'\n       ctx.fillText('天若有情',10,100)\n       ctx.strokeText('天若有情',10,200)\n   }\n   draw()\n   ```\n\n   1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/404304980-5b74dd8e7499e_articlex.png)\n\n\n\n***给文本添加样式***\n\n1. font = value 当前我们用来绘制文本的样式。这个字符串使用和css font属性相同的语法。**默认的字体是10px sans-serif。**\n2. textAlign = value 文本对齐选项。可选的值包括：start，end，left，right，center。**默认是start。**\n3. textBaseline = value 基线对齐选项，可选的值包括：top，hanging，middle，alphabetic，ideographic，bottom。**默认值是alphabetic。**\n4. direction = value 文本方向。可能的值包括：ltr，rtl，inherit。**默认值是inherit。**\n\n\n\n# 七、绘制图片\n\n我们也可以在canvas上直接绘制图片。\n\n## 7.1由零开始创建图片\n\n```javascript\nvar img = new Image() //创建一个<img>元素\nimg.src = 'myImage.png' //设置图片原地址\n```\n\n**绘制img**\n\n```javascript\n//参数1：要绘制的img\n//参数2、3：绘制的img在canvas中的坐标\nctx.drawImage(img,0,0)\n```\n\n> 注意：考虑到图片是从网络加载，如果drawImage的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在img绘制完成之后再drawImage。\n\n```javascript\nvar img = new Image() //创建img元素\nimg.onload = function() {\n\tctx.drawImage(img, 0, 0)\n}\nimg.src = 'myImage.png' //设置图片c地址\n```\n\n\n\n## 7.2 绘制img标签元素中的图片\n\nimg可以new，也可以来源于我们页面中的<img>标签。\n\n```html\n<img src=\"./美女.jpg\" alt=\"\" width=\"300\"><br>\n<canvas id=\"tutorial\" width=\"600\" height=\"400\"></canvas>\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial)\n\tif(!canvas.getContext) return\n\tvar ctx = canvas.getContext('2d')\n\tvar img = document.querySelector('img')\n\tctx.drawImg(img,0,0)\n}\ndocument.querySelector('img').onclick = function() {\n\tdraw()\n}\n```\n\n1. 1. 第一张图片就是页面中的 `<img>` 标签：\n\n2. ![img](https://www.runoob.com/wp-content/uploads/2018/12/2255709523-5b74dd8eb033e_articlex.png)\n\n\n\n## 7.3 缩放图片\n\ndrawImage()可以再添加两个参数：\n\n```javascript\ndrawImage(image,x,y,width,height)\n```\n\n这个方法多了两个参数：width和height，这两个参数用来控制 当像canvas画入时应该缩放的大小。\n\n```javascript\nctx.drawImage(img,0,0,400,200)\n```\n\n\n\n##7.4 切片(slice)\n\n```javascript\ndrawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)\n```\n\n第一个参数和其他的是相同的，都是一个图像或者另一个canvas的引用。\n\n其他8个参数：前4个事定义图像源的切片位置和大小，后四个则是定义切片的目标显示位置和大小。\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/2106688680-54566fa3d81dc_articlex.jpeg)\n\n\n\n# 八、状态的保存和恢复\n\nSaving and restoring state是绘制复杂图形时必不可少的操作。\n\nsave()和restore()\n\nsave和restore方法是用来保存和恢复canvas状态的，都没有参数。\n\nCanvas的状态就是当前画面应用的所有样式和变形的一个快照。\n\n## 8.1 关于save()\n\n> Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。\n\n一个绘画状态包括:\n\n* 当前应用的变形（即移动，旋转和缩放）\n\n* strokeStyle,fillStyle,globalAlpha,lineWidth,lineCap,lineJoin,miterLimit,shadowOffsetX,shadowOffsetY,shadowBlur,shadowColor,globalCompositeOperation的值\n\n* 当前的裁切路径（clipping path)\n\n  \n\n  ***可以调用任意多次save方法（类似数组的push()）***\n\n## 8.2关于resotre()\n\n> 每一次调用restore方法，上一个保存的状态就从栈中弹出，所有设定都恢复（类似数组pop()）\n\n```javascript\nvar ctx;\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    \n    ctx.fillRect(0,0,150,150) //使用默认设置绘制一个矩形\n    ctx.save() //保存默认状态\n    \n    ctx.fillStyle = 'red' //在原有配置基础上对颜色做改变\n    ctx.fillRect(15,15,120,120) //使用心得设置绘制一个矩形\n    \n    ctx.save() //保存当前状态\n\tctx.fillStyle = '#FFF' //再次改变颜色状态\n    ctx.fillRect(30,30,90,90) //使用心得配置绘制一个矩形\n    \n    ctx.restore() //重新加载之前的颜色状态\n    ctx.fillRect(45,45,60,60) //使用上一次的配置绘制一个矩形\n    \n    ctx.restore() //加载默认颜色配置\n    ctx.fillRect(60,60,30,30) //使用加载的配置绘制一个矩形\n}\ndraw()\n```\n\n\n\n# 九、变形\n\n## 9.1translate\n\ntranslate(x,y)\n\n用来移动canvas的原点到指定的位置\n\ntranslate方法接收两个参数。x是左右偏移量，y是上下偏移量，如图所示。\n\n在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用restore方法比手动恢复原形的状态要简单得多。又如果你是在一个循环中做位移但没有保存和恢复canvas的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出canvas范围以外了。注意：translate移动的是canvas的坐标原点(坐标变换)。\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/829832336-5b74dd8e3ad9a_articlex.png)\n\n```javascript\nvar ctx;\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.save() //保存坐标原点平移之前的状态\n    ctx.translate(100,100)\n    ctx.strokeRect(0,0,100,100)\n    ctx.restore()\n    ctx.translate(220,200)\n    ctx.fillRect(0,0,100,100)\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/1230266743-5b74dd8e3b0ce_articlex.png)\n\n\n\n## 9.2 rotate\n\nrotate(angle)\n\n旋转坐标轴。\n\n这个方法只接受一个参数：旋转的角度（angle），它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/3322150878-5b74dd8e2b6a4_articlex.png)\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvs.getContext) return\n    var ctx = canvas.getContext('2d')\n    \n    ctx.fillStyle = 'red'\n    ctx.save()\n    \n    ctx.translate(100,100)\n    ctx.rotate(Math.PI/180*45)\n    ctx.fillStyle = 'blue'\n    ctx.fillRect(0,0,100,100)\n    ctx.restore()\n    \n    ctx.save()\n    ctx.translate(0,0)\n    ctx.fillRect(0,0,50,50)\n    ctx.restore()\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/1819968878-5b74dd8e1e770_articlex.png)\n\n\n\n## 9.3 scale\n\nscale(x,y)\n\n我们用它来增减图形在canvas中的像素数目，对形状、位图进行缩小或者放大。\n\nscale方法接受两个参数。x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比1.0小表示缩小，比1.0大表示放大，值为1.0时什么效果都没有。\n\n默认情况下，canvas的1单位就是1个像素。举例说，如果我们设置缩放因子是0.5，1个单位就变成对应0.5个像素，这样绘制出来的形状就会是原先的一半。同理，设置为2.0时，1个单位就对应变成了2像素，绘制的结果就是图形放大了2倍。\n\n\n\n## 9.4 transform(变形矩阵)\n\ntransform(a,b,c,d,e,f)\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/2958376259-5b74dd8e15192_articlex.png)\n\n* a (m11): Horizontal scaling.\n* b (m12): Horizontal skewing.\n* c (m21): Vertical skewing.\n* d (m22): Vertical scaling.\n* e (dx): Horizontal moving.\n* f (dy): Vertical moving.\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.transform(1,1,0,1,0,0)\n    ctx.fillRect(0,0,100,100)\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/489430190-5b74dd8e17ad2_articlex.png)\n\n\n\n## 十、合成\n\n在前面的所有例子中，我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用globalCompositeOperation属性来改变这种情况。\n\n```javascript\nglobalCompositeOperation = type\n```\n\n```javascript\nvar ctx;\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial');\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.fillStyle = 'blue'\n    ctx.fillRect(0,0,200,200)\n    \n    ctx.globalCompositeOperation = 'source-over' //全局合成操作\n    ctx.fillStyle = 'red'\n    ctx.fillRect(100,100,200,200)\n}\n```\n\n> 注：下面的展示中，蓝色是原有的，红色是新的。\n>\n> type是下面13中字符串值之一:\n\n1. 这是默认设置，新图像会覆盖在原有图像。\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/1858023544-5b74dd8e0813d.png)\n\n","source":"_posts/canvas.md","raw":"---\ntitle: canvas\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: darkstranded.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 16：01：30\ncomments: true\ntags: \n - web\nkeywords: canvas\ndescription: canvas\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/3.jpeg\n\n---\n\n\n\n\n## 一、canvas简介\n\n<kbd>canvas</kbd>是HTML5新增的，一个可以使用脚本（通常为JavaScript）在其中绘制图像的HTML元素。它可以用来制作照片或者制作简单（也不是那么简单）的动画，甚至可以进行实时视频处理和渲染。\n\n它最初由苹果内部使用自己MacOS X Webkit推出，供应用程序使用像仪表盘的构件和Safari浏览器使用。后来，有人通过Gecko内核的浏览器（尤其是Mozilla和Firefox），Opera和Chrome和超文本网络应用技术工作组建议为下一代的网络技术使用该元素。\n\nCanvas是由HTML代码配合高度和宽度属性而定义出的可绘制区域。JavaScript代码可以访问该区域，类似于其他通用的二维API，通过一套完整的绘图函数来动态生成图形。\n\nMozilla程序从Geko1.8（Firefox1.5）开始支持<kbd>canvas</kbd>，Internet Explorer从IE9开始<kbd>canvas</kbd>。Chrome和Opera9+也支持<kbd>canvas</kbd>。\n\n\n\n## 二、Canvas基本使用\n\n### 2.1canvas元素\n\n<kbd>canvas</kbd>看起来和<kbd>`<img>`</kbd>标签一样，只是<kbd>canvas</kbd>只有两个可选的属性width、height属性，而没有src、alt属性。\n\n如果不给<kbd>canvas</kbd>设置width、height属性时，则默认width为300、height为150，单位都是px。也可以使用css属性来设置宽高，但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用css属性来设置<kbd>canvas</kbd>的宽高。\n\n***替换内容***\n\n由于某些较老的浏览器（尤其是IE9之前的IE浏览器）或者浏览器不支持HTML元素<kbd>canvas</kbd>，在这些浏览器上你应该总是能展示替代内容。\n\n支持<kbd>canvas</kbd>的浏览器会只渲染<kbd>canvas</kbd>标签，而忽略其中的替代内容。不支持<kbd></kbd>canvas</kbd>的浏览器会直接渲染替代内容。\n\n用文本替换：\n\n```html\n<canvas>\n    你的浏览器不支持canvas，请升级你的浏览器。\n</canvas>\n```\n\n用<kbd>`<img>`</kbd>替换：\n\n```html\n<canvas>\n\t<img src=\"./美女.jgp\" alt=\"\">\n</canvas>\n```\n\n***结束标签</canvas>不可省略***\n\n与<kbd>`<img>`</kbd>元素不同，<kbd>canvas</kbd>元素需要结束标签（</canvas>）。如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。\n\n##2.2渲染上下文（Thre Rending Context）\n\n<kbd>canvas</kbd>会创建一个固定大小的画布，会公开一个或多个**渲染上下文**(画笔)，使用**渲染上下文**来绘制和处理要展示的内容。\n\n我们重点研究2D渲染上下文。其他的上下文我们暂不研究，比如，WebGL使用了基于OpenGLES的3D上下文。\n\n```javascript\nvar canvas = document.getElementById('tutorial');\n//获得2d上下文对象\nvar ctx = canvas.getContext('2d')\n```\n\n\n\n### 2.3检测支持性\n\n```javascript\nvar canvas = document.getElementById('tutorial');\nif(canvas.getContext) {\n\tvar ctx = canvas.getContext('2d')\n    // drawing code here\n} else {\n\t// canvas-unsupported code here\n}\n```\n\n\n\n### 2.4代码模板\n\n```html\n<canvas id=\"tutorial\" width=\"300\" height=\"300\"></canvas>\n<script type=\"text/javascript\">\n\tfunction draw() {\n\t\tvar canvas = document.getElementById('tutorial');\n        if(!canvas.getContext) return\n        var ctx = canvas.getContext('2d')\n        //开始写代码\n    }\n</script>\n```\n\n\n\n### 2.5一个简单的例子\n\n以下实例绘制两个长方形\n\n```html\n<canvas id=\"tutorial\" width=\"300\" height=\"300\"></canvas>\n<script type=\"text/javascript\">\n\tfunction draw() {\n\t\tvar canvas = document.getElementById('tutorial');\n        if(!canvas.getContext) return\n        var ctx = canvas.getContext('2d')\n        ctx.fillStyle = \"rgb(200,0,0)\"\n        //绘制矩形\n        ctx.fillRect (10,10,55,50)\n        ctx.fillStyle = \"rgb(0,0,200,0.5)\"\n        ctx.fillRect (30,30,55,50)\n    }\n    draw()\n</script>\n```\n\n\n\n## 三、绘制形状\n\n### 3.1栅格(grid)和坐标空间\n\n如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元 相当于canvas元素中的一像素。栅格的起点为左上角，坐标为(0,0)。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素，坐标为(x,y)。\n\n后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/Canvas_default_grid.png)\n\n### 3.2绘制矩形\n\n<kbd>canvas</kbd>只支持一种原生的图形绘制：***矩形***。所有其他图形都至少需要生成一种路径(path)。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。\n\ncanvas提供了三种方法绘制矩形：\n\n* fillRect(x, y, width, height)：绘制一个填充的矩形。\n* strokeRect(x, y, width, height)：绘制一个矩形的边框。\n* clearRect(x, y, width, height)：清除指定的矩形区域，然后这块区域会变的完全透明。\n\n> 说明：这3个方法具有相同的参数。\n>\n> * x,y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)\n> * width,height：指的是绘制的矩形的宽和高。\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.fillRect(10,10,100,50) //绘制矩形，填充的默认颜色为黑色\n    ctx.strokeRect(10, 70, 100 ,50) //绘制矩形边框\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2400420933-5b74dd8f80306_articlex.png)\n\n```javascript\nctx.clearRect(15, 15, 50, 25)\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2347163070-5b74dd8f813a6_articlex.png)\n\n## 四、绘制路径(path)\n\n图形的基本元素是路径。\n\n路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。\n\n一个路径，甚至一个子路径，都是闭合的。\n\n***使用路径绘制图形需要一些额外的步骤：***\n\n> 1. 创建路径起始点\n> 2. 调用绘制方法去绘制出路径\n> 3. 把路径封闭\n> 4. 一旦路径生成，通过描边或填充路径区域来渲染图形\n\n***下面是需要用到的方法：***\n\n> 1. beginPath()\n>\n> ​       新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径\n>\n> 2. moveTo(x, y)\n>\n>    把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。\n>\n> 3. closePath()\n>\n>    闭合路径之后，图形绘制命令又重新指向到上下文中\n>\n> 4. stroke()\n>\n>    通过线条来绘制图形轮廓\n>\n> 5. fill()\n>\n>    通过填充路径的内容区域生成实心的图形\n\n\n\n## 4.1绘制线段\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath() //新建一条path\n    ctx.moveTo(50,50) // 把画笔移动到指定的坐标\n    ctx.lineTo(200,50) //绘制一条从当前位置到指定坐标(200,50)的直线\n    ctx.closePath() //闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做\n    ctx.stroke() //绘制路径\n}\ndraw()\n```\n\n## 4.2绘制三角形边框\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElmentById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    ctx.lineTo(200,50)\n    ctx.lineTo(200,200)\n    ctx.closePath() //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个三角形\n    ctx.stroke() //描边。stroke不会自动closePath()\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2106846415-5b74dd8f67000_articlex.png)\n\n\n\n## 4.3填充三角形\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    ctx.lineTo(200,50)\n    ctx.lineTo(200,200)\n    ctx.fill() //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径\n}\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3457015746-5b74dd8f72860_articlex.png)\n\n\n\n## 4.4绘制圆弧\n\n有两个方法可以绘制圆弧：\n\n1. arc(x, y, r, startAngle, endAngle, anticlockwise): \n\n   以(x,y) 为圆心，以r为半径，从startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针(默认是顺时针)。\n\n   >1. 这里的度数都是弧度。\n   >\n   >2. 0弧度是指的x轴正方向。\n   >\n   >   >radians = (Math.PI/180)*degrees //角度转换成弧度\n\n2. arcTo(x1,y1,x2,y2,radius):\n\n   根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。\n\n```javascript\n//圆弧案例1\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.arc(50,50,40,0,Math.PI /2, false)\n    ctx.stroke()\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3832141455-5b74dd8f658df_articlex.png)\n\n```javascript\n//圆弧案例2\nfuncion draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.arc(50,50,50,0,Math.PI/2,false)\n    ctx.stroke()\n    \n    ctx.beginPath()\n    ctx.arc(150,50,40,0,-Math.PI/2,true)\n    ctx.closePath()\n    ctx.stroke()\n    \n    ctx.beginPath()\n    ctx.arc(50,150,40,-Math.PI/2,Math.PI/2,false)\n    ctx.fill()\n    \n    ctx.beginPath()\n    ctx.arc(150,150,40,0,Math.PI,false)\n    ctx.fill()\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2218794221-5b74dd8f43f98_articlex.png)\n\n```javascript\n//圆弧案例3\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    //参数1、2：控制点1坐标\n    //参数3、4：控制点2坐标\n    //参数5：圆弧半径\n    ctx.arcTo(200,50,200,200,100)\n    ctx.lineTo(200,200)\n    ctx.stroke()\n    \n    ctx.beginPath()\n    ctx.rect(50,50,10,10)\n    ctx.rect(200,50,10,10)\n    ctx.rect(200,200,10,10)\n    ctx.fill()\n}\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3556678928-5b74dd8f1bd2a_articlex.png)\n\n> arcTo方法的说明：\n>\n> 这个方法可以这样理解。绘制的弧形是由两条切线所决定。\n>\n> 第1条切线：起始点和控制点1决定的直线。\n>\n> 第2条切线：控制点1和控制点2决定的直线。\n>\n> 其实绘制的圆弧就是与这两条直线相切的圆弧。\n\n\n\n## 4.5绘制贝塞尔曲线\n\n### 4.5.1什么是贝塞尔曲线\n\n贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。\n\n一般的矢量图形软件通过它来精确画出曲线，贝兹曲线是由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。\n\n贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具入PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。\n\n贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau 于 1959 年运用 de Casteljau 演算法开发，以稳定数值的方法求出贝兹曲线。\n\n***一次贝塞尔曲线其实是一条直线***\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/240px-b_1_big.gif)\n\n***二次贝塞尔曲线***\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/b_2_big.gif)\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/1544764428-5713-240px-BC3A9zier-2-big.svg-.png)\n\n三次贝塞尔曲线\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/b_3_big.gif)\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/1544764428-2467-240px-BC3A9zier-3-big.svg-.png)\n\n\n\n### 4.5.2绘制贝塞尔曲线\n\n1. 绘制二次贝塞尔曲线：/kwɒ'drætɪk/\n\n```javascript\nquadraticCurveTo(cp1x,cp1y,x,y)\n```\n\n> 说明：\n>\n> * 参数1和2：控制点坐标\n> * 参数3和4：结束点坐标\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.beginPath()\n    ctx.moveTo(10,200) //起始点\n    var cp1x = 40, cp1y = 100 //控制点\n    var x = 200, y = 200 //结束点\n    //绘制二次贝塞尔曲线\n    ctx.quadraticCurveTo(cp1x, cp1y, x, y)\n    ctx.stroke()\n    \n    ctx.beginPath()\n    ctx.rect(10,200,10,10)\n    ctx.rect(cp1x,cp1y,10,10)\n    ctx.rect(x,y,10,10)\n    ctx.fill()\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/274915666-5b74dd8ecb2e2_articlex.png)\n\n2. 绘制三次贝塞尔曲线:\n\n   ```javascript\n   bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\n   ```\n\n   > 说明：\n   >\n   > * 参数1和2：控制点1的坐标\n   > * 参数3和4：控制点2的坐标\n   > * 参数5和6：结束点的坐标\n\n   \n\n   ```javascript\n   function draw() {\n   \tvar canvas = document.getElementById('tutorial')\n       if(!canvas.getContext) return\n       var ctx = canvas.getContext('2d')\n       ctx.beginPath()\n       ctx.moveTo(40,200) //起始点\n       var cp1x = 20, cp1y = 100 //控制点1\n       var cp2x = 100, cp2y = 120 //控制点2\n       var x = 200, y = 200 //结束点\n       //绘制三次贝塞尔曲线\n       ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)\n       ctx.stroke()\n       \n       ctx.beginPath();\n       ctx.rect(40, 200, 10, 10);\n       ctx.rect(cp1x, cp1y, 10, 10);\n       ctx.rect(cp2x, cp2y, 10, 10);\n       ctx.rect(x, y, 10, 10);\n       ctx.fill();\n   }\n   draw()\n   ```\n\n   \n\n   ![img](https://www.runoob.com/wp-content/uploads/2018/12/3947786617-5b74dd8ec8678_articlex.png)\n\n\n\n# 五、添加样式和颜色\n\n在前面的绘制矩形章节中，只用到了默认的线条和颜色。\n\n如果想要给图形上色，有两个重要的属性可以做到。\n\n1. fillStyle = color 设置图形的填充颜色\n2. strokeStyle = color 设置图形轮廓的颜色\n\n> 备注：\n>\n> 1. color可以是表达css颜色值的字符串、渐变对象或者图案对象\n> 2. 默认情况下，线条和填充颜色都是黑色\n> 3. 一旦您设置了strokeStyle或者fillStyle的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置fillStyle或strokeStyle的值\n\n##     fillStyle\n\n\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    for(var i = 0; i < 6; i++) {\n\t\tfor(var j = 0; j < 6; j++) {\n\t\t\tctx.fillStyle = 'rgb(' + Math.floor(255 - 42.5 * i) + ',' + Math.floor(255 - 42.5 * j) + ',0)'\n            ctx.fillRect(j * 50, i * 50, 50, 50)\n        }\n    }\n}\ndraw()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/2505008676-5b74dd8ebad41_articlex.png)\n\n\n\n## strokeStyle\n\n\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    for(var i = 0; i < 6; i++) {\n\t\tfor(var j = 0;j < 6;j++) {\n\t\t\tctx.strokeStyle = `rgb(${randomInt(0,255)}, ${randomInt(0,255)}, ${randomInt(0,255)})`\n            ctx.strokeRect(j*50,i*50,40,40)\n        }\n    }\n}\ndraw()\n\n//返回随机的[from,to]之间的整数(包括from，也包括to)\nfunction randomInt(from,to) {\n\treturn parseInt(Math.random() * (to-from +1) + from)\n}\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3288535670-5b74dd8ea12d9_articlex.png)\n\n## Transparency(透明度)\n\n\n\nglobalAlpha = transparencyValue:这个属性影响到canvas里所有图形的透明度，有效的值范围是0.0（完全透明）到1.0（完全不透明），默认是1.0\n\n**globalAlpha**属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更好一些。\n\n**1. line style**\n\n线宽。只能是正值。默认是1.0\n\n起始点和终点的连线为中心，上下各占线宽的一半。\n\n```javascript\nctx.beginPath()\nctx.moveTo(10,10)\nctx.lineTo(100,10)\nctx.lineWidth = 10\nctx.stroke()\n\nctx.beginPath()\nctx.moveTo(110,10)\nctx.lineTo(160,10)\nctx.lineWidth = 20\nctx.stroke()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3410060825-5b74dd8ea12d9_articlex.png)\n\n**2. lineCap = type**\n\n线条末端样式。\n\n> 共有三个值：\n>\n> 1. butt： 线段末端以方形结束\n> 2. round：线段末端以圆形结束\n> 3. square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一般的矩形区域\n\n```javascript\nvar lineCaps = ['butt', 'round', 'square']\nfor(var i = 0;i<3;i++) {\n\tctx.beginPath()\n    ctx.moveTo(20+30*i,30)\n    ctx.lineTo(20+30*i,100)\n    ctx.lineWidth = 20\n    ctx.lineCap = lineCaps[i]\n    ctx.stroke()\n}\n\nctx.beginPath()\nctx.moveTo(0,30)\nctx.lineTo(300,30)\n\nctx.moveTo(0,100)\nctx.lineTo(300,100)\n\nctx.strokeStyle = 'red'\nctx.lineWidth = 1\nctx.stroke()\n```\n\n![img](https://www.runoob.com/wp-content/uploads/2018/12/3380216230-5b74dd8e97e85_articlex.png)\n\n**3. lineJoin = type**\n\n同一个path内，设定线条与线条间接合处的样式。\n\n共有三个值round,bevel和miter：\n\n1. round通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。圆角的半径是线段的宽度。\n2. bevel在相连部分的末端填充一个额外的以三角形为底的区域，每个部分都有各自独立的矩形拐角。\n3. miter(默认)通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    \n    var lineJoin = ['round','bevel', 'miter']\n    ctx.lineWidth = 20\n    for(var i =0; i< lineJoin.length;i++) {\n\t\tctx.lineJoin = lineJoin[i]\n        ctx.beginPath()\n        ctx.moveTo(50,50+i*50)\n        ctx.lineTo(100,100+i*50)\n        ctx.lineTo(150,50+i*50)\n        ctx.lineTo(200,100+i*50)\n        ctx.lineTo(250,50+i*50)\n        ctx.stroke()\n    }\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/1584506777-5b74dd8e82768_articlex.png)\n\n\n\n**4. 虚线**\n\n用setLineDash方法和lineDashOffset属性来指定虚线样式。\n\nsetLineDash方法接收一个数组，来指定线段与间隙的交替；\n\nlineDashOffset属性设置起始偏移量。\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.setLineDash([20,5]) //[实线长度，间隙长度]\n    ctx.lineDashOffset = -0\n    ctx.strokeRect(50,50,210,210)\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/2805401035-5b74dd8e6833c_articlex.png)\n\n> 备注：getLineDash()返回一个包含当前虚线样式，长度为非偶数的数组。\n\n\n\n# 六、绘制文本\n\n***绘制文本的两个方法***\n\ncanvas提供了两种方法来渲染文本：\n\n1. fillText(text, x, y, [, maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的。\n\n2. strokeText(text, x, y, [, maxWidth])在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的。\n\n   ```javascript\n   var ctx;\n   function draw() {\n   \tvar canvas = document.getELementById('tutorial')\n       if(!canvas.getContext) return\n       ctx = canvas.getContext('2d')\n       ctx.font = '100px sans-serif'\n       ctx.fillText('天若有情',10,100)\n       ctx.strokeText('天若有情',10,200)\n   }\n   draw()\n   ```\n\n   1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/404304980-5b74dd8e7499e_articlex.png)\n\n\n\n***给文本添加样式***\n\n1. font = value 当前我们用来绘制文本的样式。这个字符串使用和css font属性相同的语法。**默认的字体是10px sans-serif。**\n2. textAlign = value 文本对齐选项。可选的值包括：start，end，left，right，center。**默认是start。**\n3. textBaseline = value 基线对齐选项，可选的值包括：top，hanging，middle，alphabetic，ideographic，bottom。**默认值是alphabetic。**\n4. direction = value 文本方向。可能的值包括：ltr，rtl，inherit。**默认值是inherit。**\n\n\n\n# 七、绘制图片\n\n我们也可以在canvas上直接绘制图片。\n\n## 7.1由零开始创建图片\n\n```javascript\nvar img = new Image() //创建一个<img>元素\nimg.src = 'myImage.png' //设置图片原地址\n```\n\n**绘制img**\n\n```javascript\n//参数1：要绘制的img\n//参数2、3：绘制的img在canvas中的坐标\nctx.drawImage(img,0,0)\n```\n\n> 注意：考虑到图片是从网络加载，如果drawImage的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在img绘制完成之后再drawImage。\n\n```javascript\nvar img = new Image() //创建img元素\nimg.onload = function() {\n\tctx.drawImage(img, 0, 0)\n}\nimg.src = 'myImage.png' //设置图片c地址\n```\n\n\n\n## 7.2 绘制img标签元素中的图片\n\nimg可以new，也可以来源于我们页面中的<img>标签。\n\n```html\n<img src=\"./美女.jpg\" alt=\"\" width=\"300\"><br>\n<canvas id=\"tutorial\" width=\"600\" height=\"400\"></canvas>\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial)\n\tif(!canvas.getContext) return\n\tvar ctx = canvas.getContext('2d')\n\tvar img = document.querySelector('img')\n\tctx.drawImg(img,0,0)\n}\ndocument.querySelector('img').onclick = function() {\n\tdraw()\n}\n```\n\n1. 1. 第一张图片就是页面中的 `<img>` 标签：\n\n2. ![img](https://www.runoob.com/wp-content/uploads/2018/12/2255709523-5b74dd8eb033e_articlex.png)\n\n\n\n## 7.3 缩放图片\n\ndrawImage()可以再添加两个参数：\n\n```javascript\ndrawImage(image,x,y,width,height)\n```\n\n这个方法多了两个参数：width和height，这两个参数用来控制 当像canvas画入时应该缩放的大小。\n\n```javascript\nctx.drawImage(img,0,0,400,200)\n```\n\n\n\n##7.4 切片(slice)\n\n```javascript\ndrawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)\n```\n\n第一个参数和其他的是相同的，都是一个图像或者另一个canvas的引用。\n\n其他8个参数：前4个事定义图像源的切片位置和大小，后四个则是定义切片的目标显示位置和大小。\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/2106688680-54566fa3d81dc_articlex.jpeg)\n\n\n\n# 八、状态的保存和恢复\n\nSaving and restoring state是绘制复杂图形时必不可少的操作。\n\nsave()和restore()\n\nsave和restore方法是用来保存和恢复canvas状态的，都没有参数。\n\nCanvas的状态就是当前画面应用的所有样式和变形的一个快照。\n\n## 8.1 关于save()\n\n> Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。\n\n一个绘画状态包括:\n\n* 当前应用的变形（即移动，旋转和缩放）\n\n* strokeStyle,fillStyle,globalAlpha,lineWidth,lineCap,lineJoin,miterLimit,shadowOffsetX,shadowOffsetY,shadowBlur,shadowColor,globalCompositeOperation的值\n\n* 当前的裁切路径（clipping path)\n\n  \n\n  ***可以调用任意多次save方法（类似数组的push()）***\n\n## 8.2关于resotre()\n\n> 每一次调用restore方法，上一个保存的状态就从栈中弹出，所有设定都恢复（类似数组pop()）\n\n```javascript\nvar ctx;\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    \n    ctx.fillRect(0,0,150,150) //使用默认设置绘制一个矩形\n    ctx.save() //保存默认状态\n    \n    ctx.fillStyle = 'red' //在原有配置基础上对颜色做改变\n    ctx.fillRect(15,15,120,120) //使用心得设置绘制一个矩形\n    \n    ctx.save() //保存当前状态\n\tctx.fillStyle = '#FFF' //再次改变颜色状态\n    ctx.fillRect(30,30,90,90) //使用心得配置绘制一个矩形\n    \n    ctx.restore() //重新加载之前的颜色状态\n    ctx.fillRect(45,45,60,60) //使用上一次的配置绘制一个矩形\n    \n    ctx.restore() //加载默认颜色配置\n    ctx.fillRect(60,60,30,30) //使用加载的配置绘制一个矩形\n}\ndraw()\n```\n\n\n\n# 九、变形\n\n## 9.1translate\n\ntranslate(x,y)\n\n用来移动canvas的原点到指定的位置\n\ntranslate方法接收两个参数。x是左右偏移量，y是上下偏移量，如图所示。\n\n在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用restore方法比手动恢复原形的状态要简单得多。又如果你是在一个循环中做位移但没有保存和恢复canvas的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出canvas范围以外了。注意：translate移动的是canvas的坐标原点(坐标变换)。\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/829832336-5b74dd8e3ad9a_articlex.png)\n\n```javascript\nvar ctx;\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.save() //保存坐标原点平移之前的状态\n    ctx.translate(100,100)\n    ctx.strokeRect(0,0,100,100)\n    ctx.restore()\n    ctx.translate(220,200)\n    ctx.fillRect(0,0,100,100)\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/1230266743-5b74dd8e3b0ce_articlex.png)\n\n\n\n## 9.2 rotate\n\nrotate(angle)\n\n旋转坐标轴。\n\n这个方法只接受一个参数：旋转的角度（angle），它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/3322150878-5b74dd8e2b6a4_articlex.png)\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvs.getContext) return\n    var ctx = canvas.getContext('2d')\n    \n    ctx.fillStyle = 'red'\n    ctx.save()\n    \n    ctx.translate(100,100)\n    ctx.rotate(Math.PI/180*45)\n    ctx.fillStyle = 'blue'\n    ctx.fillRect(0,0,100,100)\n    ctx.restore()\n    \n    ctx.save()\n    ctx.translate(0,0)\n    ctx.fillRect(0,0,50,50)\n    ctx.restore()\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/1819968878-5b74dd8e1e770_articlex.png)\n\n\n\n## 9.3 scale\n\nscale(x,y)\n\n我们用它来增减图形在canvas中的像素数目，对形状、位图进行缩小或者放大。\n\nscale方法接受两个参数。x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比1.0小表示缩小，比1.0大表示放大，值为1.0时什么效果都没有。\n\n默认情况下，canvas的1单位就是1个像素。举例说，如果我们设置缩放因子是0.5，1个单位就变成对应0.5个像素，这样绘制出来的形状就会是原先的一半。同理，设置为2.0时，1个单位就对应变成了2像素，绘制的结果就是图形放大了2倍。\n\n\n\n## 9.4 transform(变形矩阵)\n\ntransform(a,b,c,d,e,f)\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/2958376259-5b74dd8e15192_articlex.png)\n\n* a (m11): Horizontal scaling.\n* b (m12): Horizontal skewing.\n* c (m21): Vertical skewing.\n* d (m22): Vertical scaling.\n* e (dx): Horizontal moving.\n* f (dy): Vertical moving.\n\n```javascript\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial')\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.transform(1,1,0,1,0,0)\n    ctx.fillRect(0,0,100,100)\n}\ndraw()\n```\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/489430190-5b74dd8e17ad2_articlex.png)\n\n\n\n## 十、合成\n\n在前面的所有例子中，我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用globalCompositeOperation属性来改变这种情况。\n\n```javascript\nglobalCompositeOperation = type\n```\n\n```javascript\nvar ctx;\nfunction draw() {\n\tvar canvas = document.getElementById('tutorial');\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext('2d')\n    ctx.fillStyle = 'blue'\n    ctx.fillRect(0,0,200,200)\n    \n    ctx.globalCompositeOperation = 'source-over' //全局合成操作\n    ctx.fillStyle = 'red'\n    ctx.fillRect(100,100,200,200)\n}\n```\n\n> 注：下面的展示中，蓝色是原有的，红色是新的。\n>\n> type是下面13中字符串值之一:\n\n1. 这是默认设置，新图像会覆盖在原有图像。\n\n1. ![img](https://www.runoob.com/wp-content/uploads/2018/12/1858023544-5b74dd8e0813d.png)\n\n","slug":"canvas","published":1,"updated":"2021-08-13T08:08:32.209Z","layout":"post","link":"","_id":"cku2cstr000154v9k5dc25lp7","content":"<h2 id=\"一、canvas简介\"><a href=\"#一、canvas简介\" class=\"headerlink\" title=\"一、canvas简介\"></a>一、canvas简介</h2><p><kbd>canvas</kbd>是HTML5新增的，一个可以使用脚本（通常为JavaScript）在其中绘制图像的HTML元素。它可以用来制作照片或者制作简单（也不是那么简单）的动画，甚至可以进行实时视频处理和渲染。</p>\n<p>它最初由苹果内部使用自己MacOS X Webkit推出，供应用程序使用像仪表盘的构件和Safari浏览器使用。后来，有人通过Gecko内核的浏览器（尤其是Mozilla和Firefox），Opera和Chrome和超文本网络应用技术工作组建议为下一代的网络技术使用该元素。</p>\n<p>Canvas是由HTML代码配合高度和宽度属性而定义出的可绘制区域。JavaScript代码可以访问该区域，类似于其他通用的二维API，通过一套完整的绘图函数来动态生成图形。</p>\n<p>Mozilla程序从Geko1.8（Firefox1.5）开始支持<kbd>canvas</kbd>，Internet Explorer从IE9开始<kbd>canvas</kbd>。Chrome和Opera9+也支持<kbd>canvas</kbd>。</p>\n<h2 id=\"二、Canvas基本使用\"><a href=\"#二、Canvas基本使用\" class=\"headerlink\" title=\"二、Canvas基本使用\"></a>二、Canvas基本使用</h2><h3 id=\"2-1canvas元素\"><a href=\"#2-1canvas元素\" class=\"headerlink\" title=\"2.1canvas元素\"></a>2.1canvas元素</h3><p><kbd>canvas</kbd>看起来和<kbd><code>&lt;img&gt;</code></kbd>标签一样，只是<kbd>canvas</kbd>只有两个可选的属性width、height属性，而没有src、alt属性。</p>\n<p>如果不给<kbd>canvas</kbd>设置width、height属性时，则默认width为300、height为150，单位都是px。也可以使用css属性来设置宽高，但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用css属性来设置<kbd>canvas</kbd>的宽高。</p>\n<p><strong><em>替换内容</em></strong></p>\n<p>由于某些较老的浏览器（尤其是IE9之前的IE浏览器）或者浏览器不支持HTML元素<kbd>canvas</kbd>，在这些浏览器上你应该总是能展示替代内容。</p>\n<p>支持<kbd>canvas</kbd>的浏览器会只渲染<kbd>canvas</kbd>标签，而忽略其中的替代内容。不支持<kbd></kbd>canvas的浏览器会直接渲染替代内容。</p>\n<p>用文本替换：</p>\n<pre><code class=\"html\">&lt;canvas&gt;\n    你的浏览器不支持canvas，请升级你的浏览器。\n&lt;/canvas&gt;\n</code></pre>\n<p>用<kbd><code>&lt;img&gt;</code></kbd>替换：</p>\n<pre><code class=\"html\">&lt;canvas&gt;\n    &lt;img src=&quot;./美女.jgp&quot; alt=&quot;&quot;&gt;\n&lt;/canvas&gt;\n</code></pre>\n<p><strong><em>结束标签不可省略</em></strong></p>\n<p>与<kbd><code>&lt;img&gt;</code></kbd>元素不同，<kbd>canvas</kbd>元素需要结束标签（）。如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。</p>\n<p>##2.2渲染上下文（Thre Rending Context）</p>\n<p><kbd>canvas</kbd>会创建一个固定大小的画布，会公开一个或多个<strong>渲染上下文</strong>(画笔)，使用<strong>渲染上下文</strong>来绘制和处理要展示的内容。</p>\n<p>我们重点研究2D渲染上下文。其他的上下文我们暂不研究，比如，WebGL使用了基于OpenGLES的3D上下文。</p>\n<pre><code class=\"javascript\">var canvas = document.getElementById(&#39;tutorial&#39;);\n//获得2d上下文对象\nvar ctx = canvas.getContext(&#39;2d&#39;)\n</code></pre>\n<h3 id=\"2-3检测支持性\"><a href=\"#2-3检测支持性\" class=\"headerlink\" title=\"2.3检测支持性\"></a>2.3检测支持性</h3><pre><code class=\"javascript\">var canvas = document.getElementById(&#39;tutorial&#39;);\nif(canvas.getContext) {\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    // drawing code here\n} else {\n    // canvas-unsupported code here\n}\n</code></pre>\n<h3 id=\"2-4代码模板\"><a href=\"#2-4代码模板\" class=\"headerlink\" title=\"2.4代码模板\"></a>2.4代码模板</h3><pre><code class=\"html\">&lt;canvas id=&quot;tutorial&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function draw() {\n        var canvas = document.getElementById(&#39;tutorial&#39;);\n        if(!canvas.getContext) return\n        var ctx = canvas.getContext(&#39;2d&#39;)\n        //开始写代码\n    }\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"2-5一个简单的例子\"><a href=\"#2-5一个简单的例子\" class=\"headerlink\" title=\"2.5一个简单的例子\"></a>2.5一个简单的例子</h3><p>以下实例绘制两个长方形</p>\n<pre><code class=\"html\">&lt;canvas id=&quot;tutorial&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function draw() {\n        var canvas = document.getElementById(&#39;tutorial&#39;);\n        if(!canvas.getContext) return\n        var ctx = canvas.getContext(&#39;2d&#39;)\n        ctx.fillStyle = &quot;rgb(200,0,0)&quot;\n        //绘制矩形\n        ctx.fillRect (10,10,55,50)\n        ctx.fillStyle = &quot;rgb(0,0,200,0.5)&quot;\n        ctx.fillRect (30,30,55,50)\n    }\n    draw()\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"三、绘制形状\"><a href=\"#三、绘制形状\" class=\"headerlink\" title=\"三、绘制形状\"></a>三、绘制形状</h2><h3 id=\"3-1栅格-grid-和坐标空间\"><a href=\"#3-1栅格-grid-和坐标空间\" class=\"headerlink\" title=\"3.1栅格(grid)和坐标空间\"></a>3.1栅格(grid)和坐标空间</h3><p>如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元 相当于canvas元素中的一像素。栅格的起点为左上角，坐标为(0,0)。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素，坐标为(x,y)。</p>\n<p>后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/Canvas_default_grid.png\" alt=\"img\"></p>\n<h3 id=\"3-2绘制矩形\"><a href=\"#3-2绘制矩形\" class=\"headerlink\" title=\"3.2绘制矩形\"></a>3.2绘制矩形</h3><p><kbd>canvas</kbd>只支持一种原生的图形绘制：<strong><em>矩形</em></strong>。所有其他图形都至少需要生成一种路径(path)。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。</p>\n<p>canvas提供了三种方法绘制矩形：</p>\n<ul>\n<li>fillRect(x, y, width, height)：绘制一个填充的矩形。</li>\n<li>strokeRect(x, y, width, height)：绘制一个矩形的边框。</li>\n<li>clearRect(x, y, width, height)：清除指定的矩形区域，然后这块区域会变的完全透明。</li>\n</ul>\n<blockquote>\n<p>说明：这3个方法具有相同的参数。</p>\n<ul>\n<li>x,y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)</li>\n<li>width,height：指的是绘制的矩形的宽和高。</li>\n</ul>\n</blockquote>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.fillRect(10,10,100,50) //绘制矩形，填充的默认颜色为黑色\n    ctx.strokeRect(10, 70, 100 ,50) //绘制矩形边框\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2400420933-5b74dd8f80306_articlex.png\" alt=\"img\"></p>\n<pre><code class=\"javascript\">ctx.clearRect(15, 15, 50, 25)\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2347163070-5b74dd8f813a6_articlex.png\" alt=\"img\"></p>\n<h2 id=\"四、绘制路径-path\"><a href=\"#四、绘制路径-path\" class=\"headerlink\" title=\"四、绘制路径(path)\"></a>四、绘制路径(path)</h2><p>图形的基本元素是路径。</p>\n<p>路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。</p>\n<p>一个路径，甚至一个子路径，都是闭合的。</p>\n<p><strong><em>使用路径绘制图形需要一些额外的步骤：</em></strong></p>\n<blockquote>\n<ol>\n<li>创建路径起始点</li>\n<li>调用绘制方法去绘制出路径</li>\n<li>把路径封闭</li>\n<li>一旦路径生成，通过描边或填充路径区域来渲染图形</li>\n</ol>\n</blockquote>\n<p><strong><em>下面是需要用到的方法：</em></strong></p>\n<blockquote>\n<ol>\n<li>beginPath()</li>\n</ol>\n<p>​       新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径</p>\n<ol start=\"2\">\n<li><p>moveTo(x, y)</p>\n<p>把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。</p>\n</li>\n<li><p>closePath()</p>\n<p>闭合路径之后，图形绘制命令又重新指向到上下文中</p>\n</li>\n<li><p>stroke()</p>\n<p>通过线条来绘制图形轮廓</p>\n</li>\n<li><p>fill()</p>\n<p>通过填充路径的内容区域生成实心的图形</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"4-1绘制线段\"><a href=\"#4-1绘制线段\" class=\"headerlink\" title=\"4.1绘制线段\"></a>4.1绘制线段</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath() //新建一条path\n    ctx.moveTo(50,50) // 把画笔移动到指定的坐标\n    ctx.lineTo(200,50) //绘制一条从当前位置到指定坐标(200,50)的直线\n    ctx.closePath() //闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做\n    ctx.stroke() //绘制路径\n}\ndraw()\n</code></pre>\n<h2 id=\"4-2绘制三角形边框\"><a href=\"#4-2绘制三角形边框\" class=\"headerlink\" title=\"4.2绘制三角形边框\"></a>4.2绘制三角形边框</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElmentById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    ctx.lineTo(200,50)\n    ctx.lineTo(200,200)\n    ctx.closePath() //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个三角形\n    ctx.stroke() //描边。stroke不会自动closePath()\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2106846415-5b74dd8f67000_articlex.png\" alt=\"img\"></p>\n<h2 id=\"4-3填充三角形\"><a href=\"#4-3填充三角形\" class=\"headerlink\" title=\"4.3填充三角形\"></a>4.3填充三角形</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    ctx.lineTo(200,50)\n    ctx.lineTo(200,200)\n    ctx.fill() //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径\n}\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3457015746-5b74dd8f72860_articlex.png\" alt=\"img\"></p>\n<h2 id=\"4-4绘制圆弧\"><a href=\"#4-4绘制圆弧\" class=\"headerlink\" title=\"4.4绘制圆弧\"></a>4.4绘制圆弧</h2><p>有两个方法可以绘制圆弧：</p>\n<ol>\n<li><p>arc(x, y, r, startAngle, endAngle, anticlockwise): </p>\n<p>以(x,y) 为圆心，以r为半径，从startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针(默认是顺时针)。</p>\n<blockquote>\n<ol>\n<li><p>这里的度数都是弧度。</p>\n</li>\n<li><p>0弧度是指的x轴正方向。</p>\n<blockquote>\n<p>radians = (Math.PI/180)*degrees //角度转换成弧度</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>arcTo(x1,y1,x2,y2,radius):</p>\n<p>根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">//圆弧案例1\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.arc(50,50,40,0,Math.PI /2, false)\n    ctx.stroke()\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3832141455-5b74dd8f658df_articlex.png\" alt=\"img\"></p>\n<pre><code class=\"javascript\">//圆弧案例2\nfuncion draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.arc(50,50,50,0,Math.PI/2,false)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.arc(150,50,40,0,-Math.PI/2,true)\n    ctx.closePath()\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.arc(50,150,40,-Math.PI/2,Math.PI/2,false)\n    ctx.fill()\n\n    ctx.beginPath()\n    ctx.arc(150,150,40,0,Math.PI,false)\n    ctx.fill()\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2218794221-5b74dd8f43f98_articlex.png\" alt=\"img\"></p>\n<pre><code class=\"javascript\">//圆弧案例3\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    //参数1、2：控制点1坐标\n    //参数3、4：控制点2坐标\n    //参数5：圆弧半径\n    ctx.arcTo(200,50,200,200,100)\n    ctx.lineTo(200,200)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.rect(50,50,10,10)\n    ctx.rect(200,50,10,10)\n    ctx.rect(200,200,10,10)\n    ctx.fill()\n}\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3556678928-5b74dd8f1bd2a_articlex.png\" alt=\"img\"></p>\n<blockquote>\n<p>arcTo方法的说明：</p>\n<p>这个方法可以这样理解。绘制的弧形是由两条切线所决定。</p>\n<p>第1条切线：起始点和控制点1决定的直线。</p>\n<p>第2条切线：控制点1和控制点2决定的直线。</p>\n<p>其实绘制的圆弧就是与这两条直线相切的圆弧。</p>\n</blockquote>\n<h2 id=\"4-5绘制贝塞尔曲线\"><a href=\"#4-5绘制贝塞尔曲线\" class=\"headerlink\" title=\"4.5绘制贝塞尔曲线\"></a>4.5绘制贝塞尔曲线</h2><h3 id=\"4-5-1什么是贝塞尔曲线\"><a href=\"#4-5-1什么是贝塞尔曲线\" class=\"headerlink\" title=\"4.5.1什么是贝塞尔曲线\"></a>4.5.1什么是贝塞尔曲线</h3><p>贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。</p>\n<p>一般的矢量图形软件通过它来精确画出曲线，贝兹曲线是由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。</p>\n<p>贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具入PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。</p>\n<p>贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau 于 1959 年运用 de Casteljau 演算法开发，以稳定数值的方法求出贝兹曲线。</p>\n<p><strong><em>一次贝塞尔曲线其实是一条直线</em></strong></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/240px-b_1_big.gif\" alt=\"img\"></p>\n<p><strong><em>二次贝塞尔曲线</em></strong></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/b_2_big.gif\" alt=\"img\"></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1544764428-5713-240px-BC3A9zier-2-big.svg-.png\" alt=\"img\"></p>\n<p>三次贝塞尔曲线</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/b_3_big.gif\" alt=\"img\"></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1544764428-2467-240px-BC3A9zier-3-big.svg-.png\" alt=\"img\"></p>\n<h3 id=\"4-5-2绘制贝塞尔曲线\"><a href=\"#4-5-2绘制贝塞尔曲线\" class=\"headerlink\" title=\"4.5.2绘制贝塞尔曲线\"></a>4.5.2绘制贝塞尔曲线</h3><ol>\n<li>绘制二次贝塞尔曲线：/kwɒ&#39;drætɪk/</li>\n</ol>\n<pre><code class=\"javascript\">quadraticCurveTo(cp1x,cp1y,x,y)\n</code></pre>\n<blockquote>\n<p>说明：</p>\n<ul>\n<li>参数1和2：控制点坐标</li>\n<li>参数3和4：结束点坐标</li>\n</ul>\n</blockquote>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.moveTo(10,200) //起始点\n    var cp1x = 40, cp1y = 100 //控制点\n    var x = 200, y = 200 //结束点\n    //绘制二次贝塞尔曲线\n    ctx.quadraticCurveTo(cp1x, cp1y, x, y)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.rect(10,200,10,10)\n    ctx.rect(cp1x,cp1y,10,10)\n    ctx.rect(x,y,10,10)\n    ctx.fill()\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/274915666-5b74dd8ecb2e2_articlex.png\" alt=\"img\"></p>\n<ol start=\"2\">\n<li><p>绘制三次贝塞尔曲线:</p>\n<pre><code class=\"javascript\">bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\n</code></pre>\n<blockquote>\n<p>说明：</p>\n<ul>\n<li>参数1和2：控制点1的坐标</li>\n<li>参数3和4：控制点2的坐标</li>\n<li>参数5和6：结束点的坐标</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"javascript\">   function draw() {\n       var canvas = document.getElementById(&#39;tutorial&#39;)\n       if(!canvas.getContext) return\n       var ctx = canvas.getContext(&#39;2d&#39;)\n       ctx.beginPath()\n       ctx.moveTo(40,200) //起始点\n       var cp1x = 20, cp1y = 100 //控制点1\n       var cp2x = 100, cp2y = 120 //控制点2\n       var x = 200, y = 200 //结束点\n       //绘制三次贝塞尔曲线\n       ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)\n       ctx.stroke()\n\n       ctx.beginPath();\n       ctx.rect(40, 200, 10, 10);\n       ctx.rect(cp1x, cp1y, 10, 10);\n       ctx.rect(cp2x, cp2y, 10, 10);\n       ctx.rect(x, y, 10, 10);\n       ctx.fill();\n   }\n   draw()\n</code></pre>\n<p>   <img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3947786617-5b74dd8ec8678_articlex.png\" alt=\"img\"></p>\n<h1 id=\"五、添加样式和颜色\"><a href=\"#五、添加样式和颜色\" class=\"headerlink\" title=\"五、添加样式和颜色\"></a>五、添加样式和颜色</h1><p>在前面的绘制矩形章节中，只用到了默认的线条和颜色。</p>\n<p>如果想要给图形上色，有两个重要的属性可以做到。</p>\n<ol>\n<li>fillStyle = color 设置图形的填充颜色</li>\n<li>strokeStyle = color 设置图形轮廓的颜色</li>\n</ol>\n<blockquote>\n<p>备注：</p>\n<ol>\n<li>color可以是表达css颜色值的字符串、渐变对象或者图案对象</li>\n<li>默认情况下，线条和填充颜色都是黑色</li>\n<li>一旦您设置了strokeStyle或者fillStyle的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置fillStyle或strokeStyle的值</li>\n</ol>\n</blockquote>\n<h2 id=\"fillStyle\"><a href=\"#fillStyle\" class=\"headerlink\" title=\"fillStyle\"></a>fillStyle</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    for(var i = 0; i &lt; 6; i++) {\n        for(var j = 0; j &lt; 6; j++) {\n            ctx.fillStyle = &#39;rgb(&#39; + Math.floor(255 - 42.5 * i) + &#39;,&#39; + Math.floor(255 - 42.5 * j) + &#39;,0)&#39;\n            ctx.fillRect(j * 50, i * 50, 50, 50)\n        }\n    }\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2505008676-5b74dd8ebad41_articlex.png\" alt=\"img\"></p>\n<h2 id=\"strokeStyle\"><a href=\"#strokeStyle\" class=\"headerlink\" title=\"strokeStyle\"></a>strokeStyle</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    for(var i = 0; i &lt; 6; i++) {\n        for(var j = 0;j &lt; 6;j++) {\n            ctx.strokeStyle = `rgb(${randomInt(0,255)}, ${randomInt(0,255)}, ${randomInt(0,255)})`\n            ctx.strokeRect(j*50,i*50,40,40)\n        }\n    }\n}\ndraw()\n\n//返回随机的[from,to]之间的整数(包括from，也包括to)\nfunction randomInt(from,to) {\n    return parseInt(Math.random() * (to-from +1) + from)\n}\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3288535670-5b74dd8ea12d9_articlex.png\" alt=\"img\"></p>\n<h2 id=\"Transparency-透明度\"><a href=\"#Transparency-透明度\" class=\"headerlink\" title=\"Transparency(透明度)\"></a>Transparency(透明度)</h2><p>globalAlpha = transparencyValue:这个属性影响到canvas里所有图形的透明度，有效的值范围是0.0（完全透明）到1.0（完全不透明），默认是1.0</p>\n<p><strong>globalAlpha</strong>属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更好一些。</p>\n<p><strong>1. line style</strong></p>\n<p>线宽。只能是正值。默认是1.0</p>\n<p>起始点和终点的连线为中心，上下各占线宽的一半。</p>\n<pre><code class=\"javascript\">ctx.beginPath()\nctx.moveTo(10,10)\nctx.lineTo(100,10)\nctx.lineWidth = 10\nctx.stroke()\n\nctx.beginPath()\nctx.moveTo(110,10)\nctx.lineTo(160,10)\nctx.lineWidth = 20\nctx.stroke()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3410060825-5b74dd8ea12d9_articlex.png\" alt=\"img\"></p>\n<p><strong>2. lineCap = type</strong></p>\n<p>线条末端样式。</p>\n<blockquote>\n<p>共有三个值：</p>\n<ol>\n<li>butt： 线段末端以方形结束</li>\n<li>round：线段末端以圆形结束</li>\n<li>square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一般的矩形区域</li>\n</ol>\n</blockquote>\n<pre><code class=\"javascript\">var lineCaps = [&#39;butt&#39;, &#39;round&#39;, &#39;square&#39;]\nfor(var i = 0;i&lt;3;i++) {\n    ctx.beginPath()\n    ctx.moveTo(20+30*i,30)\n    ctx.lineTo(20+30*i,100)\n    ctx.lineWidth = 20\n    ctx.lineCap = lineCaps[i]\n    ctx.stroke()\n}\n\nctx.beginPath()\nctx.moveTo(0,30)\nctx.lineTo(300,30)\n\nctx.moveTo(0,100)\nctx.lineTo(300,100)\n\nctx.strokeStyle = &#39;red&#39;\nctx.lineWidth = 1\nctx.stroke()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3380216230-5b74dd8e97e85_articlex.png\" alt=\"img\"></p>\n<p><strong>3. lineJoin = type</strong></p>\n<p>同一个path内，设定线条与线条间接合处的样式。</p>\n<p>共有三个值round,bevel和miter：</p>\n<ol>\n<li>round通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。圆角的半径是线段的宽度。</li>\n<li>bevel在相连部分的末端填充一个额外的以三角形为底的区域，每个部分都有各自独立的矩形拐角。</li>\n<li>miter(默认)通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。</li>\n</ol>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n\n    var lineJoin = [&#39;round&#39;,&#39;bevel&#39;, &#39;miter&#39;]\n    ctx.lineWidth = 20\n    for(var i =0; i&lt; lineJoin.length;i++) {\n        ctx.lineJoin = lineJoin[i]\n        ctx.beginPath()\n        ctx.moveTo(50,50+i*50)\n        ctx.lineTo(100,100+i*50)\n        ctx.lineTo(150,50+i*50)\n        ctx.lineTo(200,100+i*50)\n        ctx.lineTo(250,50+i*50)\n        ctx.stroke()\n    }\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1584506777-5b74dd8e82768_articlex.png\" alt=\"img\"></li>\n</ol>\n<p><strong>4. 虚线</strong></p>\n<p>用setLineDash方法和lineDashOffset属性来指定虚线样式。</p>\n<p>setLineDash方法接收一个数组，来指定线段与间隙的交替；</p>\n<p>lineDashOffset属性设置起始偏移量。</p>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.setLineDash([20,5]) //[实线长度，间隙长度]\n    ctx.lineDashOffset = -0\n    ctx.strokeRect(50,50,210,210)\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2805401035-5b74dd8e6833c_articlex.png\" alt=\"img\"></li>\n</ol>\n<blockquote>\n<p>备注：getLineDash()返回一个包含当前虚线样式，长度为非偶数的数组。</p>\n</blockquote>\n<h1 id=\"六、绘制文本\"><a href=\"#六、绘制文本\" class=\"headerlink\" title=\"六、绘制文本\"></a>六、绘制文本</h1><p><strong><em>绘制文本的两个方法</em></strong></p>\n<p>canvas提供了两种方法来渲染文本：</p>\n<ol>\n<li><p>fillText(text, x, y, [, maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的。</p>\n</li>\n<li><p>strokeText(text, x, y, [, maxWidth])在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的。</p>\n<pre><code class=\"javascript\">var ctx;\nfunction draw() {\n    var canvas = document.getELementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.font = &#39;100px sans-serif&#39;\n    ctx.fillText(&#39;天若有情&#39;,10,100)\n    ctx.strokeText(&#39;天若有情&#39;,10,200)\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/404304980-5b74dd8e7499e_articlex.png\" alt=\"img\"></li>\n</ol>\n</li>\n</ol>\n<p><strong><em>给文本添加样式</em></strong></p>\n<ol>\n<li>font = value 当前我们用来绘制文本的样式。这个字符串使用和css font属性相同的语法。<strong>默认的字体是10px sans-serif。</strong></li>\n<li>textAlign = value 文本对齐选项。可选的值包括：start，end，left，right，center。<strong>默认是start。</strong></li>\n<li>textBaseline = value 基线对齐选项，可选的值包括：top，hanging，middle，alphabetic，ideographic，bottom。<strong>默认值是alphabetic。</strong></li>\n<li>direction = value 文本方向。可能的值包括：ltr，rtl，inherit。<strong>默认值是inherit。</strong></li>\n</ol>\n<h1 id=\"七、绘制图片\"><a href=\"#七、绘制图片\" class=\"headerlink\" title=\"七、绘制图片\"></a>七、绘制图片</h1><p>我们也可以在canvas上直接绘制图片。</p>\n<h2 id=\"7-1由零开始创建图片\"><a href=\"#7-1由零开始创建图片\" class=\"headerlink\" title=\"7.1由零开始创建图片\"></a>7.1由零开始创建图片</h2><pre><code class=\"javascript\">var img = new Image() //创建一个&lt;img&gt;元素\nimg.src = &#39;myImage.png&#39; //设置图片原地址\n</code></pre>\n<p><strong>绘制img</strong></p>\n<pre><code class=\"javascript\">//参数1：要绘制的img\n//参数2、3：绘制的img在canvas中的坐标\nctx.drawImage(img,0,0)\n</code></pre>\n<blockquote>\n<p>注意：考虑到图片是从网络加载，如果drawImage的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在img绘制完成之后再drawImage。</p>\n</blockquote>\n<pre><code class=\"javascript\">var img = new Image() //创建img元素\nimg.onload = function() {\n    ctx.drawImage(img, 0, 0)\n}\nimg.src = &#39;myImage.png&#39; //设置图片c地址\n</code></pre>\n<h2 id=\"7-2-绘制img标签元素中的图片\"><a href=\"#7-2-绘制img标签元素中的图片\" class=\"headerlink\" title=\"7.2 绘制img标签元素中的图片\"></a>7.2 绘制img标签元素中的图片</h2><p>img可以new，也可以来源于我们页面中的<img>标签。</p>\n<pre><code class=\"html\">&lt;img src=&quot;./美女.jpg&quot; alt=&quot;&quot; width=&quot;300&quot;&gt;&lt;br&gt;\n&lt;canvas id=&quot;tutorial&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    var img = document.querySelector(&#39;img&#39;)\n    ctx.drawImg(img,0,0)\n}\ndocument.querySelector(&#39;img&#39;).onclick = function() {\n    draw()\n}\n</code></pre>\n<ol>\n<li><ol>\n<li>第一张图片就是页面中的 <code>&lt;img&gt;</code> 标签：</li>\n</ol>\n</li>\n<li><p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2255709523-5b74dd8eb033e_articlex.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h2 id=\"7-3-缩放图片\"><a href=\"#7-3-缩放图片\" class=\"headerlink\" title=\"7.3 缩放图片\"></a>7.3 缩放图片</h2><p>drawImage()可以再添加两个参数：</p>\n<pre><code class=\"javascript\">drawImage(image,x,y,width,height)\n</code></pre>\n<p>这个方法多了两个参数：width和height，这两个参数用来控制 当像canvas画入时应该缩放的大小。</p>\n<pre><code class=\"javascript\">ctx.drawImage(img,0,0,400,200)\n</code></pre>\n<p>##7.4 切片(slice)</p>\n<pre><code class=\"javascript\">drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)\n</code></pre>\n<p>第一个参数和其他的是相同的，都是一个图像或者另一个canvas的引用。</p>\n<p>其他8个参数：前4个事定义图像源的切片位置和大小，后四个则是定义切片的目标显示位置和大小。</p>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2106688680-54566fa3d81dc_articlex.jpeg\" alt=\"img\"></li>\n</ol>\n<h1 id=\"八、状态的保存和恢复\"><a href=\"#八、状态的保存和恢复\" class=\"headerlink\" title=\"八、状态的保存和恢复\"></a>八、状态的保存和恢复</h1><p>Saving and restoring state是绘制复杂图形时必不可少的操作。</p>\n<p>save()和restore()</p>\n<p>save和restore方法是用来保存和恢复canvas状态的，都没有参数。</p>\n<p>Canvas的状态就是当前画面应用的所有样式和变形的一个快照。</p>\n<h2 id=\"8-1-关于save\"><a href=\"#8-1-关于save\" class=\"headerlink\" title=\"8.1 关于save()\"></a>8.1 关于save()</h2><blockquote>\n<p>Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。</p>\n</blockquote>\n<p>一个绘画状态包括:</p>\n<ul>\n<li><p>当前应用的变形（即移动，旋转和缩放）</p>\n</li>\n<li><p>strokeStyle,fillStyle,globalAlpha,lineWidth,lineCap,lineJoin,miterLimit,shadowOffsetX,shadowOffsetY,shadowBlur,shadowColor,globalCompositeOperation的值</p>\n</li>\n<li><p>当前的裁切路径（clipping path)</p>\n</li>\n</ul>\n<p>  <strong><em>可以调用任意多次save方法（类似数组的push()）</em></strong></p>\n<h2 id=\"8-2关于resotre\"><a href=\"#8-2关于resotre\" class=\"headerlink\" title=\"8.2关于resotre()\"></a>8.2关于resotre()</h2><blockquote>\n<p>每一次调用restore方法，上一个保存的状态就从栈中弹出，所有设定都恢复（类似数组pop()）</p>\n</blockquote>\n<pre><code class=\"javascript\">var ctx;\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n\n    ctx.fillRect(0,0,150,150) //使用默认设置绘制一个矩形\n    ctx.save() //保存默认状态\n\n    ctx.fillStyle = &#39;red&#39; //在原有配置基础上对颜色做改变\n    ctx.fillRect(15,15,120,120) //使用心得设置绘制一个矩形\n\n    ctx.save() //保存当前状态\n    ctx.fillStyle = &#39;#FFF&#39; //再次改变颜色状态\n    ctx.fillRect(30,30,90,90) //使用心得配置绘制一个矩形\n\n    ctx.restore() //重新加载之前的颜色状态\n    ctx.fillRect(45,45,60,60) //使用上一次的配置绘制一个矩形\n\n    ctx.restore() //加载默认颜色配置\n    ctx.fillRect(60,60,30,30) //使用加载的配置绘制一个矩形\n}\ndraw()\n</code></pre>\n<h1 id=\"九、变形\"><a href=\"#九、变形\" class=\"headerlink\" title=\"九、变形\"></a>九、变形</h1><h2 id=\"9-1translate\"><a href=\"#9-1translate\" class=\"headerlink\" title=\"9.1translate\"></a>9.1translate</h2><p>translate(x,y)</p>\n<p>用来移动canvas的原点到指定的位置</p>\n<p>translate方法接收两个参数。x是左右偏移量，y是上下偏移量，如图所示。</p>\n<p>在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用restore方法比手动恢复原形的状态要简单得多。又如果你是在一个循环中做位移但没有保存和恢复canvas的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出canvas范围以外了。注意：translate移动的是canvas的坐标原点(坐标变换)。</p>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/829832336-5b74dd8e3ad9a_articlex.png\" alt=\"img\"></li>\n</ol>\n<pre><code class=\"javascript\">var ctx;\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.save() //保存坐标原点平移之前的状态\n    ctx.translate(100,100)\n    ctx.strokeRect(0,0,100,100)\n    ctx.restore()\n    ctx.translate(220,200)\n    ctx.fillRect(0,0,100,100)\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1230266743-5b74dd8e3b0ce_articlex.png\" alt=\"img\"></li>\n</ol>\n<h2 id=\"9-2-rotate\"><a href=\"#9-2-rotate\" class=\"headerlink\" title=\"9.2 rotate\"></a>9.2 rotate</h2><p>rotate(angle)</p>\n<p>旋转坐标轴。</p>\n<p>这个方法只接受一个参数：旋转的角度（angle），它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。</p>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3322150878-5b74dd8e2b6a4_articlex.png\" alt=\"img\"></li>\n</ol>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvs.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n\n    ctx.fillStyle = &#39;red&#39;\n    ctx.save()\n\n    ctx.translate(100,100)\n    ctx.rotate(Math.PI/180*45)\n    ctx.fillStyle = &#39;blue&#39;\n    ctx.fillRect(0,0,100,100)\n    ctx.restore()\n\n    ctx.save()\n    ctx.translate(0,0)\n    ctx.fillRect(0,0,50,50)\n    ctx.restore()\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1819968878-5b74dd8e1e770_articlex.png\" alt=\"img\"></li>\n</ol>\n<h2 id=\"9-3-scale\"><a href=\"#9-3-scale\" class=\"headerlink\" title=\"9.3 scale\"></a>9.3 scale</h2><p>scale(x,y)</p>\n<p>我们用它来增减图形在canvas中的像素数目，对形状、位图进行缩小或者放大。</p>\n<p>scale方法接受两个参数。x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比1.0小表示缩小，比1.0大表示放大，值为1.0时什么效果都没有。</p>\n<p>默认情况下，canvas的1单位就是1个像素。举例说，如果我们设置缩放因子是0.5，1个单位就变成对应0.5个像素，这样绘制出来的形状就会是原先的一半。同理，设置为2.0时，1个单位就对应变成了2像素，绘制的结果就是图形放大了2倍。</p>\n<h2 id=\"9-4-transform-变形矩阵\"><a href=\"#9-4-transform-变形矩阵\" class=\"headerlink\" title=\"9.4 transform(变形矩阵)\"></a>9.4 transform(变形矩阵)</h2><p>transform(a,b,c,d,e,f)</p>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2958376259-5b74dd8e15192_articlex.png\" alt=\"img\"></li>\n</ol>\n<ul>\n<li>a (m11): Horizontal scaling.</li>\n<li>b (m12): Horizontal skewing.</li>\n<li>c (m21): Vertical skewing.</li>\n<li>d (m22): Vertical scaling.</li>\n<li>e (dx): Horizontal moving.</li>\n<li>f (dy): Vertical moving.</li>\n</ul>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.transform(1,1,0,1,0,0)\n    ctx.fillRect(0,0,100,100)\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/489430190-5b74dd8e17ad2_articlex.png\" alt=\"img\"></li>\n</ol>\n<h2 id=\"十、合成\"><a href=\"#十、合成\" class=\"headerlink\" title=\"十、合成\"></a>十、合成</h2><p>在前面的所有例子中，我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用globalCompositeOperation属性来改变这种情况。</p>\n<pre><code class=\"javascript\">globalCompositeOperation = type\n</code></pre>\n<pre><code class=\"javascript\">var ctx;\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;);\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.fillStyle = &#39;blue&#39;\n    ctx.fillRect(0,0,200,200)\n\n    ctx.globalCompositeOperation = &#39;source-over&#39; //全局合成操作\n    ctx.fillStyle = &#39;red&#39;\n    ctx.fillRect(100,100,200,200)\n}\n</code></pre>\n<blockquote>\n<p>注：下面的展示中，蓝色是原有的，红色是新的。</p>\n<p>type是下面13中字符串值之一:</p>\n</blockquote>\n<ol>\n<li><p>这是默认设置，新图像会覆盖在原有图像。</p>\n</li>\n<li><p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1858023544-5b74dd8e0813d.png\" alt=\"img\"></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、canvas简介\"><a href=\"#一、canvas简介\" class=\"headerlink\" title=\"一、canvas简介\"></a>一、canvas简介</h2><p><kbd>canvas</kbd>是HTML5新增的，一个可以使用脚本（通常为JavaScript）在其中绘制图像的HTML元素。它可以用来制作照片或者制作简单（也不是那么简单）的动画，甚至可以进行实时视频处理和渲染。</p>\n<p>它最初由苹果内部使用自己MacOS X Webkit推出，供应用程序使用像仪表盘的构件和Safari浏览器使用。后来，有人通过Gecko内核的浏览器（尤其是Mozilla和Firefox），Opera和Chrome和超文本网络应用技术工作组建议为下一代的网络技术使用该元素。</p>\n<p>Canvas是由HTML代码配合高度和宽度属性而定义出的可绘制区域。JavaScript代码可以访问该区域，类似于其他通用的二维API，通过一套完整的绘图函数来动态生成图形。</p>\n<p>Mozilla程序从Geko1.8（Firefox1.5）开始支持<kbd>canvas</kbd>，Internet Explorer从IE9开始<kbd>canvas</kbd>。Chrome和Opera9+也支持<kbd>canvas</kbd>。</p>\n<h2 id=\"二、Canvas基本使用\"><a href=\"#二、Canvas基本使用\" class=\"headerlink\" title=\"二、Canvas基本使用\"></a>二、Canvas基本使用</h2><h3 id=\"2-1canvas元素\"><a href=\"#2-1canvas元素\" class=\"headerlink\" title=\"2.1canvas元素\"></a>2.1canvas元素</h3><p><kbd>canvas</kbd>看起来和<kbd><code>&lt;img&gt;</code></kbd>标签一样，只是<kbd>canvas</kbd>只有两个可选的属性width、height属性，而没有src、alt属性。</p>\n<p>如果不给<kbd>canvas</kbd>设置width、height属性时，则默认width为300、height为150，单位都是px。也可以使用css属性来设置宽高，但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用css属性来设置<kbd>canvas</kbd>的宽高。</p>\n<p><strong><em>替换内容</em></strong></p>\n<p>由于某些较老的浏览器（尤其是IE9之前的IE浏览器）或者浏览器不支持HTML元素<kbd>canvas</kbd>，在这些浏览器上你应该总是能展示替代内容。</p>\n<p>支持<kbd>canvas</kbd>的浏览器会只渲染<kbd>canvas</kbd>标签，而忽略其中的替代内容。不支持<kbd></kbd>canvas的浏览器会直接渲染替代内容。</p>\n<p>用文本替换：</p>\n<pre><code class=\"html\">&lt;canvas&gt;\n    你的浏览器不支持canvas，请升级你的浏览器。\n&lt;/canvas&gt;\n</code></pre>\n<p>用<kbd><code>&lt;img&gt;</code></kbd>替换：</p>\n<pre><code class=\"html\">&lt;canvas&gt;\n    &lt;img src=&quot;./美女.jgp&quot; alt=&quot;&quot;&gt;\n&lt;/canvas&gt;\n</code></pre>\n<p><strong><em>结束标签不可省略</em></strong></p>\n<p>与<kbd><code>&lt;img&gt;</code></kbd>元素不同，<kbd>canvas</kbd>元素需要结束标签（）。如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。</p>\n<p>##2.2渲染上下文（Thre Rending Context）</p>\n<p><kbd>canvas</kbd>会创建一个固定大小的画布，会公开一个或多个<strong>渲染上下文</strong>(画笔)，使用<strong>渲染上下文</strong>来绘制和处理要展示的内容。</p>\n<p>我们重点研究2D渲染上下文。其他的上下文我们暂不研究，比如，WebGL使用了基于OpenGLES的3D上下文。</p>\n<pre><code class=\"javascript\">var canvas = document.getElementById(&#39;tutorial&#39;);\n//获得2d上下文对象\nvar ctx = canvas.getContext(&#39;2d&#39;)\n</code></pre>\n<h3 id=\"2-3检测支持性\"><a href=\"#2-3检测支持性\" class=\"headerlink\" title=\"2.3检测支持性\"></a>2.3检测支持性</h3><pre><code class=\"javascript\">var canvas = document.getElementById(&#39;tutorial&#39;);\nif(canvas.getContext) {\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    // drawing code here\n} else {\n    // canvas-unsupported code here\n}\n</code></pre>\n<h3 id=\"2-4代码模板\"><a href=\"#2-4代码模板\" class=\"headerlink\" title=\"2.4代码模板\"></a>2.4代码模板</h3><pre><code class=\"html\">&lt;canvas id=&quot;tutorial&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function draw() {\n        var canvas = document.getElementById(&#39;tutorial&#39;);\n        if(!canvas.getContext) return\n        var ctx = canvas.getContext(&#39;2d&#39;)\n        //开始写代码\n    }\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"2-5一个简单的例子\"><a href=\"#2-5一个简单的例子\" class=\"headerlink\" title=\"2.5一个简单的例子\"></a>2.5一个简单的例子</h3><p>以下实例绘制两个长方形</p>\n<pre><code class=\"html\">&lt;canvas id=&quot;tutorial&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function draw() {\n        var canvas = document.getElementById(&#39;tutorial&#39;);\n        if(!canvas.getContext) return\n        var ctx = canvas.getContext(&#39;2d&#39;)\n        ctx.fillStyle = &quot;rgb(200,0,0)&quot;\n        //绘制矩形\n        ctx.fillRect (10,10,55,50)\n        ctx.fillStyle = &quot;rgb(0,0,200,0.5)&quot;\n        ctx.fillRect (30,30,55,50)\n    }\n    draw()\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"三、绘制形状\"><a href=\"#三、绘制形状\" class=\"headerlink\" title=\"三、绘制形状\"></a>三、绘制形状</h2><h3 id=\"3-1栅格-grid-和坐标空间\"><a href=\"#3-1栅格-grid-和坐标空间\" class=\"headerlink\" title=\"3.1栅格(grid)和坐标空间\"></a>3.1栅格(grid)和坐标空间</h3><p>如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元 相当于canvas元素中的一像素。栅格的起点为左上角，坐标为(0,0)。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素，坐标为(x,y)。</p>\n<p>后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/Canvas_default_grid.png\" alt=\"img\"></p>\n<h3 id=\"3-2绘制矩形\"><a href=\"#3-2绘制矩形\" class=\"headerlink\" title=\"3.2绘制矩形\"></a>3.2绘制矩形</h3><p><kbd>canvas</kbd>只支持一种原生的图形绘制：<strong><em>矩形</em></strong>。所有其他图形都至少需要生成一种路径(path)。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。</p>\n<p>canvas提供了三种方法绘制矩形：</p>\n<ul>\n<li>fillRect(x, y, width, height)：绘制一个填充的矩形。</li>\n<li>strokeRect(x, y, width, height)：绘制一个矩形的边框。</li>\n<li>clearRect(x, y, width, height)：清除指定的矩形区域，然后这块区域会变的完全透明。</li>\n</ul>\n<blockquote>\n<p>说明：这3个方法具有相同的参数。</p>\n<ul>\n<li>x,y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)</li>\n<li>width,height：指的是绘制的矩形的宽和高。</li>\n</ul>\n</blockquote>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.fillRect(10,10,100,50) //绘制矩形，填充的默认颜色为黑色\n    ctx.strokeRect(10, 70, 100 ,50) //绘制矩形边框\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2400420933-5b74dd8f80306_articlex.png\" alt=\"img\"></p>\n<pre><code class=\"javascript\">ctx.clearRect(15, 15, 50, 25)\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2347163070-5b74dd8f813a6_articlex.png\" alt=\"img\"></p>\n<h2 id=\"四、绘制路径-path\"><a href=\"#四、绘制路径-path\" class=\"headerlink\" title=\"四、绘制路径(path)\"></a>四、绘制路径(path)</h2><p>图形的基本元素是路径。</p>\n<p>路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。</p>\n<p>一个路径，甚至一个子路径，都是闭合的。</p>\n<p><strong><em>使用路径绘制图形需要一些额外的步骤：</em></strong></p>\n<blockquote>\n<ol>\n<li>创建路径起始点</li>\n<li>调用绘制方法去绘制出路径</li>\n<li>把路径封闭</li>\n<li>一旦路径生成，通过描边或填充路径区域来渲染图形</li>\n</ol>\n</blockquote>\n<p><strong><em>下面是需要用到的方法：</em></strong></p>\n<blockquote>\n<ol>\n<li>beginPath()</li>\n</ol>\n<p>​       新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径</p>\n<ol start=\"2\">\n<li><p>moveTo(x, y)</p>\n<p>把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。</p>\n</li>\n<li><p>closePath()</p>\n<p>闭合路径之后，图形绘制命令又重新指向到上下文中</p>\n</li>\n<li><p>stroke()</p>\n<p>通过线条来绘制图形轮廓</p>\n</li>\n<li><p>fill()</p>\n<p>通过填充路径的内容区域生成实心的图形</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"4-1绘制线段\"><a href=\"#4-1绘制线段\" class=\"headerlink\" title=\"4.1绘制线段\"></a>4.1绘制线段</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath() //新建一条path\n    ctx.moveTo(50,50) // 把画笔移动到指定的坐标\n    ctx.lineTo(200,50) //绘制一条从当前位置到指定坐标(200,50)的直线\n    ctx.closePath() //闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做\n    ctx.stroke() //绘制路径\n}\ndraw()\n</code></pre>\n<h2 id=\"4-2绘制三角形边框\"><a href=\"#4-2绘制三角形边框\" class=\"headerlink\" title=\"4.2绘制三角形边框\"></a>4.2绘制三角形边框</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElmentById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    ctx.lineTo(200,50)\n    ctx.lineTo(200,200)\n    ctx.closePath() //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个三角形\n    ctx.stroke() //描边。stroke不会自动closePath()\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2106846415-5b74dd8f67000_articlex.png\" alt=\"img\"></p>\n<h2 id=\"4-3填充三角形\"><a href=\"#4-3填充三角形\" class=\"headerlink\" title=\"4.3填充三角形\"></a>4.3填充三角形</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    ctx.lineTo(200,50)\n    ctx.lineTo(200,200)\n    ctx.fill() //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径\n}\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3457015746-5b74dd8f72860_articlex.png\" alt=\"img\"></p>\n<h2 id=\"4-4绘制圆弧\"><a href=\"#4-4绘制圆弧\" class=\"headerlink\" title=\"4.4绘制圆弧\"></a>4.4绘制圆弧</h2><p>有两个方法可以绘制圆弧：</p>\n<ol>\n<li><p>arc(x, y, r, startAngle, endAngle, anticlockwise): </p>\n<p>以(x,y) 为圆心，以r为半径，从startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针(默认是顺时针)。</p>\n<blockquote>\n<ol>\n<li><p>这里的度数都是弧度。</p>\n</li>\n<li><p>0弧度是指的x轴正方向。</p>\n<blockquote>\n<p>radians = (Math.PI/180)*degrees //角度转换成弧度</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>arcTo(x1,y1,x2,y2,radius):</p>\n<p>根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">//圆弧案例1\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.arc(50,50,40,0,Math.PI /2, false)\n    ctx.stroke()\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3832141455-5b74dd8f658df_articlex.png\" alt=\"img\"></p>\n<pre><code class=\"javascript\">//圆弧案例2\nfuncion draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.arc(50,50,50,0,Math.PI/2,false)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.arc(150,50,40,0,-Math.PI/2,true)\n    ctx.closePath()\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.arc(50,150,40,-Math.PI/2,Math.PI/2,false)\n    ctx.fill()\n\n    ctx.beginPath()\n    ctx.arc(150,150,40,0,Math.PI,false)\n    ctx.fill()\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2218794221-5b74dd8f43f98_articlex.png\" alt=\"img\"></p>\n<pre><code class=\"javascript\">//圆弧案例3\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.moveTo(50,50)\n    //参数1、2：控制点1坐标\n    //参数3、4：控制点2坐标\n    //参数5：圆弧半径\n    ctx.arcTo(200,50,200,200,100)\n    ctx.lineTo(200,200)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.rect(50,50,10,10)\n    ctx.rect(200,50,10,10)\n    ctx.rect(200,200,10,10)\n    ctx.fill()\n}\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3556678928-5b74dd8f1bd2a_articlex.png\" alt=\"img\"></p>\n<blockquote>\n<p>arcTo方法的说明：</p>\n<p>这个方法可以这样理解。绘制的弧形是由两条切线所决定。</p>\n<p>第1条切线：起始点和控制点1决定的直线。</p>\n<p>第2条切线：控制点1和控制点2决定的直线。</p>\n<p>其实绘制的圆弧就是与这两条直线相切的圆弧。</p>\n</blockquote>\n<h2 id=\"4-5绘制贝塞尔曲线\"><a href=\"#4-5绘制贝塞尔曲线\" class=\"headerlink\" title=\"4.5绘制贝塞尔曲线\"></a>4.5绘制贝塞尔曲线</h2><h3 id=\"4-5-1什么是贝塞尔曲线\"><a href=\"#4-5-1什么是贝塞尔曲线\" class=\"headerlink\" title=\"4.5.1什么是贝塞尔曲线\"></a>4.5.1什么是贝塞尔曲线</h3><p>贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。</p>\n<p>一般的矢量图形软件通过它来精确画出曲线，贝兹曲线是由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。</p>\n<p>贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具入PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。</p>\n<p>贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau 于 1959 年运用 de Casteljau 演算法开发，以稳定数值的方法求出贝兹曲线。</p>\n<p><strong><em>一次贝塞尔曲线其实是一条直线</em></strong></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/240px-b_1_big.gif\" alt=\"img\"></p>\n<p><strong><em>二次贝塞尔曲线</em></strong></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/b_2_big.gif\" alt=\"img\"></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1544764428-5713-240px-BC3A9zier-2-big.svg-.png\" alt=\"img\"></p>\n<p>三次贝塞尔曲线</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/b_3_big.gif\" alt=\"img\"></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1544764428-2467-240px-BC3A9zier-3-big.svg-.png\" alt=\"img\"></p>\n<h3 id=\"4-5-2绘制贝塞尔曲线\"><a href=\"#4-5-2绘制贝塞尔曲线\" class=\"headerlink\" title=\"4.5.2绘制贝塞尔曲线\"></a>4.5.2绘制贝塞尔曲线</h3><ol>\n<li>绘制二次贝塞尔曲线：/kwɒ&#39;drætɪk/</li>\n</ol>\n<pre><code class=\"javascript\">quadraticCurveTo(cp1x,cp1y,x,y)\n</code></pre>\n<blockquote>\n<p>说明：</p>\n<ul>\n<li>参数1和2：控制点坐标</li>\n<li>参数3和4：结束点坐标</li>\n</ul>\n</blockquote>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.beginPath()\n    ctx.moveTo(10,200) //起始点\n    var cp1x = 40, cp1y = 100 //控制点\n    var x = 200, y = 200 //结束点\n    //绘制二次贝塞尔曲线\n    ctx.quadraticCurveTo(cp1x, cp1y, x, y)\n    ctx.stroke()\n\n    ctx.beginPath()\n    ctx.rect(10,200,10,10)\n    ctx.rect(cp1x,cp1y,10,10)\n    ctx.rect(x,y,10,10)\n    ctx.fill()\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/274915666-5b74dd8ecb2e2_articlex.png\" alt=\"img\"></p>\n<ol start=\"2\">\n<li><p>绘制三次贝塞尔曲线:</p>\n<pre><code class=\"javascript\">bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\n</code></pre>\n<blockquote>\n<p>说明：</p>\n<ul>\n<li>参数1和2：控制点1的坐标</li>\n<li>参数3和4：控制点2的坐标</li>\n<li>参数5和6：结束点的坐标</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"javascript\">   function draw() {\n       var canvas = document.getElementById(&#39;tutorial&#39;)\n       if(!canvas.getContext) return\n       var ctx = canvas.getContext(&#39;2d&#39;)\n       ctx.beginPath()\n       ctx.moveTo(40,200) //起始点\n       var cp1x = 20, cp1y = 100 //控制点1\n       var cp2x = 100, cp2y = 120 //控制点2\n       var x = 200, y = 200 //结束点\n       //绘制三次贝塞尔曲线\n       ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)\n       ctx.stroke()\n\n       ctx.beginPath();\n       ctx.rect(40, 200, 10, 10);\n       ctx.rect(cp1x, cp1y, 10, 10);\n       ctx.rect(cp2x, cp2y, 10, 10);\n       ctx.rect(x, y, 10, 10);\n       ctx.fill();\n   }\n   draw()\n</code></pre>\n<p>   <img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3947786617-5b74dd8ec8678_articlex.png\" alt=\"img\"></p>\n<h1 id=\"五、添加样式和颜色\"><a href=\"#五、添加样式和颜色\" class=\"headerlink\" title=\"五、添加样式和颜色\"></a>五、添加样式和颜色</h1><p>在前面的绘制矩形章节中，只用到了默认的线条和颜色。</p>\n<p>如果想要给图形上色，有两个重要的属性可以做到。</p>\n<ol>\n<li>fillStyle = color 设置图形的填充颜色</li>\n<li>strokeStyle = color 设置图形轮廓的颜色</li>\n</ol>\n<blockquote>\n<p>备注：</p>\n<ol>\n<li>color可以是表达css颜色值的字符串、渐变对象或者图案对象</li>\n<li>默认情况下，线条和填充颜色都是黑色</li>\n<li>一旦您设置了strokeStyle或者fillStyle的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置fillStyle或strokeStyle的值</li>\n</ol>\n</blockquote>\n<h2 id=\"fillStyle\"><a href=\"#fillStyle\" class=\"headerlink\" title=\"fillStyle\"></a>fillStyle</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    for(var i = 0; i &lt; 6; i++) {\n        for(var j = 0; j &lt; 6; j++) {\n            ctx.fillStyle = &#39;rgb(&#39; + Math.floor(255 - 42.5 * i) + &#39;,&#39; + Math.floor(255 - 42.5 * j) + &#39;,0)&#39;\n            ctx.fillRect(j * 50, i * 50, 50, 50)\n        }\n    }\n}\ndraw()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2505008676-5b74dd8ebad41_articlex.png\" alt=\"img\"></p>\n<h2 id=\"strokeStyle\"><a href=\"#strokeStyle\" class=\"headerlink\" title=\"strokeStyle\"></a>strokeStyle</h2><pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    for(var i = 0; i &lt; 6; i++) {\n        for(var j = 0;j &lt; 6;j++) {\n            ctx.strokeStyle = `rgb(${randomInt(0,255)}, ${randomInt(0,255)}, ${randomInt(0,255)})`\n            ctx.strokeRect(j*50,i*50,40,40)\n        }\n    }\n}\ndraw()\n\n//返回随机的[from,to]之间的整数(包括from，也包括to)\nfunction randomInt(from,to) {\n    return parseInt(Math.random() * (to-from +1) + from)\n}\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3288535670-5b74dd8ea12d9_articlex.png\" alt=\"img\"></p>\n<h2 id=\"Transparency-透明度\"><a href=\"#Transparency-透明度\" class=\"headerlink\" title=\"Transparency(透明度)\"></a>Transparency(透明度)</h2><p>globalAlpha = transparencyValue:这个属性影响到canvas里所有图形的透明度，有效的值范围是0.0（完全透明）到1.0（完全不透明），默认是1.0</p>\n<p><strong>globalAlpha</strong>属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更好一些。</p>\n<p><strong>1. line style</strong></p>\n<p>线宽。只能是正值。默认是1.0</p>\n<p>起始点和终点的连线为中心，上下各占线宽的一半。</p>\n<pre><code class=\"javascript\">ctx.beginPath()\nctx.moveTo(10,10)\nctx.lineTo(100,10)\nctx.lineWidth = 10\nctx.stroke()\n\nctx.beginPath()\nctx.moveTo(110,10)\nctx.lineTo(160,10)\nctx.lineWidth = 20\nctx.stroke()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3410060825-5b74dd8ea12d9_articlex.png\" alt=\"img\"></p>\n<p><strong>2. lineCap = type</strong></p>\n<p>线条末端样式。</p>\n<blockquote>\n<p>共有三个值：</p>\n<ol>\n<li>butt： 线段末端以方形结束</li>\n<li>round：线段末端以圆形结束</li>\n<li>square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一般的矩形区域</li>\n</ol>\n</blockquote>\n<pre><code class=\"javascript\">var lineCaps = [&#39;butt&#39;, &#39;round&#39;, &#39;square&#39;]\nfor(var i = 0;i&lt;3;i++) {\n    ctx.beginPath()\n    ctx.moveTo(20+30*i,30)\n    ctx.lineTo(20+30*i,100)\n    ctx.lineWidth = 20\n    ctx.lineCap = lineCaps[i]\n    ctx.stroke()\n}\n\nctx.beginPath()\nctx.moveTo(0,30)\nctx.lineTo(300,30)\n\nctx.moveTo(0,100)\nctx.lineTo(300,100)\n\nctx.strokeStyle = &#39;red&#39;\nctx.lineWidth = 1\nctx.stroke()\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3380216230-5b74dd8e97e85_articlex.png\" alt=\"img\"></p>\n<p><strong>3. lineJoin = type</strong></p>\n<p>同一个path内，设定线条与线条间接合处的样式。</p>\n<p>共有三个值round,bevel和miter：</p>\n<ol>\n<li>round通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。圆角的半径是线段的宽度。</li>\n<li>bevel在相连部分的末端填充一个额外的以三角形为底的区域，每个部分都有各自独立的矩形拐角。</li>\n<li>miter(默认)通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。</li>\n</ol>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n\n    var lineJoin = [&#39;round&#39;,&#39;bevel&#39;, &#39;miter&#39;]\n    ctx.lineWidth = 20\n    for(var i =0; i&lt; lineJoin.length;i++) {\n        ctx.lineJoin = lineJoin[i]\n        ctx.beginPath()\n        ctx.moveTo(50,50+i*50)\n        ctx.lineTo(100,100+i*50)\n        ctx.lineTo(150,50+i*50)\n        ctx.lineTo(200,100+i*50)\n        ctx.lineTo(250,50+i*50)\n        ctx.stroke()\n    }\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1584506777-5b74dd8e82768_articlex.png\" alt=\"img\"></li>\n</ol>\n<p><strong>4. 虚线</strong></p>\n<p>用setLineDash方法和lineDashOffset属性来指定虚线样式。</p>\n<p>setLineDash方法接收一个数组，来指定线段与间隙的交替；</p>\n<p>lineDashOffset属性设置起始偏移量。</p>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.setLineDash([20,5]) //[实线长度，间隙长度]\n    ctx.lineDashOffset = -0\n    ctx.strokeRect(50,50,210,210)\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2805401035-5b74dd8e6833c_articlex.png\" alt=\"img\"></li>\n</ol>\n<blockquote>\n<p>备注：getLineDash()返回一个包含当前虚线样式，长度为非偶数的数组。</p>\n</blockquote>\n<h1 id=\"六、绘制文本\"><a href=\"#六、绘制文本\" class=\"headerlink\" title=\"六、绘制文本\"></a>六、绘制文本</h1><p><strong><em>绘制文本的两个方法</em></strong></p>\n<p>canvas提供了两种方法来渲染文本：</p>\n<ol>\n<li><p>fillText(text, x, y, [, maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的。</p>\n</li>\n<li><p>strokeText(text, x, y, [, maxWidth])在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的。</p>\n<pre><code class=\"javascript\">var ctx;\nfunction draw() {\n    var canvas = document.getELementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.font = &#39;100px sans-serif&#39;\n    ctx.fillText(&#39;天若有情&#39;,10,100)\n    ctx.strokeText(&#39;天若有情&#39;,10,200)\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/404304980-5b74dd8e7499e_articlex.png\" alt=\"img\"></li>\n</ol>\n</li>\n</ol>\n<p><strong><em>给文本添加样式</em></strong></p>\n<ol>\n<li>font = value 当前我们用来绘制文本的样式。这个字符串使用和css font属性相同的语法。<strong>默认的字体是10px sans-serif。</strong></li>\n<li>textAlign = value 文本对齐选项。可选的值包括：start，end，left，right，center。<strong>默认是start。</strong></li>\n<li>textBaseline = value 基线对齐选项，可选的值包括：top，hanging，middle，alphabetic，ideographic，bottom。<strong>默认值是alphabetic。</strong></li>\n<li>direction = value 文本方向。可能的值包括：ltr，rtl，inherit。<strong>默认值是inherit。</strong></li>\n</ol>\n<h1 id=\"七、绘制图片\"><a href=\"#七、绘制图片\" class=\"headerlink\" title=\"七、绘制图片\"></a>七、绘制图片</h1><p>我们也可以在canvas上直接绘制图片。</p>\n<h2 id=\"7-1由零开始创建图片\"><a href=\"#7-1由零开始创建图片\" class=\"headerlink\" title=\"7.1由零开始创建图片\"></a>7.1由零开始创建图片</h2><pre><code class=\"javascript\">var img = new Image() //创建一个&lt;img&gt;元素\nimg.src = &#39;myImage.png&#39; //设置图片原地址\n</code></pre>\n<p><strong>绘制img</strong></p>\n<pre><code class=\"javascript\">//参数1：要绘制的img\n//参数2、3：绘制的img在canvas中的坐标\nctx.drawImage(img,0,0)\n</code></pre>\n<blockquote>\n<p>注意：考虑到图片是从网络加载，如果drawImage的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在img绘制完成之后再drawImage。</p>\n</blockquote>\n<pre><code class=\"javascript\">var img = new Image() //创建img元素\nimg.onload = function() {\n    ctx.drawImage(img, 0, 0)\n}\nimg.src = &#39;myImage.png&#39; //设置图片c地址\n</code></pre>\n<h2 id=\"7-2-绘制img标签元素中的图片\"><a href=\"#7-2-绘制img标签元素中的图片\" class=\"headerlink\" title=\"7.2 绘制img标签元素中的图片\"></a>7.2 绘制img标签元素中的图片</h2><p>img可以new，也可以来源于我们页面中的<img>标签。</p>\n<pre><code class=\"html\">&lt;img src=&quot;./美女.jpg&quot; alt=&quot;&quot; width=&quot;300&quot;&gt;&lt;br&gt;\n&lt;canvas id=&quot;tutorial&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    var img = document.querySelector(&#39;img&#39;)\n    ctx.drawImg(img,0,0)\n}\ndocument.querySelector(&#39;img&#39;).onclick = function() {\n    draw()\n}\n</code></pre>\n<ol>\n<li><ol>\n<li>第一张图片就是页面中的 <code>&lt;img&gt;</code> 标签：</li>\n</ol>\n</li>\n<li><p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2255709523-5b74dd8eb033e_articlex.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h2 id=\"7-3-缩放图片\"><a href=\"#7-3-缩放图片\" class=\"headerlink\" title=\"7.3 缩放图片\"></a>7.3 缩放图片</h2><p>drawImage()可以再添加两个参数：</p>\n<pre><code class=\"javascript\">drawImage(image,x,y,width,height)\n</code></pre>\n<p>这个方法多了两个参数：width和height，这两个参数用来控制 当像canvas画入时应该缩放的大小。</p>\n<pre><code class=\"javascript\">ctx.drawImage(img,0,0,400,200)\n</code></pre>\n<p>##7.4 切片(slice)</p>\n<pre><code class=\"javascript\">drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)\n</code></pre>\n<p>第一个参数和其他的是相同的，都是一个图像或者另一个canvas的引用。</p>\n<p>其他8个参数：前4个事定义图像源的切片位置和大小，后四个则是定义切片的目标显示位置和大小。</p>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2106688680-54566fa3d81dc_articlex.jpeg\" alt=\"img\"></li>\n</ol>\n<h1 id=\"八、状态的保存和恢复\"><a href=\"#八、状态的保存和恢复\" class=\"headerlink\" title=\"八、状态的保存和恢复\"></a>八、状态的保存和恢复</h1><p>Saving and restoring state是绘制复杂图形时必不可少的操作。</p>\n<p>save()和restore()</p>\n<p>save和restore方法是用来保存和恢复canvas状态的，都没有参数。</p>\n<p>Canvas的状态就是当前画面应用的所有样式和变形的一个快照。</p>\n<h2 id=\"8-1-关于save\"><a href=\"#8-1-关于save\" class=\"headerlink\" title=\"8.1 关于save()\"></a>8.1 关于save()</h2><blockquote>\n<p>Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。</p>\n</blockquote>\n<p>一个绘画状态包括:</p>\n<ul>\n<li><p>当前应用的变形（即移动，旋转和缩放）</p>\n</li>\n<li><p>strokeStyle,fillStyle,globalAlpha,lineWidth,lineCap,lineJoin,miterLimit,shadowOffsetX,shadowOffsetY,shadowBlur,shadowColor,globalCompositeOperation的值</p>\n</li>\n<li><p>当前的裁切路径（clipping path)</p>\n</li>\n</ul>\n<p>  <strong><em>可以调用任意多次save方法（类似数组的push()）</em></strong></p>\n<h2 id=\"8-2关于resotre\"><a href=\"#8-2关于resotre\" class=\"headerlink\" title=\"8.2关于resotre()\"></a>8.2关于resotre()</h2><blockquote>\n<p>每一次调用restore方法，上一个保存的状态就从栈中弹出，所有设定都恢复（类似数组pop()）</p>\n</blockquote>\n<pre><code class=\"javascript\">var ctx;\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n\n    ctx.fillRect(0,0,150,150) //使用默认设置绘制一个矩形\n    ctx.save() //保存默认状态\n\n    ctx.fillStyle = &#39;red&#39; //在原有配置基础上对颜色做改变\n    ctx.fillRect(15,15,120,120) //使用心得设置绘制一个矩形\n\n    ctx.save() //保存当前状态\n    ctx.fillStyle = &#39;#FFF&#39; //再次改变颜色状态\n    ctx.fillRect(30,30,90,90) //使用心得配置绘制一个矩形\n\n    ctx.restore() //重新加载之前的颜色状态\n    ctx.fillRect(45,45,60,60) //使用上一次的配置绘制一个矩形\n\n    ctx.restore() //加载默认颜色配置\n    ctx.fillRect(60,60,30,30) //使用加载的配置绘制一个矩形\n}\ndraw()\n</code></pre>\n<h1 id=\"九、变形\"><a href=\"#九、变形\" class=\"headerlink\" title=\"九、变形\"></a>九、变形</h1><h2 id=\"9-1translate\"><a href=\"#9-1translate\" class=\"headerlink\" title=\"9.1translate\"></a>9.1translate</h2><p>translate(x,y)</p>\n<p>用来移动canvas的原点到指定的位置</p>\n<p>translate方法接收两个参数。x是左右偏移量，y是上下偏移量，如图所示。</p>\n<p>在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用restore方法比手动恢复原形的状态要简单得多。又如果你是在一个循环中做位移但没有保存和恢复canvas的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出canvas范围以外了。注意：translate移动的是canvas的坐标原点(坐标变换)。</p>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/829832336-5b74dd8e3ad9a_articlex.png\" alt=\"img\"></li>\n</ol>\n<pre><code class=\"javascript\">var ctx;\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.save() //保存坐标原点平移之前的状态\n    ctx.translate(100,100)\n    ctx.strokeRect(0,0,100,100)\n    ctx.restore()\n    ctx.translate(220,200)\n    ctx.fillRect(0,0,100,100)\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1230266743-5b74dd8e3b0ce_articlex.png\" alt=\"img\"></li>\n</ol>\n<h2 id=\"9-2-rotate\"><a href=\"#9-2-rotate\" class=\"headerlink\" title=\"9.2 rotate\"></a>9.2 rotate</h2><p>rotate(angle)</p>\n<p>旋转坐标轴。</p>\n<p>这个方法只接受一个参数：旋转的角度（angle），它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。</p>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/3322150878-5b74dd8e2b6a4_articlex.png\" alt=\"img\"></li>\n</ol>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvs.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n\n    ctx.fillStyle = &#39;red&#39;\n    ctx.save()\n\n    ctx.translate(100,100)\n    ctx.rotate(Math.PI/180*45)\n    ctx.fillStyle = &#39;blue&#39;\n    ctx.fillRect(0,0,100,100)\n    ctx.restore()\n\n    ctx.save()\n    ctx.translate(0,0)\n    ctx.fillRect(0,0,50,50)\n    ctx.restore()\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1819968878-5b74dd8e1e770_articlex.png\" alt=\"img\"></li>\n</ol>\n<h2 id=\"9-3-scale\"><a href=\"#9-3-scale\" class=\"headerlink\" title=\"9.3 scale\"></a>9.3 scale</h2><p>scale(x,y)</p>\n<p>我们用它来增减图形在canvas中的像素数目，对形状、位图进行缩小或者放大。</p>\n<p>scale方法接受两个参数。x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比1.0小表示缩小，比1.0大表示放大，值为1.0时什么效果都没有。</p>\n<p>默认情况下，canvas的1单位就是1个像素。举例说，如果我们设置缩放因子是0.5，1个单位就变成对应0.5个像素，这样绘制出来的形状就会是原先的一半。同理，设置为2.0时，1个单位就对应变成了2像素，绘制的结果就是图形放大了2倍。</p>\n<h2 id=\"9-4-transform-变形矩阵\"><a href=\"#9-4-transform-变形矩阵\" class=\"headerlink\" title=\"9.4 transform(变形矩阵)\"></a>9.4 transform(变形矩阵)</h2><p>transform(a,b,c,d,e,f)</p>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/2958376259-5b74dd8e15192_articlex.png\" alt=\"img\"></li>\n</ol>\n<ul>\n<li>a (m11): Horizontal scaling.</li>\n<li>b (m12): Horizontal skewing.</li>\n<li>c (m21): Vertical skewing.</li>\n<li>d (m22): Vertical scaling.</li>\n<li>e (dx): Horizontal moving.</li>\n<li>f (dy): Vertical moving.</li>\n</ul>\n<pre><code class=\"javascript\">function draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;)\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.transform(1,1,0,1,0,0)\n    ctx.fillRect(0,0,100,100)\n}\ndraw()\n</code></pre>\n<ol>\n<li><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/489430190-5b74dd8e17ad2_articlex.png\" alt=\"img\"></li>\n</ol>\n<h2 id=\"十、合成\"><a href=\"#十、合成\" class=\"headerlink\" title=\"十、合成\"></a>十、合成</h2><p>在前面的所有例子中，我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用globalCompositeOperation属性来改变这种情况。</p>\n<pre><code class=\"javascript\">globalCompositeOperation = type\n</code></pre>\n<pre><code class=\"javascript\">var ctx;\nfunction draw() {\n    var canvas = document.getElementById(&#39;tutorial&#39;);\n    if(!canvas.getContext) return\n    var ctx = canvas.getContext(&#39;2d&#39;)\n    ctx.fillStyle = &#39;blue&#39;\n    ctx.fillRect(0,0,200,200)\n\n    ctx.globalCompositeOperation = &#39;source-over&#39; //全局合成操作\n    ctx.fillStyle = &#39;red&#39;\n    ctx.fillRect(100,100,200,200)\n}\n</code></pre>\n<blockquote>\n<p>注：下面的展示中，蓝色是原有的，红色是新的。</p>\n<p>type是下面13中字符串值之一:</p>\n</blockquote>\n<ol>\n<li><p>这是默认设置，新图像会覆盖在原有图像。</p>\n</li>\n<li><p><img src=\"https://www.runoob.com/wp-content/uploads/2018/12/1858023544-5b74dd8e0813d.png\" alt=\"img\"></p>\n</li>\n</ol>\n"},{"title":"middle-front","date":"2021-09-17T16:00:00.000Z","sidebar":"auto","_content":"\n# 1、HTML篇\n\n## 1.1 HTML5语义化\n[HTML5语义化](https://rainylog.com/post/ife-note-1/)\n\n### 1.1.1 为什么需要语义化\n\n* 易修改、易维护\n\n* 无障碍阅读支持\n\n* 搜索引擎友好、利于SEO\n\n* 面向未来的HTML、浏览器在未来可能提供更丰富的支持\n\n  \n\n### 1.1.2 结构语义化\n语义元素均有一个共同特点--他们均不做任何事情。换句话说，语义元素仅仅是页面结构的规范化，并不会对内容有本质的影响。\n\n下图展示了一个典型的页面结构。\n![](https://rainylog-1256215078.cos.ap-shanghai.myqcloud.com/images/page.png)\n\n\n\n### 1.1.3 头部\n`<header>`元素有两种用法，第一是标注内容的标题，第二是标注网页的页眉，如上图你看到的那样。除非必要（内容标题附带其他信息的情况下：发布时间、作者等），一般不在内容中使用`<header>`。因而，网页中可以包含多个`<header>`元素。按照HTML5的规定，`<header>`都应包含某个级别的标题，所以应隐式或显式地包含标题，通常将不希望显示的标题设置为`display: none;`，一方面遵守规范，另一方面则提供了无障碍阅读而不至于影响到页面设计。\n\n\n\n### 1.1.4 导航栏\n\n导航栏使用`<nav>`看起来是理所当然的，进一步，它也用于一组文章的链接。一个页面可以包含多个`<nav>`元素，但通常仅仅在页面的主要导航部分使用它。\n\n\n\n《HTML5：The Missing Manual》中指出了在侧栏使用`<nav>`标签的两个案例：\n\n```html\n<!-- 案例一 -->\n<nav>\n    <!-- 此处是链接 -->\n    <aside></aside>\n    <aside></aside>\n</nav>\n\n<!-- 案例二 -->\n<aside>\n\t<nav>\n    \t<!-- 此处是链接 -->\n    </nav>\n    <section></section>\n    <div></div>\n</aside>\n```\n\n如果侧栏中包含其它不同于链接的其它区块，那么，使用第二种方案显然更为合适。\n\n\n\n导航通常包含一组链接，普遍认为，链接使用列表来组织。\n\n```html\n<nav>\n\t<ul>\n        <li><a href=\"#\" title=\"链接\">链接</a></li>\n        <li><a href=\"#\" title=\"链接\">链接</a></li>\n        <li><a href=\"#\" title=\"链接\">链接</a></li>\n    </ul>\n</nav>\n```\n\n\n\n### 1.1.5 附注\n\n`<aside>`元素并不仅仅是侧栏，它表示与它周围文本没有密切关系的内容。文章中同样可以使用`<aside>`元素，来说明文章的附加内容、解释说明某个观点、相关内容链接等等。\n\n\n\n当`<aside>`用于侧栏时，其表示整个网页的附加内容。通常的广告区域、搜索、分享链接则位于侧栏。侧栏中的`<section>`元素规定了一个区域，通常是带有标题的内容。\n\n\n\n`<section>`标签适合标记的内容区块：\n\n* 与页面主体并列显示的小内容块。\n* 独立性内容，清单、表单等。\n* 分组内容，如CMS系统中的文章分类区块。\n* 比较长文档的一部分，可能仅仅是为了正确规定页面大纲。\n\n\n\n`<div>`标签依然是可用的，当你觉得使用其它标签都不太合适的时候。新的语义元素出现之前，我们总是这么干的！\n\n\n\n### 1.1.6 页脚\n\n同可”包罗万象“的`<header>`元素不同，标准规定`<footer>`标签仅仅可以包含版权、来源信息、法律限制等等之类的文本或链接信息。如果想要在页脚中包含其它内容，可以使用熟悉的`<div>`来帮忙。\n\n```html\n<div>\n    <aside>\n    <!-- 其它内容 -->\n    </aside>\n    \n    <footer>\n    <!-- 法律、版权、来源、联系信息等 -->\n    </footer>\n</div>\n```\n\n\n\n### 1.1.7 主要内容\n\n在早先的HTML5版本中并没有规定页面主体的标签，相关的书中经常会说：除去头部、尾部、侧栏等其它部分，剩下的自然是主体部分。\n\n\n\n然而，HTML5.1中规定了一个`<main>`标签来标识主体内容。`<main>`标签不能包含在页面其它区块元素中，通常是`<body>`的子标签，或者是全局`<div>`的子标签。`<main>`标签可以帮助屏幕阅读工具识别页面的主体部分，从而让访问者迅速得到有用的信息。\n\n\n\n### 1.1.8 文章\n\n`<article>`表示一个完整的、自成一体的内容块。如文章或新闻报道。`<article>`应包含完整的标题、文章署名、发布时间、正文。当语义与表现发生冲突，例如有时需要将文章分多个页面显示，那么需要把每个页面的文章区域都用`<article>`标记。\n\n\n\n文章中包含插图时，使用新的语义元素`<figure>`标签。\n\n```html\n<article>\n    <h1>标题</h1>\n    <p>\n        <!-- 内容 -->\n    </p>\n    <figure>\n    \t<img src=\"#\" alt=\"插图\">\n        <figcaption>这是一个插图</figcaption>\n    </figure>\n</article>\n```\n\n上述情况下，`<figcaption>`包含了关于插图的详细解释，则`<img>`的`alt`属性可以略去。\n\n\n\n### 1.1.9 IFE任务\n\n#### 1.1.9.1 任务描述\n\n参考示例图（[点击查看](http://7xrp04.com1.z0.glb.clouddn.com/task_1_1_1.jpg)），完成一个HTML页面代码编写（不写CSS，不需要关注样式，只关注文档结构）。\n\n\n\n#### 1.1.9.2 范例\n\n用语义化来构建该页面的结构：[点击查看](https://github.com/geekrainy/ife/blob/master/task/task-1/index.html)\n\n\n\n# 2、CSS篇\n\n## 2.1 CSS常见面试题\n\n[45道CSS经典面试题](https://segmentfault.com/a/1190000013325778)\n\n### 2.1.1 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\n\n* `标准盒子模型`：宽度 = 内容的宽度（content）+ border + padding + margin\n* `低版本IE盒子模型`：宽度 = 内容宽度（content + border + padding）+ margin\n\n\n\n### 2.1.2 box-sizing属性？\n\n用来控制元素的盒子模型的解析模式，默认为`content-box`。\n\n* `content-box`：W3C的标准盒子模型，设置元素的`height/width`属性指的是`content`部分的高/宽。\n* `border-box`：IE传统盒子模型。设置元素的`height/width`属性指的是`border + padding + content`部分的高/宽。\n\n\n\n### 2.1.3 CSS选择器有哪些？哪些属性可以继承？\n\n* `CSS选择符`：id选择器(#myid)、类选择器(.myclassname)、标签选择器(div,h1,p)、相邻选择器(h1 + p)、子选择器(ul > li)、后代选择器(li a)、通配符选择器(*)、属性选择器(a[rel=\"external\"])、伪类选择器(a:hover, li:nth-child)\n* `可继承的属性`：font-size，font-family，color\n* `不可继承的样式`：border，padding，margin，width，height\n* `优先级（就近原则）`：!important > [id > class > tag]，!important比内联优先级高\n\n\n\n### 2.1.4 CSS优先级算法如何计算？\n\n* 元素选择符：1\n* class选择符：10\n* id选择符：100\n* 元素标签：1000\n\n\n\n1. !important声明的样式优先级最高，如果冲突再进行计算。\n2. 如果优先级相同，则选择最后出现的样式。\n3. 继承得到的样式的优先级最低。\n\n\n\n### 2.1.5 CSS3新增伪类有哪些？\n\n* `p:first-of-type`：选择属于其父元素的首个元素\n* `p:last-of-type`：选择属于其父元素的最后元素\n* `p:only-of-type`：选择属于其父元素唯一的元素\n* `p:only-child`：选择属于其父元素的唯一子元素\n* `p:nth-child(2)`：选择属于其父元素的第二个子元素\n* `:enabled, :disabled`：表单控件的禁用状态\n* `:checked`：单选框或复选框被选中\n\n\n\n### 2.1.6 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\n\n> div\n\n```css\nborder: 1px solid red;\nmargin: 0 auto;\nheight: 50px;\nwidth: 80px;\n```\n\n\n\n> 浮动元素的上下左右居中\n\n```css\nborder: 1px solid red;\nfloat: left;\nposition: absolute;\nwidth: 200px;\nheight: 100px;\nleft: 50%;\ntop: 50%;\nmargin: -50px 0 0 -100px;\n```\n\n\n\n> 绝对定位的左右居中\n\n```css\nborder: 1px solid black;\nposition: absolute;\nwidth: 200px;\nheight: 100px;\nmargin: 0 auto;\nleft: 0;\nright: 0;\n```\n\n\n\n### 2.1.7 display有哪些值？说明他们的作用？\n\n* `inline`（默认）：内联\n* `none`：隐藏\n* `block`：块显示\n* `table`：表格显示\n* `list-item`：项目列表\n* `inline-block`\n\n\n\n### 2.1.8 position的值？\n\n* `static`（默认）:按照正常文档流进行排列\n* `relative`（相对定位）：不脱离文档流，参考自身静态位置通过top，bottom，left，right定位\n* `absolute`（绝对定位）：参考距其最近一个不为static的父级元素通过top,bottom,left,right定位\n* `fixed`（固定定位）：所固定的参照对象是可视窗口\n\n\n\n### 2.1.9 CSS3有哪些新特性？\n\n1. RGBA和透明度\n2. background-image  background-origin(content-box/padding-box/border-box)   background-size   background-repeat\n3. word-wrap（对长的不可分割单词换行）word-wrap:break-word\n4. 文字阴影：text-shadow: 5px 5px 5px #FF0000; （水平阴影，垂直阴影，模糊距离，阴影颜色）\n5. font-face属性：定义自己的字体\n6. 圆角（边框半径）：border-radius 属性用于创建圆角\n7. 边框图片：border-image: url(border.png) 30 30 round;\n8. 盒阴影：box-shadow: 10px 10px 5px #888888;\n9. 媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性\n\n\n\n### 2.1.10 请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？\n\n该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，`block`布局是把块在垂直方向从上到下依次排列的；而`inline`布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。\n\n\n\n使用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。\n\n\n\n### 2.1.11 用纯CSS创建一个三角形的原理是什么？\n\n首先，需要把元素的宽度、高度设为0.然后设置边框样式。\n\n```css\nwidth: 0;\nheight: 0;\nborder-top: 40px solid transparent;\nborder-left: 40px solid transparent;\nborder-right: 40px solid transparent;\nborder-bottom: 40px solid #ff0000;\n```\n\n\n\n### 2.1.12 一个满屏品字布局如何设计？\n\n第一种真正的品字：\n\n1. 三块高宽是确定的；\n2. 上面那块用`margin: 0 auto;`居中；\n3. 下面两块用`float`或者`inline-block`不换行；\n4. 用`margin`调整位置使他们居中。\n\n\n\n第二种全屏的品字布局：\n\n上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行\n\n\n\n### 2.1.13 常见的兼容性问题？\n\n1. 不同浏览器的标签默认的`margin`和`padding`不一样。\n\n   ```css\n   * {\n   \tmargin: 0;\n       padding: 0;\n   }\n   ```\n\n   \n\n2. IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。\n\n   ```css\n   hack: diaplay: inline; // 将其转化为行内属性。\n   ```\n\n3. 渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用\"9\"这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用”+“将IE8和IE7、IE6分离开来，这样IE8已经独立识别。\n\n   ```css\n   {\n   \tbackground-color: #f1ee18; /*所有识别*/\n       .background-color: #00deff\\9; /*IE6、7、8识别*/\n       +background-color: #a200ff; /*IE6、7识别*/\n       _background-color: #1e0bd1; /*IE6识别*/\n   }\n   ```\n\n   \n\n4. 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden; 或者设置行高line-height小于你设置的高度。\n\n5. IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用`getAttribute()`获取自定义属性；Firefox下，只能使用`getAttribute()`获取自定义属性。解决方法：统一通过`getAttribute()`获取自定义属性。\n\n6. Chrome中文界面下默认会将小于12px的文本强制按照12px显示，可以通过加入CSS属性 `-webkit-text-size-adjust:none;`解决\n\n7. 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有`hover`和`active`了。解决方法是改变CSS属性的排列顺序：L-V-H-A(love hate):  a:link{}  a:visited{}  a:hover{}  a:active{}\n\n   \n\n   \n### 2.1.14 为什么要初始化CSS样式？\n\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n\n\n\n### 2.1.15 absolute的containing block计算方式跟正常流有什么不同？\n\n无论属于哪种，都要先找到其祖先元素中最近的`position`值不为`static`的元素，然后再判断：\n\n1. 若此元素为`inline`元素，则`containing block`为能够包含这个元素生成的第一个和最后一个`inline box`的`padding box`（除margin，border外的区域）的最小矩形\n2. 否则，则由这个祖先元素的`padding box`构成。\n\n如果都找不到，则为`intial containing block`。\n\n\n\n> 补充：\n>\n> 1. static（默认的）/relative：简单说就是它的父元素的内容框（即去掉padding的部分）\n> 2. absolute：向上找最近的定位为absolute/relative的元素\n> 3. fixed：它的containing block一律为根元素（html/body）\n\n\n\n### 2.1.16 CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？\n\n当一个元素的`visibility`属性被设置成`collapse`值后，对于一般的元素，它的表现跟`hidden`是一样的。\n\n1. chrome中，使用`collapse`值和使用`hidden`没有区别。\n2. firefox，opera和IE，使用`collapse`和使用`display:none`没有什么区别。\n\n\n\n### 2.1.17 display:none与visibility:hidden的区别？\n\n* `display:none`不显示对应的元素，在文档布局中不再分配空间（回流+重绘）\n* `visibility:hidden`隐藏对应元素，在文档布局中仍保留原来的空间（重绘）\n\n\n\n### 2.1.18 position跟display、overflow、float这些特性相互叠加后会怎么样？\n\ndisplay属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。\n\n\n\n类似于优先级机制：position:absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float或者absolute定位的元素，只能是块元素或表格。\n\n\n\n### 2.1.19 对BFC规范（块级格式化上下文：block formatting context）的理解？\n\nBFC规定了内部的Block Box如何布局。\n\n定位方案：\n\n \t1. 内部的Box会在垂直方向上一个接一个放置。\n \t2. Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。\n \t3. 每个元素的margin box的左边，与包含块border box的左边相接触。\n \t4. BFC的区域不会与float box重叠。\n \t5. BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。\n \t6. 计算BFC的高度时，浮动元素也会参与计算。\n\n\n\n满足下列条件之一就可触发BFC\n\n1. 根元素，html\n2. float的值不为none（默认）\n3. overflow的值不为visible（默认）\n4. display的值为inline-block、table-cell、table-caption\n5. position的值为absolute或fixed\n\n\n\n### 2.1.20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？\n\n浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。\n\n\n\n浮动带来的问题：\n\n \t1. 父元素的高度无法被撑开，影响与父元素同级的元素\n \t2. 与浮动元素同级的非浮动元素（内联元素）会跟谁其后\n \t3. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。\n\n\n\n清除浮动的方式：\n\n \t1. 父级div定义height\n \t2. 最后一个浮动元素后加空div标签，并添加样式clear:both\n \t3. 包含浮动元素的父标签添加样式overflow为hidden或auto\n \t4. 父级div定义zoom\n\n\n\n### 2.1.21 上下margin重合的问题\n\n在重合元素外包裹一层容器，并触发该容器生成一个BFC。\n\n例子：\n\n```html\n<div class=\"aside\"></div>\n<div class=\"text\">\n    <div class=\"main\"></div>\n</div>\n<!--下面是css代码-->\n.aside {\n    margin-bottom: 100px;  \n    width: 100px;\n    height: 150px;\n    background: #f66;\n}\n.main {\n    margin-top: 100px;\n    height: 200px;\n    background: #fcc;\n}\n.text{\n    /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/\n    overflow: hidden;  //此时已经触发了BFC属性。\n}\n\n```\n\n\n\n### 2.1.22 设置元素浮动后，该元素的display值是多少？\n\n自动变成display:block\n\n\n\n### 2.1.23 移动端的布局用过媒体查询吗？\n\n通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。\n\n```html\n// <head>里边\n<link rel=\"stylesheet\" type=\"text/css\" href=\"xxx.css\" media=\"only screen and (max-device-width:480px)\">\n    \n//css\n@media only screen and (max-device-width:480px) {\n\t//css样式\n}\n```\n\n\n\n### 2.1.24 使用css预处理器吗？\n\nless sass\n\n\n\n### 2.1.25 CSS优化、提高性能的方法有哪些？\n\n1. 避免过度约束\n2. 避免后代选择符\n3. 避免链式选择符\n4. 使用紧凑的语法\n5. 避免不必要的命名空间\n6. 避免不必要的重复\n7. 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么\n8. 避免!important，可以选择其他选择器\n9. 尽可能的精简规则，你可以合并不同类里的重复规则\n\n\n\n### 2.1.26 浏览器是怎样解析CSS选择器的？\n\nCSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\n\n而在CSS解析完毕后，需要将解析的结果与DOM Tree的内容一起进行分析建立一颗Render Tree，最终用来进行绘图。在建立Render Tree时（Webkit中的「Attachment」过程），浏览器就要为每个DOM Tree中的元素根据CSS的解析结果（Style Rules）来确定生成怎样的Render Tree。\n\n\n\n### 2.1.27 在网页中应该使用奇数还是偶数的字体？为什么呢？\n\n使用偶数字体。偶数字号相对更容易和Web设计的其他部分构成比例关系。Windows自带的点阵宋体（中易宋体）从Vista开始只提供12、14、16px这三个大小的点阵，而13、15、17px时用的是小一号的点。（即每个字占的空间大了1px，但点阵没变），于是略显稀疏。\n\n\n\n### 2.1.28 margin和padding分别适合什么场景使用？\n\n* 何时使用margin：\n  * 需要在border外侧添加空白\n  * 空白处不需要背景色\n  * 上下相连的两个盒子之间的空白，需要相互抵消时。\n* 何时使用padding：\n  * 需要在border内添加空白\n  * 空白处需要北京颜色\n  * 上下相连的两个盒子的空白，希望为两者之和\n* 兼容性的问题：在IE5和IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display:inline解决\n\n\n\n### 2.1.29 元素竖向的百分比设定是相对于容器的高度吗？\n\n当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如padding-top，padding-bottom，margin-top，margin-bottom等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。\n\n\n\n### 2.1.30 全屏滚动的原理是什么？用到了CSS的哪些属性？\n\n1. 原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现\n2. overflow:hidden;transition: all 1000ms ease;\n\n\n\n### 2.1.31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\n\n响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。\n\n基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。\n\n页面头部必须有meta声明的viewport。\n\n```html\n<meta name=’viewport’ content=”width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no”>\n```\n\n\n\n### 2.1.32 视觉滚动效果？\n\n视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。\n\n1. CSS3实现\n\n   * 优点：开发时间短、性能和开发效率比较好\n   * 缺点：不能兼容到低版本的浏览器\n\n2. jQuery实现\n\n   通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。\n\n   * 优点：能兼容到各个版本的，效果可控性好\n   * 缺点：开发起来对制作者要求高\n\n3. 插件实现方式\n\n   例如：parallax-scrolling，兼容性十分好\n\n\n\n### 2.1.33 ::before和:after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用\n\n1. 单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素\n2. ::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。\n\n\n\n:before和:after这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before和::after\n\n\n\n### 2.1.34 你对line-height是如何理解的？\n\n行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。\n\n单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。\n\n多行文本垂直居中：需要设置display属性为inline-block。\n\n\n\n### 2.1.35 怎么让Chrome支持小于12px的文字？\n\n```css\np{font-size:10px;-webkit-transform:scale(0.8);} //0.8是缩放比例\n```\n\n\n\n### 2.1.36 让页面里的字体变清晰，变细用CSS怎么做？\n\n-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用`-webkit-font-smoothing:antialiased`是最佳的，灰度平滑。\n\n\n\n### 2.1.37 position:fixed;在android下无效怎么处理？\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"/>\n```\n\n\n\n### 2.1.38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\n\n多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms = 16.7ms。\n\n\n\n### 2.1.39 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\n\n行框的排列会受到中间空白（回车空格）等的影响，因为空白也属于字符，这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。\n\n> 解决办法：\n\n1. 可以将`<li>`代码全部写在一排\n2. 浮动li中`float:left`\n3. 在`ul`中用`font-size:0`（谷歌不支持）；可以使用`letter-space:-3px`\n\n\n\n### 2.1.40 display:inline-block什么时候会显示间隙？\n\n1. 有空格时候会有间隙\n\n   解决：移除空格\n\n2. margin正值的时候\n\n   解决：margin使用负值\n\n3. 使用font-size时候\n\n   解决：font-size:0、letter-spacing、word-spacing\n\n\n\n### 2.1.41 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\n\n外层div使用`position:relative;`高度要求自适应的div使用`position:absolute;top:100px;bottom:0;left:0`\n\n\n\n### 2.1.42 png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？\n\n1. png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。大多数地方都可以用。\n2. jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。\n3. gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。\n4. webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。\n\n\n\n### 2.1.43 style标签写在body后与body前有什么区别？\n\n页面加载自上而下，当然是先加载样式。\n\n写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）\n\n\n\n### 2.1.44 CSS属性overflow属性定义溢出元素内容区的内容会如何处理？\n\n* 参数是scroll的时候，必会出现滚动条\n* 参数是auto的时候，子元素内容大于父元素时出现滚动条\n* 参数是visible的时候，溢出的内容出现在父元素之外\n* 参数是hidden的时候，溢出隐藏\n\n\n\n### 2.1.45 阐述一下CSS Sprites\n\n将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的`background-image`，`background-repeat`，`background-position`的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大提高页面的性能，CSS Sprites能减少页面的字节。\n\n\n\n## 2.2 能不能讲一讲Flex布局，以及常用的属性？\n\n[阮一峰的flex系列](https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html)\n\n### 2.2.1 flex布局是什么？\n\nFlex是Flexible Box的缩写，意为”弹性布局“，用来为盒装模型提供最大的灵活性。\n\n任何一个容器都可以指定为Flex布局。\n\n```css\n.box {\n\tdisplay: flex;\n}\n```\n\n\n\n行内元素也可以使用Flex布局。\n\n```css\n.box {\n\tdisplay: inline-flex;\n}\n```\n\n\n\nWebkit内核的浏览器，必须加上`-webkit`前缀。\n\n```css\n.box {\n\tdisplay: -webkit-flex; /* Safari */\n    display: flex;\n}\n```\n\n\n\n> 注意，设为Flex布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\n\n\n\n### 2.2.2 基本概念\n\n采用Flex布局的元素，称为Flex容器（flex container），简称”容器“。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目“。\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。\n\n\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n\n\n### 2.2.3 容器的属性\n\n以下6个属性设置在容器上。\n\n* flex-direction\n* flex-wrap\n* flex-flow\n* justify-content\n* align-items\n* align-content\n\n\n\n#### 2.2.3.1 flex-direction属性\n\n`flex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n```css\n.box {\n\tflex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png)\n\n\n\n它可能有四个值。\n\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n\n\n\n#### 2.2.3.2 flex-wrap属性\n\n默认情况下，项目都排在一条线（又称“轴线”）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png)\n\n```css\n.box {\n\tflex-wrap: nowrap | wrap | wrap-reverse; \n}\n```\n\n\n\n它可能取三个值。\n\n1. `nowrap`（默认）：不换行。\n\n   ![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png)\n\n2. `wrap`：换行，第一行在上方。\n\n   ![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg)\n\n3. `wrap-reverse`：换行，第一行在下方。\n\n   ![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg)\n\n\n\n#### 2.2.3.3 flex-flow\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n\n```css\n.box {\n\tflex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n\n\n#### 2.2.3.4 justify-content属性\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n```css\n.box {\n\tjustify-content: flex-start | flex-end | center | space-between\n}\n```\n\n![justify-content](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)\n\n它可能取五个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n* flex-start(默认值)：左对齐\n* flex-end：右对齐\n* center：居中\n* space-between：两端对齐，项目之间的间隔都相等\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n\n\n#### 2.2.3.5 align-items属性\n\n`align-items`属性定义项目在交叉轴上如何对齐。\n\n```css\n.box {\n\talign-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![align-items](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n* flex-start：交叉轴的起点对齐\n* flex-end：交叉轴的终点对齐\n* center：交叉轴的中点对齐\n* baseline：项目的第一行文字的基线对齐\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度\n\n\n\n#### 2.2.3.6 align-content属性\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n```css\n.box {\n\talign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n\n该属性可能取6个值。\n\n* flex-start：与交叉轴的起点对齐\n* flex-end：与交叉轴的终点对齐\n* center：与交叉轴的中点对齐\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍\n* stretch（默认值）：轴线占满整个交叉轴\n\n\n\n### 2.2.4 项目的属性\n\n以下6个属性设置在项目上。\n\n* order\n* flex-grow\n* flex-shrink\n* flex-basis\n* flex\n* align-self\n\n\n\n#### 2.2.4.1 order属性\n\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n\n```css\n.item {\n\torder: <integer>;\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)\n\n\n\n#### 2.2.4.2 flex-grow属性\n\n`flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。\n\n```css\n.item {\n\tflex-grow: <number>; /* default 0 */\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png)\n\n如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n\n\n#### 2.2.4.3 flex-shrink属性\n\n`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n```css\n.item {\n\tflex-shrink: <number>; /* default 1 */\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)\n\n如果所有项目的`flex-shrink`属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n\n\n#### 2.2.4.4 flex-basis属性\n\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n```css\n.item {\n\tflex-basis: <length> | auto; /* default auto */\n}\n```\n\n它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。\n\n\n\n#### 2.2.4.5 flex属性\n\n`flex`属性是`flex-grow`，`flex-shrink`和`flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n```css\n.item {\n\tflex: none | [<'flex-grow'><'flex-shrink'><'flex-basis'>]\n}\n```\n\n该属性有两个快捷键：`auto`（`1 1 auto`）和`none`（`0 0 auto`）。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n\n\n#### 2.2.4.6 align-self属性\n\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png)\n\n该属性可能去6个值，除了auto，其他都与align-items属性完全一致。\n\n\n\n# 3、JS篇\n\n## 3.1 从原型到原型链\n\n### 3.1.2 构造函数创建对象\n\n我们先使用构造函数创建一个对象：\n\n```js\nfunction Person() {\n\n}\nvar person = new Person();\nperson.name = 'Kevin';\nconsole.log(person.name) // Kevin\n```\n\n在这个例子中，`Person`就是一个构造函数，我们使用`new`创建了一个实例对象`person`。\n\n很简单吧，接下来进入正题：\n\n\n\n### 3.1.3 prototype\n\n每个函数都有一个`prototype`属性，就是我们经常在各种例子中看到的那个`prototype`，比如：\n\n```js\nfunction Person() {\n}\n// 虽然写在注释里，但是你要注意：\n// prototype是函数才会有的属性\nPerson.prototype.name = 'Kevin';\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name) // Kevin\nconsole.log(person2.name) // Kevin\n```\n\n那这个函数的`prototype`属性到底指向的是什么呢？是这个函数的原型吗？\n\n其实，函数的`prototype`属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的`person1`和`person2`的原型。\n\n那什么是原型呢？你可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。\n\n让我们用一张图表示构造函数和实例原型之间的关系：\n\n![prototype](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/prototype.png))\n\n\n\n在这张图中我们用`Object.prototype`表示实例原型。\n\n那么我们该怎么表示实例与实例原型，也就是`person`和`Person.prototype`之间的关系呢，这时候我们就要讲到第二个属性：\n\n\n\n### 3.1.4 `__proto__`\n\n这是每一个JavaScript对象（除了null）都具有的一个属性，叫`__proto__`，这个属性会指向该对象的原型。\n\n为了证明这一点，我们可以在火狐或者谷歌中输入：\n\n```js\nfunction Person(){\n    \n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n于是我们更新下关系图：\n\n![__proto__](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/__proto__.png)\n\n既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？\n\n\n\n### 3.1.5 constructor\n\n指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：`constructor`，每个原型都有一个`constructor`属性指向关联的构造函数。\n\n为了验证这一点，我们可以尝试：\n\n```js\nfunction Person() {\n}\nconsole.log(Person === Person.prototype.constructor); // true\n```\n\n所以再更新下关系图：\n\n![constructor](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/constructor.png)\n\n综上我们已经得出：\n\n```js\nfunction Person() {\n    \n}\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法，可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n```\n\n\n\n了解了构造函数、实力原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：\n\n\n\n### 3.1.6 实例与原型\n\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n\n\n举个例子：\n\n```js\nfunction Person() {\n}\nPerson.prototype.name = 'Kevin';\n\nvar person = new Person();\nperson.name = 'Daisy';\nconsole.log(person.name) // Daisy\n\ndelete person.name;\nconsole.log(person.name) // Kevin\n```\n\n在这个例子中，我们给实例对象`person`添加了`name`属性，当我们打印`person.name`的时候，结果自然为`Daisy`。\n\n但是当我们删除了`person`的`name`属性时，读取`person.name`，从`person`对象中找不到`name`属性就会从`person`的原型也就是`person.__ptoto__`，也就是`Person.prototype`中查找，幸运的是我们找到了`name`属性，结果为`Kevin`。\n\n\n\n但是万一还没有找到呢？原型的原型又是什么呢？\n\n\n\n### 3.1.7 原型的原型\n\n在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```js\nvar obj = new Object();\nobj.name = 'Kevin'\nconsole.log(obj.name) // Kevin\n```\n\n其实原型对象就是通过`Object`构造函数生成的，结合之前所讲，实例的`__proto__`指向构造函数的`prototype`，所以我们再更新下关系图：\n\n![原型的原型](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/原型的原型.png)\n\n\n\n### 3.1.8 原型链\n\n那 Object.prototype 的原型呢？\n\nnull，我们可以打印：\n\n```js\nconsole.log(Object.prototype.__proto__ === null) // true\n```\n\n\n\n然而`null`究竟代表了什么呢？\n\n引用阮一峰的《[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)》就是：\n\n> null表示“没有对象”，即该处不应该有值。\n\n所以`Object.prototype.__proto__`的值为`null`跟`Object.prototype`没有原型，其实表达了一个意思。\n\n所以查找到属性的时候查到`Object.prototype`就可以停止查找了。\n\n最后一张关系图也可以更新为：\n\n![原型链](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/原型链.png)\n\n顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。\n\n\n\n\n\n> 补充\n\n### 3.1.9 constructor\n\n首先是`constructor`属性，我们看个例子：\n\n```js\nfunction Person() {\n}\nvar person = new Person();\nconsole.log(person.constructor === Person); // true\n```\n\n当获取`person.constructor`时，其实`person`中并没有`constructor`属性，当不能读取到`constructor`属性时，会从`person`的原型也就是`Person.prototype`中读取，正好原型中有该属性，所以：\n\n```js\nperson.constructor === Person.prototype.constructor\n```\n\n\n\n### 3.1.10 `__proto__`\n\n其次是`__proto__`，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于`Person.prototype`中，实际上，它是来自于`Object.prototype`，与其说是一个属性，不如说是一个`getter/setter`，当使用`obj.__proto__`时，可以理解成返回了`Object.getPrototypeOf(obj)`。\n\n\n\n### 3.1.11 真的是继承吗？\n\n最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’‘属性’”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：\n\n\n\n继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n\n\n\n\n\n## 3.2 JavaScript深入之词法作用域和动态作用域\n\n### 3.2.1 作用域\n\n作用域是指程序源代码中定义变量的区域。\n\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n\nJavaScript采用词法作用域（lexical scoping），也就是静态作用域。\n\n\n\n### 3.2.2 静态作用域与动态作用域\n\n因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了。\n\n而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。\n\n让我们认真看个例子就能明白之间的区别：\n\n```js\nvar vaule = 1;\nfunction foo() {\n\tconsole.log(value);\n}\nfunction bar() {\n\tvar value = 2;\n    foo();\n}\nbar();\n\n// 结果是？？？\n```\n\n假设JavaScript采用静态作用域，让我们分析下执行过程：\n\n\n\n执行`foo`函数，先从`foo`函数内部查找是否有局部变量`value`，如果没有，就根据书写的位置，查找上面一层的代码，也就是`value`等于1，所以结果会打印1。\n\n\n\n假设JavaScript采用动态作用域，让我们分析下执行过程：\n\n\n\n执行`foo`函数，依然是从`foo`函数内部查找是否有局部变量`value`。如果没有，就从调用函数的作用域，也就是`bar`函数内部查找`value`变量，所以结果会打印2。\n\n\n\n前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是1。\n\n\n\n### 3.2.3 动态作用域\n\n也许你会好奇什么语言是动态作用域？\n\n`bash`就是动态作用域，不信的话，把下面的脚本存成例如`scope.bash`，然后进行相应的目录，用命令行执行`bash ./scope.bash`，看看打印的值是多少。\n\n```js\nvalue = 1\nfunction foo() {\n\techo $value;\n}\nfunction bar() {\n\tlocal value = 2;\n    foo;\n}\nbar\n```\n\n\n\n### 3.2.4 思考题\n\n最后，让我们看一个《JavaScript权威指南》中的例子：\n\n```js\nvar scope = 'global scope';\nfunction checkscope() {\n\tvar scope = 'local scope';\n    function f() {\n\t\treturn scope;\n    }\n    return f();\n}\ncheckscope();\n```\n\n```js\nvar scope = 'global scope';\nfunction checkscope() {\n\tvar scope = 'local scope';\n    function f() {\n\t\treturn scope;\n    }\n    return f;\n}\ncheckscope()();\n```\n\n两段代码都会打印：`local scope`。\n\n原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。\n\n而引用《JavaScript权威指南》的回答就是：\n\nJavaScript函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数`f()`定义在这个作用域链里，其中的变量scope一定是局部变量，不管何时何地执行`f()`，这种绑定在执行`f()`时依然有效。\n\n\n\n但是在这里真正想让大家思考的是：\n\n虽然两端代码执行的结果一样，但是两段代码究竟有哪些不同呢？\n\n如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下文。\n\n\n\n## 3.3 JavaScript深入之执行上下文栈\n\n### 3.3.1 顺序执行？\n\n如果要问到JavaScript代码执行顺序的话，想必写过JavaScript的开发者都会有个直观的印象，那就是顺序执行，毕竟：\n\n```js\nvar foo = function() {\n\tconsole.log('foo1');\n}\nfoo(); // foo1\n\nvar foo = function() {\n\tconsole.log('foo2');\n}\nfoo(); // foo2\n```\n\n\n\n然而去看这段代码：\n\n```js\nfunction foo() {\n\tconsole.log('foo1');\n}\nfoo(); // foo2\nfunction foo() {\n\tconsole.log('foo2');\n}\nfoo(); // foo2\n```\n\n打印的结果却是两个`foo2`。\n\n\n\n刷过面试题的都知道这是因为JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。\n\n\n\n但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？\n\n\n\n到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？\n\n\n\n### 3.3.2 可执行代码\n\n\n\n","source":"_posts/middle-front.md","raw":"---\n\n\ntitle: middle-front\ndate: 2021-09-18\ncategories:\n  - front\ntags:\n  - 前端\nsidebar: auto\n---\n\n# 1、HTML篇\n\n## 1.1 HTML5语义化\n[HTML5语义化](https://rainylog.com/post/ife-note-1/)\n\n### 1.1.1 为什么需要语义化\n\n* 易修改、易维护\n\n* 无障碍阅读支持\n\n* 搜索引擎友好、利于SEO\n\n* 面向未来的HTML、浏览器在未来可能提供更丰富的支持\n\n  \n\n### 1.1.2 结构语义化\n语义元素均有一个共同特点--他们均不做任何事情。换句话说，语义元素仅仅是页面结构的规范化，并不会对内容有本质的影响。\n\n下图展示了一个典型的页面结构。\n![](https://rainylog-1256215078.cos.ap-shanghai.myqcloud.com/images/page.png)\n\n\n\n### 1.1.3 头部\n`<header>`元素有两种用法，第一是标注内容的标题，第二是标注网页的页眉，如上图你看到的那样。除非必要（内容标题附带其他信息的情况下：发布时间、作者等），一般不在内容中使用`<header>`。因而，网页中可以包含多个`<header>`元素。按照HTML5的规定，`<header>`都应包含某个级别的标题，所以应隐式或显式地包含标题，通常将不希望显示的标题设置为`display: none;`，一方面遵守规范，另一方面则提供了无障碍阅读而不至于影响到页面设计。\n\n\n\n### 1.1.4 导航栏\n\n导航栏使用`<nav>`看起来是理所当然的，进一步，它也用于一组文章的链接。一个页面可以包含多个`<nav>`元素，但通常仅仅在页面的主要导航部分使用它。\n\n\n\n《HTML5：The Missing Manual》中指出了在侧栏使用`<nav>`标签的两个案例：\n\n```html\n<!-- 案例一 -->\n<nav>\n    <!-- 此处是链接 -->\n    <aside></aside>\n    <aside></aside>\n</nav>\n\n<!-- 案例二 -->\n<aside>\n\t<nav>\n    \t<!-- 此处是链接 -->\n    </nav>\n    <section></section>\n    <div></div>\n</aside>\n```\n\n如果侧栏中包含其它不同于链接的其它区块，那么，使用第二种方案显然更为合适。\n\n\n\n导航通常包含一组链接，普遍认为，链接使用列表来组织。\n\n```html\n<nav>\n\t<ul>\n        <li><a href=\"#\" title=\"链接\">链接</a></li>\n        <li><a href=\"#\" title=\"链接\">链接</a></li>\n        <li><a href=\"#\" title=\"链接\">链接</a></li>\n    </ul>\n</nav>\n```\n\n\n\n### 1.1.5 附注\n\n`<aside>`元素并不仅仅是侧栏，它表示与它周围文本没有密切关系的内容。文章中同样可以使用`<aside>`元素，来说明文章的附加内容、解释说明某个观点、相关内容链接等等。\n\n\n\n当`<aside>`用于侧栏时，其表示整个网页的附加内容。通常的广告区域、搜索、分享链接则位于侧栏。侧栏中的`<section>`元素规定了一个区域，通常是带有标题的内容。\n\n\n\n`<section>`标签适合标记的内容区块：\n\n* 与页面主体并列显示的小内容块。\n* 独立性内容，清单、表单等。\n* 分组内容，如CMS系统中的文章分类区块。\n* 比较长文档的一部分，可能仅仅是为了正确规定页面大纲。\n\n\n\n`<div>`标签依然是可用的，当你觉得使用其它标签都不太合适的时候。新的语义元素出现之前，我们总是这么干的！\n\n\n\n### 1.1.6 页脚\n\n同可”包罗万象“的`<header>`元素不同，标准规定`<footer>`标签仅仅可以包含版权、来源信息、法律限制等等之类的文本或链接信息。如果想要在页脚中包含其它内容，可以使用熟悉的`<div>`来帮忙。\n\n```html\n<div>\n    <aside>\n    <!-- 其它内容 -->\n    </aside>\n    \n    <footer>\n    <!-- 法律、版权、来源、联系信息等 -->\n    </footer>\n</div>\n```\n\n\n\n### 1.1.7 主要内容\n\n在早先的HTML5版本中并没有规定页面主体的标签，相关的书中经常会说：除去头部、尾部、侧栏等其它部分，剩下的自然是主体部分。\n\n\n\n然而，HTML5.1中规定了一个`<main>`标签来标识主体内容。`<main>`标签不能包含在页面其它区块元素中，通常是`<body>`的子标签，或者是全局`<div>`的子标签。`<main>`标签可以帮助屏幕阅读工具识别页面的主体部分，从而让访问者迅速得到有用的信息。\n\n\n\n### 1.1.8 文章\n\n`<article>`表示一个完整的、自成一体的内容块。如文章或新闻报道。`<article>`应包含完整的标题、文章署名、发布时间、正文。当语义与表现发生冲突，例如有时需要将文章分多个页面显示，那么需要把每个页面的文章区域都用`<article>`标记。\n\n\n\n文章中包含插图时，使用新的语义元素`<figure>`标签。\n\n```html\n<article>\n    <h1>标题</h1>\n    <p>\n        <!-- 内容 -->\n    </p>\n    <figure>\n    \t<img src=\"#\" alt=\"插图\">\n        <figcaption>这是一个插图</figcaption>\n    </figure>\n</article>\n```\n\n上述情况下，`<figcaption>`包含了关于插图的详细解释，则`<img>`的`alt`属性可以略去。\n\n\n\n### 1.1.9 IFE任务\n\n#### 1.1.9.1 任务描述\n\n参考示例图（[点击查看](http://7xrp04.com1.z0.glb.clouddn.com/task_1_1_1.jpg)），完成一个HTML页面代码编写（不写CSS，不需要关注样式，只关注文档结构）。\n\n\n\n#### 1.1.9.2 范例\n\n用语义化来构建该页面的结构：[点击查看](https://github.com/geekrainy/ife/blob/master/task/task-1/index.html)\n\n\n\n# 2、CSS篇\n\n## 2.1 CSS常见面试题\n\n[45道CSS经典面试题](https://segmentfault.com/a/1190000013325778)\n\n### 2.1.1 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\n\n* `标准盒子模型`：宽度 = 内容的宽度（content）+ border + padding + margin\n* `低版本IE盒子模型`：宽度 = 内容宽度（content + border + padding）+ margin\n\n\n\n### 2.1.2 box-sizing属性？\n\n用来控制元素的盒子模型的解析模式，默认为`content-box`。\n\n* `content-box`：W3C的标准盒子模型，设置元素的`height/width`属性指的是`content`部分的高/宽。\n* `border-box`：IE传统盒子模型。设置元素的`height/width`属性指的是`border + padding + content`部分的高/宽。\n\n\n\n### 2.1.3 CSS选择器有哪些？哪些属性可以继承？\n\n* `CSS选择符`：id选择器(#myid)、类选择器(.myclassname)、标签选择器(div,h1,p)、相邻选择器(h1 + p)、子选择器(ul > li)、后代选择器(li a)、通配符选择器(*)、属性选择器(a[rel=\"external\"])、伪类选择器(a:hover, li:nth-child)\n* `可继承的属性`：font-size，font-family，color\n* `不可继承的样式`：border，padding，margin，width，height\n* `优先级（就近原则）`：!important > [id > class > tag]，!important比内联优先级高\n\n\n\n### 2.1.4 CSS优先级算法如何计算？\n\n* 元素选择符：1\n* class选择符：10\n* id选择符：100\n* 元素标签：1000\n\n\n\n1. !important声明的样式优先级最高，如果冲突再进行计算。\n2. 如果优先级相同，则选择最后出现的样式。\n3. 继承得到的样式的优先级最低。\n\n\n\n### 2.1.5 CSS3新增伪类有哪些？\n\n* `p:first-of-type`：选择属于其父元素的首个元素\n* `p:last-of-type`：选择属于其父元素的最后元素\n* `p:only-of-type`：选择属于其父元素唯一的元素\n* `p:only-child`：选择属于其父元素的唯一子元素\n* `p:nth-child(2)`：选择属于其父元素的第二个子元素\n* `:enabled, :disabled`：表单控件的禁用状态\n* `:checked`：单选框或复选框被选中\n\n\n\n### 2.1.6 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\n\n> div\n\n```css\nborder: 1px solid red;\nmargin: 0 auto;\nheight: 50px;\nwidth: 80px;\n```\n\n\n\n> 浮动元素的上下左右居中\n\n```css\nborder: 1px solid red;\nfloat: left;\nposition: absolute;\nwidth: 200px;\nheight: 100px;\nleft: 50%;\ntop: 50%;\nmargin: -50px 0 0 -100px;\n```\n\n\n\n> 绝对定位的左右居中\n\n```css\nborder: 1px solid black;\nposition: absolute;\nwidth: 200px;\nheight: 100px;\nmargin: 0 auto;\nleft: 0;\nright: 0;\n```\n\n\n\n### 2.1.7 display有哪些值？说明他们的作用？\n\n* `inline`（默认）：内联\n* `none`：隐藏\n* `block`：块显示\n* `table`：表格显示\n* `list-item`：项目列表\n* `inline-block`\n\n\n\n### 2.1.8 position的值？\n\n* `static`（默认）:按照正常文档流进行排列\n* `relative`（相对定位）：不脱离文档流，参考自身静态位置通过top，bottom，left，right定位\n* `absolute`（绝对定位）：参考距其最近一个不为static的父级元素通过top,bottom,left,right定位\n* `fixed`（固定定位）：所固定的参照对象是可视窗口\n\n\n\n### 2.1.9 CSS3有哪些新特性？\n\n1. RGBA和透明度\n2. background-image  background-origin(content-box/padding-box/border-box)   background-size   background-repeat\n3. word-wrap（对长的不可分割单词换行）word-wrap:break-word\n4. 文字阴影：text-shadow: 5px 5px 5px #FF0000; （水平阴影，垂直阴影，模糊距离，阴影颜色）\n5. font-face属性：定义自己的字体\n6. 圆角（边框半径）：border-radius 属性用于创建圆角\n7. 边框图片：border-image: url(border.png) 30 30 round;\n8. 盒阴影：box-shadow: 10px 10px 5px #888888;\n9. 媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性\n\n\n\n### 2.1.10 请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？\n\n该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，`block`布局是把块在垂直方向从上到下依次排列的；而`inline`布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。\n\n\n\n使用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。\n\n\n\n### 2.1.11 用纯CSS创建一个三角形的原理是什么？\n\n首先，需要把元素的宽度、高度设为0.然后设置边框样式。\n\n```css\nwidth: 0;\nheight: 0;\nborder-top: 40px solid transparent;\nborder-left: 40px solid transparent;\nborder-right: 40px solid transparent;\nborder-bottom: 40px solid #ff0000;\n```\n\n\n\n### 2.1.12 一个满屏品字布局如何设计？\n\n第一种真正的品字：\n\n1. 三块高宽是确定的；\n2. 上面那块用`margin: 0 auto;`居中；\n3. 下面两块用`float`或者`inline-block`不换行；\n4. 用`margin`调整位置使他们居中。\n\n\n\n第二种全屏的品字布局：\n\n上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行\n\n\n\n### 2.1.13 常见的兼容性问题？\n\n1. 不同浏览器的标签默认的`margin`和`padding`不一样。\n\n   ```css\n   * {\n   \tmargin: 0;\n       padding: 0;\n   }\n   ```\n\n   \n\n2. IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。\n\n   ```css\n   hack: diaplay: inline; // 将其转化为行内属性。\n   ```\n\n3. 渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用\"9\"这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用”+“将IE8和IE7、IE6分离开来，这样IE8已经独立识别。\n\n   ```css\n   {\n   \tbackground-color: #f1ee18; /*所有识别*/\n       .background-color: #00deff\\9; /*IE6、7、8识别*/\n       +background-color: #a200ff; /*IE6、7识别*/\n       _background-color: #1e0bd1; /*IE6识别*/\n   }\n   ```\n\n   \n\n4. 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden; 或者设置行高line-height小于你设置的高度。\n\n5. IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用`getAttribute()`获取自定义属性；Firefox下，只能使用`getAttribute()`获取自定义属性。解决方法：统一通过`getAttribute()`获取自定义属性。\n\n6. Chrome中文界面下默认会将小于12px的文本强制按照12px显示，可以通过加入CSS属性 `-webkit-text-size-adjust:none;`解决\n\n7. 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有`hover`和`active`了。解决方法是改变CSS属性的排列顺序：L-V-H-A(love hate):  a:link{}  a:visited{}  a:hover{}  a:active{}\n\n   \n\n   \n### 2.1.14 为什么要初始化CSS样式？\n\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n\n\n\n### 2.1.15 absolute的containing block计算方式跟正常流有什么不同？\n\n无论属于哪种，都要先找到其祖先元素中最近的`position`值不为`static`的元素，然后再判断：\n\n1. 若此元素为`inline`元素，则`containing block`为能够包含这个元素生成的第一个和最后一个`inline box`的`padding box`（除margin，border外的区域）的最小矩形\n2. 否则，则由这个祖先元素的`padding box`构成。\n\n如果都找不到，则为`intial containing block`。\n\n\n\n> 补充：\n>\n> 1. static（默认的）/relative：简单说就是它的父元素的内容框（即去掉padding的部分）\n> 2. absolute：向上找最近的定位为absolute/relative的元素\n> 3. fixed：它的containing block一律为根元素（html/body）\n\n\n\n### 2.1.16 CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？\n\n当一个元素的`visibility`属性被设置成`collapse`值后，对于一般的元素，它的表现跟`hidden`是一样的。\n\n1. chrome中，使用`collapse`值和使用`hidden`没有区别。\n2. firefox，opera和IE，使用`collapse`和使用`display:none`没有什么区别。\n\n\n\n### 2.1.17 display:none与visibility:hidden的区别？\n\n* `display:none`不显示对应的元素，在文档布局中不再分配空间（回流+重绘）\n* `visibility:hidden`隐藏对应元素，在文档布局中仍保留原来的空间（重绘）\n\n\n\n### 2.1.18 position跟display、overflow、float这些特性相互叠加后会怎么样？\n\ndisplay属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。\n\n\n\n类似于优先级机制：position:absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float或者absolute定位的元素，只能是块元素或表格。\n\n\n\n### 2.1.19 对BFC规范（块级格式化上下文：block formatting context）的理解？\n\nBFC规定了内部的Block Box如何布局。\n\n定位方案：\n\n \t1. 内部的Box会在垂直方向上一个接一个放置。\n \t2. Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。\n \t3. 每个元素的margin box的左边，与包含块border box的左边相接触。\n \t4. BFC的区域不会与float box重叠。\n \t5. BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。\n \t6. 计算BFC的高度时，浮动元素也会参与计算。\n\n\n\n满足下列条件之一就可触发BFC\n\n1. 根元素，html\n2. float的值不为none（默认）\n3. overflow的值不为visible（默认）\n4. display的值为inline-block、table-cell、table-caption\n5. position的值为absolute或fixed\n\n\n\n### 2.1.20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？\n\n浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。\n\n\n\n浮动带来的问题：\n\n \t1. 父元素的高度无法被撑开，影响与父元素同级的元素\n \t2. 与浮动元素同级的非浮动元素（内联元素）会跟谁其后\n \t3. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。\n\n\n\n清除浮动的方式：\n\n \t1. 父级div定义height\n \t2. 最后一个浮动元素后加空div标签，并添加样式clear:both\n \t3. 包含浮动元素的父标签添加样式overflow为hidden或auto\n \t4. 父级div定义zoom\n\n\n\n### 2.1.21 上下margin重合的问题\n\n在重合元素外包裹一层容器，并触发该容器生成一个BFC。\n\n例子：\n\n```html\n<div class=\"aside\"></div>\n<div class=\"text\">\n    <div class=\"main\"></div>\n</div>\n<!--下面是css代码-->\n.aside {\n    margin-bottom: 100px;  \n    width: 100px;\n    height: 150px;\n    background: #f66;\n}\n.main {\n    margin-top: 100px;\n    height: 200px;\n    background: #fcc;\n}\n.text{\n    /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/\n    overflow: hidden;  //此时已经触发了BFC属性。\n}\n\n```\n\n\n\n### 2.1.22 设置元素浮动后，该元素的display值是多少？\n\n自动变成display:block\n\n\n\n### 2.1.23 移动端的布局用过媒体查询吗？\n\n通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。\n\n```html\n// <head>里边\n<link rel=\"stylesheet\" type=\"text/css\" href=\"xxx.css\" media=\"only screen and (max-device-width:480px)\">\n    \n//css\n@media only screen and (max-device-width:480px) {\n\t//css样式\n}\n```\n\n\n\n### 2.1.24 使用css预处理器吗？\n\nless sass\n\n\n\n### 2.1.25 CSS优化、提高性能的方法有哪些？\n\n1. 避免过度约束\n2. 避免后代选择符\n3. 避免链式选择符\n4. 使用紧凑的语法\n5. 避免不必要的命名空间\n6. 避免不必要的重复\n7. 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么\n8. 避免!important，可以选择其他选择器\n9. 尽可能的精简规则，你可以合并不同类里的重复规则\n\n\n\n### 2.1.26 浏览器是怎样解析CSS选择器的？\n\nCSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\n\n而在CSS解析完毕后，需要将解析的结果与DOM Tree的内容一起进行分析建立一颗Render Tree，最终用来进行绘图。在建立Render Tree时（Webkit中的「Attachment」过程），浏览器就要为每个DOM Tree中的元素根据CSS的解析结果（Style Rules）来确定生成怎样的Render Tree。\n\n\n\n### 2.1.27 在网页中应该使用奇数还是偶数的字体？为什么呢？\n\n使用偶数字体。偶数字号相对更容易和Web设计的其他部分构成比例关系。Windows自带的点阵宋体（中易宋体）从Vista开始只提供12、14、16px这三个大小的点阵，而13、15、17px时用的是小一号的点。（即每个字占的空间大了1px，但点阵没变），于是略显稀疏。\n\n\n\n### 2.1.28 margin和padding分别适合什么场景使用？\n\n* 何时使用margin：\n  * 需要在border外侧添加空白\n  * 空白处不需要背景色\n  * 上下相连的两个盒子之间的空白，需要相互抵消时。\n* 何时使用padding：\n  * 需要在border内添加空白\n  * 空白处需要北京颜色\n  * 上下相连的两个盒子的空白，希望为两者之和\n* 兼容性的问题：在IE5和IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display:inline解决\n\n\n\n### 2.1.29 元素竖向的百分比设定是相对于容器的高度吗？\n\n当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如padding-top，padding-bottom，margin-top，margin-bottom等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。\n\n\n\n### 2.1.30 全屏滚动的原理是什么？用到了CSS的哪些属性？\n\n1. 原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现\n2. overflow:hidden;transition: all 1000ms ease;\n\n\n\n### 2.1.31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\n\n响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。\n\n基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。\n\n页面头部必须有meta声明的viewport。\n\n```html\n<meta name=’viewport’ content=”width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no”>\n```\n\n\n\n### 2.1.32 视觉滚动效果？\n\n视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。\n\n1. CSS3实现\n\n   * 优点：开发时间短、性能和开发效率比较好\n   * 缺点：不能兼容到低版本的浏览器\n\n2. jQuery实现\n\n   通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。\n\n   * 优点：能兼容到各个版本的，效果可控性好\n   * 缺点：开发起来对制作者要求高\n\n3. 插件实现方式\n\n   例如：parallax-scrolling，兼容性十分好\n\n\n\n### 2.1.33 ::before和:after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用\n\n1. 单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素\n2. ::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。\n\n\n\n:before和:after这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before和::after\n\n\n\n### 2.1.34 你对line-height是如何理解的？\n\n行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。\n\n单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。\n\n多行文本垂直居中：需要设置display属性为inline-block。\n\n\n\n### 2.1.35 怎么让Chrome支持小于12px的文字？\n\n```css\np{font-size:10px;-webkit-transform:scale(0.8);} //0.8是缩放比例\n```\n\n\n\n### 2.1.36 让页面里的字体变清晰，变细用CSS怎么做？\n\n-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用`-webkit-font-smoothing:antialiased`是最佳的，灰度平滑。\n\n\n\n### 2.1.37 position:fixed;在android下无效怎么处理？\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"/>\n```\n\n\n\n### 2.1.38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\n\n多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms = 16.7ms。\n\n\n\n### 2.1.39 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\n\n行框的排列会受到中间空白（回车空格）等的影响，因为空白也属于字符，这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。\n\n> 解决办法：\n\n1. 可以将`<li>`代码全部写在一排\n2. 浮动li中`float:left`\n3. 在`ul`中用`font-size:0`（谷歌不支持）；可以使用`letter-space:-3px`\n\n\n\n### 2.1.40 display:inline-block什么时候会显示间隙？\n\n1. 有空格时候会有间隙\n\n   解决：移除空格\n\n2. margin正值的时候\n\n   解决：margin使用负值\n\n3. 使用font-size时候\n\n   解决：font-size:0、letter-spacing、word-spacing\n\n\n\n### 2.1.41 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\n\n外层div使用`position:relative;`高度要求自适应的div使用`position:absolute;top:100px;bottom:0;left:0`\n\n\n\n### 2.1.42 png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？\n\n1. png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。大多数地方都可以用。\n2. jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。\n3. gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。\n4. webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。\n\n\n\n### 2.1.43 style标签写在body后与body前有什么区别？\n\n页面加载自上而下，当然是先加载样式。\n\n写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）\n\n\n\n### 2.1.44 CSS属性overflow属性定义溢出元素内容区的内容会如何处理？\n\n* 参数是scroll的时候，必会出现滚动条\n* 参数是auto的时候，子元素内容大于父元素时出现滚动条\n* 参数是visible的时候，溢出的内容出现在父元素之外\n* 参数是hidden的时候，溢出隐藏\n\n\n\n### 2.1.45 阐述一下CSS Sprites\n\n将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的`background-image`，`background-repeat`，`background-position`的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大提高页面的性能，CSS Sprites能减少页面的字节。\n\n\n\n## 2.2 能不能讲一讲Flex布局，以及常用的属性？\n\n[阮一峰的flex系列](https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html)\n\n### 2.2.1 flex布局是什么？\n\nFlex是Flexible Box的缩写，意为”弹性布局“，用来为盒装模型提供最大的灵活性。\n\n任何一个容器都可以指定为Flex布局。\n\n```css\n.box {\n\tdisplay: flex;\n}\n```\n\n\n\n行内元素也可以使用Flex布局。\n\n```css\n.box {\n\tdisplay: inline-flex;\n}\n```\n\n\n\nWebkit内核的浏览器，必须加上`-webkit`前缀。\n\n```css\n.box {\n\tdisplay: -webkit-flex; /* Safari */\n    display: flex;\n}\n```\n\n\n\n> 注意，设为Flex布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\n\n\n\n### 2.2.2 基本概念\n\n采用Flex布局的元素，称为Flex容器（flex container），简称”容器“。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目“。\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。\n\n\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n\n\n### 2.2.3 容器的属性\n\n以下6个属性设置在容器上。\n\n* flex-direction\n* flex-wrap\n* flex-flow\n* justify-content\n* align-items\n* align-content\n\n\n\n#### 2.2.3.1 flex-direction属性\n\n`flex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n```css\n.box {\n\tflex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png)\n\n\n\n它可能有四个值。\n\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n\n\n\n#### 2.2.3.2 flex-wrap属性\n\n默认情况下，项目都排在一条线（又称“轴线”）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png)\n\n```css\n.box {\n\tflex-wrap: nowrap | wrap | wrap-reverse; \n}\n```\n\n\n\n它可能取三个值。\n\n1. `nowrap`（默认）：不换行。\n\n   ![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png)\n\n2. `wrap`：换行，第一行在上方。\n\n   ![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg)\n\n3. `wrap-reverse`：换行，第一行在下方。\n\n   ![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg)\n\n\n\n#### 2.2.3.3 flex-flow\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n\n```css\n.box {\n\tflex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n\n\n#### 2.2.3.4 justify-content属性\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n```css\n.box {\n\tjustify-content: flex-start | flex-end | center | space-between\n}\n```\n\n![justify-content](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)\n\n它可能取五个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n* flex-start(默认值)：左对齐\n* flex-end：右对齐\n* center：居中\n* space-between：两端对齐，项目之间的间隔都相等\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n\n\n#### 2.2.3.5 align-items属性\n\n`align-items`属性定义项目在交叉轴上如何对齐。\n\n```css\n.box {\n\talign-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![align-items](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n* flex-start：交叉轴的起点对齐\n* flex-end：交叉轴的终点对齐\n* center：交叉轴的中点对齐\n* baseline：项目的第一行文字的基线对齐\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度\n\n\n\n#### 2.2.3.6 align-content属性\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n```css\n.box {\n\talign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n\n该属性可能取6个值。\n\n* flex-start：与交叉轴的起点对齐\n* flex-end：与交叉轴的终点对齐\n* center：与交叉轴的中点对齐\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍\n* stretch（默认值）：轴线占满整个交叉轴\n\n\n\n### 2.2.4 项目的属性\n\n以下6个属性设置在项目上。\n\n* order\n* flex-grow\n* flex-shrink\n* flex-basis\n* flex\n* align-self\n\n\n\n#### 2.2.4.1 order属性\n\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n\n```css\n.item {\n\torder: <integer>;\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)\n\n\n\n#### 2.2.4.2 flex-grow属性\n\n`flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。\n\n```css\n.item {\n\tflex-grow: <number>; /* default 0 */\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png)\n\n如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n\n\n#### 2.2.4.3 flex-shrink属性\n\n`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n```css\n.item {\n\tflex-shrink: <number>; /* default 1 */\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)\n\n如果所有项目的`flex-shrink`属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n\n\n#### 2.2.4.4 flex-basis属性\n\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n```css\n.item {\n\tflex-basis: <length> | auto; /* default auto */\n}\n```\n\n它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。\n\n\n\n#### 2.2.4.5 flex属性\n\n`flex`属性是`flex-grow`，`flex-shrink`和`flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n```css\n.item {\n\tflex: none | [<'flex-grow'><'flex-shrink'><'flex-basis'>]\n}\n```\n\n该属性有两个快捷键：`auto`（`1 1 auto`）和`none`（`0 0 auto`）。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n\n\n#### 2.2.4.6 align-self属性\n\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png)\n\n该属性可能去6个值，除了auto，其他都与align-items属性完全一致。\n\n\n\n# 3、JS篇\n\n## 3.1 从原型到原型链\n\n### 3.1.2 构造函数创建对象\n\n我们先使用构造函数创建一个对象：\n\n```js\nfunction Person() {\n\n}\nvar person = new Person();\nperson.name = 'Kevin';\nconsole.log(person.name) // Kevin\n```\n\n在这个例子中，`Person`就是一个构造函数，我们使用`new`创建了一个实例对象`person`。\n\n很简单吧，接下来进入正题：\n\n\n\n### 3.1.3 prototype\n\n每个函数都有一个`prototype`属性，就是我们经常在各种例子中看到的那个`prototype`，比如：\n\n```js\nfunction Person() {\n}\n// 虽然写在注释里，但是你要注意：\n// prototype是函数才会有的属性\nPerson.prototype.name = 'Kevin';\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name) // Kevin\nconsole.log(person2.name) // Kevin\n```\n\n那这个函数的`prototype`属性到底指向的是什么呢？是这个函数的原型吗？\n\n其实，函数的`prototype`属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的`person1`和`person2`的原型。\n\n那什么是原型呢？你可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。\n\n让我们用一张图表示构造函数和实例原型之间的关系：\n\n![prototype](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/prototype.png))\n\n\n\n在这张图中我们用`Object.prototype`表示实例原型。\n\n那么我们该怎么表示实例与实例原型，也就是`person`和`Person.prototype`之间的关系呢，这时候我们就要讲到第二个属性：\n\n\n\n### 3.1.4 `__proto__`\n\n这是每一个JavaScript对象（除了null）都具有的一个属性，叫`__proto__`，这个属性会指向该对象的原型。\n\n为了证明这一点，我们可以在火狐或者谷歌中输入：\n\n```js\nfunction Person(){\n    \n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n于是我们更新下关系图：\n\n![__proto__](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/__proto__.png)\n\n既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？\n\n\n\n### 3.1.5 constructor\n\n指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：`constructor`，每个原型都有一个`constructor`属性指向关联的构造函数。\n\n为了验证这一点，我们可以尝试：\n\n```js\nfunction Person() {\n}\nconsole.log(Person === Person.prototype.constructor); // true\n```\n\n所以再更新下关系图：\n\n![constructor](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/constructor.png)\n\n综上我们已经得出：\n\n```js\nfunction Person() {\n    \n}\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法，可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n```\n\n\n\n了解了构造函数、实力原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：\n\n\n\n### 3.1.6 实例与原型\n\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n\n\n举个例子：\n\n```js\nfunction Person() {\n}\nPerson.prototype.name = 'Kevin';\n\nvar person = new Person();\nperson.name = 'Daisy';\nconsole.log(person.name) // Daisy\n\ndelete person.name;\nconsole.log(person.name) // Kevin\n```\n\n在这个例子中，我们给实例对象`person`添加了`name`属性，当我们打印`person.name`的时候，结果自然为`Daisy`。\n\n但是当我们删除了`person`的`name`属性时，读取`person.name`，从`person`对象中找不到`name`属性就会从`person`的原型也就是`person.__ptoto__`，也就是`Person.prototype`中查找，幸运的是我们找到了`name`属性，结果为`Kevin`。\n\n\n\n但是万一还没有找到呢？原型的原型又是什么呢？\n\n\n\n### 3.1.7 原型的原型\n\n在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```js\nvar obj = new Object();\nobj.name = 'Kevin'\nconsole.log(obj.name) // Kevin\n```\n\n其实原型对象就是通过`Object`构造函数生成的，结合之前所讲，实例的`__proto__`指向构造函数的`prototype`，所以我们再更新下关系图：\n\n![原型的原型](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/原型的原型.png)\n\n\n\n### 3.1.8 原型链\n\n那 Object.prototype 的原型呢？\n\nnull，我们可以打印：\n\n```js\nconsole.log(Object.prototype.__proto__ === null) // true\n```\n\n\n\n然而`null`究竟代表了什么呢？\n\n引用阮一峰的《[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)》就是：\n\n> null表示“没有对象”，即该处不应该有值。\n\n所以`Object.prototype.__proto__`的值为`null`跟`Object.prototype`没有原型，其实表达了一个意思。\n\n所以查找到属性的时候查到`Object.prototype`就可以停止查找了。\n\n最后一张关系图也可以更新为：\n\n![原型链](https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/原型链.png)\n\n顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。\n\n\n\n\n\n> 补充\n\n### 3.1.9 constructor\n\n首先是`constructor`属性，我们看个例子：\n\n```js\nfunction Person() {\n}\nvar person = new Person();\nconsole.log(person.constructor === Person); // true\n```\n\n当获取`person.constructor`时，其实`person`中并没有`constructor`属性，当不能读取到`constructor`属性时，会从`person`的原型也就是`Person.prototype`中读取，正好原型中有该属性，所以：\n\n```js\nperson.constructor === Person.prototype.constructor\n```\n\n\n\n### 3.1.10 `__proto__`\n\n其次是`__proto__`，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于`Person.prototype`中，实际上，它是来自于`Object.prototype`，与其说是一个属性，不如说是一个`getter/setter`，当使用`obj.__proto__`时，可以理解成返回了`Object.getPrototypeOf(obj)`。\n\n\n\n### 3.1.11 真的是继承吗？\n\n最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’‘属性’”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：\n\n\n\n继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n\n\n\n\n\n## 3.2 JavaScript深入之词法作用域和动态作用域\n\n### 3.2.1 作用域\n\n作用域是指程序源代码中定义变量的区域。\n\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n\nJavaScript采用词法作用域（lexical scoping），也就是静态作用域。\n\n\n\n### 3.2.2 静态作用域与动态作用域\n\n因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了。\n\n而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。\n\n让我们认真看个例子就能明白之间的区别：\n\n```js\nvar vaule = 1;\nfunction foo() {\n\tconsole.log(value);\n}\nfunction bar() {\n\tvar value = 2;\n    foo();\n}\nbar();\n\n// 结果是？？？\n```\n\n假设JavaScript采用静态作用域，让我们分析下执行过程：\n\n\n\n执行`foo`函数，先从`foo`函数内部查找是否有局部变量`value`，如果没有，就根据书写的位置，查找上面一层的代码，也就是`value`等于1，所以结果会打印1。\n\n\n\n假设JavaScript采用动态作用域，让我们分析下执行过程：\n\n\n\n执行`foo`函数，依然是从`foo`函数内部查找是否有局部变量`value`。如果没有，就从调用函数的作用域，也就是`bar`函数内部查找`value`变量，所以结果会打印2。\n\n\n\n前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是1。\n\n\n\n### 3.2.3 动态作用域\n\n也许你会好奇什么语言是动态作用域？\n\n`bash`就是动态作用域，不信的话，把下面的脚本存成例如`scope.bash`，然后进行相应的目录，用命令行执行`bash ./scope.bash`，看看打印的值是多少。\n\n```js\nvalue = 1\nfunction foo() {\n\techo $value;\n}\nfunction bar() {\n\tlocal value = 2;\n    foo;\n}\nbar\n```\n\n\n\n### 3.2.4 思考题\n\n最后，让我们看一个《JavaScript权威指南》中的例子：\n\n```js\nvar scope = 'global scope';\nfunction checkscope() {\n\tvar scope = 'local scope';\n    function f() {\n\t\treturn scope;\n    }\n    return f();\n}\ncheckscope();\n```\n\n```js\nvar scope = 'global scope';\nfunction checkscope() {\n\tvar scope = 'local scope';\n    function f() {\n\t\treturn scope;\n    }\n    return f;\n}\ncheckscope()();\n```\n\n两段代码都会打印：`local scope`。\n\n原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。\n\n而引用《JavaScript权威指南》的回答就是：\n\nJavaScript函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数`f()`定义在这个作用域链里，其中的变量scope一定是局部变量，不管何时何地执行`f()`，这种绑定在执行`f()`时依然有效。\n\n\n\n但是在这里真正想让大家思考的是：\n\n虽然两端代码执行的结果一样，但是两段代码究竟有哪些不同呢？\n\n如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下文。\n\n\n\n## 3.3 JavaScript深入之执行上下文栈\n\n### 3.3.1 顺序执行？\n\n如果要问到JavaScript代码执行顺序的话，想必写过JavaScript的开发者都会有个直观的印象，那就是顺序执行，毕竟：\n\n```js\nvar foo = function() {\n\tconsole.log('foo1');\n}\nfoo(); // foo1\n\nvar foo = function() {\n\tconsole.log('foo2');\n}\nfoo(); // foo2\n```\n\n\n\n然而去看这段代码：\n\n```js\nfunction foo() {\n\tconsole.log('foo1');\n}\nfoo(); // foo2\nfunction foo() {\n\tconsole.log('foo2');\n}\nfoo(); // foo2\n```\n\n打印的结果却是两个`foo2`。\n\n\n\n刷过面试题的都知道这是因为JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。\n\n\n\n但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？\n\n\n\n到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？\n\n\n\n### 3.3.2 可执行代码\n\n\n\n","slug":"middle-front","published":1,"updated":"2021-09-27T07:38:47.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku2cstr700184v9kz3pswskr","content":"<h1 id=\"1、HTML篇\"><a href=\"#1、HTML篇\" class=\"headerlink\" title=\"1、HTML篇\"></a>1、HTML篇</h1><h2 id=\"1-1-HTML5语义化\"><a href=\"#1-1-HTML5语义化\" class=\"headerlink\" title=\"1.1 HTML5语义化\"></a>1.1 HTML5语义化</h2><p><a href=\"https://rainylog.com/post/ife-note-1/\" target=\"_blank\" rel=\"noopener\">HTML5语义化</a></p>\n<h3 id=\"1-1-1-为什么需要语义化\"><a href=\"#1-1-1-为什么需要语义化\" class=\"headerlink\" title=\"1.1.1 为什么需要语义化\"></a>1.1.1 为什么需要语义化</h3><ul>\n<li><p>易修改、易维护</p>\n</li>\n<li><p>无障碍阅读支持</p>\n</li>\n<li><p>搜索引擎友好、利于SEO</p>\n</li>\n<li><p>面向未来的HTML、浏览器在未来可能提供更丰富的支持</p>\n</li>\n</ul>\n<h3 id=\"1-1-2-结构语义化\"><a href=\"#1-1-2-结构语义化\" class=\"headerlink\" title=\"1.1.2 结构语义化\"></a>1.1.2 结构语义化</h3><p>语义元素均有一个共同特点--他们均不做任何事情。换句话说，语义元素仅仅是页面结构的规范化，并不会对内容有本质的影响。</p>\n<p>下图展示了一个典型的页面结构。<br><img src=\"https://rainylog-1256215078.cos.ap-shanghai.myqcloud.com/images/page.png\" alt></p>\n<h3 id=\"1-1-3-头部\"><a href=\"#1-1-3-头部\" class=\"headerlink\" title=\"1.1.3 头部\"></a>1.1.3 头部</h3><p><code>&lt;header&gt;</code>元素有两种用法，第一是标注内容的标题，第二是标注网页的页眉，如上图你看到的那样。除非必要（内容标题附带其他信息的情况下：发布时间、作者等），一般不在内容中使用<code>&lt;header&gt;</code>。因而，网页中可以包含多个<code>&lt;header&gt;</code>元素。按照HTML5的规定，<code>&lt;header&gt;</code>都应包含某个级别的标题，所以应隐式或显式地包含标题，通常将不希望显示的标题设置为<code>display: none;</code>，一方面遵守规范，另一方面则提供了无障碍阅读而不至于影响到页面设计。</p>\n<h3 id=\"1-1-4-导航栏\"><a href=\"#1-1-4-导航栏\" class=\"headerlink\" title=\"1.1.4 导航栏\"></a>1.1.4 导航栏</h3><p>导航栏使用<code>&lt;nav&gt;</code>看起来是理所当然的，进一步，它也用于一组文章的链接。一个页面可以包含多个<code>&lt;nav&gt;</code>元素，但通常仅仅在页面的主要导航部分使用它。</p>\n<p>《HTML5：The Missing Manual》中指出了在侧栏使用<code>&lt;nav&gt;</code>标签的两个案例：</p>\n<pre><code class=\"html\">&lt;!-- 案例一 --&gt;\n&lt;nav&gt;\n    &lt;!-- 此处是链接 --&gt;\n    &lt;aside&gt;&lt;/aside&gt;\n    &lt;aside&gt;&lt;/aside&gt;\n&lt;/nav&gt;\n\n&lt;!-- 案例二 --&gt;\n&lt;aside&gt;\n    &lt;nav&gt;\n        &lt;!-- 此处是链接 --&gt;\n    &lt;/nav&gt;\n    &lt;section&gt;&lt;/section&gt;\n    &lt;div&gt;&lt;/div&gt;\n&lt;/aside&gt;\n</code></pre>\n<p>如果侧栏中包含其它不同于链接的其它区块，那么，使用第二种方案显然更为合适。</p>\n<p>导航通常包含一组链接，普遍认为，链接使用列表来组织。</p>\n<pre><code class=\"html\">&lt;nav&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;a href=&quot;#&quot; title=&quot;链接&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=&quot;#&quot; title=&quot;链接&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=&quot;#&quot; title=&quot;链接&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/nav&gt;\n</code></pre>\n<h3 id=\"1-1-5-附注\"><a href=\"#1-1-5-附注\" class=\"headerlink\" title=\"1.1.5 附注\"></a>1.1.5 附注</h3><p><code>&lt;aside&gt;</code>元素并不仅仅是侧栏，它表示与它周围文本没有密切关系的内容。文章中同样可以使用<code>&lt;aside&gt;</code>元素，来说明文章的附加内容、解释说明某个观点、相关内容链接等等。</p>\n<p>当<code>&lt;aside&gt;</code>用于侧栏时，其表示整个网页的附加内容。通常的广告区域、搜索、分享链接则位于侧栏。侧栏中的<code>&lt;section&gt;</code>元素规定了一个区域，通常是带有标题的内容。</p>\n<p><code>&lt;section&gt;</code>标签适合标记的内容区块：</p>\n<ul>\n<li>与页面主体并列显示的小内容块。</li>\n<li>独立性内容，清单、表单等。</li>\n<li>分组内容，如CMS系统中的文章分类区块。</li>\n<li>比较长文档的一部分，可能仅仅是为了正确规定页面大纲。</li>\n</ul>\n<p><code>&lt;div&gt;</code>标签依然是可用的，当你觉得使用其它标签都不太合适的时候。新的语义元素出现之前，我们总是这么干的！</p>\n<h3 id=\"1-1-6-页脚\"><a href=\"#1-1-6-页脚\" class=\"headerlink\" title=\"1.1.6 页脚\"></a>1.1.6 页脚</h3><p>同可”包罗万象“的<code>&lt;header&gt;</code>元素不同，标准规定<code>&lt;footer&gt;</code>标签仅仅可以包含版权、来源信息、法律限制等等之类的文本或链接信息。如果想要在页脚中包含其它内容，可以使用熟悉的<code>&lt;div&gt;</code>来帮忙。</p>\n<pre><code class=\"html\">&lt;div&gt;\n    &lt;aside&gt;\n    &lt;!-- 其它内容 --&gt;\n    &lt;/aside&gt;\n\n    &lt;footer&gt;\n    &lt;!-- 法律、版权、来源、联系信息等 --&gt;\n    &lt;/footer&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id=\"1-1-7-主要内容\"><a href=\"#1-1-7-主要内容\" class=\"headerlink\" title=\"1.1.7 主要内容\"></a>1.1.7 主要内容</h3><p>在早先的HTML5版本中并没有规定页面主体的标签，相关的书中经常会说：除去头部、尾部、侧栏等其它部分，剩下的自然是主体部分。</p>\n<p>然而，HTML5.1中规定了一个<code>&lt;main&gt;</code>标签来标识主体内容。<code>&lt;main&gt;</code>标签不能包含在页面其它区块元素中，通常是<code>&lt;body&gt;</code>的子标签，或者是全局<code>&lt;div&gt;</code>的子标签。<code>&lt;main&gt;</code>标签可以帮助屏幕阅读工具识别页面的主体部分，从而让访问者迅速得到有用的信息。</p>\n<h3 id=\"1-1-8-文章\"><a href=\"#1-1-8-文章\" class=\"headerlink\" title=\"1.1.8 文章\"></a>1.1.8 文章</h3><p><code>&lt;article&gt;</code>表示一个完整的、自成一体的内容块。如文章或新闻报道。<code>&lt;article&gt;</code>应包含完整的标题、文章署名、发布时间、正文。当语义与表现发生冲突，例如有时需要将文章分多个页面显示，那么需要把每个页面的文章区域都用<code>&lt;article&gt;</code>标记。</p>\n<p>文章中包含插图时，使用新的语义元素<code>&lt;figure&gt;</code>标签。</p>\n<pre><code class=\"html\">&lt;article&gt;\n    &lt;h1&gt;标题&lt;/h1&gt;\n    &lt;p&gt;\n        &lt;!-- 内容 --&gt;\n    &lt;/p&gt;\n    &lt;figure&gt;\n        &lt;img src=&quot;#&quot; alt=&quot;插图&quot;&gt;\n        &lt;figcaption&gt;这是一个插图&lt;/figcaption&gt;\n    &lt;/figure&gt;\n&lt;/article&gt;\n</code></pre>\n<p>上述情况下，<code>&lt;figcaption&gt;</code>包含了关于插图的详细解释，则<code>&lt;img&gt;</code>的<code>alt</code>属性可以略去。</p>\n<h3 id=\"1-1-9-IFE任务\"><a href=\"#1-1-9-IFE任务\" class=\"headerlink\" title=\"1.1.9 IFE任务\"></a>1.1.9 IFE任务</h3><h4 id=\"1-1-9-1-任务描述\"><a href=\"#1-1-9-1-任务描述\" class=\"headerlink\" title=\"1.1.9.1 任务描述\"></a>1.1.9.1 任务描述</h4><p>参考示例图（<a href=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_1_1.jpg\" target=\"_blank\" rel=\"noopener\">点击查看</a>），完成一个HTML页面代码编写（不写CSS，不需要关注样式，只关注文档结构）。</p>\n<h4 id=\"1-1-9-2-范例\"><a href=\"#1-1-9-2-范例\" class=\"headerlink\" title=\"1.1.9.2 范例\"></a>1.1.9.2 范例</h4><p>用语义化来构建该页面的结构：<a href=\"https://github.com/geekrainy/ife/blob/master/task/task-1/index.html\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<h1 id=\"2、CSS篇\"><a href=\"#2、CSS篇\" class=\"headerlink\" title=\"2、CSS篇\"></a>2、CSS篇</h1><h2 id=\"2-1-CSS常见面试题\"><a href=\"#2-1-CSS常见面试题\" class=\"headerlink\" title=\"2.1 CSS常见面试题\"></a>2.1 CSS常见面试题</h2><p><a href=\"https://segmentfault.com/a/1190000013325778\" target=\"_blank\" rel=\"noopener\">45道CSS经典面试题</a></p>\n<h3 id=\"2-1-1-介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\"><a href=\"#2-1-1-介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\" class=\"headerlink\" title=\"2.1.1 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\"></a>2.1.1 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</h3><ul>\n<li><code>标准盒子模型</code>：宽度 = 内容的宽度（content）+ border + padding + margin</li>\n<li><code>低版本IE盒子模型</code>：宽度 = 内容宽度（content + border + padding）+ margin</li>\n</ul>\n<h3 id=\"2-1-2-box-sizing属性？\"><a href=\"#2-1-2-box-sizing属性？\" class=\"headerlink\" title=\"2.1.2 box-sizing属性？\"></a>2.1.2 box-sizing属性？</h3><p>用来控制元素的盒子模型的解析模式，默认为<code>content-box</code>。</p>\n<ul>\n<li><code>content-box</code>：W3C的标准盒子模型，设置元素的<code>height/width</code>属性指的是<code>content</code>部分的高/宽。</li>\n<li><code>border-box</code>：IE传统盒子模型。设置元素的<code>height/width</code>属性指的是<code>border + padding + content</code>部分的高/宽。</li>\n</ul>\n<h3 id=\"2-1-3-CSS选择器有哪些？哪些属性可以继承？\"><a href=\"#2-1-3-CSS选择器有哪些？哪些属性可以继承？\" class=\"headerlink\" title=\"2.1.3 CSS选择器有哪些？哪些属性可以继承？\"></a>2.1.3 CSS选择器有哪些？哪些属性可以继承？</h3><ul>\n<li><code>CSS选择符</code>：id选择器(#myid)、类选择器(.myclassname)、标签选择器(div,h1,p)、相邻选择器(h1 + p)、子选择器(ul &gt; li)、后代选择器(li a)、通配符选择器(*)、属性选择器(a[rel=&quot;external&quot;])、伪类选择器(a:hover, li:nth-child)</li>\n<li><code>可继承的属性</code>：font-size，font-family，color</li>\n<li><code>不可继承的样式</code>：border，padding，margin，width，height</li>\n<li><code>优先级（就近原则）</code>：!important &gt; [id &gt; class &gt; tag]，!important比内联优先级高</li>\n</ul>\n<h3 id=\"2-1-4-CSS优先级算法如何计算？\"><a href=\"#2-1-4-CSS优先级算法如何计算？\" class=\"headerlink\" title=\"2.1.4 CSS优先级算法如何计算？\"></a>2.1.4 CSS优先级算法如何计算？</h3><ul>\n<li>元素选择符：1</li>\n<li>class选择符：10</li>\n<li>id选择符：100</li>\n<li>元素标签：1000</li>\n</ul>\n<ol>\n<li>!important声明的样式优先级最高，如果冲突再进行计算。</li>\n<li>如果优先级相同，则选择最后出现的样式。</li>\n<li>继承得到的样式的优先级最低。</li>\n</ol>\n<h3 id=\"2-1-5-CSS3新增伪类有哪些？\"><a href=\"#2-1-5-CSS3新增伪类有哪些？\" class=\"headerlink\" title=\"2.1.5 CSS3新增伪类有哪些？\"></a>2.1.5 CSS3新增伪类有哪些？</h3><ul>\n<li><code>p:first-of-type</code>：选择属于其父元素的首个元素</li>\n<li><code>p:last-of-type</code>：选择属于其父元素的最后元素</li>\n<li><code>p:only-of-type</code>：选择属于其父元素唯一的元素</li>\n<li><code>p:only-child</code>：选择属于其父元素的唯一子元素</li>\n<li><code>p:nth-child(2)</code>：选择属于其父元素的第二个子元素</li>\n<li><code>:enabled, :disabled</code>：表单控件的禁用状态</li>\n<li><code>:checked</code>：单选框或复选框被选中</li>\n</ul>\n<h3 id=\"2-1-6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\"><a href=\"#2-1-6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\" class=\"headerlink\" title=\"2.1.6 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\"></a>2.1.6 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h3><blockquote>\n<p>div</p>\n</blockquote>\n<pre><code class=\"css\">border: 1px solid red;\nmargin: 0 auto;\nheight: 50px;\nwidth: 80px;\n</code></pre>\n<blockquote>\n<p>浮动元素的上下左右居中</p>\n</blockquote>\n<pre><code class=\"css\">border: 1px solid red;\nfloat: left;\nposition: absolute;\nwidth: 200px;\nheight: 100px;\nleft: 50%;\ntop: 50%;\nmargin: -50px 0 0 -100px;\n</code></pre>\n<blockquote>\n<p>绝对定位的左右居中</p>\n</blockquote>\n<pre><code class=\"css\">border: 1px solid black;\nposition: absolute;\nwidth: 200px;\nheight: 100px;\nmargin: 0 auto;\nleft: 0;\nright: 0;\n</code></pre>\n<h3 id=\"2-1-7-display有哪些值？说明他们的作用？\"><a href=\"#2-1-7-display有哪些值？说明他们的作用？\" class=\"headerlink\" title=\"2.1.7 display有哪些值？说明他们的作用？\"></a>2.1.7 display有哪些值？说明他们的作用？</h3><ul>\n<li><code>inline</code>（默认）：内联</li>\n<li><code>none</code>：隐藏</li>\n<li><code>block</code>：块显示</li>\n<li><code>table</code>：表格显示</li>\n<li><code>list-item</code>：项目列表</li>\n<li><code>inline-block</code></li>\n</ul>\n<h3 id=\"2-1-8-position的值？\"><a href=\"#2-1-8-position的值？\" class=\"headerlink\" title=\"2.1.8 position的值？\"></a>2.1.8 position的值？</h3><ul>\n<li><code>static</code>（默认）:按照正常文档流进行排列</li>\n<li><code>relative</code>（相对定位）：不脱离文档流，参考自身静态位置通过top，bottom，left，right定位</li>\n<li><code>absolute</code>（绝对定位）：参考距其最近一个不为static的父级元素通过top,bottom,left,right定位</li>\n<li><code>fixed</code>（固定定位）：所固定的参照对象是可视窗口</li>\n</ul>\n<h3 id=\"2-1-9-CSS3有哪些新特性？\"><a href=\"#2-1-9-CSS3有哪些新特性？\" class=\"headerlink\" title=\"2.1.9 CSS3有哪些新特性？\"></a>2.1.9 CSS3有哪些新特性？</h3><ol>\n<li>RGBA和透明度</li>\n<li>background-image  background-origin(content-box/padding-box/border-box)   background-size   background-repeat</li>\n<li>word-wrap（对长的不可分割单词换行）word-wrap:break-word</li>\n<li>文字阴影：text-shadow: 5px 5px 5px #FF0000; （水平阴影，垂直阴影，模糊距离，阴影颜色）</li>\n<li>font-face属性：定义自己的字体</li>\n<li>圆角（边框半径）：border-radius 属性用于创建圆角</li>\n<li>边框图片：border-image: url(border.png) 30 30 round;</li>\n<li>盒阴影：box-shadow: 10px 10px 5px #888888;</li>\n<li>媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性</li>\n</ol>\n<h3 id=\"2-1-10-请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？\"><a href=\"#2-1-10-请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？\" class=\"headerlink\" title=\"2.1.10 请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？\"></a>2.1.10 请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？</h3><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，<code>block</code>布局是把块在垂直方向从上到下依次排列的；而<code>inline</code>布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。</p>\n<p>使用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。</p>\n<h3 id=\"2-1-11-用纯CSS创建一个三角形的原理是什么？\"><a href=\"#2-1-11-用纯CSS创建一个三角形的原理是什么？\" class=\"headerlink\" title=\"2.1.11 用纯CSS创建一个三角形的原理是什么？\"></a>2.1.11 用纯CSS创建一个三角形的原理是什么？</h3><p>首先，需要把元素的宽度、高度设为0.然后设置边框样式。</p>\n<pre><code class=\"css\">width: 0;\nheight: 0;\nborder-top: 40px solid transparent;\nborder-left: 40px solid transparent;\nborder-right: 40px solid transparent;\nborder-bottom: 40px solid #ff0000;\n</code></pre>\n<h3 id=\"2-1-12-一个满屏品字布局如何设计？\"><a href=\"#2-1-12-一个满屏品字布局如何设计？\" class=\"headerlink\" title=\"2.1.12 一个满屏品字布局如何设计？\"></a>2.1.12 一个满屏品字布局如何设计？</h3><p>第一种真正的品字：</p>\n<ol>\n<li>三块高宽是确定的；</li>\n<li>上面那块用<code>margin: 0 auto;</code>居中；</li>\n<li>下面两块用<code>float</code>或者<code>inline-block</code>不换行；</li>\n<li>用<code>margin</code>调整位置使他们居中。</li>\n</ol>\n<p>第二种全屏的品字布局：</p>\n<p>上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行</p>\n<h3 id=\"2-1-13-常见的兼容性问题？\"><a href=\"#2-1-13-常见的兼容性问题？\" class=\"headerlink\" title=\"2.1.13 常见的兼容性问题？\"></a>2.1.13 常见的兼容性问题？</h3><ol>\n<li><p>不同浏览器的标签默认的<code>margin</code>和<code>padding</code>不一样。</p>\n<pre><code class=\"css\">* {\n    margin: 0;\n    padding: 0;\n}\n</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。</p>\n<pre><code class=\"css\">hack: diaplay: inline; // 将其转化为行内属性。\n</code></pre>\n</li>\n<li><p>渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用&quot;9&quot;这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用”+“将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>\n<pre><code class=\"css\">{\n    background-color: #f1ee18; /*所有识别*/\n    .background-color: #00deff\\9; /*IE6、7、8识别*/\n    +background-color: #a200ff; /*IE6、7识别*/\n    _background-color: #1e0bd1; /*IE6识别*/\n}\n</code></pre>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden; 或者设置行高line-height小于你设置的高度。</p>\n</li>\n<li><p>IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用<code>getAttribute()</code>获取自定义属性；Firefox下，只能使用<code>getAttribute()</code>获取自定义属性。解决方法：统一通过<code>getAttribute()</code>获取自定义属性。</p>\n</li>\n<li><p>Chrome中文界面下默认会将小于12px的文本强制按照12px显示，可以通过加入CSS属性 <code>-webkit-text-size-adjust:none;</code>解决</p>\n</li>\n<li><p>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有<code>hover</code>和<code>active</code>了。解决方法是改变CSS属性的排列顺序：L-V-H-A(love hate):  a:link{}  a:visited{}  a:hover{}  a:active{}</p>\n</li>\n</ol>\n<h3 id=\"2-1-14-为什么要初始化CSS样式？\"><a href=\"#2-1-14-为什么要初始化CSS样式？\" class=\"headerlink\" title=\"2.1.14 为什么要初始化CSS样式？\"></a>2.1.14 为什么要初始化CSS样式？</h3><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>\n<h3 id=\"2-1-15-absolute的containing-block计算方式跟正常流有什么不同？\"><a href=\"#2-1-15-absolute的containing-block计算方式跟正常流有什么不同？\" class=\"headerlink\" title=\"2.1.15 absolute的containing block计算方式跟正常流有什么不同？\"></a>2.1.15 absolute的containing block计算方式跟正常流有什么不同？</h3><p>无论属于哪种，都要先找到其祖先元素中最近的<code>position</code>值不为<code>static</code>的元素，然后再判断：</p>\n<ol>\n<li>若此元素为<code>inline</code>元素，则<code>containing block</code>为能够包含这个元素生成的第一个和最后一个<code>inline box</code>的<code>padding box</code>（除margin，border外的区域）的最小矩形</li>\n<li>否则，则由这个祖先元素的<code>padding box</code>构成。</li>\n</ol>\n<p>如果都找不到，则为<code>intial containing block</code>。</p>\n<blockquote>\n<p>补充：</p>\n<ol>\n<li>static（默认的）/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</li>\n<li>absolute：向上找最近的定位为absolute/relative的元素</li>\n<li>fixed：它的containing block一律为根元素（html/body）</li>\n</ol>\n</blockquote>\n<h3 id=\"2-1-16-CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？\"><a href=\"#2-1-16-CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？\" class=\"headerlink\" title=\"2.1.16 CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？\"></a>2.1.16 CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？</h3><p>当一个元素的<code>visibility</code>属性被设置成<code>collapse</code>值后，对于一般的元素，它的表现跟<code>hidden</code>是一样的。</p>\n<ol>\n<li>chrome中，使用<code>collapse</code>值和使用<code>hidden</code>没有区别。</li>\n<li>firefox，opera和IE，使用<code>collapse</code>和使用<code>display:none</code>没有什么区别。</li>\n</ol>\n<h3 id=\"2-1-17-display-none与visibility-hidden的区别？\"><a href=\"#2-1-17-display-none与visibility-hidden的区别？\" class=\"headerlink\" title=\"2.1.17 display:none与visibility:hidden的区别？\"></a>2.1.17 display:none与visibility:hidden的区别？</h3><ul>\n<li><code>display:none</code>不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</li>\n<li><code>visibility:hidden</code>隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li>\n</ul>\n<h3 id=\"2-1-18-position跟display、overflow、float这些特性相互叠加后会怎么样？\"><a href=\"#2-1-18-position跟display、overflow、float这些特性相互叠加后会怎么样？\" class=\"headerlink\" title=\"2.1.18 position跟display、overflow、float这些特性相互叠加后会怎么样？\"></a>2.1.18 position跟display、overflow、float这些特性相互叠加后会怎么样？</h3><p>display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。</p>\n<p>类似于优先级机制：position:absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float或者absolute定位的元素，只能是块元素或表格。</p>\n<h3 id=\"2-1-19-对BFC规范（块级格式化上下文：block-formatting-context）的理解？\"><a href=\"#2-1-19-对BFC规范（块级格式化上下文：block-formatting-context）的理解？\" class=\"headerlink\" title=\"2.1.19 对BFC规范（块级格式化上下文：block formatting context）的理解？\"></a>2.1.19 对BFC规范（块级格式化上下文：block formatting context）的理解？</h3><p>BFC规定了内部的Block Box如何布局。</p>\n<p>定位方案：</p>\n<pre><code> 1. 内部的Box会在垂直方向上一个接一个放置。\n 2. Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。\n 3. 每个元素的margin box的左边，与包含块border box的左边相接触。\n 4. BFC的区域不会与float box重叠。\n 5. BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。\n 6. 计算BFC的高度时，浮动元素也会参与计算。\n</code></pre><p>满足下列条件之一就可触发BFC</p>\n<ol>\n<li>根元素，html</li>\n<li>float的值不为none（默认）</li>\n<li>overflow的值不为visible（默认）</li>\n<li>display的值为inline-block、table-cell、table-caption</li>\n<li>position的值为absolute或fixed</li>\n</ol>\n<h3 id=\"2-1-20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？\"><a href=\"#2-1-20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？\" class=\"headerlink\" title=\"2.1.20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？\"></a>2.1.20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h3><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。</p>\n<p>浮动带来的问题：</p>\n<pre><code> 1. 父元素的高度无法被撑开，影响与父元素同级的元素\n 2. 与浮动元素同级的非浮动元素（内联元素）会跟谁其后\n 3. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。\n</code></pre><p>清除浮动的方式：</p>\n<pre><code> 1. 父级div定义height\n 2. 最后一个浮动元素后加空div标签，并添加样式clear:both\n 3. 包含浮动元素的父标签添加样式overflow为hidden或auto\n 4. 父级div定义zoom\n</code></pre><h3 id=\"2-1-21-上下margin重合的问题\"><a href=\"#2-1-21-上下margin重合的问题\" class=\"headerlink\" title=\"2.1.21 上下margin重合的问题\"></a>2.1.21 上下margin重合的问题</h3><p>在重合元素外包裹一层容器，并触发该容器生成一个BFC。</p>\n<p>例子：</p>\n<pre><code class=\"html\">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;text&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;!--下面是css代码--&gt;\n.aside {\n    margin-bottom: 100px;  \n    width: 100px;\n    height: 150px;\n    background: #f66;\n}\n.main {\n    margin-top: 100px;\n    height: 200px;\n    background: #fcc;\n}\n.text{\n    /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/\n    overflow: hidden;  //此时已经触发了BFC属性。\n}\n\n</code></pre>\n<h3 id=\"2-1-22-设置元素浮动后，该元素的display值是多少？\"><a href=\"#2-1-22-设置元素浮动后，该元素的display值是多少？\" class=\"headerlink\" title=\"2.1.22 设置元素浮动后，该元素的display值是多少？\"></a>2.1.22 设置元素浮动后，该元素的display值是多少？</h3><p>自动变成display:block</p>\n<h3 id=\"2-1-23-移动端的布局用过媒体查询吗？\"><a href=\"#2-1-23-移动端的布局用过媒体查询吗？\" class=\"headerlink\" title=\"2.1.23 移动端的布局用过媒体查询吗？\"></a>2.1.23 移动端的布局用过媒体查询吗？</h3><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p>\n<pre><code class=\"html\">// &lt;head&gt;里边\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot; media=&quot;only screen and (max-device-width:480px)&quot;&gt;\n\n//css\n@media only screen and (max-device-width:480px) {\n    //css样式\n}\n</code></pre>\n<h3 id=\"2-1-24-使用css预处理器吗？\"><a href=\"#2-1-24-使用css预处理器吗？\" class=\"headerlink\" title=\"2.1.24 使用css预处理器吗？\"></a>2.1.24 使用css预处理器吗？</h3><p>less sass</p>\n<h3 id=\"2-1-25-CSS优化、提高性能的方法有哪些？\"><a href=\"#2-1-25-CSS优化、提高性能的方法有哪些？\" class=\"headerlink\" title=\"2.1.25 CSS优化、提高性能的方法有哪些？\"></a>2.1.25 CSS优化、提高性能的方法有哪些？</h3><ol>\n<li>避免过度约束</li>\n<li>避免后代选择符</li>\n<li>避免链式选择符</li>\n<li>使用紧凑的语法</li>\n<li>避免不必要的命名空间</li>\n<li>避免不必要的重复</li>\n<li>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</li>\n<li>避免!important，可以选择其他选择器</li>\n<li>尽可能的精简规则，你可以合并不同类里的重复规则</li>\n</ol>\n<h3 id=\"2-1-26-浏览器是怎样解析CSS选择器的？\"><a href=\"#2-1-26-浏览器是怎样解析CSS选择器的？\" class=\"headerlink\" title=\"2.1.26 浏览器是怎样解析CSS选择器的？\"></a>2.1.26 浏览器是怎样解析CSS选择器的？</h3><p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>\n<p>而在CSS解析完毕后，需要将解析的结果与DOM Tree的内容一起进行分析建立一颗Render Tree，最终用来进行绘图。在建立Render Tree时（Webkit中的「Attachment」过程），浏览器就要为每个DOM Tree中的元素根据CSS的解析结果（Style Rules）来确定生成怎样的Render Tree。</p>\n<h3 id=\"2-1-27-在网页中应该使用奇数还是偶数的字体？为什么呢？\"><a href=\"#2-1-27-在网页中应该使用奇数还是偶数的字体？为什么呢？\" class=\"headerlink\" title=\"2.1.27 在网页中应该使用奇数还是偶数的字体？为什么呢？\"></a>2.1.27 在网页中应该使用奇数还是偶数的字体？为什么呢？</h3><p>使用偶数字体。偶数字号相对更容易和Web设计的其他部分构成比例关系。Windows自带的点阵宋体（中易宋体）从Vista开始只提供12、14、16px这三个大小的点阵，而13、15、17px时用的是小一号的点。（即每个字占的空间大了1px，但点阵没变），于是略显稀疏。</p>\n<h3 id=\"2-1-28-margin和padding分别适合什么场景使用？\"><a href=\"#2-1-28-margin和padding分别适合什么场景使用？\" class=\"headerlink\" title=\"2.1.28 margin和padding分别适合什么场景使用？\"></a>2.1.28 margin和padding分别适合什么场景使用？</h3><ul>\n<li>何时使用margin：<ul>\n<li>需要在border外侧添加空白</li>\n<li>空白处不需要背景色</li>\n<li>上下相连的两个盒子之间的空白，需要相互抵消时。</li>\n</ul>\n</li>\n<li>何时使用padding：<ul>\n<li>需要在border内添加空白</li>\n<li>空白处需要北京颜色</li>\n<li>上下相连的两个盒子的空白，希望为两者之和</li>\n</ul>\n</li>\n<li>兼容性的问题：在IE5和IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display:inline解决</li>\n</ul>\n<h3 id=\"2-1-29-元素竖向的百分比设定是相对于容器的高度吗？\"><a href=\"#2-1-29-元素竖向的百分比设定是相对于容器的高度吗？\" class=\"headerlink\" title=\"2.1.29 元素竖向的百分比设定是相对于容器的高度吗？\"></a>2.1.29 元素竖向的百分比设定是相对于容器的高度吗？</h3><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如padding-top，padding-bottom，margin-top，margin-bottom等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p>\n<h3 id=\"2-1-30-全屏滚动的原理是什么？用到了CSS的哪些属性？\"><a href=\"#2-1-30-全屏滚动的原理是什么？用到了CSS的哪些属性？\" class=\"headerlink\" title=\"2.1.30 全屏滚动的原理是什么？用到了CSS的哪些属性？\"></a>2.1.30 全屏滚动的原理是什么？用到了CSS的哪些属性？</h3><ol>\n<li>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现</li>\n<li>overflow:hidden;transition: all 1000ms ease;</li>\n</ol>\n<h3 id=\"2-1-31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\"><a href=\"#2-1-31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\" class=\"headerlink\" title=\"2.1.31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\"></a>2.1.31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h3><p>响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p>\n<p>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。</p>\n<p>页面头部必须有meta声明的viewport。</p>\n<pre><code class=\"html\">&lt;meta name=’viewport’ content=”width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no”&gt;\n</code></pre>\n<h3 id=\"2-1-32-视觉滚动效果？\"><a href=\"#2-1-32-视觉滚动效果？\" class=\"headerlink\" title=\"2.1.32 视觉滚动效果？\"></a>2.1.32 视觉滚动效果？</h3><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。</p>\n<ol>\n<li><p>CSS3实现</p>\n<ul>\n<li>优点：开发时间短、性能和开发效率比较好</li>\n<li>缺点：不能兼容到低版本的浏览器</li>\n</ul>\n</li>\n<li><p>jQuery实现</p>\n<p>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。</p>\n<ul>\n<li>优点：能兼容到各个版本的，效果可控性好</li>\n<li>缺点：开发起来对制作者要求高</li>\n</ul>\n</li>\n<li><p>插件实现方式</p>\n<p>例如：parallax-scrolling，兼容性十分好</p>\n</li>\n</ol>\n<h3 id=\"2-1-33-before和-after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用\"><a href=\"#2-1-33-before和-after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用\" class=\"headerlink\" title=\"2.1.33 ::before和:after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用\"></a>2.1.33 ::before和:after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用</h3><ol>\n<li>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素</li>\n<li>::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。</li>\n</ol>\n<p>:before和:after这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before和::after</p>\n<h3 id=\"2-1-34-你对line-height是如何理解的？\"><a href=\"#2-1-34-你对line-height是如何理解的？\" class=\"headerlink\" title=\"2.1.34 你对line-height是如何理解的？\"></a>2.1.34 你对line-height是如何理解的？</h3><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。</p>\n<p>单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。</p>\n<p>多行文本垂直居中：需要设置display属性为inline-block。</p>\n<h3 id=\"2-1-35-怎么让Chrome支持小于12px的文字？\"><a href=\"#2-1-35-怎么让Chrome支持小于12px的文字？\" class=\"headerlink\" title=\"2.1.35 怎么让Chrome支持小于12px的文字？\"></a>2.1.35 怎么让Chrome支持小于12px的文字？</h3><pre><code class=\"css\">p{font-size:10px;-webkit-transform:scale(0.8);} //0.8是缩放比例\n</code></pre>\n<h3 id=\"2-1-36-让页面里的字体变清晰，变细用CSS怎么做？\"><a href=\"#2-1-36-让页面里的字体变清晰，变细用CSS怎么做？\" class=\"headerlink\" title=\"2.1.36 让页面里的字体变清晰，变细用CSS怎么做？\"></a>2.1.36 让页面里的字体变清晰，变细用CSS怎么做？</h3><p>-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用<code>-webkit-font-smoothing:antialiased</code>是最佳的，灰度平滑。</p>\n<h3 id=\"2-1-37-position-fixed-在android下无效怎么处理？\"><a href=\"#2-1-37-position-fixed-在android下无效怎么处理？\" class=\"headerlink\" title=\"2.1.37 position:fixed;在android下无效怎么处理？\"></a>2.1.37 position:fixed;在android下无效怎么处理？</h3><pre><code class=\"html\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;\n</code></pre>\n<h3 id=\"2-1-38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"><a href=\"#2-1-38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？\" class=\"headerlink\" title=\"2.1.38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"></a>2.1.38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms = 16.7ms。</p>\n<h3 id=\"2-1-39-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\"><a href=\"#2-1-39-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\" class=\"headerlink\" title=\"2.1.39 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\"></a>2.1.39 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p>行框的排列会受到中间空白（回车空格）等的影响，因为空白也属于字符，这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p>\n<blockquote>\n<p>解决办法：</p>\n</blockquote>\n<ol>\n<li>可以将<code>&lt;li&gt;</code>代码全部写在一排</li>\n<li>浮动li中<code>float:left</code></li>\n<li>在<code>ul</code>中用<code>font-size:0</code>（谷歌不支持）；可以使用<code>letter-space:-3px</code></li>\n</ol>\n<h3 id=\"2-1-40-display-inline-block什么时候会显示间隙？\"><a href=\"#2-1-40-display-inline-block什么时候会显示间隙？\" class=\"headerlink\" title=\"2.1.40 display:inline-block什么时候会显示间隙？\"></a>2.1.40 display:inline-block什么时候会显示间隙？</h3><ol>\n<li><p>有空格时候会有间隙</p>\n<p>解决：移除空格</p>\n</li>\n<li><p>margin正值的时候</p>\n<p>解决：margin使用负值</p>\n</li>\n<li><p>使用font-size时候</p>\n<p>解决：font-size:0、letter-spacing、word-spacing</p>\n</li>\n</ol>\n<h3 id=\"2-1-41-有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\"><a href=\"#2-1-41-有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\" class=\"headerlink\" title=\"2.1.41 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\"></a>2.1.41 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h3><p>外层div使用<code>position:relative;</code>高度要求自适应的div使用<code>position:absolute;top:100px;bottom:0;left:0</code></p>\n<h3 id=\"2-1-42-png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？\"><a href=\"#2-1-42-png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？\" class=\"headerlink\" title=\"2.1.42 png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？\"></a>2.1.42 png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h3><ol>\n<li>png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。大多数地方都可以用。</li>\n<li>jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li>\n<li>gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。</li>\n<li>webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li>\n</ol>\n<h3 id=\"2-1-43-style标签写在body后与body前有什么区别？\"><a href=\"#2-1-43-style标签写在body后与body前有什么区别？\" class=\"headerlink\" title=\"2.1.43 style标签写在body后与body前有什么区别？\"></a>2.1.43 style标签写在body后与body前有什么区别？</h3><p>页面加载自上而下，当然是先加载样式。</p>\n<p>写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p>\n<h3 id=\"2-1-44-CSS属性overflow属性定义溢出元素内容区的内容会如何处理？\"><a href=\"#2-1-44-CSS属性overflow属性定义溢出元素内容区的内容会如何处理？\" class=\"headerlink\" title=\"2.1.44 CSS属性overflow属性定义溢出元素内容区的内容会如何处理？\"></a>2.1.44 CSS属性overflow属性定义溢出元素内容区的内容会如何处理？</h3><ul>\n<li>参数是scroll的时候，必会出现滚动条</li>\n<li>参数是auto的时候，子元素内容大于父元素时出现滚动条</li>\n<li>参数是visible的时候，溢出的内容出现在父元素之外</li>\n<li>参数是hidden的时候，溢出隐藏</li>\n</ul>\n<h3 id=\"2-1-45-阐述一下CSS-Sprites\"><a href=\"#2-1-45-阐述一下CSS-Sprites\" class=\"headerlink\" title=\"2.1.45 阐述一下CSS Sprites\"></a>2.1.45 阐述一下CSS Sprites</h3><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的<code>background-image</code>，<code>background-repeat</code>，<code>background-position</code>的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大提高页面的性能，CSS Sprites能减少页面的字节。</p>\n<h2 id=\"2-2-能不能讲一讲Flex布局，以及常用的属性？\"><a href=\"#2-2-能不能讲一讲Flex布局，以及常用的属性？\" class=\"headerlink\" title=\"2.2 能不能讲一讲Flex布局，以及常用的属性？\"></a>2.2 能不能讲一讲Flex布局，以及常用的属性？</h2><p><a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html\" target=\"_blank\" rel=\"noopener\">阮一峰的flex系列</a></p>\n<h3 id=\"2-2-1-flex布局是什么？\"><a href=\"#2-2-1-flex布局是什么？\" class=\"headerlink\" title=\"2.2.1 flex布局是什么？\"></a>2.2.1 flex布局是什么？</h3><p>Flex是Flexible Box的缩写，意为”弹性布局“，用来为盒装模型提供最大的灵活性。</p>\n<p>任何一个容器都可以指定为Flex布局。</p>\n<pre><code class=\"css\">.box {\n    display: flex;\n}\n</code></pre>\n<p>行内元素也可以使用Flex布局。</p>\n<pre><code class=\"css\">.box {\n    display: inline-flex;\n}\n</code></pre>\n<p>Webkit内核的浏览器，必须加上<code>-webkit</code>前缀。</p>\n<pre><code class=\"css\">.box {\n    display: -webkit-flex; /* Safari */\n    display: flex;\n}\n</code></pre>\n<blockquote>\n<p>注意，设为Flex布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>\n</blockquote>\n<h3 id=\"2-2-2-基本概念\"><a href=\"#2-2-2-基本概念\" class=\"headerlink\" title=\"2.2.2 基本概念\"></a>2.2.2 基本概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器“。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目“。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png\" alt></p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>\n<h3 id=\"2-2-3-容器的属性\"><a href=\"#2-2-3-容器的属性\" class=\"headerlink\" title=\"2.2.3 容器的属性\"></a>2.2.3 容器的属性</h3><p>以下6个属性设置在容器上。</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<h4 id=\"2-2-3-1-flex-direction属性\"><a href=\"#2-2-3-1-flex-direction属性\" class=\"headerlink\" title=\"2.2.3.1 flex-direction属性\"></a>2.2.3.1 flex-direction属性</h4><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>\n<pre><code class=\"css\">.box {\n    flex-direction: row | row-reverse | column | column-reverse;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png\" alt></p>\n<p>它可能有四个值。</p>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h4 id=\"2-2-3-2-flex-wrap属性\"><a href=\"#2-2-3-2-flex-wrap属性\" class=\"headerlink\" title=\"2.2.3.2 flex-wrap属性\"></a>2.2.3.2 flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称“轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png\" alt></p>\n<pre><code class=\"css\">.box {\n    flex-wrap: nowrap | wrap | wrap-reverse; \n}\n</code></pre>\n<p>它可能取三个值。</p>\n<ol>\n<li><p><code>nowrap</code>（默认）：不换行。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png\" alt></p>\n</li>\n<li><p><code>wrap</code>：换行，第一行在上方。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg\" alt></p>\n</li>\n<li><p><code>wrap-reverse</code>：换行，第一行在下方。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg\" alt></p>\n</li>\n</ol>\n<h4 id=\"2-2-3-3-flex-flow\"><a href=\"#2-2-3-3-flex-flow\" class=\"headerlink\" title=\"2.2.3.3 flex-flow\"></a>2.2.3.3 flex-flow</h4><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>\n<pre><code class=\"css\">.box {\n    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;\n}\n</code></pre>\n<h4 id=\"2-2-3-4-justify-content属性\"><a href=\"#2-2-3-4-justify-content属性\" class=\"headerlink\" title=\"2.2.3.4 justify-content属性\"></a>2.2.3.4 justify-content属性</h4><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>\n<pre><code class=\"css\">.box {\n    justify-content: flex-start | flex-end | center | space-between\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png\" alt=\"justify-content\"></p>\n<p>它可能取五个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<ul>\n<li>flex-start(默认值)：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center：居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<h4 id=\"2-2-3-5-align-items属性\"><a href=\"#2-2-3-5-align-items属性\" class=\"headerlink\" title=\"2.2.3.5 align-items属性\"></a>2.2.3.5 align-items属性</h4><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>\n<pre><code class=\"css\">.box {\n    align-items: flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png\" alt=\"align-items\"></p>\n<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐</li>\n<li>flex-end：交叉轴的终点对齐</li>\n<li>center：交叉轴的中点对齐</li>\n<li>baseline：项目的第一行文字的基线对齐</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li>\n</ul>\n<h4 id=\"2-2-3-6-align-content属性\"><a href=\"#2-2-3-6-align-content属性\" class=\"headerlink\" title=\"2.2.3.6 align-content属性\"></a>2.2.3.6 align-content属性</h4><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<pre><code class=\"css\">.box {\n    align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png\" alt></p>\n<p>该属性可能取6个值。</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐</li>\n<li>flex-end：与交叉轴的终点对齐</li>\n<li>center：与交叉轴的中点对齐</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>\n<li>stretch（默认值）：轴线占满整个交叉轴</li>\n</ul>\n<h3 id=\"2-2-4-项目的属性\"><a href=\"#2-2-4-项目的属性\" class=\"headerlink\" title=\"2.2.4 项目的属性\"></a>2.2.4 项目的属性</h3><p>以下6个属性设置在项目上。</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h4 id=\"2-2-4-1-order属性\"><a href=\"#2-2-4-1-order属性\" class=\"headerlink\" title=\"2.2.4.1 order属性\"></a>2.2.4.1 order属性</h4><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>\n<pre><code class=\"css\">.item {\n    order: &lt;integer&gt;;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png\" alt></p>\n<h4 id=\"2-2-4-2-flex-grow属性\"><a href=\"#2-2-4-2-flex-grow属性\" class=\"headerlink\" title=\"2.2.4.2 flex-grow属性\"></a>2.2.4.2 flex-grow属性</h4><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>\n<pre><code class=\"css\">.item {\n    flex-grow: &lt;number&gt;; /* default 0 */\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png\" alt></p>\n<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h4 id=\"2-2-4-3-flex-shrink属性\"><a href=\"#2-2-4-3-flex-shrink属性\" class=\"headerlink\" title=\"2.2.4.3 flex-shrink属性\"></a>2.2.4.3 flex-shrink属性</h4><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>\n<pre><code class=\"css\">.item {\n    flex-shrink: &lt;number&gt;; /* default 1 */\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg\" alt></p>\n<p>如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<p>负值对该属性无效。</p>\n<h4 id=\"2-2-4-4-flex-basis属性\"><a href=\"#2-2-4-4-flex-basis属性\" class=\"headerlink\" title=\"2.2.4.4 flex-basis属性\"></a>2.2.4.4 flex-basis属性</h4><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>\n<pre><code class=\"css\">.item {\n    flex-basis: &lt;length&gt; | auto; /* default auto */\n}\n</code></pre>\n<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>\n<h4 id=\"2-2-4-5-flex属性\"><a href=\"#2-2-4-5-flex属性\" class=\"headerlink\" title=\"2.2.4.5 flex属性\"></a>2.2.4.5 flex属性</h4><p><code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>\n<pre><code class=\"css\">.item {\n    flex: none | [&lt;&#39;flex-grow&#39;&gt;&lt;&#39;flex-shrink&#39;&gt;&lt;&#39;flex-basis&#39;&gt;]\n}\n</code></pre>\n<p>该属性有两个快捷键：<code>auto</code>（<code>1 1 auto</code>）和<code>none</code>（<code>0 0 auto</code>）。</p>\n<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h4 id=\"2-2-4-6-align-self属性\"><a href=\"#2-2-4-6-align-self属性\" class=\"headerlink\" title=\"2.2.4.6 align-self属性\"></a>2.2.4.6 align-self属性</h4><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>\n<pre><code class=\"css\">.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png\" alt></p>\n<p>该属性可能去6个值，除了auto，其他都与align-items属性完全一致。</p>\n<h1 id=\"3、JS篇\"><a href=\"#3、JS篇\" class=\"headerlink\" title=\"3、JS篇\"></a>3、JS篇</h1><h2 id=\"3-1-从原型到原型链\"><a href=\"#3-1-从原型到原型链\" class=\"headerlink\" title=\"3.1 从原型到原型链\"></a>3.1 从原型到原型链</h2><h3 id=\"3-1-2-构造函数创建对象\"><a href=\"#3-1-2-构造函数创建对象\" class=\"headerlink\" title=\"3.1.2 构造函数创建对象\"></a>3.1.2 构造函数创建对象</h3><p>我们先使用构造函数创建一个对象：</p>\n<pre><code class=\"js\">function Person() {\n\n}\nvar person = new Person();\nperson.name = &#39;Kevin&#39;;\nconsole.log(person.name) // Kevin\n</code></pre>\n<p>在这个例子中，<code>Person</code>就是一个构造函数，我们使用<code>new</code>创建了一个实例对象<code>person</code>。</p>\n<p>很简单吧，接下来进入正题：</p>\n<h3 id=\"3-1-3-prototype\"><a href=\"#3-1-3-prototype\" class=\"headerlink\" title=\"3.1.3 prototype\"></a>3.1.3 prototype</h3><p>每个函数都有一个<code>prototype</code>属性，就是我们经常在各种例子中看到的那个<code>prototype</code>，比如：</p>\n<pre><code class=\"js\">function Person() {\n}\n// 虽然写在注释里，但是你要注意：\n// prototype是函数才会有的属性\nPerson.prototype.name = &#39;Kevin&#39;;\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name) // Kevin\nconsole.log(person2.name) // Kevin\n</code></pre>\n<p>那这个函数的<code>prototype</code>属性到底指向的是什么呢？是这个函数的原型吗？</p>\n<p>其实，函数的<code>prototype</code>属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的<code>person1</code>和<code>person2</code>的原型。</p>\n<p>那什么是原型呢？你可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。</p>\n<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/prototype.png\" alt=\"prototype\">)</p>\n<p>在这张图中我们用<code>Object.prototype</code>表示实例原型。</p>\n<p>那么我们该怎么表示实例与实例原型，也就是<code>person</code>和<code>Person.prototype</code>之间的关系呢，这时候我们就要讲到第二个属性：</p>\n<h3 id=\"3-1-4-proto\"><a href=\"#3-1-4-proto\" class=\"headerlink\" title=\"3.1.4 __proto__\"></a>3.1.4 <code>__proto__</code></h3><p>这是每一个JavaScript对象（除了null）都具有的一个属性，叫<code>__proto__</code>，这个属性会指向该对象的原型。</p>\n<p>为了证明这一点，我们可以在火狐或者谷歌中输入：</p>\n<pre><code class=\"js\">function Person(){\n\n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n</code></pre>\n<p>于是我们更新下关系图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/__proto__.png\" alt=\"__proto__\"></p>\n<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>\n<h3 id=\"3-1-5-constructor\"><a href=\"#3-1-5-constructor\" class=\"headerlink\" title=\"3.1.5 constructor\"></a>3.1.5 constructor</h3><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：<code>constructor</code>，每个原型都有一个<code>constructor</code>属性指向关联的构造函数。</p>\n<p>为了验证这一点，我们可以尝试：</p>\n<pre><code class=\"js\">function Person() {\n}\nconsole.log(Person === Person.prototype.constructor); // true\n</code></pre>\n<p>所以再更新下关系图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/constructor.png\" alt=\"constructor\"></p>\n<p>综上我们已经得出：</p>\n<pre><code class=\"js\">function Person() {\n\n}\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法，可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n</code></pre>\n<p>了解了构造函数、实力原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p>\n<h3 id=\"3-1-6-实例与原型\"><a href=\"#3-1-6-实例与原型\" class=\"headerlink\" title=\"3.1.6 实例与原型\"></a>3.1.6 实例与原型</h3><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>\n<p>举个例子：</p>\n<pre><code class=\"js\">function Person() {\n}\nPerson.prototype.name = &#39;Kevin&#39;;\n\nvar person = new Person();\nperson.name = &#39;Daisy&#39;;\nconsole.log(person.name) // Daisy\n\ndelete person.name;\nconsole.log(person.name) // Kevin\n</code></pre>\n<p>在这个例子中，我们给实例对象<code>person</code>添加了<code>name</code>属性，当我们打印<code>person.name</code>的时候，结果自然为<code>Daisy</code>。</p>\n<p>但是当我们删除了<code>person</code>的<code>name</code>属性时，读取<code>person.name</code>，从<code>person</code>对象中找不到<code>name</code>属性就会从<code>person</code>的原型也就是<code>person.__ptoto__</code>，也就是<code>Person.prototype</code>中查找，幸运的是我们找到了<code>name</code>属性，结果为<code>Kevin</code>。</p>\n<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>\n<h3 id=\"3-1-7-原型的原型\"><a href=\"#3-1-7-原型的原型\" class=\"headerlink\" title=\"3.1.7 原型的原型\"></a>3.1.7 原型的原型</h3><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>\n<pre><code class=\"js\">var obj = new Object();\nobj.name = &#39;Kevin&#39;\nconsole.log(obj.name) // Kevin\n</code></pre>\n<p>其实原型对象就是通过<code>Object</code>构造函数生成的，结合之前所讲，实例的<code>__proto__</code>指向构造函数的<code>prototype</code>，所以我们再更新下关系图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/原型的原型.png\" alt=\"原型的原型\"></p>\n<h3 id=\"3-1-8-原型链\"><a href=\"#3-1-8-原型链\" class=\"headerlink\" title=\"3.1.8 原型链\"></a>3.1.8 原型链</h3><p>那 Object.prototype 的原型呢？</p>\n<p>null，我们可以打印：</p>\n<pre><code class=\"js\">console.log(Object.prototype.__proto__ === null) // true\n</code></pre>\n<p>然而<code>null</code>究竟代表了什么呢？</p>\n<p>引用阮一峰的《<a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\" target=\"_blank\" rel=\"noopener\">undefined与null的区别</a>》就是：</p>\n<blockquote>\n<p>null表示“没有对象”，即该处不应该有值。</p>\n</blockquote>\n<p>所以<code>Object.prototype.__proto__</code>的值为<code>null</code>跟<code>Object.prototype</code>没有原型，其实表达了一个意思。</p>\n<p>所以查找到属性的时候查到<code>Object.prototype</code>就可以停止查找了。</p>\n<p>最后一张关系图也可以更新为：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/原型链.png\" alt=\"原型链\"></p>\n<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>\n<blockquote>\n<p>补充</p>\n</blockquote>\n<h3 id=\"3-1-9-constructor\"><a href=\"#3-1-9-constructor\" class=\"headerlink\" title=\"3.1.9 constructor\"></a>3.1.9 constructor</h3><p>首先是<code>constructor</code>属性，我们看个例子：</p>\n<pre><code class=\"js\">function Person() {\n}\nvar person = new Person();\nconsole.log(person.constructor === Person); // true\n</code></pre>\n<p>当获取<code>person.constructor</code>时，其实<code>person</code>中并没有<code>constructor</code>属性，当不能读取到<code>constructor</code>属性时，会从<code>person</code>的原型也就是<code>Person.prototype</code>中读取，正好原型中有该属性，所以：</p>\n<pre><code class=\"js\">person.constructor === Person.prototype.constructor\n</code></pre>\n<h3 id=\"3-1-10-proto\"><a href=\"#3-1-10-proto\" class=\"headerlink\" title=\"3.1.10 __proto__\"></a>3.1.10 <code>__proto__</code></h3><p>其次是<code>__proto__</code>，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于<code>Person.prototype</code>中，实际上，它是来自于<code>Object.prototype</code>，与其说是一个属性，不如说是一个<code>getter/setter</code>，当使用<code>obj.__proto__</code>时，可以理解成返回了<code>Object.getPrototypeOf(obj)</code>。</p>\n<h3 id=\"3-1-11-真的是继承吗？\"><a href=\"#3-1-11-真的是继承吗？\" class=\"headerlink\" title=\"3.1.11 真的是继承吗？\"></a>3.1.11 真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’‘属性’”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>\n<p>继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>\n<h2 id=\"3-2-JavaScript深入之词法作用域和动态作用域\"><a href=\"#3-2-JavaScript深入之词法作用域和动态作用域\" class=\"headerlink\" title=\"3.2 JavaScript深入之词法作用域和动态作用域\"></a>3.2 JavaScript深入之词法作用域和动态作用域</h2><h3 id=\"3-2-1-作用域\"><a href=\"#3-2-1-作用域\" class=\"headerlink\" title=\"3.2.1 作用域\"></a>3.2.1 作用域</h3><p>作用域是指程序源代码中定义变量的区域。</p>\n<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>\n<p>JavaScript采用词法作用域（lexical scoping），也就是静态作用域。</p>\n<h3 id=\"3-2-2-静态作用域与动态作用域\"><a href=\"#3-2-2-静态作用域与动态作用域\" class=\"headerlink\" title=\"3.2.2 静态作用域与动态作用域\"></a>3.2.2 静态作用域与动态作用域</h3><p>因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>\n<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p>\n<p>让我们认真看个例子就能明白之间的区别：</p>\n<pre><code class=\"js\">var vaule = 1;\nfunction foo() {\n    console.log(value);\n}\nfunction bar() {\n    var value = 2;\n    foo();\n}\nbar();\n\n// 结果是？？？\n</code></pre>\n<p>假设JavaScript采用静态作用域，让我们分析下执行过程：</p>\n<p>执行<code>foo</code>函数，先从<code>foo</code>函数内部查找是否有局部变量<code>value</code>，如果没有，就根据书写的位置，查找上面一层的代码，也就是<code>value</code>等于1，所以结果会打印1。</p>\n<p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p>\n<p>执行<code>foo</code>函数，依然是从<code>foo</code>函数内部查找是否有局部变量<code>value</code>。如果没有，就从调用函数的作用域，也就是<code>bar</code>函数内部查找<code>value</code>变量，所以结果会打印2。</p>\n<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是1。</p>\n<h3 id=\"3-2-3-动态作用域\"><a href=\"#3-2-3-动态作用域\" class=\"headerlink\" title=\"3.2.3 动态作用域\"></a>3.2.3 动态作用域</h3><p>也许你会好奇什么语言是动态作用域？</p>\n<p><code>bash</code>就是动态作用域，不信的话，把下面的脚本存成例如<code>scope.bash</code>，然后进行相应的目录，用命令行执行<code>bash ./scope.bash</code>，看看打印的值是多少。</p>\n<pre><code class=\"js\">value = 1\nfunction foo() {\n    echo $value;\n}\nfunction bar() {\n    local value = 2;\n    foo;\n}\nbar\n</code></pre>\n<h3 id=\"3-2-4-思考题\"><a href=\"#3-2-4-思考题\" class=\"headerlink\" title=\"3.2.4 思考题\"></a>3.2.4 思考题</h3><p>最后，让我们看一个《JavaScript权威指南》中的例子：</p>\n<pre><code class=\"js\">var scope = &#39;global scope&#39;;\nfunction checkscope() {\n    var scope = &#39;local scope&#39;;\n    function f() {\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n</code></pre>\n<pre><code class=\"js\">var scope = &#39;global scope&#39;;\nfunction checkscope() {\n    var scope = &#39;local scope&#39;;\n    function f() {\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n</code></pre>\n<p>两段代码都会打印：<code>local scope</code>。</p>\n<p>原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。</p>\n<p>而引用《JavaScript权威指南》的回答就是：</p>\n<p>JavaScript函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数<code>f()</code>定义在这个作用域链里，其中的变量scope一定是局部变量，不管何时何地执行<code>f()</code>，这种绑定在执行<code>f()</code>时依然有效。</p>\n<p>但是在这里真正想让大家思考的是：</p>\n<p>虽然两端代码执行的结果一样，但是两段代码究竟有哪些不同呢？</p>\n<p>如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下文。</p>\n<h2 id=\"3-3-JavaScript深入之执行上下文栈\"><a href=\"#3-3-JavaScript深入之执行上下文栈\" class=\"headerlink\" title=\"3.3 JavaScript深入之执行上下文栈\"></a>3.3 JavaScript深入之执行上下文栈</h2><h3 id=\"3-3-1-顺序执行？\"><a href=\"#3-3-1-顺序执行？\" class=\"headerlink\" title=\"3.3.1 顺序执行？\"></a>3.3.1 顺序执行？</h3><p>如果要问到JavaScript代码执行顺序的话，想必写过JavaScript的开发者都会有个直观的印象，那就是顺序执行，毕竟：</p>\n<pre><code class=\"js\">var foo = function() {\n    console.log(&#39;foo1&#39;);\n}\nfoo(); // foo1\n\nvar foo = function() {\n    console.log(&#39;foo2&#39;);\n}\nfoo(); // foo2\n</code></pre>\n<p>然而去看这段代码：</p>\n<pre><code class=\"js\">function foo() {\n    console.log(&#39;foo1&#39;);\n}\nfoo(); // foo2\nfunction foo() {\n    console.log(&#39;foo2&#39;);\n}\nfoo(); // foo2\n</code></pre>\n<p>打印的结果却是两个<code>foo2</code>。</p>\n<p>刷过面试题的都知道这是因为JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。</p>\n<p>但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？</p>\n<p>到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？</p>\n<h3 id=\"3-3-2-可执行代码\"><a href=\"#3-3-2-可执行代码\" class=\"headerlink\" title=\"3.3.2 可执行代码\"></a>3.3.2 可执行代码</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、HTML篇\"><a href=\"#1、HTML篇\" class=\"headerlink\" title=\"1、HTML篇\"></a>1、HTML篇</h1><h2 id=\"1-1-HTML5语义化\"><a href=\"#1-1-HTML5语义化\" class=\"headerlink\" title=\"1.1 HTML5语义化\"></a>1.1 HTML5语义化</h2><p><a href=\"https://rainylog.com/post/ife-note-1/\" target=\"_blank\" rel=\"noopener\">HTML5语义化</a></p>\n<h3 id=\"1-1-1-为什么需要语义化\"><a href=\"#1-1-1-为什么需要语义化\" class=\"headerlink\" title=\"1.1.1 为什么需要语义化\"></a>1.1.1 为什么需要语义化</h3><ul>\n<li><p>易修改、易维护</p>\n</li>\n<li><p>无障碍阅读支持</p>\n</li>\n<li><p>搜索引擎友好、利于SEO</p>\n</li>\n<li><p>面向未来的HTML、浏览器在未来可能提供更丰富的支持</p>\n</li>\n</ul>\n<h3 id=\"1-1-2-结构语义化\"><a href=\"#1-1-2-结构语义化\" class=\"headerlink\" title=\"1.1.2 结构语义化\"></a>1.1.2 结构语义化</h3><p>语义元素均有一个共同特点--他们均不做任何事情。换句话说，语义元素仅仅是页面结构的规范化，并不会对内容有本质的影响。</p>\n<p>下图展示了一个典型的页面结构。<br><img src=\"https://rainylog-1256215078.cos.ap-shanghai.myqcloud.com/images/page.png\" alt></p>\n<h3 id=\"1-1-3-头部\"><a href=\"#1-1-3-头部\" class=\"headerlink\" title=\"1.1.3 头部\"></a>1.1.3 头部</h3><p><code>&lt;header&gt;</code>元素有两种用法，第一是标注内容的标题，第二是标注网页的页眉，如上图你看到的那样。除非必要（内容标题附带其他信息的情况下：发布时间、作者等），一般不在内容中使用<code>&lt;header&gt;</code>。因而，网页中可以包含多个<code>&lt;header&gt;</code>元素。按照HTML5的规定，<code>&lt;header&gt;</code>都应包含某个级别的标题，所以应隐式或显式地包含标题，通常将不希望显示的标题设置为<code>display: none;</code>，一方面遵守规范，另一方面则提供了无障碍阅读而不至于影响到页面设计。</p>\n<h3 id=\"1-1-4-导航栏\"><a href=\"#1-1-4-导航栏\" class=\"headerlink\" title=\"1.1.4 导航栏\"></a>1.1.4 导航栏</h3><p>导航栏使用<code>&lt;nav&gt;</code>看起来是理所当然的，进一步，它也用于一组文章的链接。一个页面可以包含多个<code>&lt;nav&gt;</code>元素，但通常仅仅在页面的主要导航部分使用它。</p>\n<p>《HTML5：The Missing Manual》中指出了在侧栏使用<code>&lt;nav&gt;</code>标签的两个案例：</p>\n<pre><code class=\"html\">&lt;!-- 案例一 --&gt;\n&lt;nav&gt;\n    &lt;!-- 此处是链接 --&gt;\n    &lt;aside&gt;&lt;/aside&gt;\n    &lt;aside&gt;&lt;/aside&gt;\n&lt;/nav&gt;\n\n&lt;!-- 案例二 --&gt;\n&lt;aside&gt;\n    &lt;nav&gt;\n        &lt;!-- 此处是链接 --&gt;\n    &lt;/nav&gt;\n    &lt;section&gt;&lt;/section&gt;\n    &lt;div&gt;&lt;/div&gt;\n&lt;/aside&gt;\n</code></pre>\n<p>如果侧栏中包含其它不同于链接的其它区块，那么，使用第二种方案显然更为合适。</p>\n<p>导航通常包含一组链接，普遍认为，链接使用列表来组织。</p>\n<pre><code class=\"html\">&lt;nav&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;a href=&quot;#&quot; title=&quot;链接&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=&quot;#&quot; title=&quot;链接&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=&quot;#&quot; title=&quot;链接&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/nav&gt;\n</code></pre>\n<h3 id=\"1-1-5-附注\"><a href=\"#1-1-5-附注\" class=\"headerlink\" title=\"1.1.5 附注\"></a>1.1.5 附注</h3><p><code>&lt;aside&gt;</code>元素并不仅仅是侧栏，它表示与它周围文本没有密切关系的内容。文章中同样可以使用<code>&lt;aside&gt;</code>元素，来说明文章的附加内容、解释说明某个观点、相关内容链接等等。</p>\n<p>当<code>&lt;aside&gt;</code>用于侧栏时，其表示整个网页的附加内容。通常的广告区域、搜索、分享链接则位于侧栏。侧栏中的<code>&lt;section&gt;</code>元素规定了一个区域，通常是带有标题的内容。</p>\n<p><code>&lt;section&gt;</code>标签适合标记的内容区块：</p>\n<ul>\n<li>与页面主体并列显示的小内容块。</li>\n<li>独立性内容，清单、表单等。</li>\n<li>分组内容，如CMS系统中的文章分类区块。</li>\n<li>比较长文档的一部分，可能仅仅是为了正确规定页面大纲。</li>\n</ul>\n<p><code>&lt;div&gt;</code>标签依然是可用的，当你觉得使用其它标签都不太合适的时候。新的语义元素出现之前，我们总是这么干的！</p>\n<h3 id=\"1-1-6-页脚\"><a href=\"#1-1-6-页脚\" class=\"headerlink\" title=\"1.1.6 页脚\"></a>1.1.6 页脚</h3><p>同可”包罗万象“的<code>&lt;header&gt;</code>元素不同，标准规定<code>&lt;footer&gt;</code>标签仅仅可以包含版权、来源信息、法律限制等等之类的文本或链接信息。如果想要在页脚中包含其它内容，可以使用熟悉的<code>&lt;div&gt;</code>来帮忙。</p>\n<pre><code class=\"html\">&lt;div&gt;\n    &lt;aside&gt;\n    &lt;!-- 其它内容 --&gt;\n    &lt;/aside&gt;\n\n    &lt;footer&gt;\n    &lt;!-- 法律、版权、来源、联系信息等 --&gt;\n    &lt;/footer&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id=\"1-1-7-主要内容\"><a href=\"#1-1-7-主要内容\" class=\"headerlink\" title=\"1.1.7 主要内容\"></a>1.1.7 主要内容</h3><p>在早先的HTML5版本中并没有规定页面主体的标签，相关的书中经常会说：除去头部、尾部、侧栏等其它部分，剩下的自然是主体部分。</p>\n<p>然而，HTML5.1中规定了一个<code>&lt;main&gt;</code>标签来标识主体内容。<code>&lt;main&gt;</code>标签不能包含在页面其它区块元素中，通常是<code>&lt;body&gt;</code>的子标签，或者是全局<code>&lt;div&gt;</code>的子标签。<code>&lt;main&gt;</code>标签可以帮助屏幕阅读工具识别页面的主体部分，从而让访问者迅速得到有用的信息。</p>\n<h3 id=\"1-1-8-文章\"><a href=\"#1-1-8-文章\" class=\"headerlink\" title=\"1.1.8 文章\"></a>1.1.8 文章</h3><p><code>&lt;article&gt;</code>表示一个完整的、自成一体的内容块。如文章或新闻报道。<code>&lt;article&gt;</code>应包含完整的标题、文章署名、发布时间、正文。当语义与表现发生冲突，例如有时需要将文章分多个页面显示，那么需要把每个页面的文章区域都用<code>&lt;article&gt;</code>标记。</p>\n<p>文章中包含插图时，使用新的语义元素<code>&lt;figure&gt;</code>标签。</p>\n<pre><code class=\"html\">&lt;article&gt;\n    &lt;h1&gt;标题&lt;/h1&gt;\n    &lt;p&gt;\n        &lt;!-- 内容 --&gt;\n    &lt;/p&gt;\n    &lt;figure&gt;\n        &lt;img src=&quot;#&quot; alt=&quot;插图&quot;&gt;\n        &lt;figcaption&gt;这是一个插图&lt;/figcaption&gt;\n    &lt;/figure&gt;\n&lt;/article&gt;\n</code></pre>\n<p>上述情况下，<code>&lt;figcaption&gt;</code>包含了关于插图的详细解释，则<code>&lt;img&gt;</code>的<code>alt</code>属性可以略去。</p>\n<h3 id=\"1-1-9-IFE任务\"><a href=\"#1-1-9-IFE任务\" class=\"headerlink\" title=\"1.1.9 IFE任务\"></a>1.1.9 IFE任务</h3><h4 id=\"1-1-9-1-任务描述\"><a href=\"#1-1-9-1-任务描述\" class=\"headerlink\" title=\"1.1.9.1 任务描述\"></a>1.1.9.1 任务描述</h4><p>参考示例图（<a href=\"http://7xrp04.com1.z0.glb.clouddn.com/task_1_1_1.jpg\" target=\"_blank\" rel=\"noopener\">点击查看</a>），完成一个HTML页面代码编写（不写CSS，不需要关注样式，只关注文档结构）。</p>\n<h4 id=\"1-1-9-2-范例\"><a href=\"#1-1-9-2-范例\" class=\"headerlink\" title=\"1.1.9.2 范例\"></a>1.1.9.2 范例</h4><p>用语义化来构建该页面的结构：<a href=\"https://github.com/geekrainy/ife/blob/master/task/task-1/index.html\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<h1 id=\"2、CSS篇\"><a href=\"#2、CSS篇\" class=\"headerlink\" title=\"2、CSS篇\"></a>2、CSS篇</h1><h2 id=\"2-1-CSS常见面试题\"><a href=\"#2-1-CSS常见面试题\" class=\"headerlink\" title=\"2.1 CSS常见面试题\"></a>2.1 CSS常见面试题</h2><p><a href=\"https://segmentfault.com/a/1190000013325778\" target=\"_blank\" rel=\"noopener\">45道CSS经典面试题</a></p>\n<h3 id=\"2-1-1-介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\"><a href=\"#2-1-1-介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\" class=\"headerlink\" title=\"2.1.1 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？\"></a>2.1.1 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</h3><ul>\n<li><code>标准盒子模型</code>：宽度 = 内容的宽度（content）+ border + padding + margin</li>\n<li><code>低版本IE盒子模型</code>：宽度 = 内容宽度（content + border + padding）+ margin</li>\n</ul>\n<h3 id=\"2-1-2-box-sizing属性？\"><a href=\"#2-1-2-box-sizing属性？\" class=\"headerlink\" title=\"2.1.2 box-sizing属性？\"></a>2.1.2 box-sizing属性？</h3><p>用来控制元素的盒子模型的解析模式，默认为<code>content-box</code>。</p>\n<ul>\n<li><code>content-box</code>：W3C的标准盒子模型，设置元素的<code>height/width</code>属性指的是<code>content</code>部分的高/宽。</li>\n<li><code>border-box</code>：IE传统盒子模型。设置元素的<code>height/width</code>属性指的是<code>border + padding + content</code>部分的高/宽。</li>\n</ul>\n<h3 id=\"2-1-3-CSS选择器有哪些？哪些属性可以继承？\"><a href=\"#2-1-3-CSS选择器有哪些？哪些属性可以继承？\" class=\"headerlink\" title=\"2.1.3 CSS选择器有哪些？哪些属性可以继承？\"></a>2.1.3 CSS选择器有哪些？哪些属性可以继承？</h3><ul>\n<li><code>CSS选择符</code>：id选择器(#myid)、类选择器(.myclassname)、标签选择器(div,h1,p)、相邻选择器(h1 + p)、子选择器(ul &gt; li)、后代选择器(li a)、通配符选择器(*)、属性选择器(a[rel=&quot;external&quot;])、伪类选择器(a:hover, li:nth-child)</li>\n<li><code>可继承的属性</code>：font-size，font-family，color</li>\n<li><code>不可继承的样式</code>：border，padding，margin，width，height</li>\n<li><code>优先级（就近原则）</code>：!important &gt; [id &gt; class &gt; tag]，!important比内联优先级高</li>\n</ul>\n<h3 id=\"2-1-4-CSS优先级算法如何计算？\"><a href=\"#2-1-4-CSS优先级算法如何计算？\" class=\"headerlink\" title=\"2.1.4 CSS优先级算法如何计算？\"></a>2.1.4 CSS优先级算法如何计算？</h3><ul>\n<li>元素选择符：1</li>\n<li>class选择符：10</li>\n<li>id选择符：100</li>\n<li>元素标签：1000</li>\n</ul>\n<ol>\n<li>!important声明的样式优先级最高，如果冲突再进行计算。</li>\n<li>如果优先级相同，则选择最后出现的样式。</li>\n<li>继承得到的样式的优先级最低。</li>\n</ol>\n<h3 id=\"2-1-5-CSS3新增伪类有哪些？\"><a href=\"#2-1-5-CSS3新增伪类有哪些？\" class=\"headerlink\" title=\"2.1.5 CSS3新增伪类有哪些？\"></a>2.1.5 CSS3新增伪类有哪些？</h3><ul>\n<li><code>p:first-of-type</code>：选择属于其父元素的首个元素</li>\n<li><code>p:last-of-type</code>：选择属于其父元素的最后元素</li>\n<li><code>p:only-of-type</code>：选择属于其父元素唯一的元素</li>\n<li><code>p:only-child</code>：选择属于其父元素的唯一子元素</li>\n<li><code>p:nth-child(2)</code>：选择属于其父元素的第二个子元素</li>\n<li><code>:enabled, :disabled</code>：表单控件的禁用状态</li>\n<li><code>:checked</code>：单选框或复选框被选中</li>\n</ul>\n<h3 id=\"2-1-6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\"><a href=\"#2-1-6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\" class=\"headerlink\" title=\"2.1.6 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\"></a>2.1.6 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h3><blockquote>\n<p>div</p>\n</blockquote>\n<pre><code class=\"css\">border: 1px solid red;\nmargin: 0 auto;\nheight: 50px;\nwidth: 80px;\n</code></pre>\n<blockquote>\n<p>浮动元素的上下左右居中</p>\n</blockquote>\n<pre><code class=\"css\">border: 1px solid red;\nfloat: left;\nposition: absolute;\nwidth: 200px;\nheight: 100px;\nleft: 50%;\ntop: 50%;\nmargin: -50px 0 0 -100px;\n</code></pre>\n<blockquote>\n<p>绝对定位的左右居中</p>\n</blockquote>\n<pre><code class=\"css\">border: 1px solid black;\nposition: absolute;\nwidth: 200px;\nheight: 100px;\nmargin: 0 auto;\nleft: 0;\nright: 0;\n</code></pre>\n<h3 id=\"2-1-7-display有哪些值？说明他们的作用？\"><a href=\"#2-1-7-display有哪些值？说明他们的作用？\" class=\"headerlink\" title=\"2.1.7 display有哪些值？说明他们的作用？\"></a>2.1.7 display有哪些值？说明他们的作用？</h3><ul>\n<li><code>inline</code>（默认）：内联</li>\n<li><code>none</code>：隐藏</li>\n<li><code>block</code>：块显示</li>\n<li><code>table</code>：表格显示</li>\n<li><code>list-item</code>：项目列表</li>\n<li><code>inline-block</code></li>\n</ul>\n<h3 id=\"2-1-8-position的值？\"><a href=\"#2-1-8-position的值？\" class=\"headerlink\" title=\"2.1.8 position的值？\"></a>2.1.8 position的值？</h3><ul>\n<li><code>static</code>（默认）:按照正常文档流进行排列</li>\n<li><code>relative</code>（相对定位）：不脱离文档流，参考自身静态位置通过top，bottom，left，right定位</li>\n<li><code>absolute</code>（绝对定位）：参考距其最近一个不为static的父级元素通过top,bottom,left,right定位</li>\n<li><code>fixed</code>（固定定位）：所固定的参照对象是可视窗口</li>\n</ul>\n<h3 id=\"2-1-9-CSS3有哪些新特性？\"><a href=\"#2-1-9-CSS3有哪些新特性？\" class=\"headerlink\" title=\"2.1.9 CSS3有哪些新特性？\"></a>2.1.9 CSS3有哪些新特性？</h3><ol>\n<li>RGBA和透明度</li>\n<li>background-image  background-origin(content-box/padding-box/border-box)   background-size   background-repeat</li>\n<li>word-wrap（对长的不可分割单词换行）word-wrap:break-word</li>\n<li>文字阴影：text-shadow: 5px 5px 5px #FF0000; （水平阴影，垂直阴影，模糊距离，阴影颜色）</li>\n<li>font-face属性：定义自己的字体</li>\n<li>圆角（边框半径）：border-radius 属性用于创建圆角</li>\n<li>边框图片：border-image: url(border.png) 30 30 round;</li>\n<li>盒阴影：box-shadow: 10px 10px 5px #888888;</li>\n<li>媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性</li>\n</ol>\n<h3 id=\"2-1-10-请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？\"><a href=\"#2-1-10-请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？\" class=\"headerlink\" title=\"2.1.10 请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？\"></a>2.1.10 请解释一下CSS3的flexbox（弹性盒布局模型），以及使用场景？</h3><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，<code>block</code>布局是把块在垂直方向从上到下依次排列的；而<code>inline</code>布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。</p>\n<p>使用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。</p>\n<h3 id=\"2-1-11-用纯CSS创建一个三角形的原理是什么？\"><a href=\"#2-1-11-用纯CSS创建一个三角形的原理是什么？\" class=\"headerlink\" title=\"2.1.11 用纯CSS创建一个三角形的原理是什么？\"></a>2.1.11 用纯CSS创建一个三角形的原理是什么？</h3><p>首先，需要把元素的宽度、高度设为0.然后设置边框样式。</p>\n<pre><code class=\"css\">width: 0;\nheight: 0;\nborder-top: 40px solid transparent;\nborder-left: 40px solid transparent;\nborder-right: 40px solid transparent;\nborder-bottom: 40px solid #ff0000;\n</code></pre>\n<h3 id=\"2-1-12-一个满屏品字布局如何设计？\"><a href=\"#2-1-12-一个满屏品字布局如何设计？\" class=\"headerlink\" title=\"2.1.12 一个满屏品字布局如何设计？\"></a>2.1.12 一个满屏品字布局如何设计？</h3><p>第一种真正的品字：</p>\n<ol>\n<li>三块高宽是确定的；</li>\n<li>上面那块用<code>margin: 0 auto;</code>居中；</li>\n<li>下面两块用<code>float</code>或者<code>inline-block</code>不换行；</li>\n<li>用<code>margin</code>调整位置使他们居中。</li>\n</ol>\n<p>第二种全屏的品字布局：</p>\n<p>上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行</p>\n<h3 id=\"2-1-13-常见的兼容性问题？\"><a href=\"#2-1-13-常见的兼容性问题？\" class=\"headerlink\" title=\"2.1.13 常见的兼容性问题？\"></a>2.1.13 常见的兼容性问题？</h3><ol>\n<li><p>不同浏览器的标签默认的<code>margin</code>和<code>padding</code>不一样。</p>\n<pre><code class=\"css\">* {\n    margin: 0;\n    padding: 0;\n}\n</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。</p>\n<pre><code class=\"css\">hack: diaplay: inline; // 将其转化为行内属性。\n</code></pre>\n</li>\n<li><p>渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用&quot;9&quot;这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用”+“将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>\n<pre><code class=\"css\">{\n    background-color: #f1ee18; /*所有识别*/\n    .background-color: #00deff\\9; /*IE6、7、8识别*/\n    +background-color: #a200ff; /*IE6、7识别*/\n    _background-color: #1e0bd1; /*IE6识别*/\n}\n</code></pre>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden; 或者设置行高line-height小于你设置的高度。</p>\n</li>\n<li><p>IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用<code>getAttribute()</code>获取自定义属性；Firefox下，只能使用<code>getAttribute()</code>获取自定义属性。解决方法：统一通过<code>getAttribute()</code>获取自定义属性。</p>\n</li>\n<li><p>Chrome中文界面下默认会将小于12px的文本强制按照12px显示，可以通过加入CSS属性 <code>-webkit-text-size-adjust:none;</code>解决</p>\n</li>\n<li><p>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有<code>hover</code>和<code>active</code>了。解决方法是改变CSS属性的排列顺序：L-V-H-A(love hate):  a:link{}  a:visited{}  a:hover{}  a:active{}</p>\n</li>\n</ol>\n<h3 id=\"2-1-14-为什么要初始化CSS样式？\"><a href=\"#2-1-14-为什么要初始化CSS样式？\" class=\"headerlink\" title=\"2.1.14 为什么要初始化CSS样式？\"></a>2.1.14 为什么要初始化CSS样式？</h3><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>\n<h3 id=\"2-1-15-absolute的containing-block计算方式跟正常流有什么不同？\"><a href=\"#2-1-15-absolute的containing-block计算方式跟正常流有什么不同？\" class=\"headerlink\" title=\"2.1.15 absolute的containing block计算方式跟正常流有什么不同？\"></a>2.1.15 absolute的containing block计算方式跟正常流有什么不同？</h3><p>无论属于哪种，都要先找到其祖先元素中最近的<code>position</code>值不为<code>static</code>的元素，然后再判断：</p>\n<ol>\n<li>若此元素为<code>inline</code>元素，则<code>containing block</code>为能够包含这个元素生成的第一个和最后一个<code>inline box</code>的<code>padding box</code>（除margin，border外的区域）的最小矩形</li>\n<li>否则，则由这个祖先元素的<code>padding box</code>构成。</li>\n</ol>\n<p>如果都找不到，则为<code>intial containing block</code>。</p>\n<blockquote>\n<p>补充：</p>\n<ol>\n<li>static（默认的）/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</li>\n<li>absolute：向上找最近的定位为absolute/relative的元素</li>\n<li>fixed：它的containing block一律为根元素（html/body）</li>\n</ol>\n</blockquote>\n<h3 id=\"2-1-16-CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？\"><a href=\"#2-1-16-CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？\" class=\"headerlink\" title=\"2.1.16 CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？\"></a>2.1.16 CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？</h3><p>当一个元素的<code>visibility</code>属性被设置成<code>collapse</code>值后，对于一般的元素，它的表现跟<code>hidden</code>是一样的。</p>\n<ol>\n<li>chrome中，使用<code>collapse</code>值和使用<code>hidden</code>没有区别。</li>\n<li>firefox，opera和IE，使用<code>collapse</code>和使用<code>display:none</code>没有什么区别。</li>\n</ol>\n<h3 id=\"2-1-17-display-none与visibility-hidden的区别？\"><a href=\"#2-1-17-display-none与visibility-hidden的区别？\" class=\"headerlink\" title=\"2.1.17 display:none与visibility:hidden的区别？\"></a>2.1.17 display:none与visibility:hidden的区别？</h3><ul>\n<li><code>display:none</code>不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</li>\n<li><code>visibility:hidden</code>隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li>\n</ul>\n<h3 id=\"2-1-18-position跟display、overflow、float这些特性相互叠加后会怎么样？\"><a href=\"#2-1-18-position跟display、overflow、float这些特性相互叠加后会怎么样？\" class=\"headerlink\" title=\"2.1.18 position跟display、overflow、float这些特性相互叠加后会怎么样？\"></a>2.1.18 position跟display、overflow、float这些特性相互叠加后会怎么样？</h3><p>display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。</p>\n<p>类似于优先级机制：position:absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float或者absolute定位的元素，只能是块元素或表格。</p>\n<h3 id=\"2-1-19-对BFC规范（块级格式化上下文：block-formatting-context）的理解？\"><a href=\"#2-1-19-对BFC规范（块级格式化上下文：block-formatting-context）的理解？\" class=\"headerlink\" title=\"2.1.19 对BFC规范（块级格式化上下文：block formatting context）的理解？\"></a>2.1.19 对BFC规范（块级格式化上下文：block formatting context）的理解？</h3><p>BFC规定了内部的Block Box如何布局。</p>\n<p>定位方案：</p>\n<pre><code> 1. 内部的Box会在垂直方向上一个接一个放置。\n 2. Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。\n 3. 每个元素的margin box的左边，与包含块border box的左边相接触。\n 4. BFC的区域不会与float box重叠。\n 5. BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。\n 6. 计算BFC的高度时，浮动元素也会参与计算。\n</code></pre><p>满足下列条件之一就可触发BFC</p>\n<ol>\n<li>根元素，html</li>\n<li>float的值不为none（默认）</li>\n<li>overflow的值不为visible（默认）</li>\n<li>display的值为inline-block、table-cell、table-caption</li>\n<li>position的值为absolute或fixed</li>\n</ol>\n<h3 id=\"2-1-20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？\"><a href=\"#2-1-20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？\" class=\"headerlink\" title=\"2.1.20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？\"></a>2.1.20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h3><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。</p>\n<p>浮动带来的问题：</p>\n<pre><code> 1. 父元素的高度无法被撑开，影响与父元素同级的元素\n 2. 与浮动元素同级的非浮动元素（内联元素）会跟谁其后\n 3. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。\n</code></pre><p>清除浮动的方式：</p>\n<pre><code> 1. 父级div定义height\n 2. 最后一个浮动元素后加空div标签，并添加样式clear:both\n 3. 包含浮动元素的父标签添加样式overflow为hidden或auto\n 4. 父级div定义zoom\n</code></pre><h3 id=\"2-1-21-上下margin重合的问题\"><a href=\"#2-1-21-上下margin重合的问题\" class=\"headerlink\" title=\"2.1.21 上下margin重合的问题\"></a>2.1.21 上下margin重合的问题</h3><p>在重合元素外包裹一层容器，并触发该容器生成一个BFC。</p>\n<p>例子：</p>\n<pre><code class=\"html\">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;text&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;!--下面是css代码--&gt;\n.aside {\n    margin-bottom: 100px;  \n    width: 100px;\n    height: 150px;\n    background: #f66;\n}\n.main {\n    margin-top: 100px;\n    height: 200px;\n    background: #fcc;\n}\n.text{\n    /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/\n    overflow: hidden;  //此时已经触发了BFC属性。\n}\n\n</code></pre>\n<h3 id=\"2-1-22-设置元素浮动后，该元素的display值是多少？\"><a href=\"#2-1-22-设置元素浮动后，该元素的display值是多少？\" class=\"headerlink\" title=\"2.1.22 设置元素浮动后，该元素的display值是多少？\"></a>2.1.22 设置元素浮动后，该元素的display值是多少？</h3><p>自动变成display:block</p>\n<h3 id=\"2-1-23-移动端的布局用过媒体查询吗？\"><a href=\"#2-1-23-移动端的布局用过媒体查询吗？\" class=\"headerlink\" title=\"2.1.23 移动端的布局用过媒体查询吗？\"></a>2.1.23 移动端的布局用过媒体查询吗？</h3><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p>\n<pre><code class=\"html\">// &lt;head&gt;里边\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot; media=&quot;only screen and (max-device-width:480px)&quot;&gt;\n\n//css\n@media only screen and (max-device-width:480px) {\n    //css样式\n}\n</code></pre>\n<h3 id=\"2-1-24-使用css预处理器吗？\"><a href=\"#2-1-24-使用css预处理器吗？\" class=\"headerlink\" title=\"2.1.24 使用css预处理器吗？\"></a>2.1.24 使用css预处理器吗？</h3><p>less sass</p>\n<h3 id=\"2-1-25-CSS优化、提高性能的方法有哪些？\"><a href=\"#2-1-25-CSS优化、提高性能的方法有哪些？\" class=\"headerlink\" title=\"2.1.25 CSS优化、提高性能的方法有哪些？\"></a>2.1.25 CSS优化、提高性能的方法有哪些？</h3><ol>\n<li>避免过度约束</li>\n<li>避免后代选择符</li>\n<li>避免链式选择符</li>\n<li>使用紧凑的语法</li>\n<li>避免不必要的命名空间</li>\n<li>避免不必要的重复</li>\n<li>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</li>\n<li>避免!important，可以选择其他选择器</li>\n<li>尽可能的精简规则，你可以合并不同类里的重复规则</li>\n</ol>\n<h3 id=\"2-1-26-浏览器是怎样解析CSS选择器的？\"><a href=\"#2-1-26-浏览器是怎样解析CSS选择器的？\" class=\"headerlink\" title=\"2.1.26 浏览器是怎样解析CSS选择器的？\"></a>2.1.26 浏览器是怎样解析CSS选择器的？</h3><p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>\n<p>而在CSS解析完毕后，需要将解析的结果与DOM Tree的内容一起进行分析建立一颗Render Tree，最终用来进行绘图。在建立Render Tree时（Webkit中的「Attachment」过程），浏览器就要为每个DOM Tree中的元素根据CSS的解析结果（Style Rules）来确定生成怎样的Render Tree。</p>\n<h3 id=\"2-1-27-在网页中应该使用奇数还是偶数的字体？为什么呢？\"><a href=\"#2-1-27-在网页中应该使用奇数还是偶数的字体？为什么呢？\" class=\"headerlink\" title=\"2.1.27 在网页中应该使用奇数还是偶数的字体？为什么呢？\"></a>2.1.27 在网页中应该使用奇数还是偶数的字体？为什么呢？</h3><p>使用偶数字体。偶数字号相对更容易和Web设计的其他部分构成比例关系。Windows自带的点阵宋体（中易宋体）从Vista开始只提供12、14、16px这三个大小的点阵，而13、15、17px时用的是小一号的点。（即每个字占的空间大了1px，但点阵没变），于是略显稀疏。</p>\n<h3 id=\"2-1-28-margin和padding分别适合什么场景使用？\"><a href=\"#2-1-28-margin和padding分别适合什么场景使用？\" class=\"headerlink\" title=\"2.1.28 margin和padding分别适合什么场景使用？\"></a>2.1.28 margin和padding分别适合什么场景使用？</h3><ul>\n<li>何时使用margin：<ul>\n<li>需要在border外侧添加空白</li>\n<li>空白处不需要背景色</li>\n<li>上下相连的两个盒子之间的空白，需要相互抵消时。</li>\n</ul>\n</li>\n<li>何时使用padding：<ul>\n<li>需要在border内添加空白</li>\n<li>空白处需要北京颜色</li>\n<li>上下相连的两个盒子的空白，希望为两者之和</li>\n</ul>\n</li>\n<li>兼容性的问题：在IE5和IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display:inline解决</li>\n</ul>\n<h3 id=\"2-1-29-元素竖向的百分比设定是相对于容器的高度吗？\"><a href=\"#2-1-29-元素竖向的百分比设定是相对于容器的高度吗？\" class=\"headerlink\" title=\"2.1.29 元素竖向的百分比设定是相对于容器的高度吗？\"></a>2.1.29 元素竖向的百分比设定是相对于容器的高度吗？</h3><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如padding-top，padding-bottom，margin-top，margin-bottom等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p>\n<h3 id=\"2-1-30-全屏滚动的原理是什么？用到了CSS的哪些属性？\"><a href=\"#2-1-30-全屏滚动的原理是什么？用到了CSS的哪些属性？\" class=\"headerlink\" title=\"2.1.30 全屏滚动的原理是什么？用到了CSS的哪些属性？\"></a>2.1.30 全屏滚动的原理是什么？用到了CSS的哪些属性？</h3><ol>\n<li>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现</li>\n<li>overflow:hidden;transition: all 1000ms ease;</li>\n</ol>\n<h3 id=\"2-1-31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\"><a href=\"#2-1-31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\" class=\"headerlink\" title=\"2.1.31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\"></a>2.1.31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h3><p>响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p>\n<p>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。</p>\n<p>页面头部必须有meta声明的viewport。</p>\n<pre><code class=\"html\">&lt;meta name=’viewport’ content=”width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no”&gt;\n</code></pre>\n<h3 id=\"2-1-32-视觉滚动效果？\"><a href=\"#2-1-32-视觉滚动效果？\" class=\"headerlink\" title=\"2.1.32 视觉滚动效果？\"></a>2.1.32 视觉滚动效果？</h3><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。</p>\n<ol>\n<li><p>CSS3实现</p>\n<ul>\n<li>优点：开发时间短、性能和开发效率比较好</li>\n<li>缺点：不能兼容到低版本的浏览器</li>\n</ul>\n</li>\n<li><p>jQuery实现</p>\n<p>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。</p>\n<ul>\n<li>优点：能兼容到各个版本的，效果可控性好</li>\n<li>缺点：开发起来对制作者要求高</li>\n</ul>\n</li>\n<li><p>插件实现方式</p>\n<p>例如：parallax-scrolling，兼容性十分好</p>\n</li>\n</ol>\n<h3 id=\"2-1-33-before和-after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用\"><a href=\"#2-1-33-before和-after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用\" class=\"headerlink\" title=\"2.1.33 ::before和:after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用\"></a>2.1.33 ::before和:after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用</h3><ol>\n<li>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素</li>\n<li>::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。</li>\n</ol>\n<p>:before和:after这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before和::after</p>\n<h3 id=\"2-1-34-你对line-height是如何理解的？\"><a href=\"#2-1-34-你对line-height是如何理解的？\" class=\"headerlink\" title=\"2.1.34 你对line-height是如何理解的？\"></a>2.1.34 你对line-height是如何理解的？</h3><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。</p>\n<p>单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。</p>\n<p>多行文本垂直居中：需要设置display属性为inline-block。</p>\n<h3 id=\"2-1-35-怎么让Chrome支持小于12px的文字？\"><a href=\"#2-1-35-怎么让Chrome支持小于12px的文字？\" class=\"headerlink\" title=\"2.1.35 怎么让Chrome支持小于12px的文字？\"></a>2.1.35 怎么让Chrome支持小于12px的文字？</h3><pre><code class=\"css\">p{font-size:10px;-webkit-transform:scale(0.8);} //0.8是缩放比例\n</code></pre>\n<h3 id=\"2-1-36-让页面里的字体变清晰，变细用CSS怎么做？\"><a href=\"#2-1-36-让页面里的字体变清晰，变细用CSS怎么做？\" class=\"headerlink\" title=\"2.1.36 让页面里的字体变清晰，变细用CSS怎么做？\"></a>2.1.36 让页面里的字体变清晰，变细用CSS怎么做？</h3><p>-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用<code>-webkit-font-smoothing:antialiased</code>是最佳的，灰度平滑。</p>\n<h3 id=\"2-1-37-position-fixed-在android下无效怎么处理？\"><a href=\"#2-1-37-position-fixed-在android下无效怎么处理？\" class=\"headerlink\" title=\"2.1.37 position:fixed;在android下无效怎么处理？\"></a>2.1.37 position:fixed;在android下无效怎么处理？</h3><pre><code class=\"html\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;\n</code></pre>\n<h3 id=\"2-1-38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"><a href=\"#2-1-38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？\" class=\"headerlink\" title=\"2.1.38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"></a>2.1.38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms = 16.7ms。</p>\n<h3 id=\"2-1-39-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\"><a href=\"#2-1-39-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\" class=\"headerlink\" title=\"2.1.39 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\"></a>2.1.39 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p>行框的排列会受到中间空白（回车空格）等的影响，因为空白也属于字符，这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p>\n<blockquote>\n<p>解决办法：</p>\n</blockquote>\n<ol>\n<li>可以将<code>&lt;li&gt;</code>代码全部写在一排</li>\n<li>浮动li中<code>float:left</code></li>\n<li>在<code>ul</code>中用<code>font-size:0</code>（谷歌不支持）；可以使用<code>letter-space:-3px</code></li>\n</ol>\n<h3 id=\"2-1-40-display-inline-block什么时候会显示间隙？\"><a href=\"#2-1-40-display-inline-block什么时候会显示间隙？\" class=\"headerlink\" title=\"2.1.40 display:inline-block什么时候会显示间隙？\"></a>2.1.40 display:inline-block什么时候会显示间隙？</h3><ol>\n<li><p>有空格时候会有间隙</p>\n<p>解决：移除空格</p>\n</li>\n<li><p>margin正值的时候</p>\n<p>解决：margin使用负值</p>\n</li>\n<li><p>使用font-size时候</p>\n<p>解决：font-size:0、letter-spacing、word-spacing</p>\n</li>\n</ol>\n<h3 id=\"2-1-41-有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\"><a href=\"#2-1-41-有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\" class=\"headerlink\" title=\"2.1.41 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\"></a>2.1.41 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h3><p>外层div使用<code>position:relative;</code>高度要求自适应的div使用<code>position:absolute;top:100px;bottom:0;left:0</code></p>\n<h3 id=\"2-1-42-png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？\"><a href=\"#2-1-42-png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？\" class=\"headerlink\" title=\"2.1.42 png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？\"></a>2.1.42 png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h3><ol>\n<li>png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。大多数地方都可以用。</li>\n<li>jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li>\n<li>gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。</li>\n<li>webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li>\n</ol>\n<h3 id=\"2-1-43-style标签写在body后与body前有什么区别？\"><a href=\"#2-1-43-style标签写在body后与body前有什么区别？\" class=\"headerlink\" title=\"2.1.43 style标签写在body后与body前有什么区别？\"></a>2.1.43 style标签写在body后与body前有什么区别？</h3><p>页面加载自上而下，当然是先加载样式。</p>\n<p>写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p>\n<h3 id=\"2-1-44-CSS属性overflow属性定义溢出元素内容区的内容会如何处理？\"><a href=\"#2-1-44-CSS属性overflow属性定义溢出元素内容区的内容会如何处理？\" class=\"headerlink\" title=\"2.1.44 CSS属性overflow属性定义溢出元素内容区的内容会如何处理？\"></a>2.1.44 CSS属性overflow属性定义溢出元素内容区的内容会如何处理？</h3><ul>\n<li>参数是scroll的时候，必会出现滚动条</li>\n<li>参数是auto的时候，子元素内容大于父元素时出现滚动条</li>\n<li>参数是visible的时候，溢出的内容出现在父元素之外</li>\n<li>参数是hidden的时候，溢出隐藏</li>\n</ul>\n<h3 id=\"2-1-45-阐述一下CSS-Sprites\"><a href=\"#2-1-45-阐述一下CSS-Sprites\" class=\"headerlink\" title=\"2.1.45 阐述一下CSS Sprites\"></a>2.1.45 阐述一下CSS Sprites</h3><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的<code>background-image</code>，<code>background-repeat</code>，<code>background-position</code>的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大提高页面的性能，CSS Sprites能减少页面的字节。</p>\n<h2 id=\"2-2-能不能讲一讲Flex布局，以及常用的属性？\"><a href=\"#2-2-能不能讲一讲Flex布局，以及常用的属性？\" class=\"headerlink\" title=\"2.2 能不能讲一讲Flex布局，以及常用的属性？\"></a>2.2 能不能讲一讲Flex布局，以及常用的属性？</h2><p><a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html\" target=\"_blank\" rel=\"noopener\">阮一峰的flex系列</a></p>\n<h3 id=\"2-2-1-flex布局是什么？\"><a href=\"#2-2-1-flex布局是什么？\" class=\"headerlink\" title=\"2.2.1 flex布局是什么？\"></a>2.2.1 flex布局是什么？</h3><p>Flex是Flexible Box的缩写，意为”弹性布局“，用来为盒装模型提供最大的灵活性。</p>\n<p>任何一个容器都可以指定为Flex布局。</p>\n<pre><code class=\"css\">.box {\n    display: flex;\n}\n</code></pre>\n<p>行内元素也可以使用Flex布局。</p>\n<pre><code class=\"css\">.box {\n    display: inline-flex;\n}\n</code></pre>\n<p>Webkit内核的浏览器，必须加上<code>-webkit</code>前缀。</p>\n<pre><code class=\"css\">.box {\n    display: -webkit-flex; /* Safari */\n    display: flex;\n}\n</code></pre>\n<blockquote>\n<p>注意，设为Flex布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>\n</blockquote>\n<h3 id=\"2-2-2-基本概念\"><a href=\"#2-2-2-基本概念\" class=\"headerlink\" title=\"2.2.2 基本概念\"></a>2.2.2 基本概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器“。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目“。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png\" alt></p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>\n<h3 id=\"2-2-3-容器的属性\"><a href=\"#2-2-3-容器的属性\" class=\"headerlink\" title=\"2.2.3 容器的属性\"></a>2.2.3 容器的属性</h3><p>以下6个属性设置在容器上。</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<h4 id=\"2-2-3-1-flex-direction属性\"><a href=\"#2-2-3-1-flex-direction属性\" class=\"headerlink\" title=\"2.2.3.1 flex-direction属性\"></a>2.2.3.1 flex-direction属性</h4><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>\n<pre><code class=\"css\">.box {\n    flex-direction: row | row-reverse | column | column-reverse;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png\" alt></p>\n<p>它可能有四个值。</p>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h4 id=\"2-2-3-2-flex-wrap属性\"><a href=\"#2-2-3-2-flex-wrap属性\" class=\"headerlink\" title=\"2.2.3.2 flex-wrap属性\"></a>2.2.3.2 flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称“轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png\" alt></p>\n<pre><code class=\"css\">.box {\n    flex-wrap: nowrap | wrap | wrap-reverse; \n}\n</code></pre>\n<p>它可能取三个值。</p>\n<ol>\n<li><p><code>nowrap</code>（默认）：不换行。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png\" alt></p>\n</li>\n<li><p><code>wrap</code>：换行，第一行在上方。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg\" alt></p>\n</li>\n<li><p><code>wrap-reverse</code>：换行，第一行在下方。</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg\" alt></p>\n</li>\n</ol>\n<h4 id=\"2-2-3-3-flex-flow\"><a href=\"#2-2-3-3-flex-flow\" class=\"headerlink\" title=\"2.2.3.3 flex-flow\"></a>2.2.3.3 flex-flow</h4><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>\n<pre><code class=\"css\">.box {\n    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;\n}\n</code></pre>\n<h4 id=\"2-2-3-4-justify-content属性\"><a href=\"#2-2-3-4-justify-content属性\" class=\"headerlink\" title=\"2.2.3.4 justify-content属性\"></a>2.2.3.4 justify-content属性</h4><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>\n<pre><code class=\"css\">.box {\n    justify-content: flex-start | flex-end | center | space-between\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png\" alt=\"justify-content\"></p>\n<p>它可能取五个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<ul>\n<li>flex-start(默认值)：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center：居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n<h4 id=\"2-2-3-5-align-items属性\"><a href=\"#2-2-3-5-align-items属性\" class=\"headerlink\" title=\"2.2.3.5 align-items属性\"></a>2.2.3.5 align-items属性</h4><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>\n<pre><code class=\"css\">.box {\n    align-items: flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png\" alt=\"align-items\"></p>\n<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐</li>\n<li>flex-end：交叉轴的终点对齐</li>\n<li>center：交叉轴的中点对齐</li>\n<li>baseline：项目的第一行文字的基线对齐</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li>\n</ul>\n<h4 id=\"2-2-3-6-align-content属性\"><a href=\"#2-2-3-6-align-content属性\" class=\"headerlink\" title=\"2.2.3.6 align-content属性\"></a>2.2.3.6 align-content属性</h4><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<pre><code class=\"css\">.box {\n    align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png\" alt></p>\n<p>该属性可能取6个值。</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐</li>\n<li>flex-end：与交叉轴的终点对齐</li>\n<li>center：与交叉轴的中点对齐</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>\n<li>stretch（默认值）：轴线占满整个交叉轴</li>\n</ul>\n<h3 id=\"2-2-4-项目的属性\"><a href=\"#2-2-4-项目的属性\" class=\"headerlink\" title=\"2.2.4 项目的属性\"></a>2.2.4 项目的属性</h3><p>以下6个属性设置在项目上。</p>\n<ul>\n<li>order</li>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n<li>flex</li>\n<li>align-self</li>\n</ul>\n<h4 id=\"2-2-4-1-order属性\"><a href=\"#2-2-4-1-order属性\" class=\"headerlink\" title=\"2.2.4.1 order属性\"></a>2.2.4.1 order属性</h4><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>\n<pre><code class=\"css\">.item {\n    order: &lt;integer&gt;;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png\" alt></p>\n<h4 id=\"2-2-4-2-flex-grow属性\"><a href=\"#2-2-4-2-flex-grow属性\" class=\"headerlink\" title=\"2.2.4.2 flex-grow属性\"></a>2.2.4.2 flex-grow属性</h4><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>\n<pre><code class=\"css\">.item {\n    flex-grow: &lt;number&gt;; /* default 0 */\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png\" alt></p>\n<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h4 id=\"2-2-4-3-flex-shrink属性\"><a href=\"#2-2-4-3-flex-shrink属性\" class=\"headerlink\" title=\"2.2.4.3 flex-shrink属性\"></a>2.2.4.3 flex-shrink属性</h4><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>\n<pre><code class=\"css\">.item {\n    flex-shrink: &lt;number&gt;; /* default 1 */\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg\" alt></p>\n<p>如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<p>负值对该属性无效。</p>\n<h4 id=\"2-2-4-4-flex-basis属性\"><a href=\"#2-2-4-4-flex-basis属性\" class=\"headerlink\" title=\"2.2.4.4 flex-basis属性\"></a>2.2.4.4 flex-basis属性</h4><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>\n<pre><code class=\"css\">.item {\n    flex-basis: &lt;length&gt; | auto; /* default auto */\n}\n</code></pre>\n<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>\n<h4 id=\"2-2-4-5-flex属性\"><a href=\"#2-2-4-5-flex属性\" class=\"headerlink\" title=\"2.2.4.5 flex属性\"></a>2.2.4.5 flex属性</h4><p><code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>\n<pre><code class=\"css\">.item {\n    flex: none | [&lt;&#39;flex-grow&#39;&gt;&lt;&#39;flex-shrink&#39;&gt;&lt;&#39;flex-basis&#39;&gt;]\n}\n</code></pre>\n<p>该属性有两个快捷键：<code>auto</code>（<code>1 1 auto</code>）和<code>none</code>（<code>0 0 auto</code>）。</p>\n<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h4 id=\"2-2-4-6-align-self属性\"><a href=\"#2-2-4-6-align-self属性\" class=\"headerlink\" title=\"2.2.4.6 align-self属性\"></a>2.2.4.6 align-self属性</h4><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>\n<pre><code class=\"css\">.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png\" alt></p>\n<p>该属性可能去6个值，除了auto，其他都与align-items属性完全一致。</p>\n<h1 id=\"3、JS篇\"><a href=\"#3、JS篇\" class=\"headerlink\" title=\"3、JS篇\"></a>3、JS篇</h1><h2 id=\"3-1-从原型到原型链\"><a href=\"#3-1-从原型到原型链\" class=\"headerlink\" title=\"3.1 从原型到原型链\"></a>3.1 从原型到原型链</h2><h3 id=\"3-1-2-构造函数创建对象\"><a href=\"#3-1-2-构造函数创建对象\" class=\"headerlink\" title=\"3.1.2 构造函数创建对象\"></a>3.1.2 构造函数创建对象</h3><p>我们先使用构造函数创建一个对象：</p>\n<pre><code class=\"js\">function Person() {\n\n}\nvar person = new Person();\nperson.name = &#39;Kevin&#39;;\nconsole.log(person.name) // Kevin\n</code></pre>\n<p>在这个例子中，<code>Person</code>就是一个构造函数，我们使用<code>new</code>创建了一个实例对象<code>person</code>。</p>\n<p>很简单吧，接下来进入正题：</p>\n<h3 id=\"3-1-3-prototype\"><a href=\"#3-1-3-prototype\" class=\"headerlink\" title=\"3.1.3 prototype\"></a>3.1.3 prototype</h3><p>每个函数都有一个<code>prototype</code>属性，就是我们经常在各种例子中看到的那个<code>prototype</code>，比如：</p>\n<pre><code class=\"js\">function Person() {\n}\n// 虽然写在注释里，但是你要注意：\n// prototype是函数才会有的属性\nPerson.prototype.name = &#39;Kevin&#39;;\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name) // Kevin\nconsole.log(person2.name) // Kevin\n</code></pre>\n<p>那这个函数的<code>prototype</code>属性到底指向的是什么呢？是这个函数的原型吗？</p>\n<p>其实，函数的<code>prototype</code>属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的<code>person1</code>和<code>person2</code>的原型。</p>\n<p>那什么是原型呢？你可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。</p>\n<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/prototype.png\" alt=\"prototype\">)</p>\n<p>在这张图中我们用<code>Object.prototype</code>表示实例原型。</p>\n<p>那么我们该怎么表示实例与实例原型，也就是<code>person</code>和<code>Person.prototype</code>之间的关系呢，这时候我们就要讲到第二个属性：</p>\n<h3 id=\"3-1-4-proto\"><a href=\"#3-1-4-proto\" class=\"headerlink\" title=\"3.1.4 __proto__\"></a>3.1.4 <code>__proto__</code></h3><p>这是每一个JavaScript对象（除了null）都具有的一个属性，叫<code>__proto__</code>，这个属性会指向该对象的原型。</p>\n<p>为了证明这一点，我们可以在火狐或者谷歌中输入：</p>\n<pre><code class=\"js\">function Person(){\n\n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n</code></pre>\n<p>于是我们更新下关系图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/__proto__.png\" alt=\"__proto__\"></p>\n<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>\n<h3 id=\"3-1-5-constructor\"><a href=\"#3-1-5-constructor\" class=\"headerlink\" title=\"3.1.5 constructor\"></a>3.1.5 constructor</h3><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：<code>constructor</code>，每个原型都有一个<code>constructor</code>属性指向关联的构造函数。</p>\n<p>为了验证这一点，我们可以尝试：</p>\n<pre><code class=\"js\">function Person() {\n}\nconsole.log(Person === Person.prototype.constructor); // true\n</code></pre>\n<p>所以再更新下关系图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/constructor.png\" alt=\"constructor\"></p>\n<p>综上我们已经得出：</p>\n<pre><code class=\"js\">function Person() {\n\n}\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法，可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n</code></pre>\n<p>了解了构造函数、实力原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p>\n<h3 id=\"3-1-6-实例与原型\"><a href=\"#3-1-6-实例与原型\" class=\"headerlink\" title=\"3.1.6 实例与原型\"></a>3.1.6 实例与原型</h3><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>\n<p>举个例子：</p>\n<pre><code class=\"js\">function Person() {\n}\nPerson.prototype.name = &#39;Kevin&#39;;\n\nvar person = new Person();\nperson.name = &#39;Daisy&#39;;\nconsole.log(person.name) // Daisy\n\ndelete person.name;\nconsole.log(person.name) // Kevin\n</code></pre>\n<p>在这个例子中，我们给实例对象<code>person</code>添加了<code>name</code>属性，当我们打印<code>person.name</code>的时候，结果自然为<code>Daisy</code>。</p>\n<p>但是当我们删除了<code>person</code>的<code>name</code>属性时，读取<code>person.name</code>，从<code>person</code>对象中找不到<code>name</code>属性就会从<code>person</code>的原型也就是<code>person.__ptoto__</code>，也就是<code>Person.prototype</code>中查找，幸运的是我们找到了<code>name</code>属性，结果为<code>Kevin</code>。</p>\n<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>\n<h3 id=\"3-1-7-原型的原型\"><a href=\"#3-1-7-原型的原型\" class=\"headerlink\" title=\"3.1.7 原型的原型\"></a>3.1.7 原型的原型</h3><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>\n<pre><code class=\"js\">var obj = new Object();\nobj.name = &#39;Kevin&#39;\nconsole.log(obj.name) // Kevin\n</code></pre>\n<p>其实原型对象就是通过<code>Object</code>构造函数生成的，结合之前所讲，实例的<code>__proto__</code>指向构造函数的<code>prototype</code>，所以我们再更新下关系图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/原型的原型.png\" alt=\"原型的原型\"></p>\n<h3 id=\"3-1-8-原型链\"><a href=\"#3-1-8-原型链\" class=\"headerlink\" title=\"3.1.8 原型链\"></a>3.1.8 原型链</h3><p>那 Object.prototype 的原型呢？</p>\n<p>null，我们可以打印：</p>\n<pre><code class=\"js\">console.log(Object.prototype.__proto__ === null) // true\n</code></pre>\n<p>然而<code>null</code>究竟代表了什么呢？</p>\n<p>引用阮一峰的《<a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\" target=\"_blank\" rel=\"noopener\">undefined与null的区别</a>》就是：</p>\n<blockquote>\n<p>null表示“没有对象”，即该处不应该有值。</p>\n</blockquote>\n<p>所以<code>Object.prototype.__proto__</code>的值为<code>null</code>跟<code>Object.prototype</code>没有原型，其实表达了一个意思。</p>\n<p>所以查找到属性的时候查到<code>Object.prototype</code>就可以停止查找了。</p>\n<p>最后一张关系图也可以更新为：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/prototype/原型链.png\" alt=\"原型链\"></p>\n<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>\n<blockquote>\n<p>补充</p>\n</blockquote>\n<h3 id=\"3-1-9-constructor\"><a href=\"#3-1-9-constructor\" class=\"headerlink\" title=\"3.1.9 constructor\"></a>3.1.9 constructor</h3><p>首先是<code>constructor</code>属性，我们看个例子：</p>\n<pre><code class=\"js\">function Person() {\n}\nvar person = new Person();\nconsole.log(person.constructor === Person); // true\n</code></pre>\n<p>当获取<code>person.constructor</code>时，其实<code>person</code>中并没有<code>constructor</code>属性，当不能读取到<code>constructor</code>属性时，会从<code>person</code>的原型也就是<code>Person.prototype</code>中读取，正好原型中有该属性，所以：</p>\n<pre><code class=\"js\">person.constructor === Person.prototype.constructor\n</code></pre>\n<h3 id=\"3-1-10-proto\"><a href=\"#3-1-10-proto\" class=\"headerlink\" title=\"3.1.10 __proto__\"></a>3.1.10 <code>__proto__</code></h3><p>其次是<code>__proto__</code>，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于<code>Person.prototype</code>中，实际上，它是来自于<code>Object.prototype</code>，与其说是一个属性，不如说是一个<code>getter/setter</code>，当使用<code>obj.__proto__</code>时，可以理解成返回了<code>Object.getPrototypeOf(obj)</code>。</p>\n<h3 id=\"3-1-11-真的是继承吗？\"><a href=\"#3-1-11-真的是继承吗？\" class=\"headerlink\" title=\"3.1.11 真的是继承吗？\"></a>3.1.11 真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’‘属性’”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>\n<p>继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>\n<h2 id=\"3-2-JavaScript深入之词法作用域和动态作用域\"><a href=\"#3-2-JavaScript深入之词法作用域和动态作用域\" class=\"headerlink\" title=\"3.2 JavaScript深入之词法作用域和动态作用域\"></a>3.2 JavaScript深入之词法作用域和动态作用域</h2><h3 id=\"3-2-1-作用域\"><a href=\"#3-2-1-作用域\" class=\"headerlink\" title=\"3.2.1 作用域\"></a>3.2.1 作用域</h3><p>作用域是指程序源代码中定义变量的区域。</p>\n<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>\n<p>JavaScript采用词法作用域（lexical scoping），也就是静态作用域。</p>\n<h3 id=\"3-2-2-静态作用域与动态作用域\"><a href=\"#3-2-2-静态作用域与动态作用域\" class=\"headerlink\" title=\"3.2.2 静态作用域与动态作用域\"></a>3.2.2 静态作用域与动态作用域</h3><p>因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>\n<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p>\n<p>让我们认真看个例子就能明白之间的区别：</p>\n<pre><code class=\"js\">var vaule = 1;\nfunction foo() {\n    console.log(value);\n}\nfunction bar() {\n    var value = 2;\n    foo();\n}\nbar();\n\n// 结果是？？？\n</code></pre>\n<p>假设JavaScript采用静态作用域，让我们分析下执行过程：</p>\n<p>执行<code>foo</code>函数，先从<code>foo</code>函数内部查找是否有局部变量<code>value</code>，如果没有，就根据书写的位置，查找上面一层的代码，也就是<code>value</code>等于1，所以结果会打印1。</p>\n<p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p>\n<p>执行<code>foo</code>函数，依然是从<code>foo</code>函数内部查找是否有局部变量<code>value</code>。如果没有，就从调用函数的作用域，也就是<code>bar</code>函数内部查找<code>value</code>变量，所以结果会打印2。</p>\n<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是1。</p>\n<h3 id=\"3-2-3-动态作用域\"><a href=\"#3-2-3-动态作用域\" class=\"headerlink\" title=\"3.2.3 动态作用域\"></a>3.2.3 动态作用域</h3><p>也许你会好奇什么语言是动态作用域？</p>\n<p><code>bash</code>就是动态作用域，不信的话，把下面的脚本存成例如<code>scope.bash</code>，然后进行相应的目录，用命令行执行<code>bash ./scope.bash</code>，看看打印的值是多少。</p>\n<pre><code class=\"js\">value = 1\nfunction foo() {\n    echo $value;\n}\nfunction bar() {\n    local value = 2;\n    foo;\n}\nbar\n</code></pre>\n<h3 id=\"3-2-4-思考题\"><a href=\"#3-2-4-思考题\" class=\"headerlink\" title=\"3.2.4 思考题\"></a>3.2.4 思考题</h3><p>最后，让我们看一个《JavaScript权威指南》中的例子：</p>\n<pre><code class=\"js\">var scope = &#39;global scope&#39;;\nfunction checkscope() {\n    var scope = &#39;local scope&#39;;\n    function f() {\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n</code></pre>\n<pre><code class=\"js\">var scope = &#39;global scope&#39;;\nfunction checkscope() {\n    var scope = &#39;local scope&#39;;\n    function f() {\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n</code></pre>\n<p>两段代码都会打印：<code>local scope</code>。</p>\n<p>原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。</p>\n<p>而引用《JavaScript权威指南》的回答就是：</p>\n<p>JavaScript函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数<code>f()</code>定义在这个作用域链里，其中的变量scope一定是局部变量，不管何时何地执行<code>f()</code>，这种绑定在执行<code>f()</code>时依然有效。</p>\n<p>但是在这里真正想让大家思考的是：</p>\n<p>虽然两端代码执行的结果一样，但是两段代码究竟有哪些不同呢？</p>\n<p>如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下文。</p>\n<h2 id=\"3-3-JavaScript深入之执行上下文栈\"><a href=\"#3-3-JavaScript深入之执行上下文栈\" class=\"headerlink\" title=\"3.3 JavaScript深入之执行上下文栈\"></a>3.3 JavaScript深入之执行上下文栈</h2><h3 id=\"3-3-1-顺序执行？\"><a href=\"#3-3-1-顺序执行？\" class=\"headerlink\" title=\"3.3.1 顺序执行？\"></a>3.3.1 顺序执行？</h3><p>如果要问到JavaScript代码执行顺序的话，想必写过JavaScript的开发者都会有个直观的印象，那就是顺序执行，毕竟：</p>\n<pre><code class=\"js\">var foo = function() {\n    console.log(&#39;foo1&#39;);\n}\nfoo(); // foo1\n\nvar foo = function() {\n    console.log(&#39;foo2&#39;);\n}\nfoo(); // foo2\n</code></pre>\n<p>然而去看这段代码：</p>\n<pre><code class=\"js\">function foo() {\n    console.log(&#39;foo1&#39;);\n}\nfoo(); // foo2\nfunction foo() {\n    console.log(&#39;foo2&#39;);\n}\nfoo(); // foo2\n</code></pre>\n<p>打印的结果却是两个<code>foo2</code>。</p>\n<p>刷过面试题的都知道这是因为JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。</p>\n<p>但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？</p>\n<p>到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？</p>\n<h3 id=\"3-3-2-可执行代码\"><a href=\"#3-3-2-可执行代码\" class=\"headerlink\" title=\"3.3.2 可执行代码\"></a>3.3.2 可执行代码</h3>"},{"title":"vue面试题总结","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-08-17T08:27:17.475Z","comments":1,"keywords":"vue","description":"vue","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg"],"_content":"\n\n[原文](https://juejin.cn/post/6850037277675454478#comment)\n\n## 1. vue框架篇\n\n### 1.1 vue的优点\n\n* 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；\n* 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；\n* 双向数据绑定：保留了angular的特点，在数据操作方面更为简单；\n* 组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；\n* 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；\n* 虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；\n* 运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。\n\n\n### 1.2 请详细说下你对vue生命周期的理解？\n\n总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。\n\n>`创建前/后` \n>1. 在``beforeCreate``阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。\n>2. 在``created``阶段，vue实例的数据对象data有了，el为undefined，还未初始化。\n\n\n>`载入前/后`：\n>1. 在``beforeMount``阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。\n>2. 在``mounted``阶段，vue实例挂载完成，data.message成功渲染。\n\n\n>`更新前/后`：当data变化时，会触发``beforeUpdate``和``updated``方法\n\n\n>`销毁前/后`：在执行``destroy``方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在\n\n### 1.3 为什么vue组件中data必须是一个函数？\n* 对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；\n* 而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。\n\n### 1.4 vue中v-if和v-show有什么区别？\nv-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:\n1. 手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；\n2. 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n3. 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；\n4. 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n\n>用法推荐：\n1. v-if更适合带有权限的操作，渲染时判断权限数据，有则展示该功能，没有则删除。\n2. v-show更适合于日常使用，可以减少数据的渲染，减少不必要的操作。\n综上，v-if有更高的切换消耗，而v-show有更高的初始渲染消耗。\n因此，如果需要频繁切换v-show较好，如果在运行时条件不大可能改变，更倾向功能权限性的话v-if较好。\n\n### 1.5 computed和watch的区别\n#### 1.5.1 计算属性computed：\n\n* 支持缓存，只有依赖数据发生改变，才会重新进行计算\n* 不支持异步，当computed内有异步操作时无效，无法监听数据的变化\n* computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值\n* 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed\n* 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。\n\n#### 1.5.2 侦听属性watch：\n\n* 不支持缓存，数据变，直接会触发相应的操作；\n* watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；\n* 当一个属性发生变化时，需要执行对应的操作；一对多；\n* 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：\n\n> 1. immediate：组件加载立即触发回调函数执行\n\n```javascript\nwatch: {\n  firstName: {\n    handler(newName, oldName) {\n      this.fullName = newName + ' ' + this.lastName;\n    },\n    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法\n    immediate: true\n  }\n}\n```\n\n\n>2. deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler\n```javascript\nwatch: {\n  obj: {\n    handler(newName, oldName) {\n      console.log('obj.a changed');\n    },\n    immediate: true,\n    deep: true\n  }\n}\n```\n\n> 优化：我们可以使用字符串的形式监听\n```javascript\nwatch: {\n  'obj.a': {\n    handler(newName, oldName) {\n      console.log('obj.a changed');\n    },\n    immediate: true,\n    // deep: true\n  }\n}\n```\n\n这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。\n\n### 1.6 vue-loader是什么？使用它的用途有哪些？\nvue文件的一个加载器，跟template/js/style转换成js模块。\n\n### 1.7 $nextTick是什么？\nvue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。\n\n>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM\n\n### 1.8 v-for key的作用\n* 当Vue用 ``v-for`` 正在更新已渲染过的元素列表时，它默认用``就地复用``策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。\n* 为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。\n* key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。\n\n### 1.9 简述MVVM\n* ``MVVM``是 ``Model-View-ViewModel`` 的缩写。``MVVM`` 是一种设计思想。 \n  > ``Model层`` 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑\n  > ``View层`` 代表UI组件，它负责将数据模型转化成UI展现出来\n  > ``ViewModel`` 是一个同步 View 和 Model 的对象。\n\n* 在 ``MVVM`` 架构下， ``View ``和 ``Model`` 之间并没有直接的联系，而是通过``ViewModel``进行交互，``Model``和``ViewModel``之间的交互是双向的，因此``View``数据的变化会同步到``Model``中，而``Model``数据的变化也会立即反映到``View``上。\n\n* ``ViewModel``通过双向数据绑定把``View层``和``Model``层连接了起来，而``View``和``Model``之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作``DOM``，不需要关注数据状态的同步问题，复杂的数据状态维护完全由``MVVM``来统一管理。\n\n![MVVM](https://upload-images.jianshu.io/upload_images/13038962-96704c499078e5b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp)\n\n\n### 1.10 Vue的双向数据绑定原理是什么？\nvue.js 是采用数据劫持结合``发布者-订阅者模式``的方式，通过``Object.defineProperty()``来劫持各个属性的``setter``，``getter``，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\n\n1. 需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n\n\n2. compiler解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n\n\n3. Watcher订阅者是Observer和Compiler之间通信的桥梁，主要做的事情是:\n    * 在自身实例化时往属性订阅器(dep)里面添加自己\n    * 自身必须有一个update()方法\n    * 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\n\n\n4. MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n\n[vue双向绑定原理](https://www.jianshu.com/p/bb5d1bede3ea)\n![图](https://upload-images.jianshu.io/upload_images/7120480-7d53305530ed75a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)\n\n\n\n### 1.11 组件传值\n#### 1.11.1 父传子\n通过props传递\n>父组件： ``<child value = '传递的数据' />``\n>\n>子组件: ``props['value']``,接收数据,接受之后使用和data中定义数据使用方式一样\n\n#### 1.11.2 子传父\n在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。\n>父组件： ``<child @receive = 'receive' />``\n>\n>子组件: this.$emit('receive','传递的数据')\n\n#### 1.11.3 兄弟组件传值\n\n* 通过中央通信 let bus = new Vue()\n\n>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送\n\n\n>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收\n\n\n* 通过vuex\n\n### 1.12 prop 验证，和默认值\n我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告\n```javascript\nprops: {\n    visible: {\n        default: true,\n        type: Boolean,\n        required: true\n    },\n}\n```\n\n### 1.13 请说下封装 vue 组件的过程\n* 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。\n* 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>vue组件</title>\n    <script src=\"vue.js\"></script>\n</head>\n<body>\n    <div id=\"app1\">\n        <my-com></my-com>\n    </div>\n    <div id=\"app2\">\n        <my-com></my-com>\n    </div>\n \n    <script>\n        /*创建组件*/\n        var myCom = Vue.extend({\n            template: '<div>这是我的组件</div>'\n        });\n        /*全局注册组件*/\n        Vue.component('my-com',myCom);\n \n        /*定义vue实例app1*/\n        var app1 = new Vue({\n            el: '#app1'\n        });\n \n        /*定义vue实例app2*/\n        var app2 = new Vue({\n            el: '#app2'\n        });\n    </script>\n</body>\n</html>\n```\n\n### 1.14 Vue.js的template编译\n简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：\n\n>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。\n\n\n>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）\n\n### 1.15 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？\ncss的预编译,使用步骤如下：\n* 第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）\n* 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss\n* 第三步：还是在同一个文件，配置一个module属性\n* 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”\n\n特性主要有:\n\n* 可以用变量，例如（$变量名称=值）\n* 可以用混合器，例如（）\n* 可以嵌套\n\n### 1.16 vue如何监听对象或者数组某个属性的变化\n当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。\n解决方式：\n\n* this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)\n```javascript\nthis.$set(this.arr, 0, \"OBKoro1\"); // 改变数组\nthis.$set(this.obj, \"c\", \"OBKoro1\"); // 改变对象\n```\n\n* 调用以下几个数组的方法\n```javascript\nsplice()、 push()、pop()、shift()、unshift()、sort()、reverse()\n```\n\nvue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作\n\n### 1.17 常用的事件修饰符\n\n* .stop:阻止冒泡\n* .prevent:阻止默认行为.\n* .self:仅绑定元素自身触发\n* .once: 2.1.4 新增,只触发一次\n* .passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用\n* .sync 修饰符\n\n从 2.3.0 起vue重新引入了.sync修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下：\n```\n<comp :foo.sync=\"bar\"></comp>\n```\n会被扩展为：\n```\n<comp :foo=\"bar\" @update:foo=\"val => bar = val\"></comp>\n```\n当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\n```\nthis.$emit('update:foo', newValue)\n```\n\n[vue中.sync修饰符](https://blog.csdn.net/liushijun_/article/details/92426854)\n\n### 1.18 vue如何获取dom\n先给标签设置一个ref值，再通过this.$refs.domName获取，例如：\n```\n<div ref=\"test\"></div>\n\nconst dom = this.$refs.test\n```\n\n### 1.19 v-on可以监听多个方法吗？\n是可以的，来个例子：\n```\n<input type=\"text\" v-on=\"{ input:onInput,focus:onFocus,blur:onBlur, }\">\n```\n\n### 1.20 assets和static的区别\n这两个都是用来存放项目中所使用的静态资源文件。\n\n两者的区别：\n\n* ``assets``中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。\n\n* ``static``中的文件则不会被打包。\n\n>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。\n\n### 1.21slot插槽\n很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。\n\n> 以下为详细扩展\n#### 1.21.1 插槽是什么\n* 写个父组件：test.vue\n\n```vue\n<template>\n  <div>\n    <div>大家好我是父组件</div>\n    <myslot>\n      <p>测试一下吧内容写在这里了能否显示</p>\n    </myslot>\n  </div>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n\n<style>\n</style>\n```\n\n* 写个子组件：myslot.vue\n\n```vue\n<template>\n  <div>\n    <div>我是子组件</div>\n  </div>\n</template>\n\n<script>\n</script>\n\n<style>\n</style>\n```\n\n运行代码，发现，最终渲染的效果是\n>大家好我是父组件\n>\n>我是子组件\n\n那如果我想实现显示父组件中p标签的内容怎么办 修改子组件：myslot.vue\n\n```vue\n<template>\n  <div>\n      <div>我是子组件</div>\n      <p>现在测试一下slot</p>\n      <slot></slot>\n  </div>\n</template>\n\n<script>\n</script>\n\n<style>\n</style>\n```\n\n运行代码，可以看到以下效果\n>大家好我是父组件<br>我是子组件<br>现在测试一下slot<br>测试一下吧内容写在这里了能否显示\n\n官方文档对于插槽的应用场景是这样描述的: 我们经常需要向一个组件传递内容 Vue 自定义的 ``<slot>`` 元素让这变得非常简单 只要在需要的地方加入插槽就行了——就这么简单！ \n结合上面的例子来理解就是这样的： \n1. 父组件在引用子组件时希望向子组件传递模板内容``<p>``测试一下吧内容写在这里了能否显示``</p>`` \n2. 子组件让父组件传过来的模板内容在所在的位置显示 \n3. 子组件中的``<slot>``就是一个槽，可以接收父组件传过来的模板内容，``<slot>`` 元素自身将被替换 \n4. ``<myslot></myslot>``组件没有包含一个 ``<slot>`` 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃\n\n#### 1.21.2 插槽的作用\n让用户可以拓展组件，去更好地复用组件和对其做定制化处理\n\n#### 1.21.3 插槽的分类\n##### 1.21.3.1 默认插槽\n在一个 ``<submit-button>`` 组件中：\n```\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n* 我们可能希望这个 ``<button>`` 内绝大多数情况下都渲染文本“Submit”，但是有时候却希望渲染文本为别的东西，那怎么实现呢？ 我们可以将“Submit”作为后备内容，我们可以将它放在 ``<slot>`` 标签内：\n```\n<button type=\"submit\">\n  <slot>Submit</slot>\n</button>\n```\n\n现在当我在一个父级组件中使用 ``<submit-button>`` 并且不提供任何插槽内容时：\n```\n<submit-button></submit-button>\n```\n后备内容“Submit”将会被渲染：\n```\n<button type=\"submit\">\n  Submit\n</button>\n```\n\n* 但是如果我们提供内容：\n\n```\n<submit-button>\n  Save\n</submit-button>\n```\n\n则这个提供的内容将会被渲染从而取代后备内容：\n```\n<button type=\"submit\">\n  Save\n</button>\n```\n\n##### 1.21.3.2 具名插槽\n有时我们写了一个子组件，我们希望\n```\n<template>\n  <div class=\"container\">\n    <header>\n      <!-- 我们希望把页头放这里 -->\n    </header>\n    <main>\n      <!-- 我们希望把主要内容放这里 -->\n    </main>\n    <footer>\n      <!-- 我们希望把页脚放这里 -->\n    </footer>\n  </div>\n</template>\n```\n\n对于这样的情况，``<slot>`` 元素有一个特殊的 attribute：name。这个 attribute 可以用来定义额外的插槽：\n```\n<template>\n  <div class=\"container\">\n    <header>\n      <slot name=\"header\"></slot>\n    </header>\n    <main>\n      <slot></slot>\n    </main>\n    <footer>\n      <slot name=\"footer\"></slot>\n    </footer>\n  </div>\n</template>\n```\n\n一个不带 name 的 ``<slot>`` 出口会带有隐含的名字“default”。 父组件在向具名插槽提供内容的时候，我们可以在一个 ``<template>`` 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：\n```vue\n<template>\n  <myslot>\n    <div>大家好我是父组件</div>\n    <template v-slot:header>\n      <h1>Here might be a page title</h1>\n    </template>\n\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n\n    <template v-slot:footer>\n      <p>Here's footer info</p>\n    </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n最终的渲染结果可以看到\n```\nHere might be a page title\n大家好我是父组件\nA paragraph for the main content.\n\nAnd another one.\n\nHere's footer info\n```\n\n父组件中会向子组件中具名传递对应的模板内容，而没有指定名字的模板内容会传递给子组件中不带 name 的 ``<slot>`` 当然，如果父组件中\n```\n<template v-slot:default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n</template>\n```\n\n* 同样是传递给子组件中不带 name 的 ``<slot>`` 注意: v-slot 只能添加在 ``<template>`` 上 具名插槽在书写的时候可以使用缩写,v-slot用``#``来代替\n\n```vue\n<template>\n  <myslot>\n    <div>大家好我是父组件</div>\n    <template #header>\n      <h1>Here might be a page title</h1>\n    </template>\n\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n\n    <template #footer>\n      <p>Here's footer info</p>\n    </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n\n<style>\n</style>\n```\n\n##### 1.21.3.3 作用域插槽\n这里主要解决的是父组件在向子组件插槽传递模板内容时存在访问子组件数据的问题 还记得默认插槽吗？如果子组件中写在 ``<slot>`` 标签内后备内容是与 该组件的data属性双向数据绑定的\n```vue\n<template>\n  <div>\n    <span>\n      <slot>{{user.firstName}}</slot>\n    </span>\n  </div>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        user:{\n          firstName:'gerace',\n          lastName:'haLi'\n        }\n      }\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n父组件在引用子组件时，希望能够换掉备用内容\n```vue\n<template>\n  <myslot>{{ user.firstName }}</myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n运行代码这时你会发现提示报错\n```\nProperty or method \"user\" is not defined on the instance but referenced during render.\nTypeError: Cannot read property 'firstName' of undefined\n```\n\n这里为什么？vue官方文档给出了答案 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的 那应该怎么解决这个问题？ 为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 ``<slot>`` 元素的一个 attribute 绑定上去：\n```\n<span>\n  <slot v-bind:user=\"user\">\n    {{ user.lastName }}\n  </slot>\n</span>\n```\n\n绑定在 ``<slot>`` 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：\n```vue\n<template>\n  <myslot>\n      <template v-slot:default=\"slotProps\">\n      {{ slotProps.user.firstName }}\n      </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n</script>\n<style>\n</style>\n```\n\n上面例子，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字。 针对上面只给默认插槽传递模板内容的例子，在写法上可以采用默认插槽的缩写语法\n```vue\n<template>\n  <myslot v-slot:default=\"slotProps\">\n     {{ slotProps.user.firstName }}\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n</script>\n<style>\n</style>\n\n↓↓↓\n<template>\n  <myslot v-slot=\"slotProps\">\n     {{ slotProps.user.firstName }}\n  </myslot>\n</template>\n\n```\n\n>注意： 默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：\n```\n<template>\n  <myslot v-slot=\"slotProps\">\n     {{ slotProps.user.firstName }}\n     <template v-slot:other=\"otherSlotProps\">\n   \t\tslotProps is NOT available here\n     </template>\n  </myslot>\n</template>\n```\n\n* 下面再看一下多个插槽的情况 子组件\n\n```vue\n<template>\n  <div>\n    <span>\n      <slot v-bind:userData=\"user\" name=\"header\">\n        {{ user.msg }}\n      </slot>\n      <slot v-bind:hobbyData=\"hobby\" name=\"footer\">\n        {{ hobby.fruit }}\n      </slot>\n    </span>\n  </div>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        user:{\n          firstName: 'gerace',\n          lastName: 'haLi',\n        },\n        hobby:{\n          fruit: \"apple\",\n          color: \"blue\"\n        }\n      }\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n父组件\n```vue\n<template>\n  <myslot>\n      <template v-slot:header=\"slotProps\">\n        {{ slotProps.userData.firstName }}\n      </template>\n      <template v-slot:footer=\"slotProps\">\n        {{ slotProps.hobbyData.fruit }}\n      </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n</script>\n<style>\n</style>\n```\n\n针对多个插槽的情况，在写法上可以解构插槽prop，父组件的写法如下\n```\n<template>\n  <myslot>\n      <template v-slot:header=\"{userData}\">\n        {{ userData.firstName }}\n      </template>\n      <template v-slot:footer=\"{hobbyData}\">\n        {{ hobbyData.fruit }}\n      </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n在具名插槽的介绍部分有讲过，具名插槽可以使用缩写，v-slot可以使用#来代替，所以以上代码可以写成：\n\n```vue\n<template>\n  <myslot>\n      <template #header=\"{userData}\">\n        {{ userData.firstName }}\n      </template>\n      <template #footer=\"{hobbyData}\">\n        {{ hobbyData.fruit }}\n      </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n但是需要注意的是该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：\n```\n<!-- 这样会触发警告 -->\n<template>\n  <myslot>\n      <template #=\"{userData}\">\n        {{ userData.firstName }}\n      </template>\n      <template #=\"{hobbyData}\">\n        {{ hobbyData.fruit }}\n      </template>\n  </myslot>\n</template>\n```\n\n### 1.22 vue初始化页面闪动问题\n使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。\n首先：在css里加上以下代码\n```\n[v-cloak] {\n    display: none;\n}\n```\n\n如果没有彻底解决问题，则在根元素加上``style=\"display: none;\" :style=\"{display: 'block'}\"``\n\n\n## 2. vue插件篇\n### 2.1 状态管理（vuex）\n\n#### 2.1.1 vuex是什么\nVuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\n\n#### 2.1.2 怎么使用vuex\n\n1. 第一步安装\n```javascript\nnpm install vuex -S\n```\n2. 第二步创建store\n```javascript\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\n//不是在生产环境debug为true\nconst debug = process.env.NODE_ENV !== 'production';\n//创建Vuex实例对象\nconst store = new Vuex.Store({\n  strict:debug,//在不是生产环境下都开启严格模式\n  state:{\n  },\n  getters:{\n  },\n  mutations:{\n  },\n  actions:{\n  }\n})\nexport default store;\n```\n3. 第三步注入vuex\n```javascript\nimport Vue from 'vue';\nimport App from './App.vue';\nimport store from './store';\nconst vm = new Vue({\n    store:store,\n    render: h => h(App)\n}).$mount('#app')\n```\n\n#### 2.1.3 vuex中有几个核心属性，分别是什么？\n一共有5个核心属性，分别是:\n\n1. ``state`` 唯一数据源,Vue 实例中的 data 遵循相同的规则\n\n2. ``getters`` 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.\n\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n\n```\n\n3. `mutation` 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发\n\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n\nstore.commit('increment')\n```\n\n4. `action` Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作\n\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n```\n\n5. ``module``  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。\n\n```javascript\nconst moduleA = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n#### 2.1.4 ajax请求代码应该写在组件的methods中还是vuex的actions中\n如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。\n\n如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。\n\n#### 2.1.5 从vuex中获取的数据能直接更改吗？\n从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错；\n\n#### 2.1.6 vuex中的数据在页面刷新后数据消失\n用sessionstorage 或者 localstorage 存储数据\n```\n存储： sessionStorage.setItem( '名', JSON.stringify(值) )\n使用： sessionStorage.getItem('名') ---得到的值为字符串类型，用JSON.parse()去引号；\n```\n\n> 也可以引入插件vuex-persist，使用方法如下：\n\n* 安装\n```javascript\nnpm install --save vuex-persist\nor\nyarn add vuex-persist\n```\n\n* 引入\n```javascript\nimport VuexPersistence from 'vuex-persist'\n```\n\n* 先创建一个对象并进行配置\n```javascript\nconst vuexLocal = new VuexPersistence({\n    storage: window.localStorage\n})\n```\n\n* 引入进vuex插件\n```javascript\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  plugins: [vuexLocal.plugin]\n}) \n```\n通过以上设置，在图3中各个页面之间跳转，如果刷新某个视图，数据并不会丢失，依然存在，并且不需要在每个 mutations 中手动存取 storage 。\n\n#### 2.1.7 Vuex的严格模式是什么,有什么作用,怎么开启？\n在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n在Vuex.Store 构造器选项中开启,如下\n```javascript\nconst store = new Vuex.Store({\n    strict:true,\n})\n```\n\n#### 2.1.8 怎么在组件中批量使用Vuex的getter属性\n使用``mapGetters``辅助函数, 利用对象展开运算符将getter混入computed 对象中\n```\nimport {mapGetters} from 'vuex'\nexport default{\n    computed:{\n        ...mapGetters(['total','discountTotal'])\n    }\n}\n```\n\n#### 2.1.9 组件中重复使用mutation\n使用``mapMutations``辅助函数,在组件中这么使用\n```vue\nimport { mapMutations } from 'vuex'\nmethods:{\n    ...mapMutations({\n        setNumber:'SET_NUMBER',\n    })\n}\n```\n\n然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)\n\n#### 2.1.10 mutation和action有什么区别\n\n* action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态\n* action 可以包含任意异步操作。mutation只能是同步操作\n* 提交方式不同\n\n>action 是用this.store.dispatch('ACTION_NAME',data)来提交。\n>\n>mutation是用this.$store.commit('SET_NUMBER',10)来提交\n\n* 接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了\n```\n{\n    state,      // 等同于 `store.state`，若在模块中则为局部状态\n    rootState,  // 等同于 `store.state`，只存在于模块中\n    commit,     // 等同于 `store.commit`\n    dispatch,   // 等同于 `store.dispatch`\n    getters,    // 等同于 `store.getters`\n    rootGetters // 等同于 `store.getters`，只存在于模块中\n}\n```\n\n#### 2.1.11 在v-model上怎么用Vuex中state的值？\n需要通过computed计算属性来转换。\n```\n<input v-model=\"message\">\n// ...\ncomputed: {\n  message: {\n    get () {\n        return this.$store.state.message\n    },\n    set (value) {\n        this.$store.commit('updateMessage', value)\n    }\n  }\n}\n```\n\n### 2.2 路由页面管理（vue-router）\n#### 2.2.1 什么是vue-router\nVue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：\n\n* 嵌套的路由/视图表\n* 模块化的、基于组件的路由配置\n* 路由参数、查询、通配符\n* 基于 Vue.js 过渡系统的视图过渡效果\n* 细粒度的导航控制\n* 带有自动激活的 CSS class 的链接\n* HTML5 历史模式或 hash 模式，在 IE9 中自动降级\n* 自定义的滚动条行为\n\n#### 2.2.2 怎么使用vue-router\n1. 第一步安装\n```\nnpm install vue-router -S\n```\n2. 第二步在main.js中使用Vue Router组件\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nimport VueRouter from 'vue-router'\nVue.use(VueRouter)\n\nnew Vue({\n  el: '#app',\n  render: h=> h(App)\n})\n```\n\n3. 第三步配置路由\n\n* 定义 (路由) 组件\n路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。如下\n```javascript\n// 1.定义组件（导入组件）\nimport Home from './components/home.vue'\nimport News from '.components/news.vue'\n```\n\n* 定义路由（路由对象数组）\n定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。如下：\n```javascript\n// 2.定义路由\nconst routes = [\n  { path: '/home', components: Home },\n  { path: '/news', components: News },\n  { path: '*', redirect: '/home' }, // 表示没有匹配到，是默认重定向到home组件\n]\n```\n\n\n* 实例化Vue Router对象\n调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。如下\n```javascript\n// 3. 实例化Vue Router\nconst router = new VueRouter({routes}) // 此处相当于routes: routes\n```\n\n\n* 挂载根实例\n```javascript\n// 4. 挂载根实例\nnew Vue({\n  el: '#app',\n  router,\n  render: h => h(App)\n})\n```\n\n第四步在App.vue中使用路由\n在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。如下：\n```vue\n<template>\n  <div id=\"app\">\n    <router-link to=\"/home\">Home</router-link>\n    <router-link to=\"/news\">News</router-link>\n    <br />\n    <router-view></router-view> /* 显示组件的内容 */\n  </div>\n</template>\n```\n\n#### 2.2.3 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\n在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数\n\n#### 2.2.4 vue-router的导航钩子\n常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：\n\n* 全局导航钩子：router.beforeEach(to,from,next)\n* 组件内的钩子\n* 单独路由独享组件\n\n#### 2.2.5 vue路由传参\n\n* 页面刷新数据不会丢失\n\n```javascript\nmethods: {\n  jump(id) {\n    // 直接调用$router.push实现携带参数的跳转\n    this.$router.push({\n      path: `/particulars/${id}`\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: '/particulars/:id',\n  name: 'particulars',\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.params.id\n```\n\n* 使用params方式传入的参数\n> 这种方法页面刷新数据会丢失\n>\n>通过路由属性中的name来确定匹配的路由，通过params来传递参数\n```javascript\nmethods: {\n  jump(id) {\n    this.$router.push({\n      path: '/particulars',\n      params: {\n        id: id\n      }\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: '/particulars',\n  name: 'particulars',\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.params.id\n```\n\n* 使用query方法传入的参数\n> 使用path来匹配路由，然后通过query来传递参数\n>\n> 这种情况下，query传递的参数会显示在url后面?id=?\n```javascript\nmethods: {\n  jump(id) {\n    this.$router.push({\n      path: '/particulars',\n      query: {\n        id: id\n      }\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: '/particulars',\n  name: 'particulars',\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.query.id\n```\n\n#### 2.2.6 router和route的区别\n\n* ``route``为当前router跳转对象里面可以获取name、path、query、params等\n\n* ``router``为VueRouter实例，想要导航到不同URL，则使用router.push方法\n\n#### 2.2.7 路由 TypeError: Cannot read property 'matched' of undefined 的错误问题\n找到入口文件main.js里的new Vue()，必须使用router名，不能把router改成Router或者其他的别名\n```javascript\n// 引入路由\nimport router from './routers/router.js'\n\nnew Vue({\n    el: '#app',\n    router,    // 这个名字必须使用router\n    render: h => h(App)\n});\n```\n\n#### 2.2.8 路由按需加载\n随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候，路由按需加载就闪亮登场了。\n```javascript\n// webpack< 2.4 时\n{ \n    path:'/', \n    name:'home',\n    components:resolve=>require(['@/components/home'],resolve)\n} \n\n// webpack> 2.4 时\n{ \n    path:'/', \n    name:'home', \n    components:()=>import('@/components/home')\n}\n```\n\nimport()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。\n\n#### 2.2.9 Vue里面router-link在电脑上有用，在安卓上没反应怎么解决\nVue路由在Android机上有问题，babel问题，安装``babel polypill``插件解决\n\n#### 2.2.10 Vue2中注册在router-link上事件无效解决方法\n* 使用``@click.native``。\n* 原因：router-link会阻止click事件，.native指直接监听一个原生事件\n\n\n#### 2.2.11 RouterLink在IE和Firefox中不起作用（路由不跳转）的问题\n\n* 只用a标签，不使用button标签\n* 使用button标签和Router.navigate方法\n\n### 2.3 网络请求(axios)\naxios的二次封装，主要包括请求之前、返回响应以及使用等\n#### 2.3.1 请求之前\n一般的接口都会有鉴权认证（token）之类的，因此在接口的请求头里面，我们需要带上token值以通过服务器的鉴权认证。但是如果每次请求的时候再去添加，不仅会大大的加大工作量，而且很容易出错。好在axios提供了拦截器机制，我们在请求的拦截器中可以添加token。\n```javascript\n// 请求拦截\naxios.interceptors.request.use((config) => {\n  // ...省略代码\n  config.headers.x_access_token = token\n  return config\n}, function (error) => {\n  return Promise.reject(error)\n})\n```\n当然请求拦截器中，除了处理添加token以外，还可以进行一些其他的处理，具体的根据实际需求进行处理。\n\n#### 2.3.2 响应之后\n请求接口，并不是每一次请求都会成功。那么当接口请求失败的时候，我们又怎么处理呢？每次请求的时候处理？封装axios统一处理？应该选择封装axios进行统一处理。axios不仅提供了请求的拦截器，其也提供了响应的拦截器。在此处，可以获取到服务器返回的状态码，然后根据状态码进行相对应的操作。\n```javascript\n// 响应拦截\naxios.interceptors.response.use(function (response) {\n  if (response.data.code === 401) {\n    // 用户token失效\n    // 清空用户信息\n    sessionStorage.user = ''\n    sessionStorage.token = ''\n    window.location.href = '/' // 返回登录页\n    return Promise.reject(msg) // 接口Promise返回错误状态，错误信息msg可由后端返回，也可以我们自己定义一个码--信息的关系。\n  }\n  if (response.status !== 200 || response.data.code !== 200) {\n    // 接口请求失败，具体根据实际情况判断\n    message.error(mes) // 提示错误信息\n    return Promise.reject(msg) // 接口Promise返回错误状态\n  }\n  return response\n}, function (error) {\n  if (axios.isCancel(error)) {\n    requestList.length = 0\n    // store.dispatch('changeGlobalState', { loading: false })\n    throw new axios.Cancel('cancel request')\n  } else {\n    message.error('网络请求失败，请重试')\n  }\n  return Promise.reject(error)\n})\n\n```\n当然响应拦截器同请求拦截器一样，还可以进行一些其他的处理，具体的根据实际需求进行处理。\n\n#### 2.3.3 使用axios\naxios使用的时候一般有三种方式：\n* 执行get请求\n```javascript\naxios.get('url', {\n  params: {} // 接口参数\n}).then(function(res){\n  console.log(res) // 处理成功的函数，相当于success\n}).catch(function(error) {\n  console.log(error) // 错误处理，相当于error\n})\n```\n\n* 执行post请求\n```javascript\naxios.post('url', \n  {\n    data: xxx // 参数\n  },\n  {\n    headers: xxx //请求头信息\n}).then(function(res) {\n  console.log(res) // 处理成功的函数，相当于success\n}).catch(function(error) {\n  console.log(error) // 错误处理，相当于error\n})\n```\n\n* axios API通过相关配置传递给axios完成请求\n```javascript\naxios({\n  method: 'delete',\n  url: 'xxx',\n  cache: false,\n  params: { id: 123 },\n  headers: xxx\n})\n\n/* ----------------------- */\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'monkey',\n    lastName: 'soft'\n  }\n})\n```\n\n直接使用api的方式虽然简单，但是不同请求参数的名字不一样，在实际开发过程中很容易写错或者忽略，容易为开发造成不必要的时间损失。\n\n前面两种方式虽然没有参数不一致的问题，但是使用的时候，太过于麻烦，那么怎么办呢？\n\n前面两种虽然过于麻烦，但是仔细观察，是可以发现有一定的相似点，我们便可以给予这些相似点二次封装，形成适合我们使用的一个请求函数。\n```javascript\n/* \n*url: 请求的url\n*params: 请求的参数\n*config: 请求时的header信息\n*method: 请求方法\n*/\nconst request = function({ url, params, config, method }) {\n  // 如果是get请求，需要拼接参数\n  let str = ''\n  if(method === 'get' && params) {\n    Object.keys(params).forEach(item => {\n      str += `${item}=${params[item]$}`\n    })\n  }\n  return new Promise((resolve, reject) => {\n    axios[method](str ? (url + '?' + str.substring(0, str.length - 1)) : url, params, Object.assign({}, config)).then(response => {\n      resolve(response.data)\n    }, err => {\n      if(err.Cancel) {\n\n      } else {\n        reject(err)\n      }\n    }).catch(err => {\n      reject(err)\n    })\n  })\n}\n\n```\n\n### 2.4 视频播放(video.js)\n[视频播放video.js](https://juejin.cn/post/6850037269227634702)\n\n### 2.5 vue常用ui库\n#### 2.5.1 移动端\n\n* [mint-ui](http://mint-ui.github.io/#!/zh-cn)\n* [Vant](https://youzan.github.io/vant/#/zh-CN/home)\n* [VUX](https://vux.li/)\n\n#### 2.5.2 pc端\n\n* [element-ui](https://element.eleme.cn/2.13/#/zh-CN/component/installation)\n* [Ant Design of Vue](https://www.antdv.com/docs/vue/introduce-cn/)\n* [Avue](https://avuejs.com/)\n\n\n## 3. 常用webpack配置\n\n> vue-lic3脚手架（vue.config.js）\n\n### 3.1 publicPath\n\n* 类型：String\n* 默认：'/'\n\n部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/\n\n这个值也可以被设置为空字符串 ('') 或是相对路径 ('./')，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。\n\n### 3.2 productionSourceMap\n* 类型：boolean\n* 默认：true\n\n不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积\n\n> 注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便\n\n### 3.3 assetsDir\n放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是'',\n\n### 3.4 indexPath\n指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是'index.html'\n\n### 3.5 lintOnSave\n是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用\n### 3.6 css\n```javascript\ncss: {\n  // 是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，\n  extract: true,\n  sourceMap: false, // 效果同上\n  modules: false, // 为所有的 CSS 及其预处理文件开启 CSS Modules。\n  // 这个选项不会影响 `*.vue` 文件。\n},\n```\n\n### 3.7 devServer\n本地开发服务器配置，此处直接贴上我常用的配置，以注释的方式介绍\n```javascript\ndevServer: { \n  // 配置开发服务器\n  host: \"0.0.0.0\",\n  // 是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果\n  hot: true,\n  // 服务启动端口\n  port: \"8080\",\n  // 是否自动打开浏览器默认为false\n  open: false,\n  // 配置http代理\n  proxy: { \n    \"/api\": { \n      //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在ajax中使用/api/api1路径,其请求路径会解析\n      // http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;\n      target: \"http://192.168.0.118:9999\",\n      //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意\n      changeOrigin: true,\n      pathRewrite: {\n          //把多余的路径置为''\n        \"api\": \"\"\n      }\n    },\n    \"/api2\": {//可以配置多个代理，匹配上那个就使用哪种解析方式\n      target: \"http://api2\",\n      // ...\n    }\n  }\n},\n```\n\n### 3.8 pluginOptions\n这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：\n```javascript\n{\n  //定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了\n  'style-resources-loader': {\n    preProcessor: 'less',\n    patterns: [\n      './src/assets/public.less'\n    ]\n  }\n}\n```\n\n### 3.9 chainWebpack\n是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：\n```javascript\nchainWebpack(config) { \n//添加一个路径别名 假设有在assets/img/menu/目录下有十张图片，如果全路径require(\"/assets/img/menu/img1.png\")\n//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了\n    config.resolve.alias\n      //添加多个别名支持链式调用\n      .set(\"assets\", path.join(__dirname, \"/src/assets\"))\n      .set(\"img\", path.join(__dirname, \"/src/assets/img/menu\"))\n      //引入图片时只需require(\"img/img1.png\");即可\n}\n```\n\n## 4. webpack优化\n[带你深度解锁Webpack系列(优化篇)](https://segmentfault.com/a/1190000022205477)\n\n[vue-cli中Webpack配置优化（一）](https://www.cnblogs.com/zhurong/p/12603887.html)\n\n[vue-cli中Webpack配置优化（二）](https://www.cnblogs.com/zhurong/p/12611360.html#_label2_1_3)\n\n### 4.1 量化\n\n#### 4.1.1 speed-measure-webpack-plugin\n\n`speed-measure-webpack-plugin` 插件可以测量各个插件和`loader`所花费的时间，使用之后，构建时，会得到类似下面这样的信息：\n\n![](https://image-static.segmentfault.com/334/233/3342331922-6a0fde0ed940ffa7_fix732)\n\n\n\n> Vue-cli 2.x\n\n```js\n//webpack.config.js\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\nconst smp = new SpeedMeasurePlugin();\n\nconst config = {\n    //...webpack配置\n}\n\nmodule.exports = smp.wrap(config);\n```\n\n\n\n> Vue-cli 3.x（主要区别是包裹 configureWebpack ）\n\n```js\nconst SpeedMeasurePlugin = require('speed-measure-webpack-plugin')\nconst smp = new SpeedMeasurePlugin({\n  outputFormat: 'human'\n})\nmodule.exports = {\n  configureWebpack: smp.wrap({\n    plugins: []\n  })\n}\n```\n\n\n\n#### 4.1.2 webpack-bundle-analyzer\n\n这个是分析打包后，各个文件的大小，用于分析bundle的\n\n> 安装\n\n```\nnpm i webpack-bundle-analyzer -D\n```\n\n\n\n在 Vue-cli 3.x 下，安装这个包会报错，是因为用 Vue-cli 3.x 构建的项目在 node_modules 中已经存在，但是项目的 package.json 中没有引用。\n\n需要在 node_modules 中删除这个包，重新安装就可以。\n\n\n\n> 使用：（下面是vue-cli 3.x）\n\n```\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n\n  configureWebpack: smp.wrap({\n    plugins: [\n      // 这个要放在所有 plugins 最后\n      new BundleAnalyzerPlugin()\n    ]\n  })\n```\n\n在构建完成后，会直接启动一个服务，有一个可视化的界面查看构建后的bundle。\n\n\n\n### 4.2 缓存\n\n#### 4.2.1 cache-loader\n\n在一些性能开销较大的`loader`前面添加`cache-loader`，将结果缓存在磁盘中\n\n> 安装：\n\n```\nnpm install cache-loader -D\n```\n\n\n\n> 使用：\n>\n> 在vue-cli2.x 中\n\n```js\nmodule.exports = {\n    //...\n    module: {\n        //我的项目中,babel-loader耗时比较长，所以我给它配置了`cache-loader`\n        rules: [\n            {\n                test: /\\.jsx?$/,\n                use: ['cache-loader','babel-loader']\n            }\n        ]\n    }\n}\n```\n\n\n\n> 在vue-cli3.x中，这个配置是默认的配置，分别对：`vue-loader`、`babel-loader`两个进行了缓存，其他的需要缓存再自己配置。\n\n\n\n#### 4.2.2 hard-source-webpack-plugin\n\n这个是为模块提供中间缓存，效率提升很大。\n\n> 安装\n\n```\nnpm i hard-source-webpack-plugin -D\n```\n\n\n\n> 使用\n\n直接在 plugins 中 new就可以。\n\n```js\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin')\nmodule.exports = {\n  configureWebpack: smp.wrap({\n    plugins: [\n      // 为模块提供中间缓存，缓存路径是：node_modules/.cache/hard-source\n      new HardSourceWebpackPlugin(),\n      new BundleAnalyzerPlugin()\n    ]\n  })\n}\n```\n\n\n\n构建后效果：\n\n![](https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111737573-1701609808.png)\n\n![](https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111750107-1452016351.png)\n\n![](https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111800199-1571336442.png)\n\n上面三幅图，分别是配置后第一次、第二次、第三次构建的，第三次构建可以达到80%的提升。\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 4.3 exclude/include\n\n我们可以通过`exclue`、`include`配置来确保转移尽可能少的文件。顾名思义，`exclude`指定要排除的文件，`include`指定要包含的文件。\n\n\n\n`exclude`的优先级高于`include`，在`include`和`exclude`中使用绝对路径数组，尽量避免`exclude`，更倾向于使用`include`。\n\n```js\n//webpack.config.js\nconst path = require('path');\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.js[x]?$/,\n                use: ['babel-loader'],\n                include: [path.resolve(__dirname, 'src')]\n            }\n        ]\n    },\n}\n```\n\n下图是未配置`include`和配置了`include`的构建结果对比：\n\n![](https://image-static.segmentfault.com/341/005/3410059882-f459f782062d01e1_fix732)\n\n\n\n\n\n## 5. 历史好文推荐\n1. [【万字长文】史上最强css、html总结~看完涨薪不再是梦](https://juejin.im/post/6850418118695583758)\n2. [【万字长文】最全JavaScript基础总结~建议收藏](https://juejin.im/post/6854573211451932685)\n3. [Event Loop我知道，宏任务微任务是什么鬼？](https://juejin.im/post/6847902222882340872)\n4. [锋利码农武器之vscode](https://juejin.im/post/6847009771493523464)\n5. [面试宝典带你走上人生巅峰](https://juejin.im/post/6847009771371888653)\n","source":"_posts/vue-conclusion.md","raw":"---\ntitle: vue面试题总结\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 08：38：25\ncomments: true\ntags: \n - web\nkeywords: vue\ndescription: vue\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg\n---\n\n\n[原文](https://juejin.cn/post/6850037277675454478#comment)\n\n## 1. vue框架篇\n\n### 1.1 vue的优点\n\n* 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；\n* 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；\n* 双向数据绑定：保留了angular的特点，在数据操作方面更为简单；\n* 组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；\n* 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；\n* 虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；\n* 运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。\n\n\n### 1.2 请详细说下你对vue生命周期的理解？\n\n总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。\n\n>`创建前/后` \n>1. 在``beforeCreate``阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。\n>2. 在``created``阶段，vue实例的数据对象data有了，el为undefined，还未初始化。\n\n\n>`载入前/后`：\n>1. 在``beforeMount``阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。\n>2. 在``mounted``阶段，vue实例挂载完成，data.message成功渲染。\n\n\n>`更新前/后`：当data变化时，会触发``beforeUpdate``和``updated``方法\n\n\n>`销毁前/后`：在执行``destroy``方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在\n\n### 1.3 为什么vue组件中data必须是一个函数？\n* 对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；\n* 而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。\n\n### 1.4 vue中v-if和v-show有什么区别？\nv-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:\n1. 手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；\n2. 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n3. 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；\n4. 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n\n>用法推荐：\n1. v-if更适合带有权限的操作，渲染时判断权限数据，有则展示该功能，没有则删除。\n2. v-show更适合于日常使用，可以减少数据的渲染，减少不必要的操作。\n综上，v-if有更高的切换消耗，而v-show有更高的初始渲染消耗。\n因此，如果需要频繁切换v-show较好，如果在运行时条件不大可能改变，更倾向功能权限性的话v-if较好。\n\n### 1.5 computed和watch的区别\n#### 1.5.1 计算属性computed：\n\n* 支持缓存，只有依赖数据发生改变，才会重新进行计算\n* 不支持异步，当computed内有异步操作时无效，无法监听数据的变化\n* computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值\n* 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed\n* 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。\n\n#### 1.5.2 侦听属性watch：\n\n* 不支持缓存，数据变，直接会触发相应的操作；\n* watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；\n* 当一个属性发生变化时，需要执行对应的操作；一对多；\n* 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：\n\n> 1. immediate：组件加载立即触发回调函数执行\n\n```javascript\nwatch: {\n  firstName: {\n    handler(newName, oldName) {\n      this.fullName = newName + ' ' + this.lastName;\n    },\n    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法\n    immediate: true\n  }\n}\n```\n\n\n>2. deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler\n```javascript\nwatch: {\n  obj: {\n    handler(newName, oldName) {\n      console.log('obj.a changed');\n    },\n    immediate: true,\n    deep: true\n  }\n}\n```\n\n> 优化：我们可以使用字符串的形式监听\n```javascript\nwatch: {\n  'obj.a': {\n    handler(newName, oldName) {\n      console.log('obj.a changed');\n    },\n    immediate: true,\n    // deep: true\n  }\n}\n```\n\n这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。\n\n### 1.6 vue-loader是什么？使用它的用途有哪些？\nvue文件的一个加载器，跟template/js/style转换成js模块。\n\n### 1.7 $nextTick是什么？\nvue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。\n\n>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM\n\n### 1.8 v-for key的作用\n* 当Vue用 ``v-for`` 正在更新已渲染过的元素列表时，它默认用``就地复用``策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。\n* 为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。\n* key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。\n\n### 1.9 简述MVVM\n* ``MVVM``是 ``Model-View-ViewModel`` 的缩写。``MVVM`` 是一种设计思想。 \n  > ``Model层`` 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑\n  > ``View层`` 代表UI组件，它负责将数据模型转化成UI展现出来\n  > ``ViewModel`` 是一个同步 View 和 Model 的对象。\n\n* 在 ``MVVM`` 架构下， ``View ``和 ``Model`` 之间并没有直接的联系，而是通过``ViewModel``进行交互，``Model``和``ViewModel``之间的交互是双向的，因此``View``数据的变化会同步到``Model``中，而``Model``数据的变化也会立即反映到``View``上。\n\n* ``ViewModel``通过双向数据绑定把``View层``和``Model``层连接了起来，而``View``和``Model``之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作``DOM``，不需要关注数据状态的同步问题，复杂的数据状态维护完全由``MVVM``来统一管理。\n\n![MVVM](https://upload-images.jianshu.io/upload_images/13038962-96704c499078e5b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp)\n\n\n### 1.10 Vue的双向数据绑定原理是什么？\nvue.js 是采用数据劫持结合``发布者-订阅者模式``的方式，通过``Object.defineProperty()``来劫持各个属性的``setter``，``getter``，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\n\n1. 需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n\n\n2. compiler解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n\n\n3. Watcher订阅者是Observer和Compiler之间通信的桥梁，主要做的事情是:\n    * 在自身实例化时往属性订阅器(dep)里面添加自己\n    * 自身必须有一个update()方法\n    * 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\n\n\n4. MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n\n[vue双向绑定原理](https://www.jianshu.com/p/bb5d1bede3ea)\n![图](https://upload-images.jianshu.io/upload_images/7120480-7d53305530ed75a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)\n\n\n\n### 1.11 组件传值\n#### 1.11.1 父传子\n通过props传递\n>父组件： ``<child value = '传递的数据' />``\n>\n>子组件: ``props['value']``,接收数据,接受之后使用和data中定义数据使用方式一样\n\n#### 1.11.2 子传父\n在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。\n>父组件： ``<child @receive = 'receive' />``\n>\n>子组件: this.$emit('receive','传递的数据')\n\n#### 1.11.3 兄弟组件传值\n\n* 通过中央通信 let bus = new Vue()\n\n>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送\n\n\n>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收\n\n\n* 通过vuex\n\n### 1.12 prop 验证，和默认值\n我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告\n```javascript\nprops: {\n    visible: {\n        default: true,\n        type: Boolean,\n        required: true\n    },\n}\n```\n\n### 1.13 请说下封装 vue 组件的过程\n* 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。\n* 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>vue组件</title>\n    <script src=\"vue.js\"></script>\n</head>\n<body>\n    <div id=\"app1\">\n        <my-com></my-com>\n    </div>\n    <div id=\"app2\">\n        <my-com></my-com>\n    </div>\n \n    <script>\n        /*创建组件*/\n        var myCom = Vue.extend({\n            template: '<div>这是我的组件</div>'\n        });\n        /*全局注册组件*/\n        Vue.component('my-com',myCom);\n \n        /*定义vue实例app1*/\n        var app1 = new Vue({\n            el: '#app1'\n        });\n \n        /*定义vue实例app2*/\n        var app2 = new Vue({\n            el: '#app2'\n        });\n    </script>\n</body>\n</html>\n```\n\n### 1.14 Vue.js的template编译\n简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：\n\n>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。\n\n\n>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）\n\n### 1.15 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？\ncss的预编译,使用步骤如下：\n* 第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）\n* 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss\n* 第三步：还是在同一个文件，配置一个module属性\n* 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”\n\n特性主要有:\n\n* 可以用变量，例如（$变量名称=值）\n* 可以用混合器，例如（）\n* 可以嵌套\n\n### 1.16 vue如何监听对象或者数组某个属性的变化\n当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。\n解决方式：\n\n* this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)\n```javascript\nthis.$set(this.arr, 0, \"OBKoro1\"); // 改变数组\nthis.$set(this.obj, \"c\", \"OBKoro1\"); // 改变对象\n```\n\n* 调用以下几个数组的方法\n```javascript\nsplice()、 push()、pop()、shift()、unshift()、sort()、reverse()\n```\n\nvue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作\n\n### 1.17 常用的事件修饰符\n\n* .stop:阻止冒泡\n* .prevent:阻止默认行为.\n* .self:仅绑定元素自身触发\n* .once: 2.1.4 新增,只触发一次\n* .passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用\n* .sync 修饰符\n\n从 2.3.0 起vue重新引入了.sync修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下：\n```\n<comp :foo.sync=\"bar\"></comp>\n```\n会被扩展为：\n```\n<comp :foo=\"bar\" @update:foo=\"val => bar = val\"></comp>\n```\n当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\n```\nthis.$emit('update:foo', newValue)\n```\n\n[vue中.sync修饰符](https://blog.csdn.net/liushijun_/article/details/92426854)\n\n### 1.18 vue如何获取dom\n先给标签设置一个ref值，再通过this.$refs.domName获取，例如：\n```\n<div ref=\"test\"></div>\n\nconst dom = this.$refs.test\n```\n\n### 1.19 v-on可以监听多个方法吗？\n是可以的，来个例子：\n```\n<input type=\"text\" v-on=\"{ input:onInput,focus:onFocus,blur:onBlur, }\">\n```\n\n### 1.20 assets和static的区别\n这两个都是用来存放项目中所使用的静态资源文件。\n\n两者的区别：\n\n* ``assets``中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。\n\n* ``static``中的文件则不会被打包。\n\n>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。\n\n### 1.21slot插槽\n很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。\n\n> 以下为详细扩展\n#### 1.21.1 插槽是什么\n* 写个父组件：test.vue\n\n```vue\n<template>\n  <div>\n    <div>大家好我是父组件</div>\n    <myslot>\n      <p>测试一下吧内容写在这里了能否显示</p>\n    </myslot>\n  </div>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n\n<style>\n</style>\n```\n\n* 写个子组件：myslot.vue\n\n```vue\n<template>\n  <div>\n    <div>我是子组件</div>\n  </div>\n</template>\n\n<script>\n</script>\n\n<style>\n</style>\n```\n\n运行代码，发现，最终渲染的效果是\n>大家好我是父组件\n>\n>我是子组件\n\n那如果我想实现显示父组件中p标签的内容怎么办 修改子组件：myslot.vue\n\n```vue\n<template>\n  <div>\n      <div>我是子组件</div>\n      <p>现在测试一下slot</p>\n      <slot></slot>\n  </div>\n</template>\n\n<script>\n</script>\n\n<style>\n</style>\n```\n\n运行代码，可以看到以下效果\n>大家好我是父组件<br>我是子组件<br>现在测试一下slot<br>测试一下吧内容写在这里了能否显示\n\n官方文档对于插槽的应用场景是这样描述的: 我们经常需要向一个组件传递内容 Vue 自定义的 ``<slot>`` 元素让这变得非常简单 只要在需要的地方加入插槽就行了——就这么简单！ \n结合上面的例子来理解就是这样的： \n1. 父组件在引用子组件时希望向子组件传递模板内容``<p>``测试一下吧内容写在这里了能否显示``</p>`` \n2. 子组件让父组件传过来的模板内容在所在的位置显示 \n3. 子组件中的``<slot>``就是一个槽，可以接收父组件传过来的模板内容，``<slot>`` 元素自身将被替换 \n4. ``<myslot></myslot>``组件没有包含一个 ``<slot>`` 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃\n\n#### 1.21.2 插槽的作用\n让用户可以拓展组件，去更好地复用组件和对其做定制化处理\n\n#### 1.21.3 插槽的分类\n##### 1.21.3.1 默认插槽\n在一个 ``<submit-button>`` 组件中：\n```\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n* 我们可能希望这个 ``<button>`` 内绝大多数情况下都渲染文本“Submit”，但是有时候却希望渲染文本为别的东西，那怎么实现呢？ 我们可以将“Submit”作为后备内容，我们可以将它放在 ``<slot>`` 标签内：\n```\n<button type=\"submit\">\n  <slot>Submit</slot>\n</button>\n```\n\n现在当我在一个父级组件中使用 ``<submit-button>`` 并且不提供任何插槽内容时：\n```\n<submit-button></submit-button>\n```\n后备内容“Submit”将会被渲染：\n```\n<button type=\"submit\">\n  Submit\n</button>\n```\n\n* 但是如果我们提供内容：\n\n```\n<submit-button>\n  Save\n</submit-button>\n```\n\n则这个提供的内容将会被渲染从而取代后备内容：\n```\n<button type=\"submit\">\n  Save\n</button>\n```\n\n##### 1.21.3.2 具名插槽\n有时我们写了一个子组件，我们希望\n```\n<template>\n  <div class=\"container\">\n    <header>\n      <!-- 我们希望把页头放这里 -->\n    </header>\n    <main>\n      <!-- 我们希望把主要内容放这里 -->\n    </main>\n    <footer>\n      <!-- 我们希望把页脚放这里 -->\n    </footer>\n  </div>\n</template>\n```\n\n对于这样的情况，``<slot>`` 元素有一个特殊的 attribute：name。这个 attribute 可以用来定义额外的插槽：\n```\n<template>\n  <div class=\"container\">\n    <header>\n      <slot name=\"header\"></slot>\n    </header>\n    <main>\n      <slot></slot>\n    </main>\n    <footer>\n      <slot name=\"footer\"></slot>\n    </footer>\n  </div>\n</template>\n```\n\n一个不带 name 的 ``<slot>`` 出口会带有隐含的名字“default”。 父组件在向具名插槽提供内容的时候，我们可以在一个 ``<template>`` 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：\n```vue\n<template>\n  <myslot>\n    <div>大家好我是父组件</div>\n    <template v-slot:header>\n      <h1>Here might be a page title</h1>\n    </template>\n\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n\n    <template v-slot:footer>\n      <p>Here's footer info</p>\n    </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n最终的渲染结果可以看到\n```\nHere might be a page title\n大家好我是父组件\nA paragraph for the main content.\n\nAnd another one.\n\nHere's footer info\n```\n\n父组件中会向子组件中具名传递对应的模板内容，而没有指定名字的模板内容会传递给子组件中不带 name 的 ``<slot>`` 当然，如果父组件中\n```\n<template v-slot:default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n</template>\n```\n\n* 同样是传递给子组件中不带 name 的 ``<slot>`` 注意: v-slot 只能添加在 ``<template>`` 上 具名插槽在书写的时候可以使用缩写,v-slot用``#``来代替\n\n```vue\n<template>\n  <myslot>\n    <div>大家好我是父组件</div>\n    <template #header>\n      <h1>Here might be a page title</h1>\n    </template>\n\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n\n    <template #footer>\n      <p>Here's footer info</p>\n    </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n\n<style>\n</style>\n```\n\n##### 1.21.3.3 作用域插槽\n这里主要解决的是父组件在向子组件插槽传递模板内容时存在访问子组件数据的问题 还记得默认插槽吗？如果子组件中写在 ``<slot>`` 标签内后备内容是与 该组件的data属性双向数据绑定的\n```vue\n<template>\n  <div>\n    <span>\n      <slot>{{user.firstName}}</slot>\n    </span>\n  </div>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        user:{\n          firstName:'gerace',\n          lastName:'haLi'\n        }\n      }\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n父组件在引用子组件时，希望能够换掉备用内容\n```vue\n<template>\n  <myslot>{{ user.firstName }}</myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n运行代码这时你会发现提示报错\n```\nProperty or method \"user\" is not defined on the instance but referenced during render.\nTypeError: Cannot read property 'firstName' of undefined\n```\n\n这里为什么？vue官方文档给出了答案 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的 那应该怎么解决这个问题？ 为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 ``<slot>`` 元素的一个 attribute 绑定上去：\n```\n<span>\n  <slot v-bind:user=\"user\">\n    {{ user.lastName }}\n  </slot>\n</span>\n```\n\n绑定在 ``<slot>`` 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：\n```vue\n<template>\n  <myslot>\n      <template v-slot:default=\"slotProps\">\n      {{ slotProps.user.firstName }}\n      </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n</script>\n<style>\n</style>\n```\n\n上面例子，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字。 针对上面只给默认插槽传递模板内容的例子，在写法上可以采用默认插槽的缩写语法\n```vue\n<template>\n  <myslot v-slot:default=\"slotProps\">\n     {{ slotProps.user.firstName }}\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n</script>\n<style>\n</style>\n\n↓↓↓\n<template>\n  <myslot v-slot=\"slotProps\">\n     {{ slotProps.user.firstName }}\n  </myslot>\n</template>\n\n```\n\n>注意： 默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：\n```\n<template>\n  <myslot v-slot=\"slotProps\">\n     {{ slotProps.user.firstName }}\n     <template v-slot:other=\"otherSlotProps\">\n   \t\tslotProps is NOT available here\n     </template>\n  </myslot>\n</template>\n```\n\n* 下面再看一下多个插槽的情况 子组件\n\n```vue\n<template>\n  <div>\n    <span>\n      <slot v-bind:userData=\"user\" name=\"header\">\n        {{ user.msg }}\n      </slot>\n      <slot v-bind:hobbyData=\"hobby\" name=\"footer\">\n        {{ hobby.fruit }}\n      </slot>\n    </span>\n  </div>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        user:{\n          firstName: 'gerace',\n          lastName: 'haLi',\n        },\n        hobby:{\n          fruit: \"apple\",\n          color: \"blue\"\n        }\n      }\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n父组件\n```vue\n<template>\n  <myslot>\n      <template v-slot:header=\"slotProps\">\n        {{ slotProps.userData.firstName }}\n      </template>\n      <template v-slot:footer=\"slotProps\">\n        {{ slotProps.hobbyData.fruit }}\n      </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n</script>\n<style>\n</style>\n```\n\n针对多个插槽的情况，在写法上可以解构插槽prop，父组件的写法如下\n```\n<template>\n  <myslot>\n      <template v-slot:header=\"{userData}\">\n        {{ userData.firstName }}\n      </template>\n      <template v-slot:footer=\"{hobbyData}\">\n        {{ hobbyData.fruit }}\n      </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n在具名插槽的介绍部分有讲过，具名插槽可以使用缩写，v-slot可以使用#来代替，所以以上代码可以写成：\n\n```vue\n<template>\n  <myslot>\n      <template #header=\"{userData}\">\n        {{ userData.firstName }}\n      </template>\n      <template #footer=\"{hobbyData}\">\n        {{ hobbyData.fruit }}\n      </template>\n  </myslot>\n</template>\n\n<script>\n  import myslot from './myslot';\n  export default {\n    components: {\n      myslot\n    }\n  }\n</script>\n<style>\n</style>\n```\n\n但是需要注意的是该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：\n```\n<!-- 这样会触发警告 -->\n<template>\n  <myslot>\n      <template #=\"{userData}\">\n        {{ userData.firstName }}\n      </template>\n      <template #=\"{hobbyData}\">\n        {{ hobbyData.fruit }}\n      </template>\n  </myslot>\n</template>\n```\n\n### 1.22 vue初始化页面闪动问题\n使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。\n首先：在css里加上以下代码\n```\n[v-cloak] {\n    display: none;\n}\n```\n\n如果没有彻底解决问题，则在根元素加上``style=\"display: none;\" :style=\"{display: 'block'}\"``\n\n\n## 2. vue插件篇\n### 2.1 状态管理（vuex）\n\n#### 2.1.1 vuex是什么\nVuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\n\n#### 2.1.2 怎么使用vuex\n\n1. 第一步安装\n```javascript\nnpm install vuex -S\n```\n2. 第二步创建store\n```javascript\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\n//不是在生产环境debug为true\nconst debug = process.env.NODE_ENV !== 'production';\n//创建Vuex实例对象\nconst store = new Vuex.Store({\n  strict:debug,//在不是生产环境下都开启严格模式\n  state:{\n  },\n  getters:{\n  },\n  mutations:{\n  },\n  actions:{\n  }\n})\nexport default store;\n```\n3. 第三步注入vuex\n```javascript\nimport Vue from 'vue';\nimport App from './App.vue';\nimport store from './store';\nconst vm = new Vue({\n    store:store,\n    render: h => h(App)\n}).$mount('#app')\n```\n\n#### 2.1.3 vuex中有几个核心属性，分别是什么？\n一共有5个核心属性，分别是:\n\n1. ``state`` 唯一数据源,Vue 实例中的 data 遵循相同的规则\n\n2. ``getters`` 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.\n\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n\n```\n\n3. `mutation` 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发\n\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n\nstore.commit('increment')\n```\n\n4. `action` Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作\n\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n```\n\n5. ``module``  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。\n\n```javascript\nconst moduleA = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n#### 2.1.4 ajax请求代码应该写在组件的methods中还是vuex的actions中\n如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。\n\n如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。\n\n#### 2.1.5 从vuex中获取的数据能直接更改吗？\n从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错；\n\n#### 2.1.6 vuex中的数据在页面刷新后数据消失\n用sessionstorage 或者 localstorage 存储数据\n```\n存储： sessionStorage.setItem( '名', JSON.stringify(值) )\n使用： sessionStorage.getItem('名') ---得到的值为字符串类型，用JSON.parse()去引号；\n```\n\n> 也可以引入插件vuex-persist，使用方法如下：\n\n* 安装\n```javascript\nnpm install --save vuex-persist\nor\nyarn add vuex-persist\n```\n\n* 引入\n```javascript\nimport VuexPersistence from 'vuex-persist'\n```\n\n* 先创建一个对象并进行配置\n```javascript\nconst vuexLocal = new VuexPersistence({\n    storage: window.localStorage\n})\n```\n\n* 引入进vuex插件\n```javascript\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  plugins: [vuexLocal.plugin]\n}) \n```\n通过以上设置，在图3中各个页面之间跳转，如果刷新某个视图，数据并不会丢失，依然存在，并且不需要在每个 mutations 中手动存取 storage 。\n\n#### 2.1.7 Vuex的严格模式是什么,有什么作用,怎么开启？\n在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n在Vuex.Store 构造器选项中开启,如下\n```javascript\nconst store = new Vuex.Store({\n    strict:true,\n})\n```\n\n#### 2.1.8 怎么在组件中批量使用Vuex的getter属性\n使用``mapGetters``辅助函数, 利用对象展开运算符将getter混入computed 对象中\n```\nimport {mapGetters} from 'vuex'\nexport default{\n    computed:{\n        ...mapGetters(['total','discountTotal'])\n    }\n}\n```\n\n#### 2.1.9 组件中重复使用mutation\n使用``mapMutations``辅助函数,在组件中这么使用\n```vue\nimport { mapMutations } from 'vuex'\nmethods:{\n    ...mapMutations({\n        setNumber:'SET_NUMBER',\n    })\n}\n```\n\n然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)\n\n#### 2.1.10 mutation和action有什么区别\n\n* action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态\n* action 可以包含任意异步操作。mutation只能是同步操作\n* 提交方式不同\n\n>action 是用this.store.dispatch('ACTION_NAME',data)来提交。\n>\n>mutation是用this.$store.commit('SET_NUMBER',10)来提交\n\n* 接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了\n```\n{\n    state,      // 等同于 `store.state`，若在模块中则为局部状态\n    rootState,  // 等同于 `store.state`，只存在于模块中\n    commit,     // 等同于 `store.commit`\n    dispatch,   // 等同于 `store.dispatch`\n    getters,    // 等同于 `store.getters`\n    rootGetters // 等同于 `store.getters`，只存在于模块中\n}\n```\n\n#### 2.1.11 在v-model上怎么用Vuex中state的值？\n需要通过computed计算属性来转换。\n```\n<input v-model=\"message\">\n// ...\ncomputed: {\n  message: {\n    get () {\n        return this.$store.state.message\n    },\n    set (value) {\n        this.$store.commit('updateMessage', value)\n    }\n  }\n}\n```\n\n### 2.2 路由页面管理（vue-router）\n#### 2.2.1 什么是vue-router\nVue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：\n\n* 嵌套的路由/视图表\n* 模块化的、基于组件的路由配置\n* 路由参数、查询、通配符\n* 基于 Vue.js 过渡系统的视图过渡效果\n* 细粒度的导航控制\n* 带有自动激活的 CSS class 的链接\n* HTML5 历史模式或 hash 模式，在 IE9 中自动降级\n* 自定义的滚动条行为\n\n#### 2.2.2 怎么使用vue-router\n1. 第一步安装\n```\nnpm install vue-router -S\n```\n2. 第二步在main.js中使用Vue Router组件\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nimport VueRouter from 'vue-router'\nVue.use(VueRouter)\n\nnew Vue({\n  el: '#app',\n  render: h=> h(App)\n})\n```\n\n3. 第三步配置路由\n\n* 定义 (路由) 组件\n路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。如下\n```javascript\n// 1.定义组件（导入组件）\nimport Home from './components/home.vue'\nimport News from '.components/news.vue'\n```\n\n* 定义路由（路由对象数组）\n定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。如下：\n```javascript\n// 2.定义路由\nconst routes = [\n  { path: '/home', components: Home },\n  { path: '/news', components: News },\n  { path: '*', redirect: '/home' }, // 表示没有匹配到，是默认重定向到home组件\n]\n```\n\n\n* 实例化Vue Router对象\n调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。如下\n```javascript\n// 3. 实例化Vue Router\nconst router = new VueRouter({routes}) // 此处相当于routes: routes\n```\n\n\n* 挂载根实例\n```javascript\n// 4. 挂载根实例\nnew Vue({\n  el: '#app',\n  router,\n  render: h => h(App)\n})\n```\n\n第四步在App.vue中使用路由\n在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。如下：\n```vue\n<template>\n  <div id=\"app\">\n    <router-link to=\"/home\">Home</router-link>\n    <router-link to=\"/news\">News</router-link>\n    <br />\n    <router-view></router-view> /* 显示组件的内容 */\n  </div>\n</template>\n```\n\n#### 2.2.3 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\n在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数\n\n#### 2.2.4 vue-router的导航钩子\n常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：\n\n* 全局导航钩子：router.beforeEach(to,from,next)\n* 组件内的钩子\n* 单独路由独享组件\n\n#### 2.2.5 vue路由传参\n\n* 页面刷新数据不会丢失\n\n```javascript\nmethods: {\n  jump(id) {\n    // 直接调用$router.push实现携带参数的跳转\n    this.$router.push({\n      path: `/particulars/${id}`\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: '/particulars/:id',\n  name: 'particulars',\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.params.id\n```\n\n* 使用params方式传入的参数\n> 这种方法页面刷新数据会丢失\n>\n>通过路由属性中的name来确定匹配的路由，通过params来传递参数\n```javascript\nmethods: {\n  jump(id) {\n    this.$router.push({\n      path: '/particulars',\n      params: {\n        id: id\n      }\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: '/particulars',\n  name: 'particulars',\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.params.id\n```\n\n* 使用query方法传入的参数\n> 使用path来匹配路由，然后通过query来传递参数\n>\n> 这种情况下，query传递的参数会显示在url后面?id=?\n```javascript\nmethods: {\n  jump(id) {\n    this.$router.push({\n      path: '/particulars',\n      query: {\n        id: id\n      }\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: '/particulars',\n  name: 'particulars',\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.query.id\n```\n\n#### 2.2.6 router和route的区别\n\n* ``route``为当前router跳转对象里面可以获取name、path、query、params等\n\n* ``router``为VueRouter实例，想要导航到不同URL，则使用router.push方法\n\n#### 2.2.7 路由 TypeError: Cannot read property 'matched' of undefined 的错误问题\n找到入口文件main.js里的new Vue()，必须使用router名，不能把router改成Router或者其他的别名\n```javascript\n// 引入路由\nimport router from './routers/router.js'\n\nnew Vue({\n    el: '#app',\n    router,    // 这个名字必须使用router\n    render: h => h(App)\n});\n```\n\n#### 2.2.8 路由按需加载\n随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候，路由按需加载就闪亮登场了。\n```javascript\n// webpack< 2.4 时\n{ \n    path:'/', \n    name:'home',\n    components:resolve=>require(['@/components/home'],resolve)\n} \n\n// webpack> 2.4 时\n{ \n    path:'/', \n    name:'home', \n    components:()=>import('@/components/home')\n}\n```\n\nimport()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。\n\n#### 2.2.9 Vue里面router-link在电脑上有用，在安卓上没反应怎么解决\nVue路由在Android机上有问题，babel问题，安装``babel polypill``插件解决\n\n#### 2.2.10 Vue2中注册在router-link上事件无效解决方法\n* 使用``@click.native``。\n* 原因：router-link会阻止click事件，.native指直接监听一个原生事件\n\n\n#### 2.2.11 RouterLink在IE和Firefox中不起作用（路由不跳转）的问题\n\n* 只用a标签，不使用button标签\n* 使用button标签和Router.navigate方法\n\n### 2.3 网络请求(axios)\naxios的二次封装，主要包括请求之前、返回响应以及使用等\n#### 2.3.1 请求之前\n一般的接口都会有鉴权认证（token）之类的，因此在接口的请求头里面，我们需要带上token值以通过服务器的鉴权认证。但是如果每次请求的时候再去添加，不仅会大大的加大工作量，而且很容易出错。好在axios提供了拦截器机制，我们在请求的拦截器中可以添加token。\n```javascript\n// 请求拦截\naxios.interceptors.request.use((config) => {\n  // ...省略代码\n  config.headers.x_access_token = token\n  return config\n}, function (error) => {\n  return Promise.reject(error)\n})\n```\n当然请求拦截器中，除了处理添加token以外，还可以进行一些其他的处理，具体的根据实际需求进行处理。\n\n#### 2.3.2 响应之后\n请求接口，并不是每一次请求都会成功。那么当接口请求失败的时候，我们又怎么处理呢？每次请求的时候处理？封装axios统一处理？应该选择封装axios进行统一处理。axios不仅提供了请求的拦截器，其也提供了响应的拦截器。在此处，可以获取到服务器返回的状态码，然后根据状态码进行相对应的操作。\n```javascript\n// 响应拦截\naxios.interceptors.response.use(function (response) {\n  if (response.data.code === 401) {\n    // 用户token失效\n    // 清空用户信息\n    sessionStorage.user = ''\n    sessionStorage.token = ''\n    window.location.href = '/' // 返回登录页\n    return Promise.reject(msg) // 接口Promise返回错误状态，错误信息msg可由后端返回，也可以我们自己定义一个码--信息的关系。\n  }\n  if (response.status !== 200 || response.data.code !== 200) {\n    // 接口请求失败，具体根据实际情况判断\n    message.error(mes) // 提示错误信息\n    return Promise.reject(msg) // 接口Promise返回错误状态\n  }\n  return response\n}, function (error) {\n  if (axios.isCancel(error)) {\n    requestList.length = 0\n    // store.dispatch('changeGlobalState', { loading: false })\n    throw new axios.Cancel('cancel request')\n  } else {\n    message.error('网络请求失败，请重试')\n  }\n  return Promise.reject(error)\n})\n\n```\n当然响应拦截器同请求拦截器一样，还可以进行一些其他的处理，具体的根据实际需求进行处理。\n\n#### 2.3.3 使用axios\naxios使用的时候一般有三种方式：\n* 执行get请求\n```javascript\naxios.get('url', {\n  params: {} // 接口参数\n}).then(function(res){\n  console.log(res) // 处理成功的函数，相当于success\n}).catch(function(error) {\n  console.log(error) // 错误处理，相当于error\n})\n```\n\n* 执行post请求\n```javascript\naxios.post('url', \n  {\n    data: xxx // 参数\n  },\n  {\n    headers: xxx //请求头信息\n}).then(function(res) {\n  console.log(res) // 处理成功的函数，相当于success\n}).catch(function(error) {\n  console.log(error) // 错误处理，相当于error\n})\n```\n\n* axios API通过相关配置传递给axios完成请求\n```javascript\naxios({\n  method: 'delete',\n  url: 'xxx',\n  cache: false,\n  params: { id: 123 },\n  headers: xxx\n})\n\n/* ----------------------- */\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'monkey',\n    lastName: 'soft'\n  }\n})\n```\n\n直接使用api的方式虽然简单，但是不同请求参数的名字不一样，在实际开发过程中很容易写错或者忽略，容易为开发造成不必要的时间损失。\n\n前面两种方式虽然没有参数不一致的问题，但是使用的时候，太过于麻烦，那么怎么办呢？\n\n前面两种虽然过于麻烦，但是仔细观察，是可以发现有一定的相似点，我们便可以给予这些相似点二次封装，形成适合我们使用的一个请求函数。\n```javascript\n/* \n*url: 请求的url\n*params: 请求的参数\n*config: 请求时的header信息\n*method: 请求方法\n*/\nconst request = function({ url, params, config, method }) {\n  // 如果是get请求，需要拼接参数\n  let str = ''\n  if(method === 'get' && params) {\n    Object.keys(params).forEach(item => {\n      str += `${item}=${params[item]$}`\n    })\n  }\n  return new Promise((resolve, reject) => {\n    axios[method](str ? (url + '?' + str.substring(0, str.length - 1)) : url, params, Object.assign({}, config)).then(response => {\n      resolve(response.data)\n    }, err => {\n      if(err.Cancel) {\n\n      } else {\n        reject(err)\n      }\n    }).catch(err => {\n      reject(err)\n    })\n  })\n}\n\n```\n\n### 2.4 视频播放(video.js)\n[视频播放video.js](https://juejin.cn/post/6850037269227634702)\n\n### 2.5 vue常用ui库\n#### 2.5.1 移动端\n\n* [mint-ui](http://mint-ui.github.io/#!/zh-cn)\n* [Vant](https://youzan.github.io/vant/#/zh-CN/home)\n* [VUX](https://vux.li/)\n\n#### 2.5.2 pc端\n\n* [element-ui](https://element.eleme.cn/2.13/#/zh-CN/component/installation)\n* [Ant Design of Vue](https://www.antdv.com/docs/vue/introduce-cn/)\n* [Avue](https://avuejs.com/)\n\n\n## 3. 常用webpack配置\n\n> vue-lic3脚手架（vue.config.js）\n\n### 3.1 publicPath\n\n* 类型：String\n* 默认：'/'\n\n部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/\n\n这个值也可以被设置为空字符串 ('') 或是相对路径 ('./')，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。\n\n### 3.2 productionSourceMap\n* 类型：boolean\n* 默认：true\n\n不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积\n\n> 注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便\n\n### 3.3 assetsDir\n放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是'',\n\n### 3.4 indexPath\n指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是'index.html'\n\n### 3.5 lintOnSave\n是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用\n### 3.6 css\n```javascript\ncss: {\n  // 是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，\n  extract: true,\n  sourceMap: false, // 效果同上\n  modules: false, // 为所有的 CSS 及其预处理文件开启 CSS Modules。\n  // 这个选项不会影响 `*.vue` 文件。\n},\n```\n\n### 3.7 devServer\n本地开发服务器配置，此处直接贴上我常用的配置，以注释的方式介绍\n```javascript\ndevServer: { \n  // 配置开发服务器\n  host: \"0.0.0.0\",\n  // 是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果\n  hot: true,\n  // 服务启动端口\n  port: \"8080\",\n  // 是否自动打开浏览器默认为false\n  open: false,\n  // 配置http代理\n  proxy: { \n    \"/api\": { \n      //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在ajax中使用/api/api1路径,其请求路径会解析\n      // http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;\n      target: \"http://192.168.0.118:9999\",\n      //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意\n      changeOrigin: true,\n      pathRewrite: {\n          //把多余的路径置为''\n        \"api\": \"\"\n      }\n    },\n    \"/api2\": {//可以配置多个代理，匹配上那个就使用哪种解析方式\n      target: \"http://api2\",\n      // ...\n    }\n  }\n},\n```\n\n### 3.8 pluginOptions\n这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：\n```javascript\n{\n  //定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了\n  'style-resources-loader': {\n    preProcessor: 'less',\n    patterns: [\n      './src/assets/public.less'\n    ]\n  }\n}\n```\n\n### 3.9 chainWebpack\n是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：\n```javascript\nchainWebpack(config) { \n//添加一个路径别名 假设有在assets/img/menu/目录下有十张图片，如果全路径require(\"/assets/img/menu/img1.png\")\n//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了\n    config.resolve.alias\n      //添加多个别名支持链式调用\n      .set(\"assets\", path.join(__dirname, \"/src/assets\"))\n      .set(\"img\", path.join(__dirname, \"/src/assets/img/menu\"))\n      //引入图片时只需require(\"img/img1.png\");即可\n}\n```\n\n## 4. webpack优化\n[带你深度解锁Webpack系列(优化篇)](https://segmentfault.com/a/1190000022205477)\n\n[vue-cli中Webpack配置优化（一）](https://www.cnblogs.com/zhurong/p/12603887.html)\n\n[vue-cli中Webpack配置优化（二）](https://www.cnblogs.com/zhurong/p/12611360.html#_label2_1_3)\n\n### 4.1 量化\n\n#### 4.1.1 speed-measure-webpack-plugin\n\n`speed-measure-webpack-plugin` 插件可以测量各个插件和`loader`所花费的时间，使用之后，构建时，会得到类似下面这样的信息：\n\n![](https://image-static.segmentfault.com/334/233/3342331922-6a0fde0ed940ffa7_fix732)\n\n\n\n> Vue-cli 2.x\n\n```js\n//webpack.config.js\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\nconst smp = new SpeedMeasurePlugin();\n\nconst config = {\n    //...webpack配置\n}\n\nmodule.exports = smp.wrap(config);\n```\n\n\n\n> Vue-cli 3.x（主要区别是包裹 configureWebpack ）\n\n```js\nconst SpeedMeasurePlugin = require('speed-measure-webpack-plugin')\nconst smp = new SpeedMeasurePlugin({\n  outputFormat: 'human'\n})\nmodule.exports = {\n  configureWebpack: smp.wrap({\n    plugins: []\n  })\n}\n```\n\n\n\n#### 4.1.2 webpack-bundle-analyzer\n\n这个是分析打包后，各个文件的大小，用于分析bundle的\n\n> 安装\n\n```\nnpm i webpack-bundle-analyzer -D\n```\n\n\n\n在 Vue-cli 3.x 下，安装这个包会报错，是因为用 Vue-cli 3.x 构建的项目在 node_modules 中已经存在，但是项目的 package.json 中没有引用。\n\n需要在 node_modules 中删除这个包，重新安装就可以。\n\n\n\n> 使用：（下面是vue-cli 3.x）\n\n```\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n\n  configureWebpack: smp.wrap({\n    plugins: [\n      // 这个要放在所有 plugins 最后\n      new BundleAnalyzerPlugin()\n    ]\n  })\n```\n\n在构建完成后，会直接启动一个服务，有一个可视化的界面查看构建后的bundle。\n\n\n\n### 4.2 缓存\n\n#### 4.2.1 cache-loader\n\n在一些性能开销较大的`loader`前面添加`cache-loader`，将结果缓存在磁盘中\n\n> 安装：\n\n```\nnpm install cache-loader -D\n```\n\n\n\n> 使用：\n>\n> 在vue-cli2.x 中\n\n```js\nmodule.exports = {\n    //...\n    module: {\n        //我的项目中,babel-loader耗时比较长，所以我给它配置了`cache-loader`\n        rules: [\n            {\n                test: /\\.jsx?$/,\n                use: ['cache-loader','babel-loader']\n            }\n        ]\n    }\n}\n```\n\n\n\n> 在vue-cli3.x中，这个配置是默认的配置，分别对：`vue-loader`、`babel-loader`两个进行了缓存，其他的需要缓存再自己配置。\n\n\n\n#### 4.2.2 hard-source-webpack-plugin\n\n这个是为模块提供中间缓存，效率提升很大。\n\n> 安装\n\n```\nnpm i hard-source-webpack-plugin -D\n```\n\n\n\n> 使用\n\n直接在 plugins 中 new就可以。\n\n```js\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin')\nmodule.exports = {\n  configureWebpack: smp.wrap({\n    plugins: [\n      // 为模块提供中间缓存，缓存路径是：node_modules/.cache/hard-source\n      new HardSourceWebpackPlugin(),\n      new BundleAnalyzerPlugin()\n    ]\n  })\n}\n```\n\n\n\n构建后效果：\n\n![](https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111737573-1701609808.png)\n\n![](https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111750107-1452016351.png)\n\n![](https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111800199-1571336442.png)\n\n上面三幅图，分别是配置后第一次、第二次、第三次构建的，第三次构建可以达到80%的提升。\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 4.3 exclude/include\n\n我们可以通过`exclue`、`include`配置来确保转移尽可能少的文件。顾名思义，`exclude`指定要排除的文件，`include`指定要包含的文件。\n\n\n\n`exclude`的优先级高于`include`，在`include`和`exclude`中使用绝对路径数组，尽量避免`exclude`，更倾向于使用`include`。\n\n```js\n//webpack.config.js\nconst path = require('path');\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.js[x]?$/,\n                use: ['babel-loader'],\n                include: [path.resolve(__dirname, 'src')]\n            }\n        ]\n    },\n}\n```\n\n下图是未配置`include`和配置了`include`的构建结果对比：\n\n![](https://image-static.segmentfault.com/341/005/3410059882-f459f782062d01e1_fix732)\n\n\n\n\n\n## 5. 历史好文推荐\n1. [【万字长文】史上最强css、html总结~看完涨薪不再是梦](https://juejin.im/post/6850418118695583758)\n2. [【万字长文】最全JavaScript基础总结~建议收藏](https://juejin.im/post/6854573211451932685)\n3. [Event Loop我知道，宏任务微任务是什么鬼？](https://juejin.im/post/6847902222882340872)\n4. [锋利码农武器之vscode](https://juejin.im/post/6847009771493523464)\n5. [面试宝典带你走上人生巅峰](https://juejin.im/post/6847009771371888653)\n","slug":"vue-conclusion","published":1,"updated":"2021-08-25T07:55:16.560Z","layout":"post","link":"","_id":"cku2cstrd001d4v9k0o0vkc61","content":"<p><a href=\"https://juejin.cn/post/6850037277675454478#comment\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<h2 id=\"1-vue框架篇\"><a href=\"#1-vue框架篇\" class=\"headerlink\" title=\"1. vue框架篇\"></a>1. vue框架篇</h2><h3 id=\"1-1-vue的优点\"><a href=\"#1-1-vue的优点\" class=\"headerlink\" title=\"1.1 vue的优点\"></a>1.1 vue的优点</h3><ul>\n<li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</li>\n<li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li>\n<li>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</li>\n<li>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</li>\n<li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>\n<li>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</li>\n<li>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</li>\n</ul>\n<h3 id=\"1-2-请详细说下你对vue生命周期的理解？\"><a href=\"#1-2-请详细说下你对vue生命周期的理解？\" class=\"headerlink\" title=\"1.2 请详细说下你对vue生命周期的理解？\"></a>1.2 请详细说下你对vue生命周期的理解？</h3><p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p>\n<blockquote>\n<p><code>创建前/后</code> </p>\n<ol>\n<li>在<code>beforeCreate</code>阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。</li>\n<li>在<code>created</code>阶段，vue实例的数据对象data有了，el为undefined，还未初始化。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><code>载入前/后</code>：</p>\n<ol>\n<li>在<code>beforeMount</code>阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。</li>\n<li>在<code>mounted</code>阶段，vue实例挂载完成，data.message成功渲染。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><code>更新前/后</code>：当data变化时，会触发<code>beforeUpdate</code>和<code>updated</code>方法</p>\n</blockquote>\n<blockquote>\n<p><code>销毁前/后</code>：在执行<code>destroy</code>方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p>\n</blockquote>\n<h3 id=\"1-3-为什么vue组件中data必须是一个函数？\"><a href=\"#1-3-为什么vue组件中data必须是一个函数？\" class=\"headerlink\" title=\"1.3 为什么vue组件中data必须是一个函数？\"></a>1.3 为什么vue组件中data必须是一个函数？</h3><ul>\n<li>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；</li>\n<li>而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</li>\n</ul>\n<h3 id=\"1-4-vue中v-if和v-show有什么区别？\"><a href=\"#1-4-vue中v-if和v-show有什么区别？\" class=\"headerlink\" title=\"1.4 vue中v-if和v-show有什么区别？\"></a>1.4 vue中v-if和v-show有什么区别？</h3><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p>\n<ol>\n<li>手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；</li>\n<li>编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>\n<li>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</li>\n<li>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>\n</ol>\n<blockquote>\n<p>用法推荐：</p>\n<ol>\n<li>v-if更适合带有权限的操作，渲染时判断权限数据，有则展示该功能，没有则删除。</li>\n<li>v-show更适合于日常使用，可以减少数据的渲染，减少不必要的操作。<br>综上，v-if有更高的切换消耗，而v-show有更高的初始渲染消耗。<br>因此，如果需要频繁切换v-show较好，如果在运行时条件不大可能改变，更倾向功能权限性的话v-if较好。</li>\n</ol>\n</blockquote>\n<h3 id=\"1-5-computed和watch的区别\"><a href=\"#1-5-computed和watch的区别\" class=\"headerlink\" title=\"1.5 computed和watch的区别\"></a>1.5 computed和watch的区别</h3><h4 id=\"1-5-1-计算属性computed：\"><a href=\"#1-5-1-计算属性computed：\" class=\"headerlink\" title=\"1.5.1 计算属性computed：\"></a>1.5.1 计算属性computed：</h4><ul>\n<li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li>\n<li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li>\n<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>\n<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>\n<li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li>\n</ul>\n<h4 id=\"1-5-2-侦听属性watch：\"><a href=\"#1-5-2-侦听属性watch：\" class=\"headerlink\" title=\"1.5.2 侦听属性watch：\"></a>1.5.2 侦听属性watch：</h4><ul>\n<li>不支持缓存，数据变，直接会触发相应的操作；</li>\n<li>watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>\n<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>\n<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li>\n</ul>\n<blockquote>\n<ol>\n<li>immediate：组件加载立即触发回调函数执行</li>\n</ol>\n</blockquote>\n<pre><code class=\"javascript\">watch: {\n  firstName: {\n    handler(newName, oldName) {\n      this.fullName = newName + &#39; &#39; + this.lastName;\n    },\n    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法\n    immediate: true\n  }\n}\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler<pre><code class=\"javascript\">watch: {\nobj: {\n handler(newName, oldName) {\n   console.log(&#39;obj.a changed&#39;);\n },\n immediate: true,\n deep: true\n}\n}\n</code></pre>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>优化：我们可以使用字符串的形式监听</p>\n<pre><code class=\"javascript\">watch: {\n  &#39;obj.a&#39;: {\n    handler(newName, oldName) {\n      console.log(&#39;obj.a changed&#39;);\n    },\n    immediate: true,\n    // deep: true\n  }\n}\n</code></pre>\n</blockquote>\n<p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p>\n<h3 id=\"1-6-vue-loader是什么？使用它的用途有哪些？\"><a href=\"#1-6-vue-loader是什么？使用它的用途有哪些？\" class=\"headerlink\" title=\"1.6 vue-loader是什么？使用它的用途有哪些？\"></a>1.6 vue-loader是什么？使用它的用途有哪些？</h3><p>vue文件的一个加载器，跟template/js/style转换成js模块。</p>\n<h3 id=\"1-7-nextTick是什么？\"><a href=\"#1-7-nextTick是什么？\" class=\"headerlink\" title=\"1.7 $nextTick是什么？\"></a>1.7 $nextTick是什么？</h3><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。</p>\n<blockquote>\n<p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p>\n</blockquote>\n<h3 id=\"1-8-v-for-key的作用\"><a href=\"#1-8-v-for-key的作用\" class=\"headerlink\" title=\"1.8 v-for key的作用\"></a>1.8 v-for key的作用</h3><ul>\n<li>当Vue用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用<code>就地复用</code>策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</li>\n<li>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</li>\n<li>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li>\n</ul>\n<h3 id=\"1-9-简述MVVM\"><a href=\"#1-9-简述MVVM\" class=\"headerlink\" title=\"1.9 简述MVVM\"></a>1.9 简述MVVM</h3><ul>\n<li><p><code>MVVM</code>是 <code>Model-View-ViewModel</code> 的缩写。<code>MVVM</code> 是一种设计思想。 </p>\n<blockquote>\n<p><code>Model层</code> 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑<br><code>View层</code> 代表UI组件，它负责将数据模型转化成UI展现出来<br><code>ViewModel</code> 是一个同步 View 和 Model 的对象。</p>\n</blockquote>\n</li>\n<li><p>在 <code>MVVM</code> 架构下， <code>View</code>和 <code>Model</code> 之间并没有直接的联系，而是通过<code>ViewModel</code>进行交互，<code>Model</code>和<code>ViewModel</code>之间的交互是双向的，因此<code>View</code>数据的变化会同步到<code>Model</code>中，而<code>Model</code>数据的变化也会立即反映到<code>View</code>上。</p>\n</li>\n<li><p><code>ViewModel</code>通过双向数据绑定把<code>View层</code>和<code>Model</code>层连接了起来，而<code>View</code>和<code>Model</code>之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作<code>DOM</code>，不需要关注数据状态的同步问题，复杂的数据状态维护完全由<code>MVVM</code>来统一管理。</p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13038962-96704c499078e5b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp\" alt=\"MVVM\"></p>\n<h3 id=\"1-10-Vue的双向数据绑定原理是什么？\"><a href=\"#1-10-Vue的双向数据绑定原理是什么？\" class=\"headerlink\" title=\"1.10 Vue的双向数据绑定原理是什么？\"></a>1.10 Vue的双向数据绑定原理是什么？</h3><p>vue.js 是采用数据劫持结合<code>发布者-订阅者模式</code>的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>\n<ol>\n<li>需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>\n</ol>\n<ol start=\"2\">\n<li>compiler解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>\n</ol>\n<ol start=\"3\">\n<li>Watcher订阅者是Observer和Compiler之间通信的桥梁，主要做的事情是:<ul>\n<li>在自身实例化时往属性订阅器(dep)里面添加自己</li>\n<li>自身必须有一个update()方法</li>\n<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>\n</ol>\n<p><a href=\"https://www.jianshu.com/p/bb5d1bede3ea\" target=\"_blank\" rel=\"noopener\">vue双向绑定原理</a><br><img src=\"https://upload-images.jianshu.io/upload_images/7120480-7d53305530ed75a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\" alt=\"图\"></p>\n<h3 id=\"1-11-组件传值\"><a href=\"#1-11-组件传值\" class=\"headerlink\" title=\"1.11 组件传值\"></a>1.11 组件传值</h3><h4 id=\"1-11-1-父传子\"><a href=\"#1-11-1-父传子\" class=\"headerlink\" title=\"1.11.1 父传子\"></a>1.11.1 父传子</h4><p>通过props传递</p>\n<blockquote>\n<p>父组件： <code>&lt;child value = &#39;传递的数据&#39; /&gt;</code></p>\n<p>子组件: <code>props[&#39;value&#39;]</code>,接收数据,接受之后使用和data中定义数据使用方式一样</p>\n</blockquote>\n<h4 id=\"1-11-2-子传父\"><a href=\"#1-11-2-子传父\" class=\"headerlink\" title=\"1.11.2 子传父\"></a>1.11.2 子传父</h4><p>在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。</p>\n<blockquote>\n<p>父组件： <code>&lt;child @receive = &#39;receive&#39; /&gt;</code></p>\n<p>子组件: this.$emit(&#39;receive&#39;,&#39;传递的数据&#39;)</p>\n</blockquote>\n<h4 id=\"1-11-3-兄弟组件传值\"><a href=\"#1-11-3-兄弟组件传值\" class=\"headerlink\" title=\"1.11.3 兄弟组件传值\"></a>1.11.3 兄弟组件传值</h4><ul>\n<li>通过中央通信 let bus = new Vue()</li>\n</ul>\n<blockquote>\n<p>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送</p>\n</blockquote>\n<blockquote>\n<p>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收</p>\n</blockquote>\n<ul>\n<li>通过vuex</li>\n</ul>\n<h3 id=\"1-12-prop-验证，和默认值\"><a href=\"#1-12-prop-验证，和默认值\" class=\"headerlink\" title=\"1.12 prop 验证，和默认值\"></a>1.12 prop 验证，和默认值</h3><p>我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告</p>\n<pre><code class=\"javascript\">props: {\n    visible: {\n        default: true,\n        type: Boolean,\n        required: true\n    },\n}\n</code></pre>\n<h3 id=\"1-13-请说下封装-vue-组件的过程\"><a href=\"#1-13-请说下封装-vue-组件的过程\" class=\"headerlink\" title=\"1.13 请说下封装 vue 组件的过程\"></a>1.13 请说下封装 vue 组件的过程</h3><ul>\n<li>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</li>\n<li><p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;vue组件&lt;/title&gt;\n  &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app1&quot;&gt;\n      &lt;my-com&gt;&lt;/my-com&gt;\n  &lt;/div&gt;\n  &lt;div id=&quot;app2&quot;&gt;\n      &lt;my-com&gt;&lt;/my-com&gt;\n  &lt;/div&gt;\n\n  &lt;script&gt;\n      /*创建组件*/\n      var myCom = Vue.extend({\n          template: &#39;&lt;div&gt;这是我的组件&lt;/div&gt;&#39;\n      });\n      /*全局注册组件*/\n      Vue.component(&#39;my-com&#39;,myCom);\n\n      /*定义vue实例app1*/\n      var app1 = new Vue({\n          el: &#39;#app1&#39;\n      });\n\n      /*定义vue实例app2*/\n      var app2 = new Vue({\n          el: &#39;#app2&#39;\n      });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"1-14-Vue-js的template编译\"><a href=\"#1-14-Vue-js的template编译\" class=\"headerlink\" title=\"1.14 Vue.js的template编译\"></a>1.14 Vue.js的template编译</h3><p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：</p>\n<blockquote>\n<p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p>\n</blockquote>\n<blockquote>\n<p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p>\n</blockquote>\n<h3 id=\"1-15-scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？\"><a href=\"#1-15-scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？\" class=\"headerlink\" title=\"1.15 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？\"></a>1.15 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h3><p>css的预编译,使用步骤如下：</p>\n<ul>\n<li>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）</li>\n<li>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</li>\n<li>第三步：还是在同一个文件，配置一个module属性</li>\n<li>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”</li>\n</ul>\n<p>特性主要有:</p>\n<ul>\n<li>可以用变量，例如（$变量名称=值）</li>\n<li>可以用混合器，例如（）</li>\n<li>可以嵌套</li>\n</ul>\n<h3 id=\"1-16-vue如何监听对象或者数组某个属性的变化\"><a href=\"#1-16-vue如何监听对象或者数组某个属性的变化\" class=\"headerlink\" title=\"1.16 vue如何监听对象或者数组某个属性的变化\"></a>1.16 vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。<br>解决方式：</p>\n<ul>\n<li><p>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</p>\n<pre><code class=\"javascript\">this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组\nthis.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象\n</code></pre>\n</li>\n<li><p>调用以下几个数组的方法</p>\n<pre><code class=\"javascript\">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()\n</code></pre>\n</li>\n</ul>\n<p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p>\n<h3 id=\"1-17-常用的事件修饰符\"><a href=\"#1-17-常用的事件修饰符\" class=\"headerlink\" title=\"1.17 常用的事件修饰符\"></a>1.17 常用的事件修饰符</h3><ul>\n<li>.stop:阻止冒泡</li>\n<li>.prevent:阻止默认行为.</li>\n<li>.self:仅绑定元素自身触发</li>\n<li>.once: 2.1.4 新增,只触发一次</li>\n<li>.passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</li>\n<li>.sync 修饰符</li>\n</ul>\n<p>从 2.3.0 起vue重新引入了.sync修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下：</p>\n<pre><code>&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;\n</code></pre><p>会被扩展为：</p>\n<pre><code>&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;\n</code></pre><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p>\n<pre><code>this.$emit(&#39;update:foo&#39;, newValue)\n</code></pre><p><a href=\"https://blog.csdn.net/liushijun_/article/details/92426854\" target=\"_blank\" rel=\"noopener\">vue中.sync修饰符</a></p>\n<h3 id=\"1-18-vue如何获取dom\"><a href=\"#1-18-vue如何获取dom\" class=\"headerlink\" title=\"1.18 vue如何获取dom\"></a>1.18 vue如何获取dom</h3><p>先给标签设置一个ref值，再通过this.$refs.domName获取，例如：</p>\n<pre><code>&lt;div ref=&quot;test&quot;&gt;&lt;/div&gt;\n\nconst dom = this.$refs.test\n</code></pre><h3 id=\"1-19-v-on可以监听多个方法吗？\"><a href=\"#1-19-v-on可以监听多个方法吗？\" class=\"headerlink\" title=\"1.19 v-on可以监听多个方法吗？\"></a>1.19 v-on可以监听多个方法吗？</h3><p>是可以的，来个例子：</p>\n<pre><code>&lt;input type=&quot;text&quot; v-on=&quot;{ input:onInput,focus:onFocus,blur:onBlur, }&quot;&gt;\n</code></pre><h3 id=\"1-20-assets和static的区别\"><a href=\"#1-20-assets和static的区别\" class=\"headerlink\" title=\"1.20 assets和static的区别\"></a>1.20 assets和static的区别</h3><p>这两个都是用来存放项目中所使用的静态资源文件。</p>\n<p>两者的区别：</p>\n<ul>\n<li><p><code>assets</code>中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。</p>\n</li>\n<li><p><code>static</code>中的文件则不会被打包。</p>\n</li>\n</ul>\n<blockquote>\n<p>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。</p>\n</blockquote>\n<h3 id=\"1-21slot插槽\"><a href=\"#1-21slot插槽\" class=\"headerlink\" title=\"1.21slot插槽\"></a>1.21slot插槽</h3><p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p>\n<blockquote>\n<p>以下为详细扩展</p>\n</blockquote>\n<h4 id=\"1-21-1-插槽是什么\"><a href=\"#1-21-1-插槽是什么\" class=\"headerlink\" title=\"1.21.1 插槽是什么\"></a>1.21.1 插槽是什么</h4><ul>\n<li>写个父组件：test.vue</li>\n</ul>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;大家好我是父组件&lt;/div&gt;\n    &lt;myslot&gt;\n      &lt;p&gt;测试一下吧内容写在这里了能否显示&lt;/p&gt;\n    &lt;/myslot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<ul>\n<li>写个子组件：myslot.vue</li>\n</ul>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;我是子组件&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n&lt;/script&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>运行代码，发现，最终渲染的效果是</p>\n<blockquote>\n<p>大家好我是父组件</p>\n<p>我是子组件</p>\n</blockquote>\n<p>那如果我想实现显示父组件中p标签的内容怎么办 修改子组件：myslot.vue</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n      &lt;div&gt;我是子组件&lt;/div&gt;\n      &lt;p&gt;现在测试一下slot&lt;/p&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n&lt;/script&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>运行代码，可以看到以下效果</p>\n<blockquote>\n<p>大家好我是父组件<br>我是子组件<br>现在测试一下slot<br>测试一下吧内容写在这里了能否显示</p>\n</blockquote>\n<p>官方文档对于插槽的应用场景是这样描述的: 我们经常需要向一个组件传递内容 Vue 自定义的 <code>&lt;slot&gt;</code> 元素让这变得非常简单 只要在需要的地方加入插槽就行了——就这么简单！<br>结合上面的例子来理解就是这样的： </p>\n<ol>\n<li>父组件在引用子组件时希望向子组件传递模板内容<code>&lt;p&gt;</code>测试一下吧内容写在这里了能否显示<code>&lt;/p&gt;</code> </li>\n<li>子组件让父组件传过来的模板内容在所在的位置显示 </li>\n<li>子组件中的<code>&lt;slot&gt;</code>就是一个槽，可以接收父组件传过来的模板内容，<code>&lt;slot&gt;</code> 元素自身将被替换 </li>\n<li><code>&lt;myslot&gt;&lt;/myslot&gt;</code>组件没有包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃</li>\n</ol>\n<h4 id=\"1-21-2-插槽的作用\"><a href=\"#1-21-2-插槽的作用\" class=\"headerlink\" title=\"1.21.2 插槽的作用\"></a>1.21.2 插槽的作用</h4><p>让用户可以拓展组件，去更好地复用组件和对其做定制化处理</p>\n<h4 id=\"1-21-3-插槽的分类\"><a href=\"#1-21-3-插槽的分类\" class=\"headerlink\" title=\"1.21.3 插槽的分类\"></a>1.21.3 插槽的分类</h4><h5 id=\"1-21-3-1-默认插槽\"><a href=\"#1-21-3-1-默认插槽\" class=\"headerlink\" title=\"1.21.3.1 默认插槽\"></a>1.21.3.1 默认插槽</h5><p>在一个 <code>&lt;submit-button&gt;</code> 组件中：</p>\n<pre><code>&lt;button type=&quot;submit&quot;&gt;\n  &lt;slot&gt;&lt;/slot&gt;\n&lt;/button&gt;\n</code></pre><ul>\n<li>我们可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”，但是有时候却希望渲染文本为别的东西，那怎么实现呢？ 我们可以将“Submit”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：<pre><code>&lt;button type=&quot;submit&quot;&gt;\n&lt;slot&gt;Submit&lt;/slot&gt;\n&lt;/button&gt;\n</code></pre></li>\n</ul>\n<p>现在当我在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：</p>\n<pre><code>&lt;submit-button&gt;&lt;/submit-button&gt;\n</code></pre><p>后备内容“Submit”将会被渲染：</p>\n<pre><code>&lt;button type=&quot;submit&quot;&gt;\n  Submit\n&lt;/button&gt;\n</code></pre><ul>\n<li>但是如果我们提供内容：</li>\n</ul>\n<pre><code>&lt;submit-button&gt;\n  Save\n&lt;/submit-button&gt;\n</code></pre><p>则这个提供的内容将会被渲染从而取代后备内容：</p>\n<pre><code>&lt;button type=&quot;submit&quot;&gt;\n  Save\n&lt;/button&gt;\n</code></pre><h5 id=\"1-21-3-2-具名插槽\"><a href=\"#1-21-3-2-具名插槽\" class=\"headerlink\" title=\"1.21.3.2 具名插槽\"></a>1.21.3.2 具名插槽</h5><p>有时我们写了一个子组件，我们希望</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;header&gt;\n      &lt;!-- 我们希望把页头放这里 --&gt;\n    &lt;/header&gt;\n    &lt;main&gt;\n      &lt;!-- 我们希望把主要内容放这里 --&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;!-- 我们希望把页脚放这里 --&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：name。这个 attribute 可以用来定义额外的插槽：</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;header&gt;\n      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n    &lt;/header&gt;\n    &lt;main&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>一个不带 name 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。 父组件在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;\n    &lt;div&gt;大家好我是父组件&lt;/div&gt;\n    &lt;template v-slot:header&gt;\n      &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n    &lt;/template&gt;\n\n    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n    &lt;p&gt;And another one.&lt;/p&gt;\n\n    &lt;template v-slot:footer&gt;\n      &lt;p&gt;Here&#39;s footer info&lt;/p&gt;\n    &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>最终的渲染结果可以看到</p>\n<pre><code>Here might be a page title\n大家好我是父组件\nA paragraph for the main content.\n\nAnd another one.\n\nHere&#39;s footer info\n</code></pre><p>父组件中会向子组件中具名传递对应的模板内容，而没有指定名字的模板内容会传递给子组件中不带 name 的 <code>&lt;slot&gt;</code> 当然，如果父组件中</p>\n<pre><code>&lt;template v-slot:default&gt;\n    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n    &lt;p&gt;And another one.&lt;/p&gt;\n&lt;/template&gt;\n</code></pre><ul>\n<li>同样是传递给子组件中不带 name 的 <code>&lt;slot&gt;</code> 注意: v-slot 只能添加在 <code>&lt;template&gt;</code> 上 具名插槽在书写的时候可以使用缩写,v-slot用<code>#</code>来代替</li>\n</ul>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;\n    &lt;div&gt;大家好我是父组件&lt;/div&gt;\n    &lt;template #header&gt;\n      &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n    &lt;/template&gt;\n\n    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n    &lt;p&gt;And another one.&lt;/p&gt;\n\n    &lt;template #footer&gt;\n      &lt;p&gt;Here&#39;s footer info&lt;/p&gt;\n    &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<h5 id=\"1-21-3-3-作用域插槽\"><a href=\"#1-21-3-3-作用域插槽\" class=\"headerlink\" title=\"1.21.3.3 作用域插槽\"></a>1.21.3.3 作用域插槽</h5><p>这里主要解决的是父组件在向子组件插槽传递模板内容时存在访问子组件数据的问题 还记得默认插槽吗？如果子组件中写在 <code>&lt;slot&gt;</code> 标签内后备内容是与 该组件的data属性双向数据绑定的</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;span&gt;\n      &lt;slot&gt;{{user.firstName}}&lt;/slot&gt;\n    &lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    data () {\n      return {\n        user:{\n          firstName:&#39;gerace&#39;,\n          lastName:&#39;haLi&#39;\n        }\n      }\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>父组件在引用子组件时，希望能够换掉备用内容</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;{{ user.firstName }}&lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>运行代码这时你会发现提示报错</p>\n<pre><code>Property or method &quot;user&quot; is not defined on the instance but referenced during render.\nTypeError: Cannot read property &#39;firstName&#39; of undefined\n</code></pre><p>这里为什么？vue官方文档给出了答案 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的 那应该怎么解决这个问题？ 为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>\n<pre><code>&lt;span&gt;\n  &lt;slot v-bind:user=&quot;user&quot;&gt;\n    {{ user.lastName }}\n  &lt;/slot&gt;\n&lt;/span&gt;\n</code></pre><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template v-slot:default=&quot;slotProps&quot;&gt;\n      {{ slotProps.user.firstName }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>上面例子，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字。 针对上面只给默认插槽传递模板内容的例子，在写法上可以采用默认插槽的缩写语法</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot v-slot:default=&quot;slotProps&quot;&gt;\n     {{ slotProps.user.firstName }}\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n\n↓↓↓\n&lt;template&gt;\n  &lt;myslot v-slot=&quot;slotProps&quot;&gt;\n     {{ slotProps.user.firstName }}\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n</code></pre>\n<blockquote>\n<p>注意： 默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：<br><code>`</code></p>\n</blockquote>\n<template><br>  <myslot v-slot=\"slotProps\"><br>     <br>     <template v-slot:other=\"otherSlotProps\"><br>           slotProps is NOT available here<br>     </template><br>  </myslot><br></template><br><code>* 下面再看一下多个插槽的情况 子组件</code>vue<br><template><br>  <div><br>    <span><br>      <slot v-bind:userdata=\"user\" name=\"header\"><br>        <br>      </slot><br>      <slot v-bind:hobbydata=\"hobby\" name=\"footer\"><br>        <br>      </slot><br>    </span><br>  </div><br></template>\n\n<p><script><br>  export default {<br>    data () {<br>      return {<br>        user:{<br>          firstName: &#39;gerace&#39;,<br>          lastName: &#39;haLi&#39;,<br>        },<br>        hobby:{<br>          fruit: &quot;apple&quot;,<br>          color: &quot;blue&quot;<br>        }<br>      }<br>    }<br>  }<br></script></p>\n<p><style><br></style></p>\n<pre><code>\n父组件\n```vue\n&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template v-slot:header=&quot;slotProps&quot;&gt;\n        {{ slotProps.userData.firstName }}\n      &lt;/template&gt;\n      &lt;template v-slot:footer=&quot;slotProps&quot;&gt;\n        {{ slotProps.hobbyData.fruit }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre><p>针对多个插槽的情况，在写法上可以解构插槽prop，父组件的写法如下</p>\n<pre><code>&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template v-slot:header=&quot;{userData}&quot;&gt;\n        {{ userData.firstName }}\n      &lt;/template&gt;\n      &lt;template v-slot:footer=&quot;{hobbyData}&quot;&gt;\n        {{ hobbyData.fruit }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre><p>在具名插槽的介绍部分有讲过，具名插槽可以使用缩写，v-slot可以使用#来代替，所以以上代码可以写成：</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template #header=&quot;{userData}&quot;&gt;\n        {{ userData.firstName }}\n      &lt;/template&gt;\n      &lt;template #footer=&quot;{hobbyData}&quot;&gt;\n        {{ hobbyData.fruit }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>但是需要注意的是该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p>\n<pre><code>&lt;!-- 这样会触发警告 --&gt;\n&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template #=&quot;{userData}&quot;&gt;\n        {{ userData.firstName }}\n      &lt;/template&gt;\n      &lt;template #=&quot;{hobbyData}&quot;&gt;\n        {{ hobbyData.fruit }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n</code></pre><h3 id=\"1-22-vue初始化页面闪动问题\"><a href=\"#1-22-vue初始化页面闪动问题\" class=\"headerlink\" title=\"1.22 vue初始化页面闪动问题\"></a>1.22 vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。<br>首先：在css里加上以下代码</p>\n<pre><code>[v-cloak] {\n    display: none;\n}\n</code></pre><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;{display: &#39;block&#39;}&quot;</code></p>\n<h2 id=\"2-vue插件篇\"><a href=\"#2-vue插件篇\" class=\"headerlink\" title=\"2. vue插件篇\"></a>2. vue插件篇</h2><h3 id=\"2-1-状态管理（vuex）\"><a href=\"#2-1-状态管理（vuex）\" class=\"headerlink\" title=\"2.1 状态管理（vuex）\"></a>2.1 状态管理（vuex）</h3><h4 id=\"2-1-1-vuex是什么\"><a href=\"#2-1-1-vuex是什么\" class=\"headerlink\" title=\"2.1.1 vuex是什么\"></a>2.1.1 vuex是什么</h4><p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n<h4 id=\"2-1-2-怎么使用vuex\"><a href=\"#2-1-2-怎么使用vuex\" class=\"headerlink\" title=\"2.1.2 怎么使用vuex\"></a>2.1.2 怎么使用vuex</h4><ol>\n<li>第一步安装<pre><code class=\"javascript\">npm install vuex -S\n</code></pre>\n</li>\n<li>第二步创建store<pre><code class=\"javascript\">import Vue from &#39;vue&#39;;\nimport Vuex from &#39;vuex&#39;;\nVue.use(Vuex);\n//不是在生产环境debug为true\nconst debug = process.env.NODE_ENV !== &#39;production&#39;;\n//创建Vuex实例对象\nconst store = new Vuex.Store({\nstrict:debug,//在不是生产环境下都开启严格模式\nstate:{\n},\ngetters:{\n},\nmutations:{\n},\nactions:{\n}\n})\nexport default store;\n</code></pre>\n</li>\n<li>第三步注入vuex<pre><code class=\"javascript\">import Vue from &#39;vue&#39;;\nimport App from &#39;./App.vue&#39;;\nimport store from &#39;./store&#39;;\nconst vm = new Vue({\n store:store,\n render: h =&gt; h(App)\n}).$mount(&#39;#app&#39;)\n</code></pre>\n</li>\n</ol>\n<h4 id=\"2-1-3-vuex中有几个核心属性，分别是什么？\"><a href=\"#2-1-3-vuex中有几个核心属性，分别是什么？\" class=\"headerlink\" title=\"2.1.3 vuex中有几个核心属性，分别是什么？\"></a>2.1.3 vuex中有几个核心属性，分别是什么？</h4><p>一共有5个核心属性，分别是:</p>\n<ol>\n<li><p><code>state</code> 唯一数据源,Vue 实例中的 data 遵循相同的规则</p>\n</li>\n<li><p><code>getters</code> 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: &#39;...&#39;, done: true },\n      { id: 2, text: &#39;...&#39;, done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n    }\n  }\n})\n\nstore.getters.doneTodos // -&gt; [{ id: 1, text: &#39;...&#39;, done: true }]\n\n</code></pre>\n<ol start=\"3\">\n<li><code>mutation</code> 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发</li>\n</ol>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n\nstore.commit(&#39;increment&#39;)\n</code></pre>\n<ol start=\"4\">\n<li><code>action</code> Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</li>\n</ol>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit(&#39;increment&#39;)\n    }\n  }\n})\n</code></pre>\n<ol start=\"5\">\n<li><code>module</code>  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。</li>\n</ol>\n<pre><code class=\"javascript\">const moduleA = {\n  state: () =&gt; ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: () =&gt; ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -&gt; moduleA 的状态\nstore.state.b // -&gt; moduleB 的状态\n</code></pre>\n<h4 id=\"2-1-4-ajax请求代码应该写在组件的methods中还是vuex的actions中\"><a href=\"#2-1-4-ajax请求代码应该写在组件的methods中还是vuex的actions中\" class=\"headerlink\" title=\"2.1.4 ajax请求代码应该写在组件的methods中还是vuex的actions中\"></a>2.1.4 ajax请求代码应该写在组件的methods中还是vuex的actions中</h4><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p>\n<p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p>\n<h4 id=\"2-1-5-从vuex中获取的数据能直接更改吗？\"><a href=\"#2-1-5-从vuex中获取的数据能直接更改吗？\" class=\"headerlink\" title=\"2.1.5 从vuex中获取的数据能直接更改吗？\"></a>2.1.5 从vuex中获取的数据能直接更改吗？</h4><p>从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错；</p>\n<h4 id=\"2-1-6-vuex中的数据在页面刷新后数据消失\"><a href=\"#2-1-6-vuex中的数据在页面刷新后数据消失\" class=\"headerlink\" title=\"2.1.6 vuex中的数据在页面刷新后数据消失\"></a>2.1.6 vuex中的数据在页面刷新后数据消失</h4><p>用sessionstorage 或者 localstorage 存储数据</p>\n<pre><code>存储： sessionStorage.setItem( &#39;名&#39;, JSON.stringify(值) )\n使用： sessionStorage.getItem(&#39;名&#39;) ---得到的值为字符串类型，用JSON.parse()去引号；\n</code></pre><blockquote>\n<p>也可以引入插件vuex-persist，使用方法如下：</p>\n</blockquote>\n<ul>\n<li><p>安装</p>\n<pre><code class=\"javascript\">npm install --save vuex-persist\nor\nyarn add vuex-persist\n</code></pre>\n</li>\n<li><p>引入</p>\n<pre><code class=\"javascript\">import VuexPersistence from &#39;vuex-persist&#39;\n</code></pre>\n</li>\n<li><p>先创建一个对象并进行配置</p>\n<pre><code class=\"javascript\">const vuexLocal = new VuexPersistence({\n  storage: window.localStorage\n})\n</code></pre>\n</li>\n<li><p>引入进vuex插件</p>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\nstate: { ... },\nmutations: { ... },\nactions: { ... },\nplugins: [vuexLocal.plugin]\n}) \n</code></pre>\n<p>通过以上设置，在图3中各个页面之间跳转，如果刷新某个视图，数据并不会丢失，依然存在，并且不需要在每个 mutations 中手动存取 storage 。</p>\n</li>\n</ul>\n<h4 id=\"2-1-7-Vuex的严格模式是什么-有什么作用-怎么开启？\"><a href=\"#2-1-7-Vuex的严格模式是什么-有什么作用-怎么开启？\" class=\"headerlink\" title=\"2.1.7 Vuex的严格模式是什么,有什么作用,怎么开启？\"></a>2.1.7 Vuex的严格模式是什么,有什么作用,怎么开启？</h4><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。<br>在Vuex.Store 构造器选项中开启,如下</p>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\n    strict:true,\n})\n</code></pre>\n<h4 id=\"2-1-8-怎么在组件中批量使用Vuex的getter属性\"><a href=\"#2-1-8-怎么在组件中批量使用Vuex的getter属性\" class=\"headerlink\" title=\"2.1.8 怎么在组件中批量使用Vuex的getter属性\"></a>2.1.8 怎么在组件中批量使用Vuex的getter属性</h4><p>使用<code>mapGetters</code>辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>\n<pre><code>import {mapGetters} from &#39;vuex&#39;\nexport default{\n    computed:{\n        ...mapGetters([&#39;total&#39;,&#39;discountTotal&#39;])\n    }\n}\n</code></pre><h4 id=\"2-1-9-组件中重复使用mutation\"><a href=\"#2-1-9-组件中重复使用mutation\" class=\"headerlink\" title=\"2.1.9 组件中重复使用mutation\"></a>2.1.9 组件中重复使用mutation</h4><p>使用<code>mapMutations</code>辅助函数,在组件中这么使用</p>\n<pre><code class=\"vue\">import { mapMutations } from &#39;vuex&#39;\nmethods:{\n    ...mapMutations({\n        setNumber:&#39;SET_NUMBER&#39;,\n    })\n}\n</code></pre>\n<p>然后调用this.setNumber(10)相当调用this.$store.commit(&#39;SET_NUMBER&#39;,10)</p>\n<h4 id=\"2-1-10-mutation和action有什么区别\"><a href=\"#2-1-10-mutation和action有什么区别\" class=\"headerlink\" title=\"2.1.10 mutation和action有什么区别\"></a>2.1.10 mutation和action有什么区别</h4><ul>\n<li>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</li>\n<li>action 可以包含任意异步操作。mutation只能是同步操作</li>\n<li>提交方式不同</li>\n</ul>\n<blockquote>\n<p>action 是用this.store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。</p>\n<p>mutation是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交</p>\n</blockquote>\n<ul>\n<li>接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了<pre><code>{\n  state,      // 等同于 `store.state`，若在模块中则为局部状态\n  rootState,  // 等同于 `store.state`，只存在于模块中\n  commit,     // 等同于 `store.commit`\n  dispatch,   // 等同于 `store.dispatch`\n  getters,    // 等同于 `store.getters`\n  rootGetters // 等同于 `store.getters`，只存在于模块中\n}\n</code></pre></li>\n</ul>\n<h4 id=\"2-1-11-在v-model上怎么用Vuex中state的值？\"><a href=\"#2-1-11-在v-model上怎么用Vuex中state的值？\" class=\"headerlink\" title=\"2.1.11 在v-model上怎么用Vuex中state的值？\"></a>2.1.11 在v-model上怎么用Vuex中state的值？</h4><p>需要通过computed计算属性来转换。</p>\n<pre><code>&lt;input v-model=&quot;message&quot;&gt;\n// ...\ncomputed: {\n  message: {\n    get () {\n        return this.$store.state.message\n    },\n    set (value) {\n        this.$store.commit(&#39;updateMessage&#39;, value)\n    }\n  }\n}\n</code></pre><h3 id=\"2-2-路由页面管理（vue-router）\"><a href=\"#2-2-路由页面管理（vue-router）\" class=\"headerlink\" title=\"2.2 路由页面管理（vue-router）\"></a>2.2 路由页面管理（vue-router）</h3><h4 id=\"2-2-1-什么是vue-router\"><a href=\"#2-2-1-什么是vue-router\" class=\"headerlink\" title=\"2.2.1 什么是vue-router\"></a>2.2.1 什么是vue-router</h4><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>\n<ul>\n<li>嵌套的路由/视图表</li>\n<li>模块化的、基于组件的路由配置</li>\n<li>路由参数、查询、通配符</li>\n<li>基于 Vue.js 过渡系统的视图过渡效果</li>\n<li>细粒度的导航控制</li>\n<li>带有自动激活的 CSS class 的链接</li>\n<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>\n<li>自定义的滚动条行为</li>\n</ul>\n<h4 id=\"2-2-2-怎么使用vue-router\"><a href=\"#2-2-2-怎么使用vue-router\" class=\"headerlink\" title=\"2.2.2 怎么使用vue-router\"></a>2.2.2 怎么使用vue-router</h4><ol>\n<li>第一步安装<pre><code>npm install vue-router -S\n</code></pre></li>\n<li>第二步在main.js中使用Vue Router组件<br><code>`</code>javascript<br>import Vue from &#39;vue&#39;<br>import App from &#39;./App.vue&#39;<br>import VueRouter from &#39;vue-router&#39;<br>Vue.use(VueRouter)</li>\n</ol>\n<p>new Vue({<br>  el: &#39;#app&#39;,<br>  render: h=&gt; h(App)<br>})</p>\n<pre><code>\n3. 第三步配置路由\n\n* 定义 (路由) 组件\n路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。如下\n```javascript\n// 1.定义组件（导入组件）\nimport Home from &#39;./components/home.vue&#39;\nimport News from &#39;.components/news.vue&#39;\n</code></pre><ul>\n<li>定义路由（路由对象数组）<br>定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。如下：<pre><code class=\"javascript\">// 2.定义路由\nconst routes = [\n{ path: &#39;/home&#39;, components: Home },\n{ path: &#39;/news&#39;, components: News },\n{ path: &#39;*&#39;, redirect: &#39;/home&#39; }, // 表示没有匹配到，是默认重定向到home组件\n]\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>实例化Vue Router对象<br>调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。如下<pre><code class=\"javascript\">// 3. 实例化Vue Router\nconst router = new VueRouter({routes}) // 此处相当于routes: routes\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>挂载根实例<pre><code class=\"javascript\">// 4. 挂载根实例\nnew Vue({\nel: &#39;#app&#39;,\nrouter,\nrender: h =&gt; h(App)\n})\n</code></pre>\n</li>\n</ul>\n<p>第四步在App.vue中使用路由<br>在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。如下：</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;\n    &lt;router-link to=&quot;/news&quot;&gt;News&lt;/router-link&gt;\n    &lt;br /&gt;\n    &lt;router-view&gt;&lt;/router-view&gt; /* 显示组件的内容 */\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<h4 id=\"2-2-3-怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\"><a href=\"#2-2-3-怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\" class=\"headerlink\" title=\"2.2.3 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\"></a>2.2.3 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数</p>\n<h4 id=\"2-2-4-vue-router的导航钩子\"><a href=\"#2-2-4-vue-router的导航钩子\" class=\"headerlink\" title=\"2.2.4 vue-router的导航钩子\"></a>2.2.4 vue-router的导航钩子</h4><p>常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：</p>\n<ul>\n<li>全局导航钩子：router.beforeEach(to,from,next)</li>\n<li>组件内的钩子</li>\n<li>单独路由独享组件</li>\n</ul>\n<h4 id=\"2-2-5-vue路由传参\"><a href=\"#2-2-5-vue路由传参\" class=\"headerlink\" title=\"2.2.5 vue路由传参\"></a>2.2.5 vue路由传参</h4><ul>\n<li>页面刷新数据不会丢失</li>\n</ul>\n<pre><code class=\"javascript\">methods: {\n  jump(id) {\n    // 直接调用$router.push实现携带参数的跳转\n    this.$router.push({\n      path: `/particulars/${id}`\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: &#39;/particulars/:id&#39;,\n  name: &#39;particulars&#39;,\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.params.id\n</code></pre>\n<ul>\n<li>使用params方式传入的参数<blockquote>\n<p>这种方法页面刷新数据会丢失</p>\n<p>通过路由属性中的name来确定匹配的路由，通过params来传递参数<br><code>`</code>javascript<br>methods: {<br>jump(id) {<br>  this.$router.push({</p>\n<pre><code>path: &#39;/particulars&#39;,\nparams: {\n  id: id\n}\n</code></pre><p>  })<br>}<br>}</p>\n</blockquote>\n</li>\n</ul>\n<p>// 对应路由配置<br>{<br>  path: &#39;/particulars&#39;,<br>  name: &#39;particulars&#39;,<br>  component: particulars<br>}</p>\n<p>// 对应子组件：这样来获取参数<br>this.$route.params.id</p>\n<pre><code>\n* 使用query方法传入的参数\n&gt; 使用path来匹配路由，然后通过query来传递参数\n&gt;\n&gt; 这种情况下，query传递的参数会显示在url后面?id=?\n```javascript\nmethods: {\n  jump(id) {\n    this.$router.push({\n      path: &#39;/particulars&#39;,\n      query: {\n        id: id\n      }\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: &#39;/particulars&#39;,\n  name: &#39;particulars&#39;,\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.query.id\n</code></pre><h4 id=\"2-2-6-router和route的区别\"><a href=\"#2-2-6-router和route的区别\" class=\"headerlink\" title=\"2.2.6 router和route的区别\"></a>2.2.6 router和route的区别</h4><ul>\n<li><p><code>route</code>为当前router跳转对象里面可以获取name、path、query、params等</p>\n</li>\n<li><p><code>router</code>为VueRouter实例，想要导航到不同URL，则使用router.push方法</p>\n</li>\n</ul>\n<h4 id=\"2-2-7-路由-TypeError-Cannot-read-property-39-matched-39-of-undefined-的错误问题\"><a href=\"#2-2-7-路由-TypeError-Cannot-read-property-39-matched-39-of-undefined-的错误问题\" class=\"headerlink\" title=\"2.2.7 路由 TypeError: Cannot read property &#39;matched&#39; of undefined 的错误问题\"></a>2.2.7 路由 TypeError: Cannot read property &#39;matched&#39; of undefined 的错误问题</h4><p>找到入口文件main.js里的new Vue()，必须使用router名，不能把router改成Router或者其他的别名</p>\n<pre><code class=\"javascript\">// 引入路由\nimport router from &#39;./routers/router.js&#39;\n\nnew Vue({\n    el: &#39;#app&#39;,\n    router,    // 这个名字必须使用router\n    render: h =&gt; h(App)\n});\n</code></pre>\n<h4 id=\"2-2-8-路由按需加载\"><a href=\"#2-2-8-路由按需加载\" class=\"headerlink\" title=\"2.2.8 路由按需加载\"></a>2.2.8 路由按需加载</h4><p>随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候，路由按需加载就闪亮登场了。</p>\n<pre><code class=\"javascript\">// webpack&lt; 2.4 时\n{ \n    path:&#39;/&#39;, \n    name:&#39;home&#39;,\n    components:resolve=&gt;require([&#39;@/components/home&#39;],resolve)\n} \n\n// webpack&gt; 2.4 时\n{ \n    path:&#39;/&#39;, \n    name:&#39;home&#39;, \n    components:()=&gt;import(&#39;@/components/home&#39;)\n}\n</code></pre>\n<p>import()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</p>\n<h4 id=\"2-2-9-Vue里面router-link在电脑上有用，在安卓上没反应怎么解决\"><a href=\"#2-2-9-Vue里面router-link在电脑上有用，在安卓上没反应怎么解决\" class=\"headerlink\" title=\"2.2.9 Vue里面router-link在电脑上有用，在安卓上没反应怎么解决\"></a>2.2.9 Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</h4><p>Vue路由在Android机上有问题，babel问题，安装<code>babel polypill</code>插件解决</p>\n<h4 id=\"2-2-10-Vue2中注册在router-link上事件无效解决方法\"><a href=\"#2-2-10-Vue2中注册在router-link上事件无效解决方法\" class=\"headerlink\" title=\"2.2.10 Vue2中注册在router-link上事件无效解决方法\"></a>2.2.10 Vue2中注册在router-link上事件无效解决方法</h4><ul>\n<li>使用<a href=\"mailto:``@click.native\" target=\"_blank\" rel=\"noopener\">``@click.native</a><code></code>。</li>\n<li>原因：router-link会阻止click事件，.native指直接监听一个原生事件</li>\n</ul>\n<h4 id=\"2-2-11-RouterLink在IE和Firefox中不起作用（路由不跳转）的问题\"><a href=\"#2-2-11-RouterLink在IE和Firefox中不起作用（路由不跳转）的问题\" class=\"headerlink\" title=\"2.2.11 RouterLink在IE和Firefox中不起作用（路由不跳转）的问题\"></a>2.2.11 RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</h4><ul>\n<li>只用a标签，不使用button标签</li>\n<li>使用button标签和Router.navigate方法</li>\n</ul>\n<h3 id=\"2-3-网络请求-axios\"><a href=\"#2-3-网络请求-axios\" class=\"headerlink\" title=\"2.3 网络请求(axios)\"></a>2.3 网络请求(axios)</h3><p>axios的二次封装，主要包括请求之前、返回响应以及使用等</p>\n<h4 id=\"2-3-1-请求之前\"><a href=\"#2-3-1-请求之前\" class=\"headerlink\" title=\"2.3.1 请求之前\"></a>2.3.1 请求之前</h4><p>一般的接口都会有鉴权认证（token）之类的，因此在接口的请求头里面，我们需要带上token值以通过服务器的鉴权认证。但是如果每次请求的时候再去添加，不仅会大大的加大工作量，而且很容易出错。好在axios提供了拦截器机制，我们在请求的拦截器中可以添加token。</p>\n<pre><code class=\"javascript\">// 请求拦截\naxios.interceptors.request.use((config) =&gt; {\n  // ...省略代码\n  config.headers.x_access_token = token\n  return config\n}, function (error) =&gt; {\n  return Promise.reject(error)\n})\n</code></pre>\n<p>当然请求拦截器中，除了处理添加token以外，还可以进行一些其他的处理，具体的根据实际需求进行处理。</p>\n<h4 id=\"2-3-2-响应之后\"><a href=\"#2-3-2-响应之后\" class=\"headerlink\" title=\"2.3.2 响应之后\"></a>2.3.2 响应之后</h4><p>请求接口，并不是每一次请求都会成功。那么当接口请求失败的时候，我们又怎么处理呢？每次请求的时候处理？封装axios统一处理？应该选择封装axios进行统一处理。axios不仅提供了请求的拦截器，其也提供了响应的拦截器。在此处，可以获取到服务器返回的状态码，然后根据状态码进行相对应的操作。</p>\n<pre><code class=\"javascript\">// 响应拦截\naxios.interceptors.response.use(function (response) {\n  if (response.data.code === 401) {\n    // 用户token失效\n    // 清空用户信息\n    sessionStorage.user = &#39;&#39;\n    sessionStorage.token = &#39;&#39;\n    window.location.href = &#39;/&#39; // 返回登录页\n    return Promise.reject(msg) // 接口Promise返回错误状态，错误信息msg可由后端返回，也可以我们自己定义一个码--信息的关系。\n  }\n  if (response.status !== 200 || response.data.code !== 200) {\n    // 接口请求失败，具体根据实际情况判断\n    message.error(mes) // 提示错误信息\n    return Promise.reject(msg) // 接口Promise返回错误状态\n  }\n  return response\n}, function (error) {\n  if (axios.isCancel(error)) {\n    requestList.length = 0\n    // store.dispatch(&#39;changeGlobalState&#39;, { loading: false })\n    throw new axios.Cancel(&#39;cancel request&#39;)\n  } else {\n    message.error(&#39;网络请求失败，请重试&#39;)\n  }\n  return Promise.reject(error)\n})\n\n</code></pre>\n<p>当然响应拦截器同请求拦截器一样，还可以进行一些其他的处理，具体的根据实际需求进行处理。</p>\n<h4 id=\"2-3-3-使用axios\"><a href=\"#2-3-3-使用axios\" class=\"headerlink\" title=\"2.3.3 使用axios\"></a>2.3.3 使用axios</h4><p>axios使用的时候一般有三种方式：</p>\n<ul>\n<li><p>执行get请求</p>\n<pre><code class=\"javascript\">axios.get(&#39;url&#39;, {\nparams: {} // 接口参数\n}).then(function(res){\nconsole.log(res) // 处理成功的函数，相当于success\n}).catch(function(error) {\nconsole.log(error) // 错误处理，相当于error\n})\n</code></pre>\n</li>\n<li><p>执行post请求</p>\n<pre><code class=\"javascript\">axios.post(&#39;url&#39;, \n{\n  data: xxx // 参数\n},\n{\n  headers: xxx //请求头信息\n}).then(function(res) {\nconsole.log(res) // 处理成功的函数，相当于success\n}).catch(function(error) {\nconsole.log(error) // 错误处理，相当于error\n})\n</code></pre>\n</li>\n<li><p>axios API通过相关配置传递给axios完成请求<br><code>`</code>javascript<br>axios({<br>method: &#39;delete&#39;,<br>url: &#39;xxx&#39;,<br>cache: false,<br>params: { id: 123 },<br>headers: xxx<br>})</p>\n</li>\n</ul>\n<p>/<em> ----------------------- </em>/<br>axios({<br>  method: &#39;post&#39;,<br>  url: &#39;/user/12345&#39;,<br>  data: {<br>    firstName: &#39;monkey&#39;,<br>    lastName: &#39;soft&#39;<br>  }<br>})</p>\n<pre><code>\n直接使用api的方式虽然简单，但是不同请求参数的名字不一样，在实际开发过程中很容易写错或者忽略，容易为开发造成不必要的时间损失。\n\n前面两种方式虽然没有参数不一致的问题，但是使用的时候，太过于麻烦，那么怎么办呢？\n\n前面两种虽然过于麻烦，但是仔细观察，是可以发现有一定的相似点，我们便可以给予这些相似点二次封装，形成适合我们使用的一个请求函数。\n```javascript\n/* \n*url: 请求的url\n*params: 请求的参数\n*config: 请求时的header信息\n*method: 请求方法\n*/\nconst request = function({ url, params, config, method }) {\n  // 如果是get请求，需要拼接参数\n  let str = &#39;&#39;\n  if(method === &#39;get&#39; &amp;&amp; params) {\n    Object.keys(params).forEach(item =&gt; {\n      str += `${item}=${params[item]$}`\n    })\n  }\n  return new Promise((resolve, reject) =&gt; {\n    axios[method](str ? (url + &#39;?&#39; + str.substring(0, str.length - 1)) : url, params, Object.assign({}, config)).then(response =&gt; {\n      resolve(response.data)\n    }, err =&gt; {\n      if(err.Cancel) {\n\n      } else {\n        reject(err)\n      }\n    }).catch(err =&gt; {\n      reject(err)\n    })\n  })\n}\n\n</code></pre><h3 id=\"2-4-视频播放-video-js\"><a href=\"#2-4-视频播放-video-js\" class=\"headerlink\" title=\"2.4 视频播放(video.js)\"></a>2.4 视频播放(video.js)</h3><p><a href=\"https://juejin.cn/post/6850037269227634702\" target=\"_blank\" rel=\"noopener\">视频播放video.js</a></p>\n<h3 id=\"2-5-vue常用ui库\"><a href=\"#2-5-vue常用ui库\" class=\"headerlink\" title=\"2.5 vue常用ui库\"></a>2.5 vue常用ui库</h3><h4 id=\"2-5-1-移动端\"><a href=\"#2-5-1-移动端\" class=\"headerlink\" title=\"2.5.1 移动端\"></a>2.5.1 移动端</h4><ul>\n<li><a href=\"http://mint-ui.github.io/#!/zh-cn\" target=\"_blank\" rel=\"noopener\">mint-ui</a></li>\n<li><a href=\"https://youzan.github.io/vant/#/zh-CN/home\" target=\"_blank\" rel=\"noopener\">Vant</a></li>\n<li><a href=\"https://vux.li/\" target=\"_blank\" rel=\"noopener\">VUX</a></li>\n</ul>\n<h4 id=\"2-5-2-pc端\"><a href=\"#2-5-2-pc端\" class=\"headerlink\" title=\"2.5.2 pc端\"></a>2.5.2 pc端</h4><ul>\n<li><a href=\"https://element.eleme.cn/2.13/#/zh-CN/component/installation\" target=\"_blank\" rel=\"noopener\">element-ui</a></li>\n<li><a href=\"https://www.antdv.com/docs/vue/introduce-cn/\" target=\"_blank\" rel=\"noopener\">Ant Design of Vue</a></li>\n<li><a href=\"https://avuejs.com/\" target=\"_blank\" rel=\"noopener\">Avue</a></li>\n</ul>\n<h2 id=\"3-常用webpack配置\"><a href=\"#3-常用webpack配置\" class=\"headerlink\" title=\"3. 常用webpack配置\"></a>3. 常用webpack配置</h2><blockquote>\n<p>vue-lic3脚手架（vue.config.js）</p>\n</blockquote>\n<h3 id=\"3-1-publicPath\"><a href=\"#3-1-publicPath\" class=\"headerlink\" title=\"3.1 publicPath\"></a>3.1 publicPath</h3><ul>\n<li>类型：String</li>\n<li>默认：&#39;/&#39;</li>\n</ul>\n<p>部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如<a href=\"https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/\" target=\"_blank\" rel=\"noopener\">https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/</a></p>\n<p>这个值也可以被设置为空字符串 (&#39;&#39;) 或是相对路径 (&#39;./&#39;)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p>\n<h3 id=\"3-2-productionSourceMap\"><a href=\"#3-2-productionSourceMap\" class=\"headerlink\" title=\"3.2 productionSourceMap\"></a>3.2 productionSourceMap</h3><ul>\n<li>类型：boolean</li>\n<li>默认：true</li>\n</ul>\n<p>不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积</p>\n<blockquote>\n<p>注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便</p>\n</blockquote>\n<h3 id=\"3-3-assetsDir\"><a href=\"#3-3-assetsDir\" class=\"headerlink\" title=\"3.3 assetsDir\"></a>3.3 assetsDir</h3><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是&#39;&#39;,</p>\n<h3 id=\"3-4-indexPath\"><a href=\"#3-4-indexPath\" class=\"headerlink\" title=\"3.4 indexPath\"></a>3.4 indexPath</h3><p>指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是&#39;index.html&#39;</p>\n<h3 id=\"3-5-lintOnSave\"><a href=\"#3-5-lintOnSave\" class=\"headerlink\" title=\"3.5 lintOnSave\"></a>3.5 lintOnSave</h3><p>是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用</p>\n<h3 id=\"3-6-css\"><a href=\"#3-6-css\" class=\"headerlink\" title=\"3.6 css\"></a>3.6 css</h3><pre><code class=\"javascript\">css: {\n  // 是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，\n  extract: true,\n  sourceMap: false, // 效果同上\n  modules: false, // 为所有的 CSS 及其预处理文件开启 CSS Modules。\n  // 这个选项不会影响 `*.vue` 文件。\n},\n</code></pre>\n<h3 id=\"3-7-devServer\"><a href=\"#3-7-devServer\" class=\"headerlink\" title=\"3.7 devServer\"></a>3.7 devServer</h3><p>本地开发服务器配置，此处直接贴上我常用的配置，以注释的方式介绍</p>\n<pre><code class=\"javascript\">devServer: { \n  // 配置开发服务器\n  host: &quot;0.0.0.0&quot;,\n  // 是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果\n  hot: true,\n  // 服务启动端口\n  port: &quot;8080&quot;,\n  // 是否自动打开浏览器默认为false\n  open: false,\n  // 配置http代理\n  proxy: { \n    &quot;/api&quot;: { \n      //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在ajax中使用/api/api1路径,其请求路径会解析\n      // http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;\n      target: &quot;http://192.168.0.118:9999&quot;,\n      //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意\n      changeOrigin: true,\n      pathRewrite: {\n          //把多余的路径置为&#39;&#39;\n        &quot;api&quot;: &quot;&quot;\n      }\n    },\n    &quot;/api2&quot;: {//可以配置多个代理，匹配上那个就使用哪种解析方式\n      target: &quot;http://api2&quot;,\n      // ...\n    }\n  }\n},\n</code></pre>\n<h3 id=\"3-8-pluginOptions\"><a href=\"#3-8-pluginOptions\" class=\"headerlink\" title=\"3.8 pluginOptions\"></a>3.8 pluginOptions</h3><p>这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：</p>\n<pre><code class=\"javascript\">{\n  //定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了\n  &#39;style-resources-loader&#39;: {\n    preProcessor: &#39;less&#39;,\n    patterns: [\n      &#39;./src/assets/public.less&#39;\n    ]\n  }\n}\n</code></pre>\n<h3 id=\"3-9-chainWebpack\"><a href=\"#3-9-chainWebpack\" class=\"headerlink\" title=\"3.9 chainWebpack\"></a>3.9 chainWebpack</h3><p>是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：</p>\n<pre><code class=\"javascript\">chainWebpack(config) { \n//添加一个路径别名 假设有在assets/img/menu/目录下有十张图片，如果全路径require(&quot;/assets/img/menu/img1.png&quot;)\n//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了\n    config.resolve.alias\n      //添加多个别名支持链式调用\n      .set(&quot;assets&quot;, path.join(__dirname, &quot;/src/assets&quot;))\n      .set(&quot;img&quot;, path.join(__dirname, &quot;/src/assets/img/menu&quot;))\n      //引入图片时只需require(&quot;img/img1.png&quot;);即可\n}\n</code></pre>\n<h2 id=\"4-webpack优化\"><a href=\"#4-webpack优化\" class=\"headerlink\" title=\"4. webpack优化\"></a>4. webpack优化</h2><p><a href=\"https://segmentfault.com/a/1190000022205477\" target=\"_blank\" rel=\"noopener\">带你深度解锁Webpack系列(优化篇)</a></p>\n<p><a href=\"https://www.cnblogs.com/zhurong/p/12603887.html\" target=\"_blank\" rel=\"noopener\">vue-cli中Webpack配置优化（一）</a></p>\n<p><a href=\"https://www.cnblogs.com/zhurong/p/12611360.html#_label2_1_3\" target=\"_blank\" rel=\"noopener\">vue-cli中Webpack配置优化（二）</a></p>\n<h3 id=\"4-1-量化\"><a href=\"#4-1-量化\" class=\"headerlink\" title=\"4.1 量化\"></a>4.1 量化</h3><h4 id=\"4-1-1-speed-measure-webpack-plugin\"><a href=\"#4-1-1-speed-measure-webpack-plugin\" class=\"headerlink\" title=\"4.1.1 speed-measure-webpack-plugin\"></a>4.1.1 speed-measure-webpack-plugin</h4><p><code>speed-measure-webpack-plugin</code> 插件可以测量各个插件和<code>loader</code>所花费的时间，使用之后，构建时，会得到类似下面这样的信息：</p>\n<p><img src=\"https://image-static.segmentfault.com/334/233/3342331922-6a0fde0ed940ffa7_fix732\" alt></p>\n<blockquote>\n<p>Vue-cli 2.x</p>\n</blockquote>\n<pre><code class=\"js\">//webpack.config.js\nconst SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);\nconst smp = new SpeedMeasurePlugin();\n\nconst config = {\n    //...webpack配置\n}\n\nmodule.exports = smp.wrap(config);\n</code></pre>\n<blockquote>\n<p>Vue-cli 3.x（主要区别是包裹 configureWebpack ）</p>\n</blockquote>\n<pre><code class=\"js\">const SpeedMeasurePlugin = require(&#39;speed-measure-webpack-plugin&#39;)\nconst smp = new SpeedMeasurePlugin({\n  outputFormat: &#39;human&#39;\n})\nmodule.exports = {\n  configureWebpack: smp.wrap({\n    plugins: []\n  })\n}\n</code></pre>\n<h4 id=\"4-1-2-webpack-bundle-analyzer\"><a href=\"#4-1-2-webpack-bundle-analyzer\" class=\"headerlink\" title=\"4.1.2 webpack-bundle-analyzer\"></a>4.1.2 webpack-bundle-analyzer</h4><p>这个是分析打包后，各个文件的大小，用于分析bundle的</p>\n<blockquote>\n<p>安装</p>\n</blockquote>\n<pre><code>npm i webpack-bundle-analyzer -D\n</code></pre><p>在 Vue-cli 3.x 下，安装这个包会报错，是因为用 Vue-cli 3.x 构建的项目在 node_modules 中已经存在，但是项目的 package.json 中没有引用。</p>\n<p>需要在 node_modules 中删除这个包，重新安装就可以。</p>\n<blockquote>\n<p>使用：（下面是vue-cli 3.x）</p>\n</blockquote>\n<pre><code>const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin\n\n  configureWebpack: smp.wrap({\n    plugins: [\n      // 这个要放在所有 plugins 最后\n      new BundleAnalyzerPlugin()\n    ]\n  })\n</code></pre><p>在构建完成后，会直接启动一个服务，有一个可视化的界面查看构建后的bundle。</p>\n<h3 id=\"4-2-缓存\"><a href=\"#4-2-缓存\" class=\"headerlink\" title=\"4.2 缓存\"></a>4.2 缓存</h3><h4 id=\"4-2-1-cache-loader\"><a href=\"#4-2-1-cache-loader\" class=\"headerlink\" title=\"4.2.1 cache-loader\"></a>4.2.1 cache-loader</h4><p>在一些性能开销较大的<code>loader</code>前面添加<code>cache-loader</code>，将结果缓存在磁盘中</p>\n<blockquote>\n<p>安装：</p>\n</blockquote>\n<pre><code>npm install cache-loader -D\n</code></pre><blockquote>\n<p>使用：</p>\n<p>在vue-cli2.x 中</p>\n</blockquote>\n<pre><code class=\"js\">module.exports = {\n    //...\n    module: {\n        //我的项目中,babel-loader耗时比较长，所以我给它配置了`cache-loader`\n        rules: [\n            {\n                test: /\\.jsx?$/,\n                use: [&#39;cache-loader&#39;,&#39;babel-loader&#39;]\n            }\n        ]\n    }\n}\n</code></pre>\n<blockquote>\n<p>在vue-cli3.x中，这个配置是默认的配置，分别对：<code>vue-loader</code>、<code>babel-loader</code>两个进行了缓存，其他的需要缓存再自己配置。</p>\n</blockquote>\n<h4 id=\"4-2-2-hard-source-webpack-plugin\"><a href=\"#4-2-2-hard-source-webpack-plugin\" class=\"headerlink\" title=\"4.2.2 hard-source-webpack-plugin\"></a>4.2.2 hard-source-webpack-plugin</h4><p>这个是为模块提供中间缓存，效率提升很大。</p>\n<blockquote>\n<p>安装</p>\n</blockquote>\n<pre><code>npm i hard-source-webpack-plugin -D\n</code></pre><blockquote>\n<p>使用</p>\n</blockquote>\n<p>直接在 plugins 中 new就可以。</p>\n<pre><code class=\"js\">const HardSourceWebpackPlugin = require(&#39;hard-source-webpack-plugin&#39;)\nmodule.exports = {\n  configureWebpack: smp.wrap({\n    plugins: [\n      // 为模块提供中间缓存，缓存路径是：node_modules/.cache/hard-source\n      new HardSourceWebpackPlugin(),\n      new BundleAnalyzerPlugin()\n    ]\n  })\n}\n</code></pre>\n<p>构建后效果：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111737573-1701609808.png\" alt></p>\n<p><img src=\"https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111750107-1452016351.png\" alt></p>\n<p><img src=\"https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111800199-1571336442.png\" alt></p>\n<p>上面三幅图，分别是配置后第一次、第二次、第三次构建的，第三次构建可以达到80%的提升。</p>\n<h3 id=\"4-3-exclude-include\"><a href=\"#4-3-exclude-include\" class=\"headerlink\" title=\"4.3 exclude/include\"></a>4.3 exclude/include</h3><p>我们可以通过<code>exclue</code>、<code>include</code>配置来确保转移尽可能少的文件。顾名思义，<code>exclude</code>指定要排除的文件，<code>include</code>指定要包含的文件。</p>\n<p><code>exclude</code>的优先级高于<code>include</code>，在<code>include</code>和<code>exclude</code>中使用绝对路径数组，尽量避免<code>exclude</code>，更倾向于使用<code>include</code>。</p>\n<pre><code class=\"js\">//webpack.config.js\nconst path = require(&#39;path&#39;);\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.js[x]?$/,\n                use: [&#39;babel-loader&#39;],\n                include: [path.resolve(__dirname, &#39;src&#39;)]\n            }\n        ]\n    },\n}\n</code></pre>\n<p>下图是未配置<code>include</code>和配置了<code>include</code>的构建结果对比：</p>\n<p><img src=\"https://image-static.segmentfault.com/341/005/3410059882-f459f782062d01e1_fix732\" alt></p>\n<h2 id=\"5-历史好文推荐\"><a href=\"#5-历史好文推荐\" class=\"headerlink\" title=\"5. 历史好文推荐\"></a>5. 历史好文推荐</h2><ol>\n<li><a href=\"https://juejin.im/post/6850418118695583758\" target=\"_blank\" rel=\"noopener\">【万字长文】史上最强css、html总结~看完涨薪不再是梦</a></li>\n<li><a href=\"https://juejin.im/post/6854573211451932685\" target=\"_blank\" rel=\"noopener\">【万字长文】最全JavaScript基础总结~建议收藏</a></li>\n<li><a href=\"https://juejin.im/post/6847902222882340872\" target=\"_blank\" rel=\"noopener\">Event Loop我知道，宏任务微任务是什么鬼？</a></li>\n<li><a href=\"https://juejin.im/post/6847009771493523464\" target=\"_blank\" rel=\"noopener\">锋利码农武器之vscode</a></li>\n<li><a href=\"https://juejin.im/post/6847009771371888653\" target=\"_blank\" rel=\"noopener\">面试宝典带你走上人生巅峰</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://juejin.cn/post/6850037277675454478#comment\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<h2 id=\"1-vue框架篇\"><a href=\"#1-vue框架篇\" class=\"headerlink\" title=\"1. vue框架篇\"></a>1. vue框架篇</h2><h3 id=\"1-1-vue的优点\"><a href=\"#1-1-vue的优点\" class=\"headerlink\" title=\"1.1 vue的优点\"></a>1.1 vue的优点</h3><ul>\n<li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</li>\n<li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li>\n<li>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</li>\n<li>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</li>\n<li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>\n<li>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</li>\n<li>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</li>\n</ul>\n<h3 id=\"1-2-请详细说下你对vue生命周期的理解？\"><a href=\"#1-2-请详细说下你对vue生命周期的理解？\" class=\"headerlink\" title=\"1.2 请详细说下你对vue生命周期的理解？\"></a>1.2 请详细说下你对vue生命周期的理解？</h3><p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p>\n<blockquote>\n<p><code>创建前/后</code> </p>\n<ol>\n<li>在<code>beforeCreate</code>阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。</li>\n<li>在<code>created</code>阶段，vue实例的数据对象data有了，el为undefined，还未初始化。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><code>载入前/后</code>：</p>\n<ol>\n<li>在<code>beforeMount</code>阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。</li>\n<li>在<code>mounted</code>阶段，vue实例挂载完成，data.message成功渲染。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><code>更新前/后</code>：当data变化时，会触发<code>beforeUpdate</code>和<code>updated</code>方法</p>\n</blockquote>\n<blockquote>\n<p><code>销毁前/后</code>：在执行<code>destroy</code>方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p>\n</blockquote>\n<h3 id=\"1-3-为什么vue组件中data必须是一个函数？\"><a href=\"#1-3-为什么vue组件中data必须是一个函数？\" class=\"headerlink\" title=\"1.3 为什么vue组件中data必须是一个函数？\"></a>1.3 为什么vue组件中data必须是一个函数？</h3><ul>\n<li>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；</li>\n<li>而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</li>\n</ul>\n<h3 id=\"1-4-vue中v-if和v-show有什么区别？\"><a href=\"#1-4-vue中v-if和v-show有什么区别？\" class=\"headerlink\" title=\"1.4 vue中v-if和v-show有什么区别？\"></a>1.4 vue中v-if和v-show有什么区别？</h3><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p>\n<ol>\n<li>手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；</li>\n<li>编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>\n<li>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</li>\n<li>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>\n</ol>\n<blockquote>\n<p>用法推荐：</p>\n<ol>\n<li>v-if更适合带有权限的操作，渲染时判断权限数据，有则展示该功能，没有则删除。</li>\n<li>v-show更适合于日常使用，可以减少数据的渲染，减少不必要的操作。<br>综上，v-if有更高的切换消耗，而v-show有更高的初始渲染消耗。<br>因此，如果需要频繁切换v-show较好，如果在运行时条件不大可能改变，更倾向功能权限性的话v-if较好。</li>\n</ol>\n</blockquote>\n<h3 id=\"1-5-computed和watch的区别\"><a href=\"#1-5-computed和watch的区别\" class=\"headerlink\" title=\"1.5 computed和watch的区别\"></a>1.5 computed和watch的区别</h3><h4 id=\"1-5-1-计算属性computed：\"><a href=\"#1-5-1-计算属性computed：\" class=\"headerlink\" title=\"1.5.1 计算属性computed：\"></a>1.5.1 计算属性computed：</h4><ul>\n<li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li>\n<li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li>\n<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>\n<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>\n<li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li>\n</ul>\n<h4 id=\"1-5-2-侦听属性watch：\"><a href=\"#1-5-2-侦听属性watch：\" class=\"headerlink\" title=\"1.5.2 侦听属性watch：\"></a>1.5.2 侦听属性watch：</h4><ul>\n<li>不支持缓存，数据变，直接会触发相应的操作；</li>\n<li>watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>\n<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>\n<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li>\n</ul>\n<blockquote>\n<ol>\n<li>immediate：组件加载立即触发回调函数执行</li>\n</ol>\n</blockquote>\n<pre><code class=\"javascript\">watch: {\n  firstName: {\n    handler(newName, oldName) {\n      this.fullName = newName + &#39; &#39; + this.lastName;\n    },\n    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法\n    immediate: true\n  }\n}\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler<pre><code class=\"javascript\">watch: {\nobj: {\n handler(newName, oldName) {\n   console.log(&#39;obj.a changed&#39;);\n },\n immediate: true,\n deep: true\n}\n}\n</code></pre>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>优化：我们可以使用字符串的形式监听</p>\n<pre><code class=\"javascript\">watch: {\n  &#39;obj.a&#39;: {\n    handler(newName, oldName) {\n      console.log(&#39;obj.a changed&#39;);\n    },\n    immediate: true,\n    // deep: true\n  }\n}\n</code></pre>\n</blockquote>\n<p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p>\n<h3 id=\"1-6-vue-loader是什么？使用它的用途有哪些？\"><a href=\"#1-6-vue-loader是什么？使用它的用途有哪些？\" class=\"headerlink\" title=\"1.6 vue-loader是什么？使用它的用途有哪些？\"></a>1.6 vue-loader是什么？使用它的用途有哪些？</h3><p>vue文件的一个加载器，跟template/js/style转换成js模块。</p>\n<h3 id=\"1-7-nextTick是什么？\"><a href=\"#1-7-nextTick是什么？\" class=\"headerlink\" title=\"1.7 $nextTick是什么？\"></a>1.7 $nextTick是什么？</h3><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。</p>\n<blockquote>\n<p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p>\n</blockquote>\n<h3 id=\"1-8-v-for-key的作用\"><a href=\"#1-8-v-for-key的作用\" class=\"headerlink\" title=\"1.8 v-for key的作用\"></a>1.8 v-for key的作用</h3><ul>\n<li>当Vue用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用<code>就地复用</code>策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</li>\n<li>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</li>\n<li>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li>\n</ul>\n<h3 id=\"1-9-简述MVVM\"><a href=\"#1-9-简述MVVM\" class=\"headerlink\" title=\"1.9 简述MVVM\"></a>1.9 简述MVVM</h3><ul>\n<li><p><code>MVVM</code>是 <code>Model-View-ViewModel</code> 的缩写。<code>MVVM</code> 是一种设计思想。 </p>\n<blockquote>\n<p><code>Model层</code> 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑<br><code>View层</code> 代表UI组件，它负责将数据模型转化成UI展现出来<br><code>ViewModel</code> 是一个同步 View 和 Model 的对象。</p>\n</blockquote>\n</li>\n<li><p>在 <code>MVVM</code> 架构下， <code>View</code>和 <code>Model</code> 之间并没有直接的联系，而是通过<code>ViewModel</code>进行交互，<code>Model</code>和<code>ViewModel</code>之间的交互是双向的，因此<code>View</code>数据的变化会同步到<code>Model</code>中，而<code>Model</code>数据的变化也会立即反映到<code>View</code>上。</p>\n</li>\n<li><p><code>ViewModel</code>通过双向数据绑定把<code>View层</code>和<code>Model</code>层连接了起来，而<code>View</code>和<code>Model</code>之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作<code>DOM</code>，不需要关注数据状态的同步问题，复杂的数据状态维护完全由<code>MVVM</code>来统一管理。</p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13038962-96704c499078e5b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp\" alt=\"MVVM\"></p>\n<h3 id=\"1-10-Vue的双向数据绑定原理是什么？\"><a href=\"#1-10-Vue的双向数据绑定原理是什么？\" class=\"headerlink\" title=\"1.10 Vue的双向数据绑定原理是什么？\"></a>1.10 Vue的双向数据绑定原理是什么？</h3><p>vue.js 是采用数据劫持结合<code>发布者-订阅者模式</code>的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>\n<ol>\n<li>需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>\n</ol>\n<ol start=\"2\">\n<li>compiler解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>\n</ol>\n<ol start=\"3\">\n<li>Watcher订阅者是Observer和Compiler之间通信的桥梁，主要做的事情是:<ul>\n<li>在自身实例化时往属性订阅器(dep)里面添加自己</li>\n<li>自身必须有一个update()方法</li>\n<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>\n</ol>\n<p><a href=\"https://www.jianshu.com/p/bb5d1bede3ea\" target=\"_blank\" rel=\"noopener\">vue双向绑定原理</a><br><img src=\"https://upload-images.jianshu.io/upload_images/7120480-7d53305530ed75a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\" alt=\"图\"></p>\n<h3 id=\"1-11-组件传值\"><a href=\"#1-11-组件传值\" class=\"headerlink\" title=\"1.11 组件传值\"></a>1.11 组件传值</h3><h4 id=\"1-11-1-父传子\"><a href=\"#1-11-1-父传子\" class=\"headerlink\" title=\"1.11.1 父传子\"></a>1.11.1 父传子</h4><p>通过props传递</p>\n<blockquote>\n<p>父组件： <code>&lt;child value = &#39;传递的数据&#39; /&gt;</code></p>\n<p>子组件: <code>props[&#39;value&#39;]</code>,接收数据,接受之后使用和data中定义数据使用方式一样</p>\n</blockquote>\n<h4 id=\"1-11-2-子传父\"><a href=\"#1-11-2-子传父\" class=\"headerlink\" title=\"1.11.2 子传父\"></a>1.11.2 子传父</h4><p>在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。</p>\n<blockquote>\n<p>父组件： <code>&lt;child @receive = &#39;receive&#39; /&gt;</code></p>\n<p>子组件: this.$emit(&#39;receive&#39;,&#39;传递的数据&#39;)</p>\n</blockquote>\n<h4 id=\"1-11-3-兄弟组件传值\"><a href=\"#1-11-3-兄弟组件传值\" class=\"headerlink\" title=\"1.11.3 兄弟组件传值\"></a>1.11.3 兄弟组件传值</h4><ul>\n<li>通过中央通信 let bus = new Vue()</li>\n</ul>\n<blockquote>\n<p>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送</p>\n</blockquote>\n<blockquote>\n<p>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收</p>\n</blockquote>\n<ul>\n<li>通过vuex</li>\n</ul>\n<h3 id=\"1-12-prop-验证，和默认值\"><a href=\"#1-12-prop-验证，和默认值\" class=\"headerlink\" title=\"1.12 prop 验证，和默认值\"></a>1.12 prop 验证，和默认值</h3><p>我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告</p>\n<pre><code class=\"javascript\">props: {\n    visible: {\n        default: true,\n        type: Boolean,\n        required: true\n    },\n}\n</code></pre>\n<h3 id=\"1-13-请说下封装-vue-组件的过程\"><a href=\"#1-13-请说下封装-vue-组件的过程\" class=\"headerlink\" title=\"1.13 请说下封装 vue 组件的过程\"></a>1.13 请说下封装 vue 组件的过程</h3><ul>\n<li>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</li>\n<li><p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;vue组件&lt;/title&gt;\n  &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app1&quot;&gt;\n      &lt;my-com&gt;&lt;/my-com&gt;\n  &lt;/div&gt;\n  &lt;div id=&quot;app2&quot;&gt;\n      &lt;my-com&gt;&lt;/my-com&gt;\n  &lt;/div&gt;\n\n  &lt;script&gt;\n      /*创建组件*/\n      var myCom = Vue.extend({\n          template: &#39;&lt;div&gt;这是我的组件&lt;/div&gt;&#39;\n      });\n      /*全局注册组件*/\n      Vue.component(&#39;my-com&#39;,myCom);\n\n      /*定义vue实例app1*/\n      var app1 = new Vue({\n          el: &#39;#app1&#39;\n      });\n\n      /*定义vue实例app2*/\n      var app2 = new Vue({\n          el: &#39;#app2&#39;\n      });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"1-14-Vue-js的template编译\"><a href=\"#1-14-Vue-js的template编译\" class=\"headerlink\" title=\"1.14 Vue.js的template编译\"></a>1.14 Vue.js的template编译</h3><p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：</p>\n<blockquote>\n<p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p>\n</blockquote>\n<blockquote>\n<p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p>\n</blockquote>\n<h3 id=\"1-15-scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？\"><a href=\"#1-15-scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？\" class=\"headerlink\" title=\"1.15 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？\"></a>1.15 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h3><p>css的预编译,使用步骤如下：</p>\n<ul>\n<li>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）</li>\n<li>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</li>\n<li>第三步：还是在同一个文件，配置一个module属性</li>\n<li>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”</li>\n</ul>\n<p>特性主要有:</p>\n<ul>\n<li>可以用变量，例如（$变量名称=值）</li>\n<li>可以用混合器，例如（）</li>\n<li>可以嵌套</li>\n</ul>\n<h3 id=\"1-16-vue如何监听对象或者数组某个属性的变化\"><a href=\"#1-16-vue如何监听对象或者数组某个属性的变化\" class=\"headerlink\" title=\"1.16 vue如何监听对象或者数组某个属性的变化\"></a>1.16 vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。<br>解决方式：</p>\n<ul>\n<li><p>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</p>\n<pre><code class=\"javascript\">this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组\nthis.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象\n</code></pre>\n</li>\n<li><p>调用以下几个数组的方法</p>\n<pre><code class=\"javascript\">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()\n</code></pre>\n</li>\n</ul>\n<p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p>\n<h3 id=\"1-17-常用的事件修饰符\"><a href=\"#1-17-常用的事件修饰符\" class=\"headerlink\" title=\"1.17 常用的事件修饰符\"></a>1.17 常用的事件修饰符</h3><ul>\n<li>.stop:阻止冒泡</li>\n<li>.prevent:阻止默认行为.</li>\n<li>.self:仅绑定元素自身触发</li>\n<li>.once: 2.1.4 新增,只触发一次</li>\n<li>.passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</li>\n<li>.sync 修饰符</li>\n</ul>\n<p>从 2.3.0 起vue重新引入了.sync修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下：</p>\n<pre><code>&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;\n</code></pre><p>会被扩展为：</p>\n<pre><code>&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;\n</code></pre><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p>\n<pre><code>this.$emit(&#39;update:foo&#39;, newValue)\n</code></pre><p><a href=\"https://blog.csdn.net/liushijun_/article/details/92426854\" target=\"_blank\" rel=\"noopener\">vue中.sync修饰符</a></p>\n<h3 id=\"1-18-vue如何获取dom\"><a href=\"#1-18-vue如何获取dom\" class=\"headerlink\" title=\"1.18 vue如何获取dom\"></a>1.18 vue如何获取dom</h3><p>先给标签设置一个ref值，再通过this.$refs.domName获取，例如：</p>\n<pre><code>&lt;div ref=&quot;test&quot;&gt;&lt;/div&gt;\n\nconst dom = this.$refs.test\n</code></pre><h3 id=\"1-19-v-on可以监听多个方法吗？\"><a href=\"#1-19-v-on可以监听多个方法吗？\" class=\"headerlink\" title=\"1.19 v-on可以监听多个方法吗？\"></a>1.19 v-on可以监听多个方法吗？</h3><p>是可以的，来个例子：</p>\n<pre><code>&lt;input type=&quot;text&quot; v-on=&quot;{ input:onInput,focus:onFocus,blur:onBlur, }&quot;&gt;\n</code></pre><h3 id=\"1-20-assets和static的区别\"><a href=\"#1-20-assets和static的区别\" class=\"headerlink\" title=\"1.20 assets和static的区别\"></a>1.20 assets和static的区别</h3><p>这两个都是用来存放项目中所使用的静态资源文件。</p>\n<p>两者的区别：</p>\n<ul>\n<li><p><code>assets</code>中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。</p>\n</li>\n<li><p><code>static</code>中的文件则不会被打包。</p>\n</li>\n</ul>\n<blockquote>\n<p>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。</p>\n</blockquote>\n<h3 id=\"1-21slot插槽\"><a href=\"#1-21slot插槽\" class=\"headerlink\" title=\"1.21slot插槽\"></a>1.21slot插槽</h3><p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p>\n<blockquote>\n<p>以下为详细扩展</p>\n</blockquote>\n<h4 id=\"1-21-1-插槽是什么\"><a href=\"#1-21-1-插槽是什么\" class=\"headerlink\" title=\"1.21.1 插槽是什么\"></a>1.21.1 插槽是什么</h4><ul>\n<li>写个父组件：test.vue</li>\n</ul>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;大家好我是父组件&lt;/div&gt;\n    &lt;myslot&gt;\n      &lt;p&gt;测试一下吧内容写在这里了能否显示&lt;/p&gt;\n    &lt;/myslot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<ul>\n<li>写个子组件：myslot.vue</li>\n</ul>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;我是子组件&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n&lt;/script&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>运行代码，发现，最终渲染的效果是</p>\n<blockquote>\n<p>大家好我是父组件</p>\n<p>我是子组件</p>\n</blockquote>\n<p>那如果我想实现显示父组件中p标签的内容怎么办 修改子组件：myslot.vue</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n      &lt;div&gt;我是子组件&lt;/div&gt;\n      &lt;p&gt;现在测试一下slot&lt;/p&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n&lt;/script&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>运行代码，可以看到以下效果</p>\n<blockquote>\n<p>大家好我是父组件<br>我是子组件<br>现在测试一下slot<br>测试一下吧内容写在这里了能否显示</p>\n</blockquote>\n<p>官方文档对于插槽的应用场景是这样描述的: 我们经常需要向一个组件传递内容 Vue 自定义的 <code>&lt;slot&gt;</code> 元素让这变得非常简单 只要在需要的地方加入插槽就行了——就这么简单！<br>结合上面的例子来理解就是这样的： </p>\n<ol>\n<li>父组件在引用子组件时希望向子组件传递模板内容<code>&lt;p&gt;</code>测试一下吧内容写在这里了能否显示<code>&lt;/p&gt;</code> </li>\n<li>子组件让父组件传过来的模板内容在所在的位置显示 </li>\n<li>子组件中的<code>&lt;slot&gt;</code>就是一个槽，可以接收父组件传过来的模板内容，<code>&lt;slot&gt;</code> 元素自身将被替换 </li>\n<li><code>&lt;myslot&gt;&lt;/myslot&gt;</code>组件没有包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃</li>\n</ol>\n<h4 id=\"1-21-2-插槽的作用\"><a href=\"#1-21-2-插槽的作用\" class=\"headerlink\" title=\"1.21.2 插槽的作用\"></a>1.21.2 插槽的作用</h4><p>让用户可以拓展组件，去更好地复用组件和对其做定制化处理</p>\n<h4 id=\"1-21-3-插槽的分类\"><a href=\"#1-21-3-插槽的分类\" class=\"headerlink\" title=\"1.21.3 插槽的分类\"></a>1.21.3 插槽的分类</h4><h5 id=\"1-21-3-1-默认插槽\"><a href=\"#1-21-3-1-默认插槽\" class=\"headerlink\" title=\"1.21.3.1 默认插槽\"></a>1.21.3.1 默认插槽</h5><p>在一个 <code>&lt;submit-button&gt;</code> 组件中：</p>\n<pre><code>&lt;button type=&quot;submit&quot;&gt;\n  &lt;slot&gt;&lt;/slot&gt;\n&lt;/button&gt;\n</code></pre><ul>\n<li>我们可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”，但是有时候却希望渲染文本为别的东西，那怎么实现呢？ 我们可以将“Submit”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：<pre><code>&lt;button type=&quot;submit&quot;&gt;\n&lt;slot&gt;Submit&lt;/slot&gt;\n&lt;/button&gt;\n</code></pre></li>\n</ul>\n<p>现在当我在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：</p>\n<pre><code>&lt;submit-button&gt;&lt;/submit-button&gt;\n</code></pre><p>后备内容“Submit”将会被渲染：</p>\n<pre><code>&lt;button type=&quot;submit&quot;&gt;\n  Submit\n&lt;/button&gt;\n</code></pre><ul>\n<li>但是如果我们提供内容：</li>\n</ul>\n<pre><code>&lt;submit-button&gt;\n  Save\n&lt;/submit-button&gt;\n</code></pre><p>则这个提供的内容将会被渲染从而取代后备内容：</p>\n<pre><code>&lt;button type=&quot;submit&quot;&gt;\n  Save\n&lt;/button&gt;\n</code></pre><h5 id=\"1-21-3-2-具名插槽\"><a href=\"#1-21-3-2-具名插槽\" class=\"headerlink\" title=\"1.21.3.2 具名插槽\"></a>1.21.3.2 具名插槽</h5><p>有时我们写了一个子组件，我们希望</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;header&gt;\n      &lt;!-- 我们希望把页头放这里 --&gt;\n    &lt;/header&gt;\n    &lt;main&gt;\n      &lt;!-- 我们希望把主要内容放这里 --&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;!-- 我们希望把页脚放这里 --&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：name。这个 attribute 可以用来定义额外的插槽：</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;header&gt;\n      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n    &lt;/header&gt;\n    &lt;main&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>一个不带 name 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。 父组件在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;\n    &lt;div&gt;大家好我是父组件&lt;/div&gt;\n    &lt;template v-slot:header&gt;\n      &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n    &lt;/template&gt;\n\n    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n    &lt;p&gt;And another one.&lt;/p&gt;\n\n    &lt;template v-slot:footer&gt;\n      &lt;p&gt;Here&#39;s footer info&lt;/p&gt;\n    &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>最终的渲染结果可以看到</p>\n<pre><code>Here might be a page title\n大家好我是父组件\nA paragraph for the main content.\n\nAnd another one.\n\nHere&#39;s footer info\n</code></pre><p>父组件中会向子组件中具名传递对应的模板内容，而没有指定名字的模板内容会传递给子组件中不带 name 的 <code>&lt;slot&gt;</code> 当然，如果父组件中</p>\n<pre><code>&lt;template v-slot:default&gt;\n    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n    &lt;p&gt;And another one.&lt;/p&gt;\n&lt;/template&gt;\n</code></pre><ul>\n<li>同样是传递给子组件中不带 name 的 <code>&lt;slot&gt;</code> 注意: v-slot 只能添加在 <code>&lt;template&gt;</code> 上 具名插槽在书写的时候可以使用缩写,v-slot用<code>#</code>来代替</li>\n</ul>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;\n    &lt;div&gt;大家好我是父组件&lt;/div&gt;\n    &lt;template #header&gt;\n      &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n    &lt;/template&gt;\n\n    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n    &lt;p&gt;And another one.&lt;/p&gt;\n\n    &lt;template #footer&gt;\n      &lt;p&gt;Here&#39;s footer info&lt;/p&gt;\n    &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<h5 id=\"1-21-3-3-作用域插槽\"><a href=\"#1-21-3-3-作用域插槽\" class=\"headerlink\" title=\"1.21.3.3 作用域插槽\"></a>1.21.3.3 作用域插槽</h5><p>这里主要解决的是父组件在向子组件插槽传递模板内容时存在访问子组件数据的问题 还记得默认插槽吗？如果子组件中写在 <code>&lt;slot&gt;</code> 标签内后备内容是与 该组件的data属性双向数据绑定的</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;span&gt;\n      &lt;slot&gt;{{user.firstName}}&lt;/slot&gt;\n    &lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    data () {\n      return {\n        user:{\n          firstName:&#39;gerace&#39;,\n          lastName:&#39;haLi&#39;\n        }\n      }\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>父组件在引用子组件时，希望能够换掉备用内容</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;{{ user.firstName }}&lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>运行代码这时你会发现提示报错</p>\n<pre><code>Property or method &quot;user&quot; is not defined on the instance but referenced during render.\nTypeError: Cannot read property &#39;firstName&#39; of undefined\n</code></pre><p>这里为什么？vue官方文档给出了答案 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的 那应该怎么解决这个问题？ 为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>\n<pre><code>&lt;span&gt;\n  &lt;slot v-bind:user=&quot;user&quot;&gt;\n    {{ user.lastName }}\n  &lt;/slot&gt;\n&lt;/span&gt;\n</code></pre><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template v-slot:default=&quot;slotProps&quot;&gt;\n      {{ slotProps.user.firstName }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>上面例子，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字。 针对上面只给默认插槽传递模板内容的例子，在写法上可以采用默认插槽的缩写语法</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot v-slot:default=&quot;slotProps&quot;&gt;\n     {{ slotProps.user.firstName }}\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n\n↓↓↓\n&lt;template&gt;\n  &lt;myslot v-slot=&quot;slotProps&quot;&gt;\n     {{ slotProps.user.firstName }}\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n</code></pre>\n<blockquote>\n<p>注意： 默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：<br><code>`</code></p>\n</blockquote>\n<template><br>  <myslot v-slot=\"slotProps\"><br>     <br>     <template v-slot:other=\"otherSlotProps\"><br>           slotProps is NOT available here<br>     </template><br>  </myslot><br></template><br><code>* 下面再看一下多个插槽的情况 子组件</code>vue<br><template><br>  <div><br>    <span><br>      <slot v-bind:userdata=\"user\" name=\"header\"><br>        <br>      </slot><br>      <slot v-bind:hobbydata=\"hobby\" name=\"footer\"><br>        <br>      </slot><br>    </span><br>  </div><br></template>\n\n<p><script><br>  export default {<br>    data () {<br>      return {<br>        user:{<br>          firstName: &#39;gerace&#39;,<br>          lastName: &#39;haLi&#39;,<br>        },<br>        hobby:{<br>          fruit: &quot;apple&quot;,<br>          color: &quot;blue&quot;<br>        }<br>      }<br>    }<br>  }<br></script></p>\n<p><style><br></style></p>\n<pre><code>\n父组件\n```vue\n&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template v-slot:header=&quot;slotProps&quot;&gt;\n        {{ slotProps.userData.firstName }}\n      &lt;/template&gt;\n      &lt;template v-slot:footer=&quot;slotProps&quot;&gt;\n        {{ slotProps.hobbyData.fruit }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre><p>针对多个插槽的情况，在写法上可以解构插槽prop，父组件的写法如下</p>\n<pre><code>&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template v-slot:header=&quot;{userData}&quot;&gt;\n        {{ userData.firstName }}\n      &lt;/template&gt;\n      &lt;template v-slot:footer=&quot;{hobbyData}&quot;&gt;\n        {{ hobbyData.fruit }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre><p>在具名插槽的介绍部分有讲过，具名插槽可以使用缩写，v-slot可以使用#来代替，所以以上代码可以写成：</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template #header=&quot;{userData}&quot;&gt;\n        {{ userData.firstName }}\n      &lt;/template&gt;\n      &lt;template #footer=&quot;{hobbyData}&quot;&gt;\n        {{ hobbyData.fruit }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  import myslot from &#39;./myslot&#39;;\n  export default {\n    components: {\n      myslot\n    }\n  }\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p>但是需要注意的是该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p>\n<pre><code>&lt;!-- 这样会触发警告 --&gt;\n&lt;template&gt;\n  &lt;myslot&gt;\n      &lt;template #=&quot;{userData}&quot;&gt;\n        {{ userData.firstName }}\n      &lt;/template&gt;\n      &lt;template #=&quot;{hobbyData}&quot;&gt;\n        {{ hobbyData.fruit }}\n      &lt;/template&gt;\n  &lt;/myslot&gt;\n&lt;/template&gt;\n</code></pre><h3 id=\"1-22-vue初始化页面闪动问题\"><a href=\"#1-22-vue初始化页面闪动问题\" class=\"headerlink\" title=\"1.22 vue初始化页面闪动问题\"></a>1.22 vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。<br>首先：在css里加上以下代码</p>\n<pre><code>[v-cloak] {\n    display: none;\n}\n</code></pre><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;{display: &#39;block&#39;}&quot;</code></p>\n<h2 id=\"2-vue插件篇\"><a href=\"#2-vue插件篇\" class=\"headerlink\" title=\"2. vue插件篇\"></a>2. vue插件篇</h2><h3 id=\"2-1-状态管理（vuex）\"><a href=\"#2-1-状态管理（vuex）\" class=\"headerlink\" title=\"2.1 状态管理（vuex）\"></a>2.1 状态管理（vuex）</h3><h4 id=\"2-1-1-vuex是什么\"><a href=\"#2-1-1-vuex是什么\" class=\"headerlink\" title=\"2.1.1 vuex是什么\"></a>2.1.1 vuex是什么</h4><p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n<h4 id=\"2-1-2-怎么使用vuex\"><a href=\"#2-1-2-怎么使用vuex\" class=\"headerlink\" title=\"2.1.2 怎么使用vuex\"></a>2.1.2 怎么使用vuex</h4><ol>\n<li>第一步安装<pre><code class=\"javascript\">npm install vuex -S\n</code></pre>\n</li>\n<li>第二步创建store<pre><code class=\"javascript\">import Vue from &#39;vue&#39;;\nimport Vuex from &#39;vuex&#39;;\nVue.use(Vuex);\n//不是在生产环境debug为true\nconst debug = process.env.NODE_ENV !== &#39;production&#39;;\n//创建Vuex实例对象\nconst store = new Vuex.Store({\nstrict:debug,//在不是生产环境下都开启严格模式\nstate:{\n},\ngetters:{\n},\nmutations:{\n},\nactions:{\n}\n})\nexport default store;\n</code></pre>\n</li>\n<li>第三步注入vuex<pre><code class=\"javascript\">import Vue from &#39;vue&#39;;\nimport App from &#39;./App.vue&#39;;\nimport store from &#39;./store&#39;;\nconst vm = new Vue({\n store:store,\n render: h =&gt; h(App)\n}).$mount(&#39;#app&#39;)\n</code></pre>\n</li>\n</ol>\n<h4 id=\"2-1-3-vuex中有几个核心属性，分别是什么？\"><a href=\"#2-1-3-vuex中有几个核心属性，分别是什么？\" class=\"headerlink\" title=\"2.1.3 vuex中有几个核心属性，分别是什么？\"></a>2.1.3 vuex中有几个核心属性，分别是什么？</h4><p>一共有5个核心属性，分别是:</p>\n<ol>\n<li><p><code>state</code> 唯一数据源,Vue 实例中的 data 遵循相同的规则</p>\n</li>\n<li><p><code>getters</code> 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: &#39;...&#39;, done: true },\n      { id: 2, text: &#39;...&#39;, done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n    }\n  }\n})\n\nstore.getters.doneTodos // -&gt; [{ id: 1, text: &#39;...&#39;, done: true }]\n\n</code></pre>\n<ol start=\"3\">\n<li><code>mutation</code> 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发</li>\n</ol>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n\nstore.commit(&#39;increment&#39;)\n</code></pre>\n<ol start=\"4\">\n<li><code>action</code> Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</li>\n</ol>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit(&#39;increment&#39;)\n    }\n  }\n})\n</code></pre>\n<ol start=\"5\">\n<li><code>module</code>  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。</li>\n</ol>\n<pre><code class=\"javascript\">const moduleA = {\n  state: () =&gt; ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: () =&gt; ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -&gt; moduleA 的状态\nstore.state.b // -&gt; moduleB 的状态\n</code></pre>\n<h4 id=\"2-1-4-ajax请求代码应该写在组件的methods中还是vuex的actions中\"><a href=\"#2-1-4-ajax请求代码应该写在组件的methods中还是vuex的actions中\" class=\"headerlink\" title=\"2.1.4 ajax请求代码应该写在组件的methods中还是vuex的actions中\"></a>2.1.4 ajax请求代码应该写在组件的methods中还是vuex的actions中</h4><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p>\n<p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p>\n<h4 id=\"2-1-5-从vuex中获取的数据能直接更改吗？\"><a href=\"#2-1-5-从vuex中获取的数据能直接更改吗？\" class=\"headerlink\" title=\"2.1.5 从vuex中获取的数据能直接更改吗？\"></a>2.1.5 从vuex中获取的数据能直接更改吗？</h4><p>从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错；</p>\n<h4 id=\"2-1-6-vuex中的数据在页面刷新后数据消失\"><a href=\"#2-1-6-vuex中的数据在页面刷新后数据消失\" class=\"headerlink\" title=\"2.1.6 vuex中的数据在页面刷新后数据消失\"></a>2.1.6 vuex中的数据在页面刷新后数据消失</h4><p>用sessionstorage 或者 localstorage 存储数据</p>\n<pre><code>存储： sessionStorage.setItem( &#39;名&#39;, JSON.stringify(值) )\n使用： sessionStorage.getItem(&#39;名&#39;) ---得到的值为字符串类型，用JSON.parse()去引号；\n</code></pre><blockquote>\n<p>也可以引入插件vuex-persist，使用方法如下：</p>\n</blockquote>\n<ul>\n<li><p>安装</p>\n<pre><code class=\"javascript\">npm install --save vuex-persist\nor\nyarn add vuex-persist\n</code></pre>\n</li>\n<li><p>引入</p>\n<pre><code class=\"javascript\">import VuexPersistence from &#39;vuex-persist&#39;\n</code></pre>\n</li>\n<li><p>先创建一个对象并进行配置</p>\n<pre><code class=\"javascript\">const vuexLocal = new VuexPersistence({\n  storage: window.localStorage\n})\n</code></pre>\n</li>\n<li><p>引入进vuex插件</p>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\nstate: { ... },\nmutations: { ... },\nactions: { ... },\nplugins: [vuexLocal.plugin]\n}) \n</code></pre>\n<p>通过以上设置，在图3中各个页面之间跳转，如果刷新某个视图，数据并不会丢失，依然存在，并且不需要在每个 mutations 中手动存取 storage 。</p>\n</li>\n</ul>\n<h4 id=\"2-1-7-Vuex的严格模式是什么-有什么作用-怎么开启？\"><a href=\"#2-1-7-Vuex的严格模式是什么-有什么作用-怎么开启？\" class=\"headerlink\" title=\"2.1.7 Vuex的严格模式是什么,有什么作用,怎么开启？\"></a>2.1.7 Vuex的严格模式是什么,有什么作用,怎么开启？</h4><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。<br>在Vuex.Store 构造器选项中开启,如下</p>\n<pre><code class=\"javascript\">const store = new Vuex.Store({\n    strict:true,\n})\n</code></pre>\n<h4 id=\"2-1-8-怎么在组件中批量使用Vuex的getter属性\"><a href=\"#2-1-8-怎么在组件中批量使用Vuex的getter属性\" class=\"headerlink\" title=\"2.1.8 怎么在组件中批量使用Vuex的getter属性\"></a>2.1.8 怎么在组件中批量使用Vuex的getter属性</h4><p>使用<code>mapGetters</code>辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>\n<pre><code>import {mapGetters} from &#39;vuex&#39;\nexport default{\n    computed:{\n        ...mapGetters([&#39;total&#39;,&#39;discountTotal&#39;])\n    }\n}\n</code></pre><h4 id=\"2-1-9-组件中重复使用mutation\"><a href=\"#2-1-9-组件中重复使用mutation\" class=\"headerlink\" title=\"2.1.9 组件中重复使用mutation\"></a>2.1.9 组件中重复使用mutation</h4><p>使用<code>mapMutations</code>辅助函数,在组件中这么使用</p>\n<pre><code class=\"vue\">import { mapMutations } from &#39;vuex&#39;\nmethods:{\n    ...mapMutations({\n        setNumber:&#39;SET_NUMBER&#39;,\n    })\n}\n</code></pre>\n<p>然后调用this.setNumber(10)相当调用this.$store.commit(&#39;SET_NUMBER&#39;,10)</p>\n<h4 id=\"2-1-10-mutation和action有什么区别\"><a href=\"#2-1-10-mutation和action有什么区别\" class=\"headerlink\" title=\"2.1.10 mutation和action有什么区别\"></a>2.1.10 mutation和action有什么区别</h4><ul>\n<li>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</li>\n<li>action 可以包含任意异步操作。mutation只能是同步操作</li>\n<li>提交方式不同</li>\n</ul>\n<blockquote>\n<p>action 是用this.store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。</p>\n<p>mutation是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交</p>\n</blockquote>\n<ul>\n<li>接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了<pre><code>{\n  state,      // 等同于 `store.state`，若在模块中则为局部状态\n  rootState,  // 等同于 `store.state`，只存在于模块中\n  commit,     // 等同于 `store.commit`\n  dispatch,   // 等同于 `store.dispatch`\n  getters,    // 等同于 `store.getters`\n  rootGetters // 等同于 `store.getters`，只存在于模块中\n}\n</code></pre></li>\n</ul>\n<h4 id=\"2-1-11-在v-model上怎么用Vuex中state的值？\"><a href=\"#2-1-11-在v-model上怎么用Vuex中state的值？\" class=\"headerlink\" title=\"2.1.11 在v-model上怎么用Vuex中state的值？\"></a>2.1.11 在v-model上怎么用Vuex中state的值？</h4><p>需要通过computed计算属性来转换。</p>\n<pre><code>&lt;input v-model=&quot;message&quot;&gt;\n// ...\ncomputed: {\n  message: {\n    get () {\n        return this.$store.state.message\n    },\n    set (value) {\n        this.$store.commit(&#39;updateMessage&#39;, value)\n    }\n  }\n}\n</code></pre><h3 id=\"2-2-路由页面管理（vue-router）\"><a href=\"#2-2-路由页面管理（vue-router）\" class=\"headerlink\" title=\"2.2 路由页面管理（vue-router）\"></a>2.2 路由页面管理（vue-router）</h3><h4 id=\"2-2-1-什么是vue-router\"><a href=\"#2-2-1-什么是vue-router\" class=\"headerlink\" title=\"2.2.1 什么是vue-router\"></a>2.2.1 什么是vue-router</h4><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>\n<ul>\n<li>嵌套的路由/视图表</li>\n<li>模块化的、基于组件的路由配置</li>\n<li>路由参数、查询、通配符</li>\n<li>基于 Vue.js 过渡系统的视图过渡效果</li>\n<li>细粒度的导航控制</li>\n<li>带有自动激活的 CSS class 的链接</li>\n<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>\n<li>自定义的滚动条行为</li>\n</ul>\n<h4 id=\"2-2-2-怎么使用vue-router\"><a href=\"#2-2-2-怎么使用vue-router\" class=\"headerlink\" title=\"2.2.2 怎么使用vue-router\"></a>2.2.2 怎么使用vue-router</h4><ol>\n<li>第一步安装<pre><code>npm install vue-router -S\n</code></pre></li>\n<li>第二步在main.js中使用Vue Router组件<br><code>`</code>javascript<br>import Vue from &#39;vue&#39;<br>import App from &#39;./App.vue&#39;<br>import VueRouter from &#39;vue-router&#39;<br>Vue.use(VueRouter)</li>\n</ol>\n<p>new Vue({<br>  el: &#39;#app&#39;,<br>  render: h=&gt; h(App)<br>})</p>\n<pre><code>\n3. 第三步配置路由\n\n* 定义 (路由) 组件\n路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。如下\n```javascript\n// 1.定义组件（导入组件）\nimport Home from &#39;./components/home.vue&#39;\nimport News from &#39;.components/news.vue&#39;\n</code></pre><ul>\n<li>定义路由（路由对象数组）<br>定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。如下：<pre><code class=\"javascript\">// 2.定义路由\nconst routes = [\n{ path: &#39;/home&#39;, components: Home },\n{ path: &#39;/news&#39;, components: News },\n{ path: &#39;*&#39;, redirect: &#39;/home&#39; }, // 表示没有匹配到，是默认重定向到home组件\n]\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>实例化Vue Router对象<br>调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。如下<pre><code class=\"javascript\">// 3. 实例化Vue Router\nconst router = new VueRouter({routes}) // 此处相当于routes: routes\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>挂载根实例<pre><code class=\"javascript\">// 4. 挂载根实例\nnew Vue({\nel: &#39;#app&#39;,\nrouter,\nrender: h =&gt; h(App)\n})\n</code></pre>\n</li>\n</ul>\n<p>第四步在App.vue中使用路由<br>在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。如下：</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;\n    &lt;router-link to=&quot;/news&quot;&gt;News&lt;/router-link&gt;\n    &lt;br /&gt;\n    &lt;router-view&gt;&lt;/router-view&gt; /* 显示组件的内容 */\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<h4 id=\"2-2-3-怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\"><a href=\"#2-2-3-怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\" class=\"headerlink\" title=\"2.2.3 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？\"></a>2.2.3 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数</p>\n<h4 id=\"2-2-4-vue-router的导航钩子\"><a href=\"#2-2-4-vue-router的导航钩子\" class=\"headerlink\" title=\"2.2.4 vue-router的导航钩子\"></a>2.2.4 vue-router的导航钩子</h4><p>常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：</p>\n<ul>\n<li>全局导航钩子：router.beforeEach(to,from,next)</li>\n<li>组件内的钩子</li>\n<li>单独路由独享组件</li>\n</ul>\n<h4 id=\"2-2-5-vue路由传参\"><a href=\"#2-2-5-vue路由传参\" class=\"headerlink\" title=\"2.2.5 vue路由传参\"></a>2.2.5 vue路由传参</h4><ul>\n<li>页面刷新数据不会丢失</li>\n</ul>\n<pre><code class=\"javascript\">methods: {\n  jump(id) {\n    // 直接调用$router.push实现携带参数的跳转\n    this.$router.push({\n      path: `/particulars/${id}`\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: &#39;/particulars/:id&#39;,\n  name: &#39;particulars&#39;,\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.params.id\n</code></pre>\n<ul>\n<li>使用params方式传入的参数<blockquote>\n<p>这种方法页面刷新数据会丢失</p>\n<p>通过路由属性中的name来确定匹配的路由，通过params来传递参数<br><code>`</code>javascript<br>methods: {<br>jump(id) {<br>  this.$router.push({</p>\n<pre><code>path: &#39;/particulars&#39;,\nparams: {\n  id: id\n}\n</code></pre><p>  })<br>}<br>}</p>\n</blockquote>\n</li>\n</ul>\n<p>// 对应路由配置<br>{<br>  path: &#39;/particulars&#39;,<br>  name: &#39;particulars&#39;,<br>  component: particulars<br>}</p>\n<p>// 对应子组件：这样来获取参数<br>this.$route.params.id</p>\n<pre><code>\n* 使用query方法传入的参数\n&gt; 使用path来匹配路由，然后通过query来传递参数\n&gt;\n&gt; 这种情况下，query传递的参数会显示在url后面?id=?\n```javascript\nmethods: {\n  jump(id) {\n    this.$router.push({\n      path: &#39;/particulars&#39;,\n      query: {\n        id: id\n      }\n    })\n  }\n}\n\n// 对应路由配置\n{\n  path: &#39;/particulars&#39;,\n  name: &#39;particulars&#39;,\n  component: particulars\n}\n\n// 对应子组件：这样来获取参数\nthis.$route.query.id\n</code></pre><h4 id=\"2-2-6-router和route的区别\"><a href=\"#2-2-6-router和route的区别\" class=\"headerlink\" title=\"2.2.6 router和route的区别\"></a>2.2.6 router和route的区别</h4><ul>\n<li><p><code>route</code>为当前router跳转对象里面可以获取name、path、query、params等</p>\n</li>\n<li><p><code>router</code>为VueRouter实例，想要导航到不同URL，则使用router.push方法</p>\n</li>\n</ul>\n<h4 id=\"2-2-7-路由-TypeError-Cannot-read-property-39-matched-39-of-undefined-的错误问题\"><a href=\"#2-2-7-路由-TypeError-Cannot-read-property-39-matched-39-of-undefined-的错误问题\" class=\"headerlink\" title=\"2.2.7 路由 TypeError: Cannot read property &#39;matched&#39; of undefined 的错误问题\"></a>2.2.7 路由 TypeError: Cannot read property &#39;matched&#39; of undefined 的错误问题</h4><p>找到入口文件main.js里的new Vue()，必须使用router名，不能把router改成Router或者其他的别名</p>\n<pre><code class=\"javascript\">// 引入路由\nimport router from &#39;./routers/router.js&#39;\n\nnew Vue({\n    el: &#39;#app&#39;,\n    router,    // 这个名字必须使用router\n    render: h =&gt; h(App)\n});\n</code></pre>\n<h4 id=\"2-2-8-路由按需加载\"><a href=\"#2-2-8-路由按需加载\" class=\"headerlink\" title=\"2.2.8 路由按需加载\"></a>2.2.8 路由按需加载</h4><p>随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候，路由按需加载就闪亮登场了。</p>\n<pre><code class=\"javascript\">// webpack&lt; 2.4 时\n{ \n    path:&#39;/&#39;, \n    name:&#39;home&#39;,\n    components:resolve=&gt;require([&#39;@/components/home&#39;],resolve)\n} \n\n// webpack&gt; 2.4 时\n{ \n    path:&#39;/&#39;, \n    name:&#39;home&#39;, \n    components:()=&gt;import(&#39;@/components/home&#39;)\n}\n</code></pre>\n<p>import()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</p>\n<h4 id=\"2-2-9-Vue里面router-link在电脑上有用，在安卓上没反应怎么解决\"><a href=\"#2-2-9-Vue里面router-link在电脑上有用，在安卓上没反应怎么解决\" class=\"headerlink\" title=\"2.2.9 Vue里面router-link在电脑上有用，在安卓上没反应怎么解决\"></a>2.2.9 Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</h4><p>Vue路由在Android机上有问题，babel问题，安装<code>babel polypill</code>插件解决</p>\n<h4 id=\"2-2-10-Vue2中注册在router-link上事件无效解决方法\"><a href=\"#2-2-10-Vue2中注册在router-link上事件无效解决方法\" class=\"headerlink\" title=\"2.2.10 Vue2中注册在router-link上事件无效解决方法\"></a>2.2.10 Vue2中注册在router-link上事件无效解决方法</h4><ul>\n<li>使用<a href=\"mailto:``@click.native\" target=\"_blank\" rel=\"noopener\">``@click.native</a><code></code>。</li>\n<li>原因：router-link会阻止click事件，.native指直接监听一个原生事件</li>\n</ul>\n<h4 id=\"2-2-11-RouterLink在IE和Firefox中不起作用（路由不跳转）的问题\"><a href=\"#2-2-11-RouterLink在IE和Firefox中不起作用（路由不跳转）的问题\" class=\"headerlink\" title=\"2.2.11 RouterLink在IE和Firefox中不起作用（路由不跳转）的问题\"></a>2.2.11 RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</h4><ul>\n<li>只用a标签，不使用button标签</li>\n<li>使用button标签和Router.navigate方法</li>\n</ul>\n<h3 id=\"2-3-网络请求-axios\"><a href=\"#2-3-网络请求-axios\" class=\"headerlink\" title=\"2.3 网络请求(axios)\"></a>2.3 网络请求(axios)</h3><p>axios的二次封装，主要包括请求之前、返回响应以及使用等</p>\n<h4 id=\"2-3-1-请求之前\"><a href=\"#2-3-1-请求之前\" class=\"headerlink\" title=\"2.3.1 请求之前\"></a>2.3.1 请求之前</h4><p>一般的接口都会有鉴权认证（token）之类的，因此在接口的请求头里面，我们需要带上token值以通过服务器的鉴权认证。但是如果每次请求的时候再去添加，不仅会大大的加大工作量，而且很容易出错。好在axios提供了拦截器机制，我们在请求的拦截器中可以添加token。</p>\n<pre><code class=\"javascript\">// 请求拦截\naxios.interceptors.request.use((config) =&gt; {\n  // ...省略代码\n  config.headers.x_access_token = token\n  return config\n}, function (error) =&gt; {\n  return Promise.reject(error)\n})\n</code></pre>\n<p>当然请求拦截器中，除了处理添加token以外，还可以进行一些其他的处理，具体的根据实际需求进行处理。</p>\n<h4 id=\"2-3-2-响应之后\"><a href=\"#2-3-2-响应之后\" class=\"headerlink\" title=\"2.3.2 响应之后\"></a>2.3.2 响应之后</h4><p>请求接口，并不是每一次请求都会成功。那么当接口请求失败的时候，我们又怎么处理呢？每次请求的时候处理？封装axios统一处理？应该选择封装axios进行统一处理。axios不仅提供了请求的拦截器，其也提供了响应的拦截器。在此处，可以获取到服务器返回的状态码，然后根据状态码进行相对应的操作。</p>\n<pre><code class=\"javascript\">// 响应拦截\naxios.interceptors.response.use(function (response) {\n  if (response.data.code === 401) {\n    // 用户token失效\n    // 清空用户信息\n    sessionStorage.user = &#39;&#39;\n    sessionStorage.token = &#39;&#39;\n    window.location.href = &#39;/&#39; // 返回登录页\n    return Promise.reject(msg) // 接口Promise返回错误状态，错误信息msg可由后端返回，也可以我们自己定义一个码--信息的关系。\n  }\n  if (response.status !== 200 || response.data.code !== 200) {\n    // 接口请求失败，具体根据实际情况判断\n    message.error(mes) // 提示错误信息\n    return Promise.reject(msg) // 接口Promise返回错误状态\n  }\n  return response\n}, function (error) {\n  if (axios.isCancel(error)) {\n    requestList.length = 0\n    // store.dispatch(&#39;changeGlobalState&#39;, { loading: false })\n    throw new axios.Cancel(&#39;cancel request&#39;)\n  } else {\n    message.error(&#39;网络请求失败，请重试&#39;)\n  }\n  return Promise.reject(error)\n})\n\n</code></pre>\n<p>当然响应拦截器同请求拦截器一样，还可以进行一些其他的处理，具体的根据实际需求进行处理。</p>\n<h4 id=\"2-3-3-使用axios\"><a href=\"#2-3-3-使用axios\" class=\"headerlink\" title=\"2.3.3 使用axios\"></a>2.3.3 使用axios</h4><p>axios使用的时候一般有三种方式：</p>\n<ul>\n<li><p>执行get请求</p>\n<pre><code class=\"javascript\">axios.get(&#39;url&#39;, {\nparams: {} // 接口参数\n}).then(function(res){\nconsole.log(res) // 处理成功的函数，相当于success\n}).catch(function(error) {\nconsole.log(error) // 错误处理，相当于error\n})\n</code></pre>\n</li>\n<li><p>执行post请求</p>\n<pre><code class=\"javascript\">axios.post(&#39;url&#39;, \n{\n  data: xxx // 参数\n},\n{\n  headers: xxx //请求头信息\n}).then(function(res) {\nconsole.log(res) // 处理成功的函数，相当于success\n}).catch(function(error) {\nconsole.log(error) // 错误处理，相当于error\n})\n</code></pre>\n</li>\n<li><p>axios API通过相关配置传递给axios完成请求<br><code>`</code>javascript<br>axios({<br>method: &#39;delete&#39;,<br>url: &#39;xxx&#39;,<br>cache: false,<br>params: { id: 123 },<br>headers: xxx<br>})</p>\n</li>\n</ul>\n<p>/<em> ----------------------- </em>/<br>axios({<br>  method: &#39;post&#39;,<br>  url: &#39;/user/12345&#39;,<br>  data: {<br>    firstName: &#39;monkey&#39;,<br>    lastName: &#39;soft&#39;<br>  }<br>})</p>\n<pre><code>\n直接使用api的方式虽然简单，但是不同请求参数的名字不一样，在实际开发过程中很容易写错或者忽略，容易为开发造成不必要的时间损失。\n\n前面两种方式虽然没有参数不一致的问题，但是使用的时候，太过于麻烦，那么怎么办呢？\n\n前面两种虽然过于麻烦，但是仔细观察，是可以发现有一定的相似点，我们便可以给予这些相似点二次封装，形成适合我们使用的一个请求函数。\n```javascript\n/* \n*url: 请求的url\n*params: 请求的参数\n*config: 请求时的header信息\n*method: 请求方法\n*/\nconst request = function({ url, params, config, method }) {\n  // 如果是get请求，需要拼接参数\n  let str = &#39;&#39;\n  if(method === &#39;get&#39; &amp;&amp; params) {\n    Object.keys(params).forEach(item =&gt; {\n      str += `${item}=${params[item]$}`\n    })\n  }\n  return new Promise((resolve, reject) =&gt; {\n    axios[method](str ? (url + &#39;?&#39; + str.substring(0, str.length - 1)) : url, params, Object.assign({}, config)).then(response =&gt; {\n      resolve(response.data)\n    }, err =&gt; {\n      if(err.Cancel) {\n\n      } else {\n        reject(err)\n      }\n    }).catch(err =&gt; {\n      reject(err)\n    })\n  })\n}\n\n</code></pre><h3 id=\"2-4-视频播放-video-js\"><a href=\"#2-4-视频播放-video-js\" class=\"headerlink\" title=\"2.4 视频播放(video.js)\"></a>2.4 视频播放(video.js)</h3><p><a href=\"https://juejin.cn/post/6850037269227634702\" target=\"_blank\" rel=\"noopener\">视频播放video.js</a></p>\n<h3 id=\"2-5-vue常用ui库\"><a href=\"#2-5-vue常用ui库\" class=\"headerlink\" title=\"2.5 vue常用ui库\"></a>2.5 vue常用ui库</h3><h4 id=\"2-5-1-移动端\"><a href=\"#2-5-1-移动端\" class=\"headerlink\" title=\"2.5.1 移动端\"></a>2.5.1 移动端</h4><ul>\n<li><a href=\"http://mint-ui.github.io/#!/zh-cn\" target=\"_blank\" rel=\"noopener\">mint-ui</a></li>\n<li><a href=\"https://youzan.github.io/vant/#/zh-CN/home\" target=\"_blank\" rel=\"noopener\">Vant</a></li>\n<li><a href=\"https://vux.li/\" target=\"_blank\" rel=\"noopener\">VUX</a></li>\n</ul>\n<h4 id=\"2-5-2-pc端\"><a href=\"#2-5-2-pc端\" class=\"headerlink\" title=\"2.5.2 pc端\"></a>2.5.2 pc端</h4><ul>\n<li><a href=\"https://element.eleme.cn/2.13/#/zh-CN/component/installation\" target=\"_blank\" rel=\"noopener\">element-ui</a></li>\n<li><a href=\"https://www.antdv.com/docs/vue/introduce-cn/\" target=\"_blank\" rel=\"noopener\">Ant Design of Vue</a></li>\n<li><a href=\"https://avuejs.com/\" target=\"_blank\" rel=\"noopener\">Avue</a></li>\n</ul>\n<h2 id=\"3-常用webpack配置\"><a href=\"#3-常用webpack配置\" class=\"headerlink\" title=\"3. 常用webpack配置\"></a>3. 常用webpack配置</h2><blockquote>\n<p>vue-lic3脚手架（vue.config.js）</p>\n</blockquote>\n<h3 id=\"3-1-publicPath\"><a href=\"#3-1-publicPath\" class=\"headerlink\" title=\"3.1 publicPath\"></a>3.1 publicPath</h3><ul>\n<li>类型：String</li>\n<li>默认：&#39;/&#39;</li>\n</ul>\n<p>部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如<a href=\"https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/\" target=\"_blank\" rel=\"noopener\">https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/</a></p>\n<p>这个值也可以被设置为空字符串 (&#39;&#39;) 或是相对路径 (&#39;./&#39;)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p>\n<h3 id=\"3-2-productionSourceMap\"><a href=\"#3-2-productionSourceMap\" class=\"headerlink\" title=\"3.2 productionSourceMap\"></a>3.2 productionSourceMap</h3><ul>\n<li>类型：boolean</li>\n<li>默认：true</li>\n</ul>\n<p>不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积</p>\n<blockquote>\n<p>注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便</p>\n</blockquote>\n<h3 id=\"3-3-assetsDir\"><a href=\"#3-3-assetsDir\" class=\"headerlink\" title=\"3.3 assetsDir\"></a>3.3 assetsDir</h3><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是&#39;&#39;,</p>\n<h3 id=\"3-4-indexPath\"><a href=\"#3-4-indexPath\" class=\"headerlink\" title=\"3.4 indexPath\"></a>3.4 indexPath</h3><p>指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是&#39;index.html&#39;</p>\n<h3 id=\"3-5-lintOnSave\"><a href=\"#3-5-lintOnSave\" class=\"headerlink\" title=\"3.5 lintOnSave\"></a>3.5 lintOnSave</h3><p>是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用</p>\n<h3 id=\"3-6-css\"><a href=\"#3-6-css\" class=\"headerlink\" title=\"3.6 css\"></a>3.6 css</h3><pre><code class=\"javascript\">css: {\n  // 是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，\n  extract: true,\n  sourceMap: false, // 效果同上\n  modules: false, // 为所有的 CSS 及其预处理文件开启 CSS Modules。\n  // 这个选项不会影响 `*.vue` 文件。\n},\n</code></pre>\n<h3 id=\"3-7-devServer\"><a href=\"#3-7-devServer\" class=\"headerlink\" title=\"3.7 devServer\"></a>3.7 devServer</h3><p>本地开发服务器配置，此处直接贴上我常用的配置，以注释的方式介绍</p>\n<pre><code class=\"javascript\">devServer: { \n  // 配置开发服务器\n  host: &quot;0.0.0.0&quot;,\n  // 是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果\n  hot: true,\n  // 服务启动端口\n  port: &quot;8080&quot;,\n  // 是否自动打开浏览器默认为false\n  open: false,\n  // 配置http代理\n  proxy: { \n    &quot;/api&quot;: { \n      //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在ajax中使用/api/api1路径,其请求路径会解析\n      // http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;\n      target: &quot;http://192.168.0.118:9999&quot;,\n      //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意\n      changeOrigin: true,\n      pathRewrite: {\n          //把多余的路径置为&#39;&#39;\n        &quot;api&quot;: &quot;&quot;\n      }\n    },\n    &quot;/api2&quot;: {//可以配置多个代理，匹配上那个就使用哪种解析方式\n      target: &quot;http://api2&quot;,\n      // ...\n    }\n  }\n},\n</code></pre>\n<h3 id=\"3-8-pluginOptions\"><a href=\"#3-8-pluginOptions\" class=\"headerlink\" title=\"3.8 pluginOptions\"></a>3.8 pluginOptions</h3><p>这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：</p>\n<pre><code class=\"javascript\">{\n  //定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了\n  &#39;style-resources-loader&#39;: {\n    preProcessor: &#39;less&#39;,\n    patterns: [\n      &#39;./src/assets/public.less&#39;\n    ]\n  }\n}\n</code></pre>\n<h3 id=\"3-9-chainWebpack\"><a href=\"#3-9-chainWebpack\" class=\"headerlink\" title=\"3.9 chainWebpack\"></a>3.9 chainWebpack</h3><p>是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：</p>\n<pre><code class=\"javascript\">chainWebpack(config) { \n//添加一个路径别名 假设有在assets/img/menu/目录下有十张图片，如果全路径require(&quot;/assets/img/menu/img1.png&quot;)\n//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了\n    config.resolve.alias\n      //添加多个别名支持链式调用\n      .set(&quot;assets&quot;, path.join(__dirname, &quot;/src/assets&quot;))\n      .set(&quot;img&quot;, path.join(__dirname, &quot;/src/assets/img/menu&quot;))\n      //引入图片时只需require(&quot;img/img1.png&quot;);即可\n}\n</code></pre>\n<h2 id=\"4-webpack优化\"><a href=\"#4-webpack优化\" class=\"headerlink\" title=\"4. webpack优化\"></a>4. webpack优化</h2><p><a href=\"https://segmentfault.com/a/1190000022205477\" target=\"_blank\" rel=\"noopener\">带你深度解锁Webpack系列(优化篇)</a></p>\n<p><a href=\"https://www.cnblogs.com/zhurong/p/12603887.html\" target=\"_blank\" rel=\"noopener\">vue-cli中Webpack配置优化（一）</a></p>\n<p><a href=\"https://www.cnblogs.com/zhurong/p/12611360.html#_label2_1_3\" target=\"_blank\" rel=\"noopener\">vue-cli中Webpack配置优化（二）</a></p>\n<h3 id=\"4-1-量化\"><a href=\"#4-1-量化\" class=\"headerlink\" title=\"4.1 量化\"></a>4.1 量化</h3><h4 id=\"4-1-1-speed-measure-webpack-plugin\"><a href=\"#4-1-1-speed-measure-webpack-plugin\" class=\"headerlink\" title=\"4.1.1 speed-measure-webpack-plugin\"></a>4.1.1 speed-measure-webpack-plugin</h4><p><code>speed-measure-webpack-plugin</code> 插件可以测量各个插件和<code>loader</code>所花费的时间，使用之后，构建时，会得到类似下面这样的信息：</p>\n<p><img src=\"https://image-static.segmentfault.com/334/233/3342331922-6a0fde0ed940ffa7_fix732\" alt></p>\n<blockquote>\n<p>Vue-cli 2.x</p>\n</blockquote>\n<pre><code class=\"js\">//webpack.config.js\nconst SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);\nconst smp = new SpeedMeasurePlugin();\n\nconst config = {\n    //...webpack配置\n}\n\nmodule.exports = smp.wrap(config);\n</code></pre>\n<blockquote>\n<p>Vue-cli 3.x（主要区别是包裹 configureWebpack ）</p>\n</blockquote>\n<pre><code class=\"js\">const SpeedMeasurePlugin = require(&#39;speed-measure-webpack-plugin&#39;)\nconst smp = new SpeedMeasurePlugin({\n  outputFormat: &#39;human&#39;\n})\nmodule.exports = {\n  configureWebpack: smp.wrap({\n    plugins: []\n  })\n}\n</code></pre>\n<h4 id=\"4-1-2-webpack-bundle-analyzer\"><a href=\"#4-1-2-webpack-bundle-analyzer\" class=\"headerlink\" title=\"4.1.2 webpack-bundle-analyzer\"></a>4.1.2 webpack-bundle-analyzer</h4><p>这个是分析打包后，各个文件的大小，用于分析bundle的</p>\n<blockquote>\n<p>安装</p>\n</blockquote>\n<pre><code>npm i webpack-bundle-analyzer -D\n</code></pre><p>在 Vue-cli 3.x 下，安装这个包会报错，是因为用 Vue-cli 3.x 构建的项目在 node_modules 中已经存在，但是项目的 package.json 中没有引用。</p>\n<p>需要在 node_modules 中删除这个包，重新安装就可以。</p>\n<blockquote>\n<p>使用：（下面是vue-cli 3.x）</p>\n</blockquote>\n<pre><code>const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin\n\n  configureWebpack: smp.wrap({\n    plugins: [\n      // 这个要放在所有 plugins 最后\n      new BundleAnalyzerPlugin()\n    ]\n  })\n</code></pre><p>在构建完成后，会直接启动一个服务，有一个可视化的界面查看构建后的bundle。</p>\n<h3 id=\"4-2-缓存\"><a href=\"#4-2-缓存\" class=\"headerlink\" title=\"4.2 缓存\"></a>4.2 缓存</h3><h4 id=\"4-2-1-cache-loader\"><a href=\"#4-2-1-cache-loader\" class=\"headerlink\" title=\"4.2.1 cache-loader\"></a>4.2.1 cache-loader</h4><p>在一些性能开销较大的<code>loader</code>前面添加<code>cache-loader</code>，将结果缓存在磁盘中</p>\n<blockquote>\n<p>安装：</p>\n</blockquote>\n<pre><code>npm install cache-loader -D\n</code></pre><blockquote>\n<p>使用：</p>\n<p>在vue-cli2.x 中</p>\n</blockquote>\n<pre><code class=\"js\">module.exports = {\n    //...\n    module: {\n        //我的项目中,babel-loader耗时比较长，所以我给它配置了`cache-loader`\n        rules: [\n            {\n                test: /\\.jsx?$/,\n                use: [&#39;cache-loader&#39;,&#39;babel-loader&#39;]\n            }\n        ]\n    }\n}\n</code></pre>\n<blockquote>\n<p>在vue-cli3.x中，这个配置是默认的配置，分别对：<code>vue-loader</code>、<code>babel-loader</code>两个进行了缓存，其他的需要缓存再自己配置。</p>\n</blockquote>\n<h4 id=\"4-2-2-hard-source-webpack-plugin\"><a href=\"#4-2-2-hard-source-webpack-plugin\" class=\"headerlink\" title=\"4.2.2 hard-source-webpack-plugin\"></a>4.2.2 hard-source-webpack-plugin</h4><p>这个是为模块提供中间缓存，效率提升很大。</p>\n<blockquote>\n<p>安装</p>\n</blockquote>\n<pre><code>npm i hard-source-webpack-plugin -D\n</code></pre><blockquote>\n<p>使用</p>\n</blockquote>\n<p>直接在 plugins 中 new就可以。</p>\n<pre><code class=\"js\">const HardSourceWebpackPlugin = require(&#39;hard-source-webpack-plugin&#39;)\nmodule.exports = {\n  configureWebpack: smp.wrap({\n    plugins: [\n      // 为模块提供中间缓存，缓存路径是：node_modules/.cache/hard-source\n      new HardSourceWebpackPlugin(),\n      new BundleAnalyzerPlugin()\n    ]\n  })\n}\n</code></pre>\n<p>构建后效果：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111737573-1701609808.png\" alt></p>\n<p><img src=\"https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111750107-1452016351.png\" alt></p>\n<p><img src=\"https://img2020.cnblogs.com/blog/592961/202003/592961-20200331111800199-1571336442.png\" alt></p>\n<p>上面三幅图，分别是配置后第一次、第二次、第三次构建的，第三次构建可以达到80%的提升。</p>\n<h3 id=\"4-3-exclude-include\"><a href=\"#4-3-exclude-include\" class=\"headerlink\" title=\"4.3 exclude/include\"></a>4.3 exclude/include</h3><p>我们可以通过<code>exclue</code>、<code>include</code>配置来确保转移尽可能少的文件。顾名思义，<code>exclude</code>指定要排除的文件，<code>include</code>指定要包含的文件。</p>\n<p><code>exclude</code>的优先级高于<code>include</code>，在<code>include</code>和<code>exclude</code>中使用绝对路径数组，尽量避免<code>exclude</code>，更倾向于使用<code>include</code>。</p>\n<pre><code class=\"js\">//webpack.config.js\nconst path = require(&#39;path&#39;);\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.js[x]?$/,\n                use: [&#39;babel-loader&#39;],\n                include: [path.resolve(__dirname, &#39;src&#39;)]\n            }\n        ]\n    },\n}\n</code></pre>\n<p>下图是未配置<code>include</code>和配置了<code>include</code>的构建结果对比：</p>\n<p><img src=\"https://image-static.segmentfault.com/341/005/3410059882-f459f782062d01e1_fix732\" alt></p>\n<h2 id=\"5-历史好文推荐\"><a href=\"#5-历史好文推荐\" class=\"headerlink\" title=\"5. 历史好文推荐\"></a>5. 历史好文推荐</h2><ol>\n<li><a href=\"https://juejin.im/post/6850418118695583758\" target=\"_blank\" rel=\"noopener\">【万字长文】史上最强css、html总结~看完涨薪不再是梦</a></li>\n<li><a href=\"https://juejin.im/post/6854573211451932685\" target=\"_blank\" rel=\"noopener\">【万字长文】最全JavaScript基础总结~建议收藏</a></li>\n<li><a href=\"https://juejin.im/post/6847902222882340872\" target=\"_blank\" rel=\"noopener\">Event Loop我知道，宏任务微任务是什么鬼？</a></li>\n<li><a href=\"https://juejin.im/post/6847009771493523464\" target=\"_blank\" rel=\"noopener\">锋利码农武器之vscode</a></li>\n<li><a href=\"https://juejin.im/post/6847009771371888653\" target=\"_blank\" rel=\"noopener\">面试宝典带你走上人生巅峰</a></li>\n</ol>\n"},{"title":"Nodejs","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"hojun.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-08-12T10:45:51.947Z","comments":1,"keywords":"node","description":"nodejs教程","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/5.jpeg"],"_content":"\n\n# 01-Node.js基础\n\n## 一、Node.js是什么\n\nNode.js is a JavaScript runtime built on Chrome's V8 JavaScript engine.\n\n\n\n### 1、 特性\n\nNode.js可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：\n\n- 文件的读写（File System）\n- 进程的管理（Process）\n- 网络通信（HTTP/HTTPS）\n\n\n\n### 2、举例\n\n#### 2.1 浏览器安全级别的限制\n\n##### Ajax限制\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>browser-safe-sandbox</title>\n</head>\n<body>\n  <div>browser-safe-sandbox</div>\n  <script>\n    const xhr = new XMLHttpRequest()\n    xhr.open('get', 'https://m.maoyan.com/ajax/moreClassicList?sortId=1&showType=3&limit=10&offset=30&optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&optimus_risk_level=71&optimus_code=10', false)\n    xhr.send()\n  </script>\n</body>\n</html>\n```\n\n\n\n##### 浏览器预览\n\n```\nbrowser-sync start --server --files **/* --directory\n```\n\n\n\n\n\n#### 2.2 文件的读写（File System）\n\n```javascript\nconst fs = require('fs')\n\nfs.readFile('./ajax.png', 'utf-8', (err, content) => {\n  console.log(content)\n})\n```\n\n\n\n#### 2.3 进程的管理（Process）\n\n```javascript\nfunction main(argv) {\n  console.log(argv)\n}\n\nmain(process.argv.slice(2))\n```\n\n\n\n> 运行\n\n```\nnode 2.3-process.js argv1 argv2\n```\n\n\n\n#### 2.4 网络通信（HTTP/HTTPS）\n\n```javascript\nconst http = require(\"http\")\n\nhttp.createServer((req,res) => {\n  res.writeHead(200, {\n    \"content-type\": \"text/plain\"\n  })\n  res.write(\"hello nodejs\")\n  res.end()\n}).listen(3000)\n```\n\n\n\n\n\n## 二、Node相关工具\n\n### 1、NVM：Node Version Manager\n\n#### 1.1 Mac安装nvm\n\n```\nhttps://github.com/nvm-sh/nvm/blob/master/README.md\n```\n\n\n\n#### 1.2 Windows安装nvm\n\n```\nnvm-windows\nnodist\n```\n\n\n\n#### 1.3 常用的nvm命令\n\n- `nvm list`：查看当前环境安装了哪些版本\n- `nvm use 14.15.0`：切换node版本\n- `nvm alias default (v)14.15.0`：切换node默认版本\n\n\n\n### 2、NPM：Node Package Manager\n\n- `npm view jquery versions`：查看包的所有版本\n\n\n\n#### 2.1 全局安装package\n\n```\n$ npm install forever --global (-g)\n$ forever\n$ npm uninstall forever --global\n$ forever\n\n```\n\n\n\n> 全局安装包的目录\n\n- Mac\n\n  ```\n  /Users/felix/.nvm/versions/node/nvm各个版本/bin/\n  \n  ```\n\n  \n\n- Windows\n\n  ```\n  C:\\Users\\你的用户名\\AppData\\Roaming\\npm\\node_modules\n  \n  ```\n\n\n\n#### 2.2 本地安装package\n\n```\n$ cd ~/desktop\n$ mkdir gp-project\n$ cd gp-project\n$ npm install underscore\n$ npm list (ls)\n\n```\n\n\n\n#### 2.3 package.json初始化\n\n```\n$ pwd\n$ npm init -y\n$ ls\n$ cat package.json\n\n```\n\n\n\n#### 2.4 使用package.json\n\n- `npm install —production`：只拉取生产环境的包\n\n```\n$ npm install underscore --save\n$ cat package.json\n$ npm install lodash --save-dev\n$ cat package.json\n$ rm -rf node_modules\n$ ls\n$ npm install\n$ npm uninstall underscore --save\n$ npm list | grep underscore  // 查看underscore包的树(依赖关系)\n$ cat package.json\n\n```\n\n\n\n\n\n> \"dependencies\"：这些包是你的应用程序在生产环境中所需要的。\n>\n> \"devDepedencies\"：这些包只是在开发和测试中需要的。\n\n\n\n![npm](https://img-blog.csdn.net/2018071517553381?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p3bF93aWxsb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n```\n// package.json\n{\n...\n\"dependencies\": { // --save / -S\n},\n\"devDependencies\": { // --save-dev / -D\n}\n\n}\n\n```\n\n\n\n\n\n#### 2.5 安装指定版本的包\n\n- `npm install jquery@2.2.4`： 安装指定版本\n- `npm install jquery@1 -S`：安装1最高的版本\n\n```\n$ pwd\n$ npm list\n$ npm info underscore\n$ npm view underscore versions\n$ npm install underscore@1.8.0\n$ npm list\n$ npm uninstall underscore\n$ npm list\n\n```\n\n\n\n#### 2.6 更新本地安装的包\n\n> -13.4.6\n>\n> major: 13（主版本号）,minor: 4（次版本号），patch：6（补丁，单数不稳定，双数稳定）\n\n- `npm outdated`：查看哪些包过期\n- `npm update`：更新所有的包\n\n```\n$ npm info underscore\n$ npm view underscore versions // 查看underscore包所有的版本\n$ npm install underscore@1.4.4 --save-dev // 安装1.4.4的underscore到开发环境 \n$ npm list | grep gulp // 查看gulp包的依赖关系\n$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本\n$ npm list | grep gulp\n$ npm update\n\n```\n\n\n\n```json\n{\n\t\"dependencies\": {\n\t\t\"jquery\": \"^1.12.4\", // ^锁定主版本号\n        \"jquery\": \"~1.12.4\", // ~锁定主版本号和次版本号\n        jquery: \"1.12.4\", // 全部锁定\n        jquery: \"*\" // 最新版本\n    }\n}\n\n```\n\n\n\n#### 2.7 清除缓存\n\n- `npm cache clean --force`\n\n\n\n#### 2.8 上传自己的包\n\n##### 2.8.1 编写模块\n\n保存为index.js\n\n```javascript\nexports.sayHello = function(){ \n  return 'Hello World'; \n}\n\n```\n\n\n\n##### 2.8.2 初始化描述文件\n\n- npm init package.json\n\n```json\n{ \n  \"name\": \"gp19-npm\", \n  \"version\": \"1.0.1\", \n  \"description\": \"gp19 self module\", \n  \"main\": \"index.js\",\n  \"scripts\": { \n    \"test\": \"make test\" \n  }, \n  \"repository\": { \n    \"type\": \"Git\", \n    \"url\": \"git+https://github.com/lurongtao/gp19-npm.git\" \n  }, \n  \"keywords\": [ \n    \"demo\" \n  ], \n  \"author\": \"Felixlu\", \n  \"license\": \"ISC\", \n  \"bugs\": { \n    \"url\": \"https://github.com/lurongtao/gp19-npm/issues\" \n  }, \n  \"homepage\": \"https://github.com/lurongtao/gp19-npm#readme\", \n}\n\n```\n\n\n\n##### 2.8.3 注册npm仓库账号\n\n- npm adduser\n\n```\nhttps://www.npmjs.com 上面的账号\nfelix_lurt/qqmko09ijn\n$ npm adduser\n\n```\n\n\n\n##### 2.8.4 上传包\n\n- npm publish\n\n\n\n坑：403 Forbidden\n\n```\n查看npm源：npm config get registry\n切换npm源方法一：npm config set registry http://registry.npmjs.org\n切换npm源方法二：nrm use npm\n\n```\n\n\n\n##### 2.8.5 安装包\n\n- npm install gp19-npm\n\n\n\n##### 2.8.6 卸载包\n\n```\n查看当前项目引用了哪些包 ：\nnpm ls\n卸载包：\nnpm unpublish --force\n\n```\n\n\n\n##### 2.8.7 使用引入包\n\n```\nvar hello = require('gp19-npm')\nhello.sayHello()\n\n```\n\n\n\n#### 2.9 npm脚本\n\nNode开发离不开npm，而脚本功能是npm最强大、最常用的功能之一。\n\n\n\n##### 2.9.1 什么是npm脚本？\n\nnpm允许在package.json文件里面，使用scripts字段定义脚本命令。\n\n```json\n{\n\t// ...\n    \"scripts\": {\n\t\t\"builds\": \"node build.js\"\n    }\n}\n\n```\n\n\n\n##### 2.9.2 执行顺序\n\n如果npm脚本里面需要执行多个任务，那么需要明确它们的执行顺序。\n\n> scripts1.js\n\n```js\nvar x = 0\nconsole.log(x)\n\n```\n\n\n\n> scripts2.js\n\n```js\nvar y = 0\nconsole.log(y)\n\n```\n\n\n\n```json\n\"scripts\" : {\n\t\"script1\": \"node script1.js\",\n    \"script2\": \"ndoe script2.js\"\n}\n\n```\n\n\n\n如果是并行执行（即同时的平行执行），可以使用`&`符号。\n\n```\n$ npm run script1 & npm run script2\n\n```\n\n\n\n如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用`&&`符号。\n\n```\n$ npm run script1 && npm run script2\n\n```\n\n\n\n##### 2.9.3 简写形式\n\n常用的npm脚本简写形式\n\n```\nnpm start 是 npm run start\n\n```\n\n\n\n\n\n##### 2.9.4 变量\n\nnpm脚本有一个非常强大功能，就是可以使用npm的内部变量。\n\n首先，通过`npm _package_`前缀，npm脚本可以拿到package.json里面的字段。比如，下面是一个package.json。\n\n\n\n> 注意：一定要在npm脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到的\n\n```json\n{\n\t\"name\": \"foo\",\n    \"version\": \"1.2.5\",\n    \"scripts\": {\n\t\t\"view\": \"node view.js\"\n    }\n}\n\n```\n\n那么，变量`npm_package_name`返回foo，变量`npm_package_version`返回1.2.5。\n\n```js\n// view.js\nconsole.log(process.env.npm_package_name); // foo\nconsole.log(process.env.npm_package_version); // 1.2.5\n\n```\n\n上面代码中，我们通过环境变量`process.env`对象，拿到`package.json`的字段值。如果是Bash脚本，可以用`$npm_package_name`和 `$npm_package_version`取到这两个值。\n\n\n\nnpmpackage前缀也支持嵌套的package.json字段。\n\n```json\n\"repository\": {\n\t\"type\": 'git',\n    \"url\": \"xxx\"\n},\n\"scripts\": {\n\t\"view\": \"echo $npm_package_repository_type\"\n}\n\n```\n\n上面代码中，repository字段的type属性，可以通过`npm_package_repository_type`取到。\n\n\n\n下面是另外一个例子。\n\n```json\n\"scripts\": {\n\t\"install\": \"foo.js\"\n}\n\n```\n\n上面代码中，`npm_package_scripts_install`变量的值等于foo.js。\n\n然后，npm脚本还可以通过`npmconfig`前缀，拿到npm的配置变量，即`npm config get xxx`命令返回的值。比如，当前模块的发型标签，可以通过`npm_config_tag`取到。\n\n```json\n\"view\": \"echo $npm_config_tag\",\n\n```\n\n\n\n注意，package.json里面的config对象，可以被环境变量覆盖。\n\n```json\n{\n\t\"name\": \"foo\",\n    \"config\": {\"port\": \"8080\"},\n    \"scripts\": {\"start\": \"node server.js\"}\n}\n\n```\n\n上面代码中，`npm_package_config_port`变量返回的是8080。这个值可以用下面的方法覆盖。\n\n```\n$ npm config set foo:port 80\n\n```\n\n最后，env命令可以列出所有环境变量。\n\n\"env\":\"env\" \n\n\n\n\n\n#### 2.10 npm安装git上发布的包\n\n```\n# 这样适合安装公司内部的git服务器上的项目\nnpm install git+https://git@github.com:lurongtao/gp-project.git\n\n# 或者以ssh的方式\nnpm install git+ssh://git@github.com:lurongtao/gp-project.git\n\n```\n\n\n\n#### 2.11 cross-env使用\n\n##### 2.11.1 cross-env是什么\n\n运行跨平台设置和使用环境变量的脚本\n\n\n\n##### 2.11.2 出现原因\n\n当您使用`NODE_ENV=production`，来设置环境变量时，大多数Windows命令提示将会阻塞（报错）。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows不支持`NOE_ENV=production`的设置方式。\n\n\n\n##### 2.11.3 解决\n\ncross-env使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包（cross-env）能够提供一个设置环境变量的scripts，让你能够以Unix方式设置环境变量，然后在Windows上也能兼容运行。\n\n\n\n##### 2.11.4 安装\n\n```\nnpm install --save-dev cross-env\n\n```\n\n\n\n##### 2.11.5 使用\n\n```json\n{\n\t\"scripts\": {\n\t\t\"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\"\n    }\n}\n\n```\n\n`NODE_ENV`环境变量将由`cross-env`设置，打印`process.env.NODE_ENV === 'production'`\n\n\n\n### 3、NRM：npm registry manager\n\n#### 3.1 手工切换源\n\n##### 3.1.1 查看当前源\n\n```\nnpm config get registry\n\n```\n\n\n\n##### 3.1.2 切换淘宝源\n\n```\nnpm config set registry https://registry.npm.taobao.org\n\n```\n\n\n\n#### 3.2 NRM管理源\n\nNRM是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在npm源间切换。\n\n\n\n##### 3.2.1 安装nrm\n\n在命令行执行命令，`npm install -g nrm`，全局安装nrm。\n\n\n\n##### 3.2.2 使用nrm\n\n执行命令`nrm ls`查看可选的源。其中，带`*`的是当前使用的源，上面输出表明当前源是官方源。\n\n\n\n##### 3.2.3 切换nrm\n\n如果要切换到taobao源，执行命令`nrm use taobao`。\n\n\n\n##### 3.2.4 测试速度\n\n你还可以通过`nrm test`测试相应源的响应时间。\n\n\n\n### 4、 NPX：npm package extention\n\nnpm从5.2版开始，增加了npx命令。它有很多用处，本文介绍该命令的主要使用场景。\n\nNode自带npm模块，所以可以直接使用npx命令。万一不能用，就要手动安装一下。\n\n```\n$ npm install -g npx\n\n```\n\n\n\n#### 4.1 调用项目安装的模块\n\nnpx想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。\n\n```\n$ npm install -D mocha\n\n```\n\n\n\n一般来说，调用Mocha，只能在项目脚本和package.json的scripts字段里面，如果想在命令行下调用，必须像下面这样。\n\n```\n# 项目的根目录下执行\n$ node-modules/.bin/mocha --version\n\n```\n\nnpx就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。\n\n```\n$ npx mocha --version\n\n```\n\nnpx的原理很简单，就是运行的时候，会倒`node_modules/.bin`路径和环境变量`$PATH`里面，检查命令是否存在。\n\n\n\n由于npx会检查环境变量$PATH，所以系统命令也可以调用。\n\n```\n# 等同于 ls\n$ npx ls\n\n```\n\n注意，Bash内置的命令不在$PATH里面，所以不能用。比如cd 是Bash命令，因此就不能用npx cd。\n\n\n\n#### 4.2 避免全局安装模块\n\n除了调用项目内部模块，npx还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx可以运行它，而且不进行全局安装。\n\n```\n$ npx create-react-app my-react-app\n\n```\n\n上面代码运行时，npx将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。\n\n\n\n注意，只要npx后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个Web服务。\n\n```\n$ npx http-server\n\n```\n\n\n\n#### 4.3 --no--install参数和--ignore-existing参数\n\n如果想让npx强制使用本地模块，不下载远程模块，可以使用--no-install参数。如果本地不存在该模块，就会报错。\n\n```\n$ npx --no-install http-server\n\n```\n\n反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用--ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。\n\n```\n$ npx --ignore-existing http-server\n\n```\n\n\n\n### 5、node的浏览端调试\n\n- `node --inspect --inspect-brk server.js`\n\n\n\n### 6、node进程管理工具\n\n- supervisor\n\n- nodemon\n\n  ```\n  npm install nodemon\n  nodemon server.js\n  \n  ```\n\n  \n\n- forever\n\n- pm2\n\n\n\n## 三、模块/包与CommonJS\n\n### 1、模块/包分类\n\nNode.js有三类模块，即内置的模块、第三方的模块、自定义的模块。\n\n\n\n#### 1.1 内置的模块\n\nNode.js内置模块又叫核心模块，Node.js安装完成可直接使用。如：\n\n```js\nconst path = require('path')\nvar extname = path.extname('index.html')\nconsole.log(extname)\n\n```\n\n\n\n#### 1.2 第三方的Node.js模块\n\n第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如：\n\n```\nnpm install chalk\n\n```\n\n```js\nconst chalk = require('chalk')\nconsole.log(chalk.blue('Hello world!'))\n\n```\n\n\n\n#### 1.3 自定义的Node.js模块\n\n自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。\n\n\n\n自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。\n\n\n\n##### 1.3.1 模块定义、接口暴露和引用接口\n\n我们可以把公共的功能抽离成为一个单独的js文件作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过`exports`或者`module.exports`暴露属性或者方法。\n\n\n\n> m1.js\n\n```js\nconst name = 'gp19'\n\nconst sayName = () => {\n\tconsole.log(name)\n}\n\nconsole.log('module 1')\n\n// 接口暴露方法一：\nmodule.exports = {\n\tsay: sayName\n}\n\n// 接口暴露方法二：\nexports.say = sayName\n\n// 错误！\nexports = {\n\tsay: sayName\n}\n\n```\n\n\n\n> main.js\n\n```js\nconst m1 = require('./m1')\nm1.say()\n\n```\n\n\n\n##### 1.3.2 模块的循环引用\n\n由于exports使用方式不对，会在两个不同js循环引用的情况下，导致其中一个js无法获取另外一个js的方法，从而导致执行报错。如：\n\n- a.js\n\n```js\nexports.done = false\nconst b = require('./b.js')\nconsole.log('in a, b.done = %j', b.done)\nexports.done = true\nconsole.log('a done')\n\n```\n\n\n\n- b.js\n\n```js\nconsole.log('b starting')\nexports.done = false\nconst a = require('./a.js')\nconsole.log('in b, a.done= %j', a.done)\nexports.done = true\nconsole.log('b done')\n\n```\n\n\n\n- main.js\n\n```js\nconsole.log('main starting')\nconst a = require('./a.js')\nconst b = require('./b.js')\nconsole.log('in main, a.done = %j, b.done = %j', a.done, b.done)\n\n```\n\n`main.js`首先会load `a.js`，此时执行到`const b = require('./b.js');`的时候，程序会转去load`b.js`, 在`b.js`中执行到`const a = require('./a.js');` 为了防止无限循环，将`a.js`exports的未完成副本返回到`b.js`模块。然后`b.js`完成加载，并将其导出对象提供给`a.js`模块。\n\n我们知道nodeJs的对每个js文件进行了一层包装称为`module`，`module`中有一个属性`exports`，当调用`require('a.js')`的时候其实返回的是`module.exports`对象，`module.exports`初始化为一个`{}`空的object，所以在上面的例子中，执行到`b.js`中`const a = require('./a.js');`时不会load新的`a module`, 而是将已经load但是还未完成的`a module`的`exports`属性返回给`b module`，所以`b.js`拿到的是`a module`的`exports`对象，即：`{done:false}`, 虽然在`a.js`中`exports.done`被修改成了`true`，但是由于此时`a.js`未`load`完成，所以在`b.js`输出的`a module`的属性`done`为`false`，而在`main.js`中输出的`a module`的属性`done`为`true`. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。\n\n\n\n## 四、常用内置模块\n\n这里介绍几个常用的内置模块：url，querystring，http，events，fs，stream，readline，crypto，zlib\n\n\n\n### 1、url\n\n\n\n#### 1.1 parse\n\n> 要解析的内容，是否查询字符串\n\n`url.parse(urlString[,parseQueryString[,slashesDenoteHost]])`\n\n```js\nconst url = require('url')\nconst urlString = 'https://www.baidu.com:443/ad/index.html?id=8&name=mouse#tag=110'\nconst parsedStr = url.parse(urlString)\nconsole.log(parsedStr)\n\n=>\n\nUrl {\n  protocol: 'https:',\n  slashes: true,\n  auth: null,\n  host: 'www.baidu.com:443',\n  port: '443',\n  hostname: 'www.baidu.com',\n  hash: '#tag=110',\n  search: '?id=8&name=mouse',\n  query: [Object: null prototype] { id: '8', name: 'mouse' },\n  pathname: '/ad/index.html',\n  path: '/ad/index.html?id=8&name=mouse',\n  href: 'https://www.baidu.com:443/ad/index.html?id=8&name=mouse#tag=110'\n}\n\n```\n\n\n\n#### 1.2 format\n\n> 将一个解析后的URL对象、转成、一个格式化的URL字符串。\n\n`url.format(urlObject)`\n\n```js\nconst url = require('url')\nconst urlObject = {\n  protocol: 'https:',\n  slashes: true,\n  auth: null,\n  host: 'www.baidu.com:443',\n  port: '443',\n  hostname: 'www.baidu.com',\n  hash: '#tag=110',\n  search: '?id=8&name=mouse',\n  query: { id: '8', name: 'mouse' },\n  pathname: '/ad/index.html',\n  path: '/ad/index.html?id=8&name=mouse',\n  href: 'https://www.baidu.com:443/ad/index.html?id=8&name=mouse#tag=110'\n}\nconst parsedObj = url.format(urlObject)\nconsole.log(parsedObj)\n\n=> \n'https://www.baidu.com:443/ad/index.html?id=8&name=mouse#tag=110'\n\n```\n\n\n\n#### 1.3 resolve\n\n> 用于拼接URL（替换 域名后面第一个`/`后的内容,如果出现`.`就向上返回一级之后再拼接，两个`..`就向上反两级再拼接）\n\n`url.resolve(from, to)`\n\n```\nconst url = require('url')\nvar a = url.resolve('/one/two/three', 'four') \nvar b = url.resolve('http://example.com/', '/one')\nvar c = url.resolve('http://example.com/one', '/two');\nvar d = url.resolve('http://example.com/one/ddd/ddd/ddd', './two');\nvar e = url.resolve('http://example.com/one/ddd/ddd/ddd', '../two');\nvar f = url.resolve('http://example.com/one/ddd/ddd/ddd', '.../two');\nconsole.log(a +\",\"+ b +\",\"+ c+','+d+','+e+','+f);\n\n=>\n/one/two/four,\nhttp://example.com/one,\nhttp://example.com/two,\nhttp://example.com/one/ddd/ddd/two,\nhttp://example.com/one/ddd/two\nhttp://example.com/one/ddd/ddd/.../two\n\n```\n\n\n\n### 2、querystring\n\n#### 2.1 parse\n\n> 将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。\n\n`querystring.parse(str[, sep[, eq[, options]]])`\n\n- `str`：欲转换的字符串\n- `sep`：设置分隔符，默认为`&`\n- `eq`：设置赋值符，默认为`=`\n- `[options]`maxKeys：可接受字符串的最大长度，默认为1000\n\n```js\nconst querystring = require('querystring')\nvar qs = 'foo=bar&baz=qux&baz=quux&corge'\nvar parsed = querystring.parse(qs)\nconsole.log(parsed)\n\n=>\n\n{ foo: 'bar', baz: ['qux', 'quux'], corge: '' }\n\n```\n\n\n\n#### 2.2 stringify\n\n> 将对象转换成字符串，字符串里多个参数将用 ‘&' 分隔，将用 ‘=' 赋值。\n\n`querystring.stringify(obj[, sep[, eq[, options]]])`\n\n- `obj`：欲转换的对象\n- `sep`：设置分隔符，默认为`&`\n- `eq`：设置赋值符，默认为`=`\n\n```js\nconst querystring = require('querystring')\nvar qo = { foo: 'bar', baz: ['qux', 'quux'], corge: '' }\nvar parsed = querystring.stringify(qo)\nconsole.log(parsed)\n\n==>\n'foo=bar&baz=qux&baz=quux&corge='\n \n\nconst querystring = require('querystring')\nvar qo = {foo: 'bar', baz: 'qux'}\nvar parsed =querystring.stringify(qo, ';', ':')\nconsole.log(parsed)\n\n==>\n'foo:bar;baz:qux'\n\n```\n\n\n\n#### 2.3 escape/unescape\n\n> 以针对网址查询字符串的特定要求优化的方式对给定的 `str` 执行网址百分比编码\n>\n> `querystring.escape()` 方法被 `querystring.stringify()` 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 `querystring.escape` 分配给替代函数来提供替换的百分比编码实现。\n\n`querystring.escape(str)`\n\n```js\nconst querystring = require('querystring')\nvar str = 'id=3&city=北京&url=https://www.baidu.com'\nvar escaped = querystring.escape(str)\nconsole.log(escaped)\n\n==> 'id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com'\n\n```\n\n\n\n> 在给定的 `str` 上执行网址百分比编码字符的解码。\n>\n> `querystring.unescape()` 方法被 `querystring.parse()` 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 `querystring.unescape` 分配给替代函数来提供替代的解码实现。\n>\n> 默认情况下，`querystring.unescape()` 方法将尝试使用 JavaScript 内置的 `decodeURIComponent()` 方法进行解码。 如果失败，则将使用更安全的不会因格式错误的网址而抛出错误的同类方法。\n\n`querystring.unescape(str)`\n\n```js\nconst querystring = require('querystring')\nvar str = 'id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com'\nvar unescaped = querystring.unescape(str)\nconsole.log(unescaped)\n\n==>\n'id=3&city=北京&url=https://www.baidu.com'\n\n```\n\n\n\n### 3、http/https\n\n#### 3.1 get\n\n```js\nvar http = require('http')\nvar https = require('https')\n\n// 1、接口 2、跨域\nconst server = http.createServer((request, response) => {\n  var url = request.url.substr(1)\n\n  var data = ''\n\n  \n  response.writeHeader(200, {\n    'content-type': 'application/json;charset=utf-8',\n    'Access-Control-Allow-Origin': '*'\n  })\n\n  //response.write('<div>hello</div>')\n  //response.end()\n  // 或\n  //response.end('<div>hello</div>')\n    \n  https.get(`https://m.lagou.com/listmore.json${url}`, (res) => {\n\n    res.on('data', (chunk) => {\n      data += chunk\n    })\n\n    res.on('end', () => {\n      response.end(JSON.stringify({\n        ret: true,\n        data\n      }))\n    })\n  })\n\n})\n\nserver.listen(8080, () => {\n  console.log('localhost:8080')\n})\n\n```\n\n\n\n#### 3.2 post:服务器提交（攻击）\n\n```js\nconst https = require('https')\nconst querystring = require('querystring')\n\nconst postData = querystring.stringify({\n  province: '上海',\n  city: '上海',\n  district: '宝山区',\n  address: '同济支路199号智慧七立方3号楼2-4层',\n  latitude: 43.0,\n  longitude: 160.0,\n  message: '求购一条小鱼',\n  contact: '13666666',\n  type: 'sell',\n  time: 1571217561\n})\n\nconst options = {\n  protocol: 'http:',\n  hostname: 'localhost',\n  method: 'POST',\n  port: 3000,\n  path: '/index.php/trade/add_item',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData)\n  }\n}\n\nconst server = http.createServer((req, res) => {\n\tconst request = http.request(options, result => {\n\t\t\n    })\n    req.write(postData)\n    req.end()\n    \n    res.end()\n})\nserver.listen(8080, ()=> {\n\tconsole.log('localhost:8080')\n})\n\n//function doPost() {\n//  let data\n\n//  let req = https.request(options, (res) => {\n//    res.on('data', chunk => data += chunk)\n//    res.on('end', () => {\n//      console.log(data)\n//    })\n//  })\n\n//  req.write(postData)\n//  req.end()\n//}\n\n// setInterval(() => {\n//   doPost()\n// }, 1000)\n\n```\n\n\n\n#### 3.3 跨域：JSONP\n\n```js\nconst http = require('http')\nconst url = require('url')\n\nconst app = http.createServer((req, res) => {\n  let urlObj = url.parse(req.url, true)\n\n  switch (urlObj.pathname) {\n    case '/api/user':\n      res.end(`${urlObj.query.cb}({\"name\": \"gp145\"})`)\n      break\n    default:\n      res.end('404.')\n      break\n  }\n})\n\napp.listen(8080, () => {\n  console.log('localhost:8080')\n})\n\n```\n\n\n\n#### 3.4 跨域：CORS\n\n```js\nconst http = require('http')\nconst url = require('url')\nconst querystring = require('querystring')\n\nconst app = http.createServer((req, res) => {\n  let data = ''\n  let urlObj = url.parse(req.url, true)\n\n  res.writeHead(200, {\n    'content-type': 'application/json;charset=utf-8',\n    'Access-Control-Allow-Origin': '*'\n  })\n\n  req.on('data', (chunk) => {\n    data += chunk\n  })\n\n  req.on('end', () => {\n    responseResult(querystring.parse(data))\n  })\n\n  function responseResult(data) {\n    switch (urlObj.pathname) {\n      case '/api/login':\n        res.end(JSON.stringify({\n          message: data\n        }))\n        break\n      default:\n        res.end('404.')\n        break\n    }\n  }\n})\n\napp.listen(8080, () => {\n  console.log('localhost:8080')\n})\n\n```\n\n\n\n#### 3.5 跨域：middleware(http-proxy-middware)\n\n```js\nconst http = require('http')\nconst proxy = require('http-proxy-middleware')\n\nhttp.createServer((req, res) => {\n  let url = req.url\n\n  res.writeHead(200, {\n    'Access-Control-Allow-Origin': '*'\n  })\n\n  if (/^\\/api/.test(url)) {\n    let apiProxy = proxy('/api', { \n      target: 'https://m.lagou.com',\n      changeOrigin: true,\n      pathRewrite: {\n        '^/api': ''\n      }\n    })\n\n    // http-proy-middleware 在Node.js中使用的方法\n    apiProxy(req, res)\n  } else {\n    switch (url) {\n      case '/index.html':\n        res.end('index.html')\n        break\n      case '/search.html':\n        res.end('search.html')\n        break\n      default:\n        res.end('[404]page not found.')\n    }\n  }\n}).listen(8080)\n\n```\n\n\n\n#### 3.6 爬虫\n\n```js\nconst https = require('https')\nconst http = require('http')\nconst cheerio = require('cheerio')\n\nhttp.createServer((request, response) => {\n  response.writeHead(200, {\n    'content-type': 'application/json;charset=utf-8'\n  })\n\n  const options = {\n    protocol: 'https:',\n    hostname: 'maoyan.com',\n    port: 443,\n    path: '/',\n    method: 'GET'\n  }\n\n  const req = https.request(options, (res) => {\n    let data = ''\n    res.on('data', (chunk) => {\n      data += chunk\n    })\n\n    res.on('end', () => {\n      filterData(data)\n    })\n  })\n\n  function filterData(data) {\n    let $ = cheerio.load(data)\n    let $movieList = $('.movie-item')\n    let movies = []\n    $movieList.each((index, value) => {\n      movies.push({\n        title: $(value).find('.movie-title').attr('title'),\n        score: $(value).find('.movie-score i').text(),\n      })\n    })\n\n    response.end(JSON.stringify(movies))\n  }\n\n  req.end()\n}).listen(9000)\n\n```\n\n\n\n### 4、Events\n\n```js\nconst EventEmitter = require('events')\n\nclass MyEventEmitter extends EventEmitter {}\n\nconst event = new MyEventEmitter()\n\nevent.on('play', (movie) => {\n  console.log(movie)\n})\n\nevent.emit('play', '我和我的祖国')\nevent.emit('play', '中国机长')\n\n```\n\n\n\n### 5、File System\n\n```js\nconst fs = require('fs')\nconst fsP = require('fs').promises\n\n// 创建文件夹\nfs.mkdir('./logs', (err) => {\n  console.log('done.')\n})\n\n// 文件夹改名\nfs.rename('./logs', './log', () => {\n  console.log('done')\n})\n\n// 删除文件夹\nfs.rmdir('./log', () => {\n  console.log('done.')\n})\n\n// 写内容到文件里\nfs.writeFile(\n  './logs/log1.txt',\n  'hello',\n  // 错误优先的回调函数\n  (err) => {\n    if (err) {\n      console.log(err.message)\n    } else {\n      console.log('文件创建成功')\n    }\n  }\n)\n\n// 给文件追加内容\nfs.appendFile('./logs/log1.txt', '\\nworld', () => {\n  console.log('done.')\n})\n\n// 读取文件内容\nfs.readFile('./logs/log1.txt', 'utf-8', (err, data) => {\n  console.log(data)\n})\n\n// 删除文件\nfs.unlink('./logs/log1.txt', (err) => {\n  console.log('done.')\n})\n\n// 批量写文件\nfor (var i = 0; i < 10; i++) {\n  fs.writeFile(`./logs/log-${i}.txt`, `log-${i}`, (err) => {\n    console.log('done.')\n  })\n}\n\n// 读取文件/目录信息\nfs.readdir('./', (err, data) => {\n  data.forEach((value, index) => {\n    fs.stat(`./${value}`, (err, stats) => {\n      // console.log(value + ':' + stats.size)\n      console.log(value + ' is ' + (stats.isDirectory() ? 'directory' : 'file'))\n    })\n  })\n})\n\n// 同步读取文件\ntry {\n  const content = fs.readFileSync('./logs/log-1.txt', 'utf-8')\n  console.log(content)\n  console.log(0)\n} catch (e) {\n  console.log(e.message)\n}\n\nconsole.log(1)\n\n// 异步读取文件：方法一\nfs.readFile('./logs/log-0.txt', 'utf-8', (err, content) => {\n  console.log(content)\n  console.log(0)\n})\nconsole.log(1)\n\n// 异步读取文件：方法二\nfs.readFile('./logs/log-0.txt', 'utf-8').then(result => {\n  console.log(result)\n})\n\n// 异步读取文件：方法三\nfunction getFile() {\n  return new Promise((resolve) => {\n    fs.readFile('./logs/log-0.txt', 'utf-8', (err, data) => {\n      resolve(data)\n    })\n  })\n}\n\n;(async () => {\n  console.log(await getFile())\n})()\n\n// 异步读取文件：方法四\nconst fsp = fsP.readFile('./logs/log-1.txt', 'utf-8').then((result) => {\n  console.log(result)\n})\n\nconsole.log(fsP)\n\n// watch 监测文件变化\nfs.watch('./logs/log-0.txt', () => {\n  console.log(0)\n})\n\n```\n\n\n\n### 6、Stream\n\n```js\nconst fs = require('fs')\n\nconst readstream = fs.createReadStream('./note.txt')\nconst writestream = fs.createWriteStream('./note2.txt')\n\nwritestream.write(readstream)\n\n```\n\n\n\n### 7、Zlib\n\n```js\nconst fs = require('fs')\nconst zlib = require('zlib')\n\nconst gzip = zlib.createGzip()\n\nconst readstream = fs.createReadStream('./note.txt')\nconst writestream = fs.createWriteStream('./note2.txt')\n\nreadstream\n  .pipe(gzip)\n  .pipe(writestream)\n\nwritestream.write(readstream)\n\n```\n\n\n\n### 8、ReadLine\n\n```js\nconst readline = require('readline')\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\n\nrl.question('What do you think of Node.js? ', (answer) => {\n  // TODO: Log the answer in a database\n  console.log(`Thank you for your valuable feedback: ${answer}`)\n\n  rl.close()\n})\n\n```\n\n\n\n### 9、Crypto\n\n```js\nconst crypto = require('crypto')\n\nconst secret = 'abcdefg'\nconst hash = crypto.createHmac('sha256', secret)\n                   .update('I love you')\n                   .digest('hex')\nconsole.log(hash)\n\n```\n\n\n\n## 五、路由\n\n```js\nvar http = require('http')\nvar fs = require('fs')\n\nhttp.createServer( function ( req, res ) {\n\n  switch ( req.url ) {\n    case '/home':\n      res.write('home')\n      res.end()\n      break\n    case '/mine':\n      res.write('mine')\n      res.end()\n      break\n    case '/login': \n      fs.readFile( './static/login.html',function ( error , data ) {\n        if ( error ) throw error  \n        res.write( data )\n        res.end()\n      })\n      break\n    case '/fulian.jpg':\n      fs.readFile( './static/fulian.jpg', 'binary', function( error , data ) {\n        if( error ) throw error \n        res.write( data, 'binary' )\n        res.end()\n      })\n      break\n    default: \n      break\n   }\n\n }).listen( 8000, 'localhost', function () {\n   console.log( '服务器运行在： http://localhost:8000' )\n })\n\n```\n\n\n\n## 六、静态资源服务\n\n### 6.1 readStaticFile\n\n`/modules/readStaticFile.js`\n\n```js\n// 引入依赖的模块\nvar path = require('path')\nvar fs = require('fs')\nvar mime = require('mime')\n\nfunction readStaticFile(res, filePathname) {\n\n  var ext = path.parse(filePathname).ext\n  var mimeType = mime.getType(ext)\n\n  // 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 \n  if (ext) {\n    // 根据传入的目标文件路径来读取对应文件\n    fs.readFile(filePathname, (err, data) => {\n    // 错误处理\n      if (err) {\n        res.writeHead(404, { \"Content-Type\": \"text/plain\" })\n        res.write(\"404 - NOT FOUND\")\n        res.end()\n      } else {\n        res.writeHead(200, { \"Content-Type\": mimeType })\n        res.write(data)\n        res.end()\n      }\n    });\n    // 返回 true 表示, 客户端想要的 是 静态文件\n    return true\n  } else {\n    // 返回 false 表示, 客户端想要的 不是 静态文件\n    return false\n  }\n}\n\n// 导出函数\nmodule.exports = readStaticFile\n\n```\n\n\n\n### 6.2 server\n\n`/server.js`\n\n```js\n// 引入相关模块\nvar http = require('http');\nvar url = require('url');\nvar path = require('path');\nvar readStaticFile = require('./modules/readStaticFile');\n\n// 搭建 HTTP 服务器\nvar server = http.createServer(function(req, res) {\n  var urlObj = url.parse(req.url);\n  var urlPathname = urlObj.pathname;\n  var filePathname = path.join(__dirname, \"/public\", urlPathname);\n\n  // 读取静态文件\n  readStaticFile(res, filePathname);\n});\n\n// 在 3000 端口监听请求\nserver.listen(3000, function() {\n  console.log(\"服务器运行中.\");\n  console.log(\"正在监听 3000 端口:\")\n})\n\n```\n\n\n\n### 6.3 最终目录结构\n\n![](https://lurongtao.gitee.io/felixbooks-gp19-node.js/images/dir.jpg)\n\n\n\n\n\n# 02-Express\n\n基于Node.js平台，快速、开放、极简的web开发框架。\n\n```\n$ npm install express --save\n\n```\n\n\n\n## 一、特色\n\n### 1、Web应用\n\nExpress是一个基于Node.js平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种Web和移动设备应用。\n\n\n\n### 2、API\n\n丰富的HTTP快捷方法和任意排列组合的Connect中间件，让你创建健壮、友好的API变得既快速又简单。\n\n\n\n### 3、性能\n\nExpress不对Node.js已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的基本性能。\n\n\n\n## 二、安装\n\n首先假定你已经安装了Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。\n\n```\n$ mkdir myapp\n$ cd myapp\n\n```\n\n通过`npm init`命令为你的应用创建一个`package.json`文件。欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。\n\n```\n$ npm init\n\n```\n\n此命令将要求你输入几个参数，例如此应用的名称和版本。你可以直接按“回车”键接受默认设置即可，下面这个除外：\n\n```\nentry point: (index.js)\n\n```\n\n键入app.js或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的`index.js`文件名，只需按“回车”键即可。\n\n\n\n接下来安装Express并将其保存到依赖列表中：\n\n```\n$ npm install express --save\n\n```\n\n\n\n如果只是临时安装Express，不想将它添加到依赖列表中，只需略去--save参数即可：\n\n```\n$ npm install express\n\n```\n\n\n\n> 安装Node模块时，如果指定了` --save` 参数，那么此模块将被添加到`package.json`文件中`dependencies`依赖列表中。然后通过`npm install` 命令即可\n\n\n\n## 三、Hello World实例\n\n接下来，我们一起创建一个基本的Express应用。\n\n注意：这里所创建的是一个最最简单的Express应用，并且仅仅只有一个文件 - 和通过Express应用生成器所创建的应用完全不一样，Express应用生成器所创建的应用框架包含多JavaScript文件、Jade模板和针对不同用途的子目录。\n\n\n\n进入myapp目录，创建一个名为app.js的文件，然后将下列代码复制进去：\n\n```js\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n\nvar server = app.listen(3000, function () {\n  var host = server.address().address;\n  var port = server.address().port;\n\n  console.log('Example app listening at http://%s:%s', host, port);\n});\n\n```\n\n上面的代码启动一个服务并监听从3000端口进入的所有连接请求。他将对所有(/)URL或 路由返回“Hello World！”字符串。对于其他所有路径全部返回 404 Not Found。\n\n> req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on('data', callback) 以及任何 Node 提供的方法。\n\n\n\n通过如下命令启动此应用：\n\n```\n$ node app.js\n\n```\n\n然后在浏览器中打开 <http://localhost:3000/> 并查看输出结果。\n\n\n\n## 四、路由\n\n路由是指如何定义应用的端点（URls）以及如何响应客户端的请求。\n\n\n\n路由是由一个URI、HTTP请求（GET、POST等）和若干个句柄组成，它的结构如下：app.METHOD(path, [callback..], callback)， app 是 express 对象的一个实例，METHOD是一个 HTTP 请求方法，path 是服务器上的路径， callback 是当路由匹配时要执行的函数。\n\n\n\n下面是一个基本的路由示例：\n\n```js\nvar express = require('express');\nvar app = express();\n\n// respond with \"hello world\" when a GET request is made to the homepage\napp.get('/', function(req, res) {\n  res.send('hello world');\n});\n\n```\n\n\n\n### 1、路由方法\n\n路由方法源于 HTTP 请求方法，和 express 实例相关联。\n\n下面这个例子展示了为应用跟路径定义的 GET 和 POST 请求：\n\n```js\n// GET method route\n// 对网站首页的访问返回 \"Hello World!\" 字样\napp.get('/', function (req, res) {\n  res.send('Hello World!')\n})\n\n// 网站首页接受 POST 请求\napp.post('/', function (req, res) {\n  res.send('Got a POST request')\n})\n\n// /user 节点接受 PUT 请求\napp.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user')\n})\n\n// /user 节点接受 DELETE 请求\napp.delete('/user', function (req, res) {\n  res.send('Got a DELETE request at /user')\n})\n\n```\n\nExpress 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。\n\n> 有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如：`app['m-search']('/', function ...)`\n\n\n\napp.all()是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。\n\n\n\n在下面的例子中，来自\"/secret\"的请求，不管使用 GET、POST、PUT、DELETE或其他任何http模块支持的HTTP请求，句柄都会得到执行。\n\n```js\napp.all('/secret', function (req, res, next) {\n  console.log('Accessing the secret section ...')\n  next(); // pass control to the next handler\n})\n\n```\n\n\n\n### 2、路由路径\n\n路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。\n\n\n\nExpress使用`path-to-regexp`匹配路由路径，请参考文档查阅所有定义路由路径的方法。Express Route Tester是测试基本Express路径的好工具，但不支持模式匹配。\n\n> 查询字符串不是路由路径的一部分。\n\n使用字符串的路由路径示例：\n\n```js\n// 匹配根路径的请求\napp.get('/', function (req, res) {\n  res.send('root');\n});\n\n// 匹配 /about 路径的请求\napp.get('/about', function (req, res) {\n  res.send('about');\n});\n\n// 匹配 /random.text 路径的请求\napp.get('/random.text', function (req, res) {\n  res.send('random.text');\n});\n\n```\n\n\n\n使用字符串模式的路由路径示例：\n\n```js\n// 匹配 acd 和 abcd\napp.get('/ab?cd', function(req, res) {\n  res.send('ab?cd');\n});\n\n// 匹配 abcd、abbcd、abbbcd等\napp.get('/ab+cd', function(req, res) {\n  res.send('ab+cd');\n});\n\n// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等\napp.get('/ab*cd', function(req, res) {\n  res.send('ab*cd');\n});\n\n// 匹配 /abe 和 /abcde\napp.get('/ab(cd)?e', function(req, res) {\n res.send('ab(cd)?e');\n});\n\n```\n\n> 字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。\n\n\n\n使用正则表达式的路由路径示例：\n\n```js\n// 匹配任何路径中含有 a 的路径：\napp.get(/a/, function(req, res) {\n  res.send('/a/');\n});\n\n// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等\napp.get(/.*fly$/, function(req, res) {\n  res.send('/.*fly$/');\n});\n\n```\n\n\n\n### 3、路由句柄\n\n可以为请求处理提供多个回调函数，其行为类似中间件。唯一的区别是这些回调函数有可能调用`next('route')`方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。\n\n\n\n路由句柄有多种形式，可以是一个函数、一个函数数组、或者是两者混合，如下所示。\n\n\n\n使用一个回调函数处理路由：\n\n```js\napp.get('/example/a', function(req, res) {\n\tres.send('Hello from A!')\n})\n\n```\n\n\n\n使用多个回调函数处理路由（记得指定next对象）：\n\n```js\napp.get('/example/b', function (req, res, next) {\n  console.log('response will be sent by the next function ...');\n  next();\n}, function (req, res) {\n  res.send('Hello from B!');\n});\n\n```\n\n\n\n使用回调函数数组处理路由：\n\n```js\nvar cb0 = function (req, res, next) {\n  console.log('CB0')\n  next()\n}\n\nvar cb1 = function (req, res, next) {\n  console.log('CB1')\n  next()\n}\n\nvar cb2 = function (req, res) {\n  res.send('Hello from C!')\n}\n\napp.get('/example/c', [cb0, cb1, cb2])\n\n```\n\n\n\n混合使用函数和函数数组处理路由：\n\n```js\nvar cb0 = function (req, res, next) {\n  console.log('CB0')\n  next()\n}\n\nvar cb1 = function (req, res, next) {\n  console.log('CB1')\n  next()\n}\n\napp.get('/example/d', [cb0, cb1], function (req, res, next) {\n  console.log('response will be sent by the next function ...')\n  next()\n}, function (req, res) {\n  res.send('Hello from D!')\n})\n\n```\n\n\n\n### 4、响应方法\n\n下表中响应对象(res)的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。\n\n|       方法       |                            描述                            |\n| :--------------: | :--------------------------------------------------------: |\n|  res.download()  |                        提示下载文件                        |\n|    res.end()     |                      终结响应处理流程                      |\n|    res.json()    |                   发送一个JSON格式的响应                   |\n|   res.jsonp()    |             发送一个支持JSONP的JSON格式的响应              |\n|   res.direct()   |                         重定向请求                         |\n|   res.render()   |                        渲染视图模板                        |\n|    res.send()    |                     发送各种类型的响应                     |\n|  res.sendFile()  |                 以八位字节流的形式发送文件                 |\n| res.sendStatus() | 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送 |\n\n\n\n### 5、app.route()\n\n可使用app.route()创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。\n\n\n\n下面这个示例程序使用app.route()定义了链式路由句柄。\n\n```js\napp.route('/book')\n  .get(function(req, res) {\n    res.send('Get a random book');\n  })\n  .post(function(req, res) {\n    res.send('Add a book');\n  })\n  .put(function(req, res) {\n    res.send('Update the book');\n  });\n\n```\n\n\n\n### 6、express.Router\n\n可使用express.Router类创建模块化、可挂载的路由句柄。Router实例是一个完整的中间件和路由系统，因此常称其为一个'mini-app'。\n\n\n\n下面的实例程序创建了一个路由模块，并加载 了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。\n\n\n\n在app目录下创建名为bird.js的文件，内容如下：\n\n```js\nvar express = require('express');\nvar router = express.Router();\n\n// 该路由使用的中间件\nrouter.use(function timeLog(req, res, next) {\n  console.log('Time: ', Date.now());\n  next();\n});\n// 定义网站主页的路由\nrouter.get('/', function(req, res) {\n  res.send('Birds home page');\n});\n// 定义 about 页面的路由\nrouter.get('/about', function(req, res) {\n  res.send('About birds');\n});\n\nmodule.exports = router;\n\n```\n\n\n\n然后在应用中加载路由模块：\n\n```js\nvar birds = require('./birds')\n...\napp.use('/birds', birds)\n\n```\n\n应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。\n\n\n\n## 五、利用Express托管静态文件\n\n通过Express内置的`express.static`可以方便地托管静态文件，例如图片、CSS、JavaScript文件等。\n\n\n\n将静态资源文件所在的目录作为参数传递给`express.static`中间件就可以提供静态资源文件的访问了。例如，假设在public目录放置了图片、CSS和JavaScript文件，你就可以：\n\n```js\napp.use(express.static('public'))\n\n```\n\n现在，public目录下面的文件就可以访问了。\n\n```\nhttp://localhost:3000/images/kitten.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/images/bg.png\nhttp://localhost:3000/hello.html\n\n```\n\n> 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在URL中。\n\n\n\n如果你的静态资源存放在多个目录下面，你可以多次调用`express.static`中间件：\n\n```js\napp.use(express.static('public'))\napp.use(express.static('files'))\n\n```\n\n\n\n访问静态资源文件时，`express.static`中间件会根据目录添加的顺序查找所需的文件。\n\n\n\n如果你希望所有通过`express.static`访问的文件都存放在一个”虚拟(virtual)“目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：\n\n```js\napp.use('/static', express.static('public'))\n\n```\n\n现在，你就可以通过带有”/static“前缀的地址来访问public目录下面的文件了。\n\n```js\nhttp://localhost:3000/static/images/kitten.jpg\nhttp://localhost:3000/static/css/style.css\nhttp://localhost:3000/static/js/app.js\nhttp://localhost:3000/static/images/bg.png\nhttp://localhost:3000/static/hello.html\n\n```\n\n\n\n## 六、使用中间件\n\nExpress是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。\n\n\n\n中间件（Middleware）是一个函数，它可以访问请求对象（request object(req)），响应对象(response object(res))，和web应用中处于请求-响应循环流程中的中间件，一般被命名为next的变量。\n\n\n\n中间件的功能包括：\n\n- 执行任何代码\n- 修改请求和响应对象\n- 终结请求-响应循环\n- 调用堆栈中的下一个中间件\n\n\n\n如果当前中间件没有终结请求-响应循环，则必须调用`next()`方法将控制权交给下一个中间件，否则请求就会挂起。\n\n\n\nExpress应用可使用如下几种中间件：\n\n- 应用级中间件\n- 路由级中间件\n- 错误处理中间件\n- 内置中间件\n- 第三方中间件\n\n\n\n使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。\n\n\n\n### 1、应用级中间件\n\n应用级中间件绑定到app对象，使用`app.use()`和`app.METHOD()`，其中，`METHOD`是需要处理的HTTP请求的方法，例如GET,PUT,POST等等，全部小写。例如：\n\n```js\nvar app = express()\n\n// 没有挂载路径的中间件，应用的每个请求都会执行该中间件\napp.use(function (req, res, next) {\n\tconsole.log('Time:', Date.now())\n    next()\n})\n\n// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它\napp.use('/user/:id', function(req, res, next) {\n\tconsole.log('Request Type:', req.method)\n    next()\n})\n\n// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求\napp.get('/user/:id', function(req, res, next) {\n\tres.send('USER')\n})\n\n```\n\n\n\n下面这个例子展示了在一个挂载点装载一组中间件。\n\n```js\n// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息\napp.use('/user/:id', function(req, res, next) {\n\tconsole.log('Request URL:', req.originalUrl)\n    next()\n}, function(req, res, next) {\n\tconsole.log('Request Type:', req.method)\n    next()\n})\n\n```\n\n作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。 第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。\n\n```js\n// 一个中间件栈，处理指向 /user/:id 的 GET请求\napp.get('/user/:id', function(req, res, next) {\n\tconsole.log('ID:', req.params.id)\n    next()\n}, function(req, res, next) {\n\tres.send('User Info')\n})\n\n// 处理 /user/:id, 打印出用户id\napp.get('/user/:id', function(req, res, next) {\n\tres.end(req.params.id)\n})\n\n```\n\n\n\n如果需要在中间件栈中跳过剩余中间件，调用 `next('route')`方法将控制权交给下一个路由。注意：`next('route')`只对使用 `app.VERB()`  或 `router.VERB()`加载的中间件有效。\n\n```js\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\napp.get('/user/:id', function(req, res, next) {\n\t// 如果 user id 为0，跳到下一个路由\n    if (req.params.id === 0) next('route')\n    // 否则将控制权交给栈中下一个中间件\n    else next()\n}, function(req, res, next) {\n\t// 渲染常规页面\n    res.render('regular')\n})\n\n// 处理 /user/:id, 渲染一个特殊页面\napp.get('/user/:id', function(req, res, next) {\n\tres.render('special')\n})\n\n```\n\n\n\n### 2、路由级中间件\n\n路由级中间件和应用级中间件一样，只是它绑定的对象为 `express.Router()`。\n\n```\nvar router = express.Router()\n\n```\n\n路由级使用`router.use()`或`router.VERB()`加载。\n\n 上述在应用级创建的中间件系统，可通过如下代码改写为路由级。\n\n```js\nvar app = express()\nvar router = express.Router()\n\n// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件\nrouter.use(function (req, res, next) {\n  console.log('Time:', Date.now())\n  next()\n})\n\n// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息\nrouter.use('/user/:id', function(req, res, next) {\n  console.log('Request URL:', req.originalUrl)\n  next()\n}, function (req, res, next) {\n  console.log('Request Type:', req.method)\n  next()\n})\n\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\nrouter.get('/user/:id', function (req, res, next) {\n  // 如果 user id 为 0, 跳到下一个路由\n  if (req.params.id == 0) next('route')\n  // 负责将控制权交给栈中下一个中间件\n  else next() //\n}, function (req, res, next) {\n  // 渲染常规页面\n  res.render('regular')\n})\n\n// 处理 /user/:id， 渲染一个特殊页面\nrouter.get('/user/:id', function (req, res, next) {\n  console.log(req.params.id)\n  res.render('special')\n})\n\n// 将路由挂载至应用\napp.use('/', router)\n\n```\n\n\n\n### 3、错误处理中间件\n\n> 错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。\n\n错误处理中间件和其他中间件定义类似，只是要使用4个参数，而不是3个，其签名如下：(err,req,res,next)。\n\n```js\napp.use(function(err, req, res, next) {\n  console.error(err.stack)\n  res.status(500).send('Something broke!')\n})\n\n```\n\n\n\n### 4、内置中间件\n\n从4.x版本开始，Express已经不再依赖Connect了。除了express.static，Express以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。\n\n\n\n`express.static(root, [options])`\n\nexpress.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在Express应用中提托管静态资源。\n\n参数 root 指提供静态资源的根目录。\n\n可选的 options 参数拥有如下属性。\n\n| 属性         | 描述                                                         | 类型     | 缺省值       |\n| ------------ | ------------------------------------------------------------ | -------- | ------------ |\n| dotfiles     | 是否对外输出文件名以点（.）开头的文件。可选值为”allow“，”deny“和”ignore“。 | String   | ”ignore“     |\n| etag         | 是否启用etag生成                                             | Boolean  | true         |\n| extensions   | 设置文件扩展名备份选项                                       | Array    | []           |\n| index        | 发送目录索引文件，设置为false禁用目录索引                    | Mixed    | \"index.html\" |\n| lastModified | 设置Last-Modified头为文件在操作系统上的最后修改日期。可能值为true或false | Boolean  | true         |\n| maxAge       | 以毫秒或者其字符串格式设置Cache-Control头的max-age属性。     | Number   | 0            |\n| redirect     | 当路径为目录时，重定向至”/“                                  | Boolean  | true         |\n| setHeaders   | 设置HTTP头以提供文件的函数                                   | Function |              |\n\n下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。\n\n```js\nvar options = {\n  dotfiles: 'ignore',\n  etag: false,\n  extensions: ['htm', 'html'],\n  index: false,\n  maxAge: '1d',\n  redirect: false,\n  setHeaders: function (res, path, stat) {\n    res.set('x-timestamp', Date.now())\n  }\n}\n\napp.use(express.static('public', options))\n\n```\n\n每个应用可有多个静态目录。\n\n```js\napp.use(express.static('public'))\napp.use(express.static('uploads'))\napp.use(express.static('files'))\n\n```\n\n\n\n### 5、第三方中间件\n\n通过使用第三方中间件从而为 Express 应用增加更多功能。\n\n安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。\n\n下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser\n\n```\n$ npm install cookie-parser\n\n```\n\n```js\nvar express = require('express')\nvar app = express()\nvar cookieParser = require('cookie-parser')\n\n// 加载用于解析 cookie 的中间件\napp.use(cookieParser())\n\n```\n\n\n\n## 七、在Express中使用模板引擎\n\n需要在应用中进行如下设置才能让Express渲染模板文件：\n\n- `views`，放模板文件的目录，比如：`app.set('views', './views')`\n- `view engine`，模板引擎，比如：`app.set('view engine', 'ejs')`\n\n\n\n**art-template**\n\nart-template for express 4.x.\n\n- 1、Install\n\n  ```\n  npm install --save art-template\n  npm install --save express-art-template\n  \n  ```\n\n  \n\n- 2、Example\n\n  ```js\n  var express = require('express')\n  var app = express()\n  \n  // view engine setup\n  app.engine('art', require('express-art-template'))\n  app.set('view', {\n      debug: process.env.NODE_ENV !== 'production'\n  })\n  app.set('views', path.join(__dirname, 'views'))\n  app.set('view engine', 'art')\n  \n  // routes\n  app.get('/', function (req, res) {\n      res.render('index.art', {\n          user: {\n              name: 'aui',\n              tags: ['art', 'template', 'nodejs']\n          }\n      })\n  })\n  \n  ```\n\n  \n\n# 03-Koa2\n\n## 一、koa2快速开始\n\n因为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以上node.js环境 版本v7.6以上 npm 版本3.x以上","source":"_posts/nodejs.md","raw":"---\ntitle: Nodejs\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: hojun.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-12 19：05：08\ncomments: true\ntags: \n - 后端\nkeywords: node\ndescription: nodejs教程\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/5.jpeg\n\n---\n\n\n# 01-Node.js基础\n\n## 一、Node.js是什么\n\nNode.js is a JavaScript runtime built on Chrome's V8 JavaScript engine.\n\n\n\n### 1、 特性\n\nNode.js可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：\n\n- 文件的读写（File System）\n- 进程的管理（Process）\n- 网络通信（HTTP/HTTPS）\n\n\n\n### 2、举例\n\n#### 2.1 浏览器安全级别的限制\n\n##### Ajax限制\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>browser-safe-sandbox</title>\n</head>\n<body>\n  <div>browser-safe-sandbox</div>\n  <script>\n    const xhr = new XMLHttpRequest()\n    xhr.open('get', 'https://m.maoyan.com/ajax/moreClassicList?sortId=1&showType=3&limit=10&offset=30&optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&optimus_risk_level=71&optimus_code=10', false)\n    xhr.send()\n  </script>\n</body>\n</html>\n```\n\n\n\n##### 浏览器预览\n\n```\nbrowser-sync start --server --files **/* --directory\n```\n\n\n\n\n\n#### 2.2 文件的读写（File System）\n\n```javascript\nconst fs = require('fs')\n\nfs.readFile('./ajax.png', 'utf-8', (err, content) => {\n  console.log(content)\n})\n```\n\n\n\n#### 2.3 进程的管理（Process）\n\n```javascript\nfunction main(argv) {\n  console.log(argv)\n}\n\nmain(process.argv.slice(2))\n```\n\n\n\n> 运行\n\n```\nnode 2.3-process.js argv1 argv2\n```\n\n\n\n#### 2.4 网络通信（HTTP/HTTPS）\n\n```javascript\nconst http = require(\"http\")\n\nhttp.createServer((req,res) => {\n  res.writeHead(200, {\n    \"content-type\": \"text/plain\"\n  })\n  res.write(\"hello nodejs\")\n  res.end()\n}).listen(3000)\n```\n\n\n\n\n\n## 二、Node相关工具\n\n### 1、NVM：Node Version Manager\n\n#### 1.1 Mac安装nvm\n\n```\nhttps://github.com/nvm-sh/nvm/blob/master/README.md\n```\n\n\n\n#### 1.2 Windows安装nvm\n\n```\nnvm-windows\nnodist\n```\n\n\n\n#### 1.3 常用的nvm命令\n\n- `nvm list`：查看当前环境安装了哪些版本\n- `nvm use 14.15.0`：切换node版本\n- `nvm alias default (v)14.15.0`：切换node默认版本\n\n\n\n### 2、NPM：Node Package Manager\n\n- `npm view jquery versions`：查看包的所有版本\n\n\n\n#### 2.1 全局安装package\n\n```\n$ npm install forever --global (-g)\n$ forever\n$ npm uninstall forever --global\n$ forever\n\n```\n\n\n\n> 全局安装包的目录\n\n- Mac\n\n  ```\n  /Users/felix/.nvm/versions/node/nvm各个版本/bin/\n  \n  ```\n\n  \n\n- Windows\n\n  ```\n  C:\\Users\\你的用户名\\AppData\\Roaming\\npm\\node_modules\n  \n  ```\n\n\n\n#### 2.2 本地安装package\n\n```\n$ cd ~/desktop\n$ mkdir gp-project\n$ cd gp-project\n$ npm install underscore\n$ npm list (ls)\n\n```\n\n\n\n#### 2.3 package.json初始化\n\n```\n$ pwd\n$ npm init -y\n$ ls\n$ cat package.json\n\n```\n\n\n\n#### 2.4 使用package.json\n\n- `npm install —production`：只拉取生产环境的包\n\n```\n$ npm install underscore --save\n$ cat package.json\n$ npm install lodash --save-dev\n$ cat package.json\n$ rm -rf node_modules\n$ ls\n$ npm install\n$ npm uninstall underscore --save\n$ npm list | grep underscore  // 查看underscore包的树(依赖关系)\n$ cat package.json\n\n```\n\n\n\n\n\n> \"dependencies\"：这些包是你的应用程序在生产环境中所需要的。\n>\n> \"devDepedencies\"：这些包只是在开发和测试中需要的。\n\n\n\n![npm](https://img-blog.csdn.net/2018071517553381?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p3bF93aWxsb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n```\n// package.json\n{\n...\n\"dependencies\": { // --save / -S\n},\n\"devDependencies\": { // --save-dev / -D\n}\n\n}\n\n```\n\n\n\n\n\n#### 2.5 安装指定版本的包\n\n- `npm install jquery@2.2.4`： 安装指定版本\n- `npm install jquery@1 -S`：安装1最高的版本\n\n```\n$ pwd\n$ npm list\n$ npm info underscore\n$ npm view underscore versions\n$ npm install underscore@1.8.0\n$ npm list\n$ npm uninstall underscore\n$ npm list\n\n```\n\n\n\n#### 2.6 更新本地安装的包\n\n> -13.4.6\n>\n> major: 13（主版本号）,minor: 4（次版本号），patch：6（补丁，单数不稳定，双数稳定）\n\n- `npm outdated`：查看哪些包过期\n- `npm update`：更新所有的包\n\n```\n$ npm info underscore\n$ npm view underscore versions // 查看underscore包所有的版本\n$ npm install underscore@1.4.4 --save-dev // 安装1.4.4的underscore到开发环境 \n$ npm list | grep gulp // 查看gulp包的依赖关系\n$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本\n$ npm list | grep gulp\n$ npm update\n\n```\n\n\n\n```json\n{\n\t\"dependencies\": {\n\t\t\"jquery\": \"^1.12.4\", // ^锁定主版本号\n        \"jquery\": \"~1.12.4\", // ~锁定主版本号和次版本号\n        jquery: \"1.12.4\", // 全部锁定\n        jquery: \"*\" // 最新版本\n    }\n}\n\n```\n\n\n\n#### 2.7 清除缓存\n\n- `npm cache clean --force`\n\n\n\n#### 2.8 上传自己的包\n\n##### 2.8.1 编写模块\n\n保存为index.js\n\n```javascript\nexports.sayHello = function(){ \n  return 'Hello World'; \n}\n\n```\n\n\n\n##### 2.8.2 初始化描述文件\n\n- npm init package.json\n\n```json\n{ \n  \"name\": \"gp19-npm\", \n  \"version\": \"1.0.1\", \n  \"description\": \"gp19 self module\", \n  \"main\": \"index.js\",\n  \"scripts\": { \n    \"test\": \"make test\" \n  }, \n  \"repository\": { \n    \"type\": \"Git\", \n    \"url\": \"git+https://github.com/lurongtao/gp19-npm.git\" \n  }, \n  \"keywords\": [ \n    \"demo\" \n  ], \n  \"author\": \"Felixlu\", \n  \"license\": \"ISC\", \n  \"bugs\": { \n    \"url\": \"https://github.com/lurongtao/gp19-npm/issues\" \n  }, \n  \"homepage\": \"https://github.com/lurongtao/gp19-npm#readme\", \n}\n\n```\n\n\n\n##### 2.8.3 注册npm仓库账号\n\n- npm adduser\n\n```\nhttps://www.npmjs.com 上面的账号\nfelix_lurt/qqmko09ijn\n$ npm adduser\n\n```\n\n\n\n##### 2.8.4 上传包\n\n- npm publish\n\n\n\n坑：403 Forbidden\n\n```\n查看npm源：npm config get registry\n切换npm源方法一：npm config set registry http://registry.npmjs.org\n切换npm源方法二：nrm use npm\n\n```\n\n\n\n##### 2.8.5 安装包\n\n- npm install gp19-npm\n\n\n\n##### 2.8.6 卸载包\n\n```\n查看当前项目引用了哪些包 ：\nnpm ls\n卸载包：\nnpm unpublish --force\n\n```\n\n\n\n##### 2.8.7 使用引入包\n\n```\nvar hello = require('gp19-npm')\nhello.sayHello()\n\n```\n\n\n\n#### 2.9 npm脚本\n\nNode开发离不开npm，而脚本功能是npm最强大、最常用的功能之一。\n\n\n\n##### 2.9.1 什么是npm脚本？\n\nnpm允许在package.json文件里面，使用scripts字段定义脚本命令。\n\n```json\n{\n\t// ...\n    \"scripts\": {\n\t\t\"builds\": \"node build.js\"\n    }\n}\n\n```\n\n\n\n##### 2.9.2 执行顺序\n\n如果npm脚本里面需要执行多个任务，那么需要明确它们的执行顺序。\n\n> scripts1.js\n\n```js\nvar x = 0\nconsole.log(x)\n\n```\n\n\n\n> scripts2.js\n\n```js\nvar y = 0\nconsole.log(y)\n\n```\n\n\n\n```json\n\"scripts\" : {\n\t\"script1\": \"node script1.js\",\n    \"script2\": \"ndoe script2.js\"\n}\n\n```\n\n\n\n如果是并行执行（即同时的平行执行），可以使用`&`符号。\n\n```\n$ npm run script1 & npm run script2\n\n```\n\n\n\n如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用`&&`符号。\n\n```\n$ npm run script1 && npm run script2\n\n```\n\n\n\n##### 2.9.3 简写形式\n\n常用的npm脚本简写形式\n\n```\nnpm start 是 npm run start\n\n```\n\n\n\n\n\n##### 2.9.4 变量\n\nnpm脚本有一个非常强大功能，就是可以使用npm的内部变量。\n\n首先，通过`npm _package_`前缀，npm脚本可以拿到package.json里面的字段。比如，下面是一个package.json。\n\n\n\n> 注意：一定要在npm脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到的\n\n```json\n{\n\t\"name\": \"foo\",\n    \"version\": \"1.2.5\",\n    \"scripts\": {\n\t\t\"view\": \"node view.js\"\n    }\n}\n\n```\n\n那么，变量`npm_package_name`返回foo，变量`npm_package_version`返回1.2.5。\n\n```js\n// view.js\nconsole.log(process.env.npm_package_name); // foo\nconsole.log(process.env.npm_package_version); // 1.2.5\n\n```\n\n上面代码中，我们通过环境变量`process.env`对象，拿到`package.json`的字段值。如果是Bash脚本，可以用`$npm_package_name`和 `$npm_package_version`取到这两个值。\n\n\n\nnpmpackage前缀也支持嵌套的package.json字段。\n\n```json\n\"repository\": {\n\t\"type\": 'git',\n    \"url\": \"xxx\"\n},\n\"scripts\": {\n\t\"view\": \"echo $npm_package_repository_type\"\n}\n\n```\n\n上面代码中，repository字段的type属性，可以通过`npm_package_repository_type`取到。\n\n\n\n下面是另外一个例子。\n\n```json\n\"scripts\": {\n\t\"install\": \"foo.js\"\n}\n\n```\n\n上面代码中，`npm_package_scripts_install`变量的值等于foo.js。\n\n然后，npm脚本还可以通过`npmconfig`前缀，拿到npm的配置变量，即`npm config get xxx`命令返回的值。比如，当前模块的发型标签，可以通过`npm_config_tag`取到。\n\n```json\n\"view\": \"echo $npm_config_tag\",\n\n```\n\n\n\n注意，package.json里面的config对象，可以被环境变量覆盖。\n\n```json\n{\n\t\"name\": \"foo\",\n    \"config\": {\"port\": \"8080\"},\n    \"scripts\": {\"start\": \"node server.js\"}\n}\n\n```\n\n上面代码中，`npm_package_config_port`变量返回的是8080。这个值可以用下面的方法覆盖。\n\n```\n$ npm config set foo:port 80\n\n```\n\n最后，env命令可以列出所有环境变量。\n\n\"env\":\"env\" \n\n\n\n\n\n#### 2.10 npm安装git上发布的包\n\n```\n# 这样适合安装公司内部的git服务器上的项目\nnpm install git+https://git@github.com:lurongtao/gp-project.git\n\n# 或者以ssh的方式\nnpm install git+ssh://git@github.com:lurongtao/gp-project.git\n\n```\n\n\n\n#### 2.11 cross-env使用\n\n##### 2.11.1 cross-env是什么\n\n运行跨平台设置和使用环境变量的脚本\n\n\n\n##### 2.11.2 出现原因\n\n当您使用`NODE_ENV=production`，来设置环境变量时，大多数Windows命令提示将会阻塞（报错）。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows不支持`NOE_ENV=production`的设置方式。\n\n\n\n##### 2.11.3 解决\n\ncross-env使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包（cross-env）能够提供一个设置环境变量的scripts，让你能够以Unix方式设置环境变量，然后在Windows上也能兼容运行。\n\n\n\n##### 2.11.4 安装\n\n```\nnpm install --save-dev cross-env\n\n```\n\n\n\n##### 2.11.5 使用\n\n```json\n{\n\t\"scripts\": {\n\t\t\"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\"\n    }\n}\n\n```\n\n`NODE_ENV`环境变量将由`cross-env`设置，打印`process.env.NODE_ENV === 'production'`\n\n\n\n### 3、NRM：npm registry manager\n\n#### 3.1 手工切换源\n\n##### 3.1.1 查看当前源\n\n```\nnpm config get registry\n\n```\n\n\n\n##### 3.1.2 切换淘宝源\n\n```\nnpm config set registry https://registry.npm.taobao.org\n\n```\n\n\n\n#### 3.2 NRM管理源\n\nNRM是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在npm源间切换。\n\n\n\n##### 3.2.1 安装nrm\n\n在命令行执行命令，`npm install -g nrm`，全局安装nrm。\n\n\n\n##### 3.2.2 使用nrm\n\n执行命令`nrm ls`查看可选的源。其中，带`*`的是当前使用的源，上面输出表明当前源是官方源。\n\n\n\n##### 3.2.3 切换nrm\n\n如果要切换到taobao源，执行命令`nrm use taobao`。\n\n\n\n##### 3.2.4 测试速度\n\n你还可以通过`nrm test`测试相应源的响应时间。\n\n\n\n### 4、 NPX：npm package extention\n\nnpm从5.2版开始，增加了npx命令。它有很多用处，本文介绍该命令的主要使用场景。\n\nNode自带npm模块，所以可以直接使用npx命令。万一不能用，就要手动安装一下。\n\n```\n$ npm install -g npx\n\n```\n\n\n\n#### 4.1 调用项目安装的模块\n\nnpx想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。\n\n```\n$ npm install -D mocha\n\n```\n\n\n\n一般来说，调用Mocha，只能在项目脚本和package.json的scripts字段里面，如果想在命令行下调用，必须像下面这样。\n\n```\n# 项目的根目录下执行\n$ node-modules/.bin/mocha --version\n\n```\n\nnpx就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。\n\n```\n$ npx mocha --version\n\n```\n\nnpx的原理很简单，就是运行的时候，会倒`node_modules/.bin`路径和环境变量`$PATH`里面，检查命令是否存在。\n\n\n\n由于npx会检查环境变量$PATH，所以系统命令也可以调用。\n\n```\n# 等同于 ls\n$ npx ls\n\n```\n\n注意，Bash内置的命令不在$PATH里面，所以不能用。比如cd 是Bash命令，因此就不能用npx cd。\n\n\n\n#### 4.2 避免全局安装模块\n\n除了调用项目内部模块，npx还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx可以运行它，而且不进行全局安装。\n\n```\n$ npx create-react-app my-react-app\n\n```\n\n上面代码运行时，npx将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。\n\n\n\n注意，只要npx后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个Web服务。\n\n```\n$ npx http-server\n\n```\n\n\n\n#### 4.3 --no--install参数和--ignore-existing参数\n\n如果想让npx强制使用本地模块，不下载远程模块，可以使用--no-install参数。如果本地不存在该模块，就会报错。\n\n```\n$ npx --no-install http-server\n\n```\n\n反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用--ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。\n\n```\n$ npx --ignore-existing http-server\n\n```\n\n\n\n### 5、node的浏览端调试\n\n- `node --inspect --inspect-brk server.js`\n\n\n\n### 6、node进程管理工具\n\n- supervisor\n\n- nodemon\n\n  ```\n  npm install nodemon\n  nodemon server.js\n  \n  ```\n\n  \n\n- forever\n\n- pm2\n\n\n\n## 三、模块/包与CommonJS\n\n### 1、模块/包分类\n\nNode.js有三类模块，即内置的模块、第三方的模块、自定义的模块。\n\n\n\n#### 1.1 内置的模块\n\nNode.js内置模块又叫核心模块，Node.js安装完成可直接使用。如：\n\n```js\nconst path = require('path')\nvar extname = path.extname('index.html')\nconsole.log(extname)\n\n```\n\n\n\n#### 1.2 第三方的Node.js模块\n\n第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如：\n\n```\nnpm install chalk\n\n```\n\n```js\nconst chalk = require('chalk')\nconsole.log(chalk.blue('Hello world!'))\n\n```\n\n\n\n#### 1.3 自定义的Node.js模块\n\n自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。\n\n\n\n自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。\n\n\n\n##### 1.3.1 模块定义、接口暴露和引用接口\n\n我们可以把公共的功能抽离成为一个单独的js文件作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过`exports`或者`module.exports`暴露属性或者方法。\n\n\n\n> m1.js\n\n```js\nconst name = 'gp19'\n\nconst sayName = () => {\n\tconsole.log(name)\n}\n\nconsole.log('module 1')\n\n// 接口暴露方法一：\nmodule.exports = {\n\tsay: sayName\n}\n\n// 接口暴露方法二：\nexports.say = sayName\n\n// 错误！\nexports = {\n\tsay: sayName\n}\n\n```\n\n\n\n> main.js\n\n```js\nconst m1 = require('./m1')\nm1.say()\n\n```\n\n\n\n##### 1.3.2 模块的循环引用\n\n由于exports使用方式不对，会在两个不同js循环引用的情况下，导致其中一个js无法获取另外一个js的方法，从而导致执行报错。如：\n\n- a.js\n\n```js\nexports.done = false\nconst b = require('./b.js')\nconsole.log('in a, b.done = %j', b.done)\nexports.done = true\nconsole.log('a done')\n\n```\n\n\n\n- b.js\n\n```js\nconsole.log('b starting')\nexports.done = false\nconst a = require('./a.js')\nconsole.log('in b, a.done= %j', a.done)\nexports.done = true\nconsole.log('b done')\n\n```\n\n\n\n- main.js\n\n```js\nconsole.log('main starting')\nconst a = require('./a.js')\nconst b = require('./b.js')\nconsole.log('in main, a.done = %j, b.done = %j', a.done, b.done)\n\n```\n\n`main.js`首先会load `a.js`，此时执行到`const b = require('./b.js');`的时候，程序会转去load`b.js`, 在`b.js`中执行到`const a = require('./a.js');` 为了防止无限循环，将`a.js`exports的未完成副本返回到`b.js`模块。然后`b.js`完成加载，并将其导出对象提供给`a.js`模块。\n\n我们知道nodeJs的对每个js文件进行了一层包装称为`module`，`module`中有一个属性`exports`，当调用`require('a.js')`的时候其实返回的是`module.exports`对象，`module.exports`初始化为一个`{}`空的object，所以在上面的例子中，执行到`b.js`中`const a = require('./a.js');`时不会load新的`a module`, 而是将已经load但是还未完成的`a module`的`exports`属性返回给`b module`，所以`b.js`拿到的是`a module`的`exports`对象，即：`{done:false}`, 虽然在`a.js`中`exports.done`被修改成了`true`，但是由于此时`a.js`未`load`完成，所以在`b.js`输出的`a module`的属性`done`为`false`，而在`main.js`中输出的`a module`的属性`done`为`true`. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。\n\n\n\n## 四、常用内置模块\n\n这里介绍几个常用的内置模块：url，querystring，http，events，fs，stream，readline，crypto，zlib\n\n\n\n### 1、url\n\n\n\n#### 1.1 parse\n\n> 要解析的内容，是否查询字符串\n\n`url.parse(urlString[,parseQueryString[,slashesDenoteHost]])`\n\n```js\nconst url = require('url')\nconst urlString = 'https://www.baidu.com:443/ad/index.html?id=8&name=mouse#tag=110'\nconst parsedStr = url.parse(urlString)\nconsole.log(parsedStr)\n\n=>\n\nUrl {\n  protocol: 'https:',\n  slashes: true,\n  auth: null,\n  host: 'www.baidu.com:443',\n  port: '443',\n  hostname: 'www.baidu.com',\n  hash: '#tag=110',\n  search: '?id=8&name=mouse',\n  query: [Object: null prototype] { id: '8', name: 'mouse' },\n  pathname: '/ad/index.html',\n  path: '/ad/index.html?id=8&name=mouse',\n  href: 'https://www.baidu.com:443/ad/index.html?id=8&name=mouse#tag=110'\n}\n\n```\n\n\n\n#### 1.2 format\n\n> 将一个解析后的URL对象、转成、一个格式化的URL字符串。\n\n`url.format(urlObject)`\n\n```js\nconst url = require('url')\nconst urlObject = {\n  protocol: 'https:',\n  slashes: true,\n  auth: null,\n  host: 'www.baidu.com:443',\n  port: '443',\n  hostname: 'www.baidu.com',\n  hash: '#tag=110',\n  search: '?id=8&name=mouse',\n  query: { id: '8', name: 'mouse' },\n  pathname: '/ad/index.html',\n  path: '/ad/index.html?id=8&name=mouse',\n  href: 'https://www.baidu.com:443/ad/index.html?id=8&name=mouse#tag=110'\n}\nconst parsedObj = url.format(urlObject)\nconsole.log(parsedObj)\n\n=> \n'https://www.baidu.com:443/ad/index.html?id=8&name=mouse#tag=110'\n\n```\n\n\n\n#### 1.3 resolve\n\n> 用于拼接URL（替换 域名后面第一个`/`后的内容,如果出现`.`就向上返回一级之后再拼接，两个`..`就向上反两级再拼接）\n\n`url.resolve(from, to)`\n\n```\nconst url = require('url')\nvar a = url.resolve('/one/two/three', 'four') \nvar b = url.resolve('http://example.com/', '/one')\nvar c = url.resolve('http://example.com/one', '/two');\nvar d = url.resolve('http://example.com/one/ddd/ddd/ddd', './two');\nvar e = url.resolve('http://example.com/one/ddd/ddd/ddd', '../two');\nvar f = url.resolve('http://example.com/one/ddd/ddd/ddd', '.../two');\nconsole.log(a +\",\"+ b +\",\"+ c+','+d+','+e+','+f);\n\n=>\n/one/two/four,\nhttp://example.com/one,\nhttp://example.com/two,\nhttp://example.com/one/ddd/ddd/two,\nhttp://example.com/one/ddd/two\nhttp://example.com/one/ddd/ddd/.../two\n\n```\n\n\n\n### 2、querystring\n\n#### 2.1 parse\n\n> 将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。\n\n`querystring.parse(str[, sep[, eq[, options]]])`\n\n- `str`：欲转换的字符串\n- `sep`：设置分隔符，默认为`&`\n- `eq`：设置赋值符，默认为`=`\n- `[options]`maxKeys：可接受字符串的最大长度，默认为1000\n\n```js\nconst querystring = require('querystring')\nvar qs = 'foo=bar&baz=qux&baz=quux&corge'\nvar parsed = querystring.parse(qs)\nconsole.log(parsed)\n\n=>\n\n{ foo: 'bar', baz: ['qux', 'quux'], corge: '' }\n\n```\n\n\n\n#### 2.2 stringify\n\n> 将对象转换成字符串，字符串里多个参数将用 ‘&' 分隔，将用 ‘=' 赋值。\n\n`querystring.stringify(obj[, sep[, eq[, options]]])`\n\n- `obj`：欲转换的对象\n- `sep`：设置分隔符，默认为`&`\n- `eq`：设置赋值符，默认为`=`\n\n```js\nconst querystring = require('querystring')\nvar qo = { foo: 'bar', baz: ['qux', 'quux'], corge: '' }\nvar parsed = querystring.stringify(qo)\nconsole.log(parsed)\n\n==>\n'foo=bar&baz=qux&baz=quux&corge='\n \n\nconst querystring = require('querystring')\nvar qo = {foo: 'bar', baz: 'qux'}\nvar parsed =querystring.stringify(qo, ';', ':')\nconsole.log(parsed)\n\n==>\n'foo:bar;baz:qux'\n\n```\n\n\n\n#### 2.3 escape/unescape\n\n> 以针对网址查询字符串的特定要求优化的方式对给定的 `str` 执行网址百分比编码\n>\n> `querystring.escape()` 方法被 `querystring.stringify()` 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 `querystring.escape` 分配给替代函数来提供替换的百分比编码实现。\n\n`querystring.escape(str)`\n\n```js\nconst querystring = require('querystring')\nvar str = 'id=3&city=北京&url=https://www.baidu.com'\nvar escaped = querystring.escape(str)\nconsole.log(escaped)\n\n==> 'id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com'\n\n```\n\n\n\n> 在给定的 `str` 上执行网址百分比编码字符的解码。\n>\n> `querystring.unescape()` 方法被 `querystring.parse()` 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 `querystring.unescape` 分配给替代函数来提供替代的解码实现。\n>\n> 默认情况下，`querystring.unescape()` 方法将尝试使用 JavaScript 内置的 `decodeURIComponent()` 方法进行解码。 如果失败，则将使用更安全的不会因格式错误的网址而抛出错误的同类方法。\n\n`querystring.unescape(str)`\n\n```js\nconst querystring = require('querystring')\nvar str = 'id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com'\nvar unescaped = querystring.unescape(str)\nconsole.log(unescaped)\n\n==>\n'id=3&city=北京&url=https://www.baidu.com'\n\n```\n\n\n\n### 3、http/https\n\n#### 3.1 get\n\n```js\nvar http = require('http')\nvar https = require('https')\n\n// 1、接口 2、跨域\nconst server = http.createServer((request, response) => {\n  var url = request.url.substr(1)\n\n  var data = ''\n\n  \n  response.writeHeader(200, {\n    'content-type': 'application/json;charset=utf-8',\n    'Access-Control-Allow-Origin': '*'\n  })\n\n  //response.write('<div>hello</div>')\n  //response.end()\n  // 或\n  //response.end('<div>hello</div>')\n    \n  https.get(`https://m.lagou.com/listmore.json${url}`, (res) => {\n\n    res.on('data', (chunk) => {\n      data += chunk\n    })\n\n    res.on('end', () => {\n      response.end(JSON.stringify({\n        ret: true,\n        data\n      }))\n    })\n  })\n\n})\n\nserver.listen(8080, () => {\n  console.log('localhost:8080')\n})\n\n```\n\n\n\n#### 3.2 post:服务器提交（攻击）\n\n```js\nconst https = require('https')\nconst querystring = require('querystring')\n\nconst postData = querystring.stringify({\n  province: '上海',\n  city: '上海',\n  district: '宝山区',\n  address: '同济支路199号智慧七立方3号楼2-4层',\n  latitude: 43.0,\n  longitude: 160.0,\n  message: '求购一条小鱼',\n  contact: '13666666',\n  type: 'sell',\n  time: 1571217561\n})\n\nconst options = {\n  protocol: 'http:',\n  hostname: 'localhost',\n  method: 'POST',\n  port: 3000,\n  path: '/index.php/trade/add_item',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData)\n  }\n}\n\nconst server = http.createServer((req, res) => {\n\tconst request = http.request(options, result => {\n\t\t\n    })\n    req.write(postData)\n    req.end()\n    \n    res.end()\n})\nserver.listen(8080, ()=> {\n\tconsole.log('localhost:8080')\n})\n\n//function doPost() {\n//  let data\n\n//  let req = https.request(options, (res) => {\n//    res.on('data', chunk => data += chunk)\n//    res.on('end', () => {\n//      console.log(data)\n//    })\n//  })\n\n//  req.write(postData)\n//  req.end()\n//}\n\n// setInterval(() => {\n//   doPost()\n// }, 1000)\n\n```\n\n\n\n#### 3.3 跨域：JSONP\n\n```js\nconst http = require('http')\nconst url = require('url')\n\nconst app = http.createServer((req, res) => {\n  let urlObj = url.parse(req.url, true)\n\n  switch (urlObj.pathname) {\n    case '/api/user':\n      res.end(`${urlObj.query.cb}({\"name\": \"gp145\"})`)\n      break\n    default:\n      res.end('404.')\n      break\n  }\n})\n\napp.listen(8080, () => {\n  console.log('localhost:8080')\n})\n\n```\n\n\n\n#### 3.4 跨域：CORS\n\n```js\nconst http = require('http')\nconst url = require('url')\nconst querystring = require('querystring')\n\nconst app = http.createServer((req, res) => {\n  let data = ''\n  let urlObj = url.parse(req.url, true)\n\n  res.writeHead(200, {\n    'content-type': 'application/json;charset=utf-8',\n    'Access-Control-Allow-Origin': '*'\n  })\n\n  req.on('data', (chunk) => {\n    data += chunk\n  })\n\n  req.on('end', () => {\n    responseResult(querystring.parse(data))\n  })\n\n  function responseResult(data) {\n    switch (urlObj.pathname) {\n      case '/api/login':\n        res.end(JSON.stringify({\n          message: data\n        }))\n        break\n      default:\n        res.end('404.')\n        break\n    }\n  }\n})\n\napp.listen(8080, () => {\n  console.log('localhost:8080')\n})\n\n```\n\n\n\n#### 3.5 跨域：middleware(http-proxy-middware)\n\n```js\nconst http = require('http')\nconst proxy = require('http-proxy-middleware')\n\nhttp.createServer((req, res) => {\n  let url = req.url\n\n  res.writeHead(200, {\n    'Access-Control-Allow-Origin': '*'\n  })\n\n  if (/^\\/api/.test(url)) {\n    let apiProxy = proxy('/api', { \n      target: 'https://m.lagou.com',\n      changeOrigin: true,\n      pathRewrite: {\n        '^/api': ''\n      }\n    })\n\n    // http-proy-middleware 在Node.js中使用的方法\n    apiProxy(req, res)\n  } else {\n    switch (url) {\n      case '/index.html':\n        res.end('index.html')\n        break\n      case '/search.html':\n        res.end('search.html')\n        break\n      default:\n        res.end('[404]page not found.')\n    }\n  }\n}).listen(8080)\n\n```\n\n\n\n#### 3.6 爬虫\n\n```js\nconst https = require('https')\nconst http = require('http')\nconst cheerio = require('cheerio')\n\nhttp.createServer((request, response) => {\n  response.writeHead(200, {\n    'content-type': 'application/json;charset=utf-8'\n  })\n\n  const options = {\n    protocol: 'https:',\n    hostname: 'maoyan.com',\n    port: 443,\n    path: '/',\n    method: 'GET'\n  }\n\n  const req = https.request(options, (res) => {\n    let data = ''\n    res.on('data', (chunk) => {\n      data += chunk\n    })\n\n    res.on('end', () => {\n      filterData(data)\n    })\n  })\n\n  function filterData(data) {\n    let $ = cheerio.load(data)\n    let $movieList = $('.movie-item')\n    let movies = []\n    $movieList.each((index, value) => {\n      movies.push({\n        title: $(value).find('.movie-title').attr('title'),\n        score: $(value).find('.movie-score i').text(),\n      })\n    })\n\n    response.end(JSON.stringify(movies))\n  }\n\n  req.end()\n}).listen(9000)\n\n```\n\n\n\n### 4、Events\n\n```js\nconst EventEmitter = require('events')\n\nclass MyEventEmitter extends EventEmitter {}\n\nconst event = new MyEventEmitter()\n\nevent.on('play', (movie) => {\n  console.log(movie)\n})\n\nevent.emit('play', '我和我的祖国')\nevent.emit('play', '中国机长')\n\n```\n\n\n\n### 5、File System\n\n```js\nconst fs = require('fs')\nconst fsP = require('fs').promises\n\n// 创建文件夹\nfs.mkdir('./logs', (err) => {\n  console.log('done.')\n})\n\n// 文件夹改名\nfs.rename('./logs', './log', () => {\n  console.log('done')\n})\n\n// 删除文件夹\nfs.rmdir('./log', () => {\n  console.log('done.')\n})\n\n// 写内容到文件里\nfs.writeFile(\n  './logs/log1.txt',\n  'hello',\n  // 错误优先的回调函数\n  (err) => {\n    if (err) {\n      console.log(err.message)\n    } else {\n      console.log('文件创建成功')\n    }\n  }\n)\n\n// 给文件追加内容\nfs.appendFile('./logs/log1.txt', '\\nworld', () => {\n  console.log('done.')\n})\n\n// 读取文件内容\nfs.readFile('./logs/log1.txt', 'utf-8', (err, data) => {\n  console.log(data)\n})\n\n// 删除文件\nfs.unlink('./logs/log1.txt', (err) => {\n  console.log('done.')\n})\n\n// 批量写文件\nfor (var i = 0; i < 10; i++) {\n  fs.writeFile(`./logs/log-${i}.txt`, `log-${i}`, (err) => {\n    console.log('done.')\n  })\n}\n\n// 读取文件/目录信息\nfs.readdir('./', (err, data) => {\n  data.forEach((value, index) => {\n    fs.stat(`./${value}`, (err, stats) => {\n      // console.log(value + ':' + stats.size)\n      console.log(value + ' is ' + (stats.isDirectory() ? 'directory' : 'file'))\n    })\n  })\n})\n\n// 同步读取文件\ntry {\n  const content = fs.readFileSync('./logs/log-1.txt', 'utf-8')\n  console.log(content)\n  console.log(0)\n} catch (e) {\n  console.log(e.message)\n}\n\nconsole.log(1)\n\n// 异步读取文件：方法一\nfs.readFile('./logs/log-0.txt', 'utf-8', (err, content) => {\n  console.log(content)\n  console.log(0)\n})\nconsole.log(1)\n\n// 异步读取文件：方法二\nfs.readFile('./logs/log-0.txt', 'utf-8').then(result => {\n  console.log(result)\n})\n\n// 异步读取文件：方法三\nfunction getFile() {\n  return new Promise((resolve) => {\n    fs.readFile('./logs/log-0.txt', 'utf-8', (err, data) => {\n      resolve(data)\n    })\n  })\n}\n\n;(async () => {\n  console.log(await getFile())\n})()\n\n// 异步读取文件：方法四\nconst fsp = fsP.readFile('./logs/log-1.txt', 'utf-8').then((result) => {\n  console.log(result)\n})\n\nconsole.log(fsP)\n\n// watch 监测文件变化\nfs.watch('./logs/log-0.txt', () => {\n  console.log(0)\n})\n\n```\n\n\n\n### 6、Stream\n\n```js\nconst fs = require('fs')\n\nconst readstream = fs.createReadStream('./note.txt')\nconst writestream = fs.createWriteStream('./note2.txt')\n\nwritestream.write(readstream)\n\n```\n\n\n\n### 7、Zlib\n\n```js\nconst fs = require('fs')\nconst zlib = require('zlib')\n\nconst gzip = zlib.createGzip()\n\nconst readstream = fs.createReadStream('./note.txt')\nconst writestream = fs.createWriteStream('./note2.txt')\n\nreadstream\n  .pipe(gzip)\n  .pipe(writestream)\n\nwritestream.write(readstream)\n\n```\n\n\n\n### 8、ReadLine\n\n```js\nconst readline = require('readline')\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\n\nrl.question('What do you think of Node.js? ', (answer) => {\n  // TODO: Log the answer in a database\n  console.log(`Thank you for your valuable feedback: ${answer}`)\n\n  rl.close()\n})\n\n```\n\n\n\n### 9、Crypto\n\n```js\nconst crypto = require('crypto')\n\nconst secret = 'abcdefg'\nconst hash = crypto.createHmac('sha256', secret)\n                   .update('I love you')\n                   .digest('hex')\nconsole.log(hash)\n\n```\n\n\n\n## 五、路由\n\n```js\nvar http = require('http')\nvar fs = require('fs')\n\nhttp.createServer( function ( req, res ) {\n\n  switch ( req.url ) {\n    case '/home':\n      res.write('home')\n      res.end()\n      break\n    case '/mine':\n      res.write('mine')\n      res.end()\n      break\n    case '/login': \n      fs.readFile( './static/login.html',function ( error , data ) {\n        if ( error ) throw error  \n        res.write( data )\n        res.end()\n      })\n      break\n    case '/fulian.jpg':\n      fs.readFile( './static/fulian.jpg', 'binary', function( error , data ) {\n        if( error ) throw error \n        res.write( data, 'binary' )\n        res.end()\n      })\n      break\n    default: \n      break\n   }\n\n }).listen( 8000, 'localhost', function () {\n   console.log( '服务器运行在： http://localhost:8000' )\n })\n\n```\n\n\n\n## 六、静态资源服务\n\n### 6.1 readStaticFile\n\n`/modules/readStaticFile.js`\n\n```js\n// 引入依赖的模块\nvar path = require('path')\nvar fs = require('fs')\nvar mime = require('mime')\n\nfunction readStaticFile(res, filePathname) {\n\n  var ext = path.parse(filePathname).ext\n  var mimeType = mime.getType(ext)\n\n  // 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 \n  if (ext) {\n    // 根据传入的目标文件路径来读取对应文件\n    fs.readFile(filePathname, (err, data) => {\n    // 错误处理\n      if (err) {\n        res.writeHead(404, { \"Content-Type\": \"text/plain\" })\n        res.write(\"404 - NOT FOUND\")\n        res.end()\n      } else {\n        res.writeHead(200, { \"Content-Type\": mimeType })\n        res.write(data)\n        res.end()\n      }\n    });\n    // 返回 true 表示, 客户端想要的 是 静态文件\n    return true\n  } else {\n    // 返回 false 表示, 客户端想要的 不是 静态文件\n    return false\n  }\n}\n\n// 导出函数\nmodule.exports = readStaticFile\n\n```\n\n\n\n### 6.2 server\n\n`/server.js`\n\n```js\n// 引入相关模块\nvar http = require('http');\nvar url = require('url');\nvar path = require('path');\nvar readStaticFile = require('./modules/readStaticFile');\n\n// 搭建 HTTP 服务器\nvar server = http.createServer(function(req, res) {\n  var urlObj = url.parse(req.url);\n  var urlPathname = urlObj.pathname;\n  var filePathname = path.join(__dirname, \"/public\", urlPathname);\n\n  // 读取静态文件\n  readStaticFile(res, filePathname);\n});\n\n// 在 3000 端口监听请求\nserver.listen(3000, function() {\n  console.log(\"服务器运行中.\");\n  console.log(\"正在监听 3000 端口:\")\n})\n\n```\n\n\n\n### 6.3 最终目录结构\n\n![](https://lurongtao.gitee.io/felixbooks-gp19-node.js/images/dir.jpg)\n\n\n\n\n\n# 02-Express\n\n基于Node.js平台，快速、开放、极简的web开发框架。\n\n```\n$ npm install express --save\n\n```\n\n\n\n## 一、特色\n\n### 1、Web应用\n\nExpress是一个基于Node.js平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种Web和移动设备应用。\n\n\n\n### 2、API\n\n丰富的HTTP快捷方法和任意排列组合的Connect中间件，让你创建健壮、友好的API变得既快速又简单。\n\n\n\n### 3、性能\n\nExpress不对Node.js已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的基本性能。\n\n\n\n## 二、安装\n\n首先假定你已经安装了Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。\n\n```\n$ mkdir myapp\n$ cd myapp\n\n```\n\n通过`npm init`命令为你的应用创建一个`package.json`文件。欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。\n\n```\n$ npm init\n\n```\n\n此命令将要求你输入几个参数，例如此应用的名称和版本。你可以直接按“回车”键接受默认设置即可，下面这个除外：\n\n```\nentry point: (index.js)\n\n```\n\n键入app.js或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的`index.js`文件名，只需按“回车”键即可。\n\n\n\n接下来安装Express并将其保存到依赖列表中：\n\n```\n$ npm install express --save\n\n```\n\n\n\n如果只是临时安装Express，不想将它添加到依赖列表中，只需略去--save参数即可：\n\n```\n$ npm install express\n\n```\n\n\n\n> 安装Node模块时，如果指定了` --save` 参数，那么此模块将被添加到`package.json`文件中`dependencies`依赖列表中。然后通过`npm install` 命令即可\n\n\n\n## 三、Hello World实例\n\n接下来，我们一起创建一个基本的Express应用。\n\n注意：这里所创建的是一个最最简单的Express应用，并且仅仅只有一个文件 - 和通过Express应用生成器所创建的应用完全不一样，Express应用生成器所创建的应用框架包含多JavaScript文件、Jade模板和针对不同用途的子目录。\n\n\n\n进入myapp目录，创建一个名为app.js的文件，然后将下列代码复制进去：\n\n```js\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n\nvar server = app.listen(3000, function () {\n  var host = server.address().address;\n  var port = server.address().port;\n\n  console.log('Example app listening at http://%s:%s', host, port);\n});\n\n```\n\n上面的代码启动一个服务并监听从3000端口进入的所有连接请求。他将对所有(/)URL或 路由返回“Hello World！”字符串。对于其他所有路径全部返回 404 Not Found。\n\n> req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on('data', callback) 以及任何 Node 提供的方法。\n\n\n\n通过如下命令启动此应用：\n\n```\n$ node app.js\n\n```\n\n然后在浏览器中打开 <http://localhost:3000/> 并查看输出结果。\n\n\n\n## 四、路由\n\n路由是指如何定义应用的端点（URls）以及如何响应客户端的请求。\n\n\n\n路由是由一个URI、HTTP请求（GET、POST等）和若干个句柄组成，它的结构如下：app.METHOD(path, [callback..], callback)， app 是 express 对象的一个实例，METHOD是一个 HTTP 请求方法，path 是服务器上的路径， callback 是当路由匹配时要执行的函数。\n\n\n\n下面是一个基本的路由示例：\n\n```js\nvar express = require('express');\nvar app = express();\n\n// respond with \"hello world\" when a GET request is made to the homepage\napp.get('/', function(req, res) {\n  res.send('hello world');\n});\n\n```\n\n\n\n### 1、路由方法\n\n路由方法源于 HTTP 请求方法，和 express 实例相关联。\n\n下面这个例子展示了为应用跟路径定义的 GET 和 POST 请求：\n\n```js\n// GET method route\n// 对网站首页的访问返回 \"Hello World!\" 字样\napp.get('/', function (req, res) {\n  res.send('Hello World!')\n})\n\n// 网站首页接受 POST 请求\napp.post('/', function (req, res) {\n  res.send('Got a POST request')\n})\n\n// /user 节点接受 PUT 请求\napp.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user')\n})\n\n// /user 节点接受 DELETE 请求\napp.delete('/user', function (req, res) {\n  res.send('Got a DELETE request at /user')\n})\n\n```\n\nExpress 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。\n\n> 有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如：`app['m-search']('/', function ...)`\n\n\n\napp.all()是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。\n\n\n\n在下面的例子中，来自\"/secret\"的请求，不管使用 GET、POST、PUT、DELETE或其他任何http模块支持的HTTP请求，句柄都会得到执行。\n\n```js\napp.all('/secret', function (req, res, next) {\n  console.log('Accessing the secret section ...')\n  next(); // pass control to the next handler\n})\n\n```\n\n\n\n### 2、路由路径\n\n路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。\n\n\n\nExpress使用`path-to-regexp`匹配路由路径，请参考文档查阅所有定义路由路径的方法。Express Route Tester是测试基本Express路径的好工具，但不支持模式匹配。\n\n> 查询字符串不是路由路径的一部分。\n\n使用字符串的路由路径示例：\n\n```js\n// 匹配根路径的请求\napp.get('/', function (req, res) {\n  res.send('root');\n});\n\n// 匹配 /about 路径的请求\napp.get('/about', function (req, res) {\n  res.send('about');\n});\n\n// 匹配 /random.text 路径的请求\napp.get('/random.text', function (req, res) {\n  res.send('random.text');\n});\n\n```\n\n\n\n使用字符串模式的路由路径示例：\n\n```js\n// 匹配 acd 和 abcd\napp.get('/ab?cd', function(req, res) {\n  res.send('ab?cd');\n});\n\n// 匹配 abcd、abbcd、abbbcd等\napp.get('/ab+cd', function(req, res) {\n  res.send('ab+cd');\n});\n\n// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等\napp.get('/ab*cd', function(req, res) {\n  res.send('ab*cd');\n});\n\n// 匹配 /abe 和 /abcde\napp.get('/ab(cd)?e', function(req, res) {\n res.send('ab(cd)?e');\n});\n\n```\n\n> 字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。\n\n\n\n使用正则表达式的路由路径示例：\n\n```js\n// 匹配任何路径中含有 a 的路径：\napp.get(/a/, function(req, res) {\n  res.send('/a/');\n});\n\n// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等\napp.get(/.*fly$/, function(req, res) {\n  res.send('/.*fly$/');\n});\n\n```\n\n\n\n### 3、路由句柄\n\n可以为请求处理提供多个回调函数，其行为类似中间件。唯一的区别是这些回调函数有可能调用`next('route')`方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。\n\n\n\n路由句柄有多种形式，可以是一个函数、一个函数数组、或者是两者混合，如下所示。\n\n\n\n使用一个回调函数处理路由：\n\n```js\napp.get('/example/a', function(req, res) {\n\tres.send('Hello from A!')\n})\n\n```\n\n\n\n使用多个回调函数处理路由（记得指定next对象）：\n\n```js\napp.get('/example/b', function (req, res, next) {\n  console.log('response will be sent by the next function ...');\n  next();\n}, function (req, res) {\n  res.send('Hello from B!');\n});\n\n```\n\n\n\n使用回调函数数组处理路由：\n\n```js\nvar cb0 = function (req, res, next) {\n  console.log('CB0')\n  next()\n}\n\nvar cb1 = function (req, res, next) {\n  console.log('CB1')\n  next()\n}\n\nvar cb2 = function (req, res) {\n  res.send('Hello from C!')\n}\n\napp.get('/example/c', [cb0, cb1, cb2])\n\n```\n\n\n\n混合使用函数和函数数组处理路由：\n\n```js\nvar cb0 = function (req, res, next) {\n  console.log('CB0')\n  next()\n}\n\nvar cb1 = function (req, res, next) {\n  console.log('CB1')\n  next()\n}\n\napp.get('/example/d', [cb0, cb1], function (req, res, next) {\n  console.log('response will be sent by the next function ...')\n  next()\n}, function (req, res) {\n  res.send('Hello from D!')\n})\n\n```\n\n\n\n### 4、响应方法\n\n下表中响应对象(res)的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。\n\n|       方法       |                            描述                            |\n| :--------------: | :--------------------------------------------------------: |\n|  res.download()  |                        提示下载文件                        |\n|    res.end()     |                      终结响应处理流程                      |\n|    res.json()    |                   发送一个JSON格式的响应                   |\n|   res.jsonp()    |             发送一个支持JSONP的JSON格式的响应              |\n|   res.direct()   |                         重定向请求                         |\n|   res.render()   |                        渲染视图模板                        |\n|    res.send()    |                     发送各种类型的响应                     |\n|  res.sendFile()  |                 以八位字节流的形式发送文件                 |\n| res.sendStatus() | 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送 |\n\n\n\n### 5、app.route()\n\n可使用app.route()创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。\n\n\n\n下面这个示例程序使用app.route()定义了链式路由句柄。\n\n```js\napp.route('/book')\n  .get(function(req, res) {\n    res.send('Get a random book');\n  })\n  .post(function(req, res) {\n    res.send('Add a book');\n  })\n  .put(function(req, res) {\n    res.send('Update the book');\n  });\n\n```\n\n\n\n### 6、express.Router\n\n可使用express.Router类创建模块化、可挂载的路由句柄。Router实例是一个完整的中间件和路由系统，因此常称其为一个'mini-app'。\n\n\n\n下面的实例程序创建了一个路由模块，并加载 了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。\n\n\n\n在app目录下创建名为bird.js的文件，内容如下：\n\n```js\nvar express = require('express');\nvar router = express.Router();\n\n// 该路由使用的中间件\nrouter.use(function timeLog(req, res, next) {\n  console.log('Time: ', Date.now());\n  next();\n});\n// 定义网站主页的路由\nrouter.get('/', function(req, res) {\n  res.send('Birds home page');\n});\n// 定义 about 页面的路由\nrouter.get('/about', function(req, res) {\n  res.send('About birds');\n});\n\nmodule.exports = router;\n\n```\n\n\n\n然后在应用中加载路由模块：\n\n```js\nvar birds = require('./birds')\n...\napp.use('/birds', birds)\n\n```\n\n应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。\n\n\n\n## 五、利用Express托管静态文件\n\n通过Express内置的`express.static`可以方便地托管静态文件，例如图片、CSS、JavaScript文件等。\n\n\n\n将静态资源文件所在的目录作为参数传递给`express.static`中间件就可以提供静态资源文件的访问了。例如，假设在public目录放置了图片、CSS和JavaScript文件，你就可以：\n\n```js\napp.use(express.static('public'))\n\n```\n\n现在，public目录下面的文件就可以访问了。\n\n```\nhttp://localhost:3000/images/kitten.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/images/bg.png\nhttp://localhost:3000/hello.html\n\n```\n\n> 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在URL中。\n\n\n\n如果你的静态资源存放在多个目录下面，你可以多次调用`express.static`中间件：\n\n```js\napp.use(express.static('public'))\napp.use(express.static('files'))\n\n```\n\n\n\n访问静态资源文件时，`express.static`中间件会根据目录添加的顺序查找所需的文件。\n\n\n\n如果你希望所有通过`express.static`访问的文件都存放在一个”虚拟(virtual)“目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：\n\n```js\napp.use('/static', express.static('public'))\n\n```\n\n现在，你就可以通过带有”/static“前缀的地址来访问public目录下面的文件了。\n\n```js\nhttp://localhost:3000/static/images/kitten.jpg\nhttp://localhost:3000/static/css/style.css\nhttp://localhost:3000/static/js/app.js\nhttp://localhost:3000/static/images/bg.png\nhttp://localhost:3000/static/hello.html\n\n```\n\n\n\n## 六、使用中间件\n\nExpress是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。\n\n\n\n中间件（Middleware）是一个函数，它可以访问请求对象（request object(req)），响应对象(response object(res))，和web应用中处于请求-响应循环流程中的中间件，一般被命名为next的变量。\n\n\n\n中间件的功能包括：\n\n- 执行任何代码\n- 修改请求和响应对象\n- 终结请求-响应循环\n- 调用堆栈中的下一个中间件\n\n\n\n如果当前中间件没有终结请求-响应循环，则必须调用`next()`方法将控制权交给下一个中间件，否则请求就会挂起。\n\n\n\nExpress应用可使用如下几种中间件：\n\n- 应用级中间件\n- 路由级中间件\n- 错误处理中间件\n- 内置中间件\n- 第三方中间件\n\n\n\n使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。\n\n\n\n### 1、应用级中间件\n\n应用级中间件绑定到app对象，使用`app.use()`和`app.METHOD()`，其中，`METHOD`是需要处理的HTTP请求的方法，例如GET,PUT,POST等等，全部小写。例如：\n\n```js\nvar app = express()\n\n// 没有挂载路径的中间件，应用的每个请求都会执行该中间件\napp.use(function (req, res, next) {\n\tconsole.log('Time:', Date.now())\n    next()\n})\n\n// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它\napp.use('/user/:id', function(req, res, next) {\n\tconsole.log('Request Type:', req.method)\n    next()\n})\n\n// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求\napp.get('/user/:id', function(req, res, next) {\n\tres.send('USER')\n})\n\n```\n\n\n\n下面这个例子展示了在一个挂载点装载一组中间件。\n\n```js\n// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息\napp.use('/user/:id', function(req, res, next) {\n\tconsole.log('Request URL:', req.originalUrl)\n    next()\n}, function(req, res, next) {\n\tconsole.log('Request Type:', req.method)\n    next()\n})\n\n```\n\n作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。 第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。\n\n```js\n// 一个中间件栈，处理指向 /user/:id 的 GET请求\napp.get('/user/:id', function(req, res, next) {\n\tconsole.log('ID:', req.params.id)\n    next()\n}, function(req, res, next) {\n\tres.send('User Info')\n})\n\n// 处理 /user/:id, 打印出用户id\napp.get('/user/:id', function(req, res, next) {\n\tres.end(req.params.id)\n})\n\n```\n\n\n\n如果需要在中间件栈中跳过剩余中间件，调用 `next('route')`方法将控制权交给下一个路由。注意：`next('route')`只对使用 `app.VERB()`  或 `router.VERB()`加载的中间件有效。\n\n```js\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\napp.get('/user/:id', function(req, res, next) {\n\t// 如果 user id 为0，跳到下一个路由\n    if (req.params.id === 0) next('route')\n    // 否则将控制权交给栈中下一个中间件\n    else next()\n}, function(req, res, next) {\n\t// 渲染常规页面\n    res.render('regular')\n})\n\n// 处理 /user/:id, 渲染一个特殊页面\napp.get('/user/:id', function(req, res, next) {\n\tres.render('special')\n})\n\n```\n\n\n\n### 2、路由级中间件\n\n路由级中间件和应用级中间件一样，只是它绑定的对象为 `express.Router()`。\n\n```\nvar router = express.Router()\n\n```\n\n路由级使用`router.use()`或`router.VERB()`加载。\n\n 上述在应用级创建的中间件系统，可通过如下代码改写为路由级。\n\n```js\nvar app = express()\nvar router = express.Router()\n\n// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件\nrouter.use(function (req, res, next) {\n  console.log('Time:', Date.now())\n  next()\n})\n\n// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息\nrouter.use('/user/:id', function(req, res, next) {\n  console.log('Request URL:', req.originalUrl)\n  next()\n}, function (req, res, next) {\n  console.log('Request Type:', req.method)\n  next()\n})\n\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\nrouter.get('/user/:id', function (req, res, next) {\n  // 如果 user id 为 0, 跳到下一个路由\n  if (req.params.id == 0) next('route')\n  // 负责将控制权交给栈中下一个中间件\n  else next() //\n}, function (req, res, next) {\n  // 渲染常规页面\n  res.render('regular')\n})\n\n// 处理 /user/:id， 渲染一个特殊页面\nrouter.get('/user/:id', function (req, res, next) {\n  console.log(req.params.id)\n  res.render('special')\n})\n\n// 将路由挂载至应用\napp.use('/', router)\n\n```\n\n\n\n### 3、错误处理中间件\n\n> 错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。\n\n错误处理中间件和其他中间件定义类似，只是要使用4个参数，而不是3个，其签名如下：(err,req,res,next)。\n\n```js\napp.use(function(err, req, res, next) {\n  console.error(err.stack)\n  res.status(500).send('Something broke!')\n})\n\n```\n\n\n\n### 4、内置中间件\n\n从4.x版本开始，Express已经不再依赖Connect了。除了express.static，Express以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。\n\n\n\n`express.static(root, [options])`\n\nexpress.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在Express应用中提托管静态资源。\n\n参数 root 指提供静态资源的根目录。\n\n可选的 options 参数拥有如下属性。\n\n| 属性         | 描述                                                         | 类型     | 缺省值       |\n| ------------ | ------------------------------------------------------------ | -------- | ------------ |\n| dotfiles     | 是否对外输出文件名以点（.）开头的文件。可选值为”allow“，”deny“和”ignore“。 | String   | ”ignore“     |\n| etag         | 是否启用etag生成                                             | Boolean  | true         |\n| extensions   | 设置文件扩展名备份选项                                       | Array    | []           |\n| index        | 发送目录索引文件，设置为false禁用目录索引                    | Mixed    | \"index.html\" |\n| lastModified | 设置Last-Modified头为文件在操作系统上的最后修改日期。可能值为true或false | Boolean  | true         |\n| maxAge       | 以毫秒或者其字符串格式设置Cache-Control头的max-age属性。     | Number   | 0            |\n| redirect     | 当路径为目录时，重定向至”/“                                  | Boolean  | true         |\n| setHeaders   | 设置HTTP头以提供文件的函数                                   | Function |              |\n\n下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。\n\n```js\nvar options = {\n  dotfiles: 'ignore',\n  etag: false,\n  extensions: ['htm', 'html'],\n  index: false,\n  maxAge: '1d',\n  redirect: false,\n  setHeaders: function (res, path, stat) {\n    res.set('x-timestamp', Date.now())\n  }\n}\n\napp.use(express.static('public', options))\n\n```\n\n每个应用可有多个静态目录。\n\n```js\napp.use(express.static('public'))\napp.use(express.static('uploads'))\napp.use(express.static('files'))\n\n```\n\n\n\n### 5、第三方中间件\n\n通过使用第三方中间件从而为 Express 应用增加更多功能。\n\n安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。\n\n下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser\n\n```\n$ npm install cookie-parser\n\n```\n\n```js\nvar express = require('express')\nvar app = express()\nvar cookieParser = require('cookie-parser')\n\n// 加载用于解析 cookie 的中间件\napp.use(cookieParser())\n\n```\n\n\n\n## 七、在Express中使用模板引擎\n\n需要在应用中进行如下设置才能让Express渲染模板文件：\n\n- `views`，放模板文件的目录，比如：`app.set('views', './views')`\n- `view engine`，模板引擎，比如：`app.set('view engine', 'ejs')`\n\n\n\n**art-template**\n\nart-template for express 4.x.\n\n- 1、Install\n\n  ```\n  npm install --save art-template\n  npm install --save express-art-template\n  \n  ```\n\n  \n\n- 2、Example\n\n  ```js\n  var express = require('express')\n  var app = express()\n  \n  // view engine setup\n  app.engine('art', require('express-art-template'))\n  app.set('view', {\n      debug: process.env.NODE_ENV !== 'production'\n  })\n  app.set('views', path.join(__dirname, 'views'))\n  app.set('view engine', 'art')\n  \n  // routes\n  app.get('/', function (req, res) {\n      res.render('index.art', {\n          user: {\n              name: 'aui',\n              tags: ['art', 'template', 'nodejs']\n          }\n      })\n  })\n  \n  ```\n\n  \n\n# 03-Koa2\n\n## 一、koa2快速开始\n\n因为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以上node.js环境 版本v7.6以上 npm 版本3.x以上","slug":"nodejs","published":1,"updated":"2021-08-13T01:23:02.628Z","layout":"post","link":"","_id":"cku2cstre001e4v9kqgoc1gmb","content":"<h1 id=\"01-Node-js基础\"><a href=\"#01-Node-js基础\" class=\"headerlink\" title=\"01-Node.js基础\"></a>01-Node.js基础</h1><h2 id=\"一、Node-js是什么\"><a href=\"#一、Node-js是什么\" class=\"headerlink\" title=\"一、Node.js是什么\"></a>一、Node.js是什么</h2><p>Node.js is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine.</p>\n<h3 id=\"1、-特性\"><a href=\"#1、-特性\" class=\"headerlink\" title=\"1、 特性\"></a>1、 特性</h3><p>Node.js可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：</p>\n<ul>\n<li>文件的读写（File System）</li>\n<li>进程的管理（Process）</li>\n<li>网络通信（HTTP/HTTPS）</li>\n</ul>\n<h3 id=\"2、举例\"><a href=\"#2、举例\" class=\"headerlink\" title=\"2、举例\"></a>2、举例</h3><h4 id=\"2-1-浏览器安全级别的限制\"><a href=\"#2-1-浏览器安全级别的限制\" class=\"headerlink\" title=\"2.1 浏览器安全级别的限制\"></a>2.1 浏览器安全级别的限制</h4><h5 id=\"Ajax限制\"><a href=\"#Ajax限制\" class=\"headerlink\" title=\"Ajax限制\"></a>Ajax限制</h5><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;browser-safe-sandbox&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div&gt;browser-safe-sandbox&lt;/div&gt;\n  &lt;script&gt;\n    const xhr = new XMLHttpRequest()\n    xhr.open(&#39;get&#39;, &#39;https://m.maoyan.com/ajax/moreClassicList?sortId=1&amp;showType=3&amp;limit=10&amp;offset=30&amp;optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&amp;optimus_risk_level=71&amp;optimus_code=10&#39;, false)\n    xhr.send()\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h5 id=\"浏览器预览\"><a href=\"#浏览器预览\" class=\"headerlink\" title=\"浏览器预览\"></a>浏览器预览</h5><pre><code>browser-sync start --server --files **/* --directory\n</code></pre><h4 id=\"2-2-文件的读写（File-System）\"><a href=\"#2-2-文件的读写（File-System）\" class=\"headerlink\" title=\"2.2 文件的读写（File System）\"></a>2.2 文件的读写（File System）</h4><pre><code class=\"javascript\">const fs = require(&#39;fs&#39;)\n\nfs.readFile(&#39;./ajax.png&#39;, &#39;utf-8&#39;, (err, content) =&gt; {\n  console.log(content)\n})\n</code></pre>\n<h4 id=\"2-3-进程的管理（Process）\"><a href=\"#2-3-进程的管理（Process）\" class=\"headerlink\" title=\"2.3 进程的管理（Process）\"></a>2.3 进程的管理（Process）</h4><pre><code class=\"javascript\">function main(argv) {\n  console.log(argv)\n}\n\nmain(process.argv.slice(2))\n</code></pre>\n<blockquote>\n<p>运行</p>\n</blockquote>\n<pre><code>node 2.3-process.js argv1 argv2\n</code></pre><h4 id=\"2-4-网络通信（HTTP-HTTPS）\"><a href=\"#2-4-网络通信（HTTP-HTTPS）\" class=\"headerlink\" title=\"2.4 网络通信（HTTP/HTTPS）\"></a>2.4 网络通信（HTTP/HTTPS）</h4><pre><code class=\"javascript\">const http = require(&quot;http&quot;)\n\nhttp.createServer((req,res) =&gt; {\n  res.writeHead(200, {\n    &quot;content-type&quot;: &quot;text/plain&quot;\n  })\n  res.write(&quot;hello nodejs&quot;)\n  res.end()\n}).listen(3000)\n</code></pre>\n<h2 id=\"二、Node相关工具\"><a href=\"#二、Node相关工具\" class=\"headerlink\" title=\"二、Node相关工具\"></a>二、Node相关工具</h2><h3 id=\"1、NVM：Node-Version-Manager\"><a href=\"#1、NVM：Node-Version-Manager\" class=\"headerlink\" title=\"1、NVM：Node Version Manager\"></a>1、NVM：Node Version Manager</h3><h4 id=\"1-1-Mac安装nvm\"><a href=\"#1-1-Mac安装nvm\" class=\"headerlink\" title=\"1.1 Mac安装nvm\"></a>1.1 Mac安装nvm</h4><pre><code>https://github.com/nvm-sh/nvm/blob/master/README.md\n</code></pre><h4 id=\"1-2-Windows安装nvm\"><a href=\"#1-2-Windows安装nvm\" class=\"headerlink\" title=\"1.2 Windows安装nvm\"></a>1.2 Windows安装nvm</h4><pre><code>nvm-windows\nnodist\n</code></pre><h4 id=\"1-3-常用的nvm命令\"><a href=\"#1-3-常用的nvm命令\" class=\"headerlink\" title=\"1.3 常用的nvm命令\"></a>1.3 常用的nvm命令</h4><ul>\n<li><code>nvm list</code>：查看当前环境安装了哪些版本</li>\n<li><code>nvm use 14.15.0</code>：切换node版本</li>\n<li><code>nvm alias default (v)14.15.0</code>：切换node默认版本</li>\n</ul>\n<h3 id=\"2、NPM：Node-Package-Manager\"><a href=\"#2、NPM：Node-Package-Manager\" class=\"headerlink\" title=\"2、NPM：Node Package Manager\"></a>2、NPM：Node Package Manager</h3><ul>\n<li><code>npm view jquery versions</code>：查看包的所有版本</li>\n</ul>\n<h4 id=\"2-1-全局安装package\"><a href=\"#2-1-全局安装package\" class=\"headerlink\" title=\"2.1 全局安装package\"></a>2.1 全局安装package</h4><pre><code>$ npm install forever --global (-g)\n$ forever\n$ npm uninstall forever --global\n$ forever\n\n</code></pre><blockquote>\n<p>全局安装包的目录</p>\n</blockquote>\n<ul>\n<li><p>Mac</p>\n<pre><code>/Users/felix/.nvm/versions/node/nvm各个版本/bin/\n\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Windows</p>\n<pre><code>C:\\Users\\你的用户名\\AppData\\Roaming\\npm\\node_modules\n\n</code></pre></li>\n</ul>\n<h4 id=\"2-2-本地安装package\"><a href=\"#2-2-本地安装package\" class=\"headerlink\" title=\"2.2 本地安装package\"></a>2.2 本地安装package</h4><pre><code>$ cd ~/desktop\n$ mkdir gp-project\n$ cd gp-project\n$ npm install underscore\n$ npm list (ls)\n\n</code></pre><h4 id=\"2-3-package-json初始化\"><a href=\"#2-3-package-json初始化\" class=\"headerlink\" title=\"2.3 package.json初始化\"></a>2.3 package.json初始化</h4><pre><code>$ pwd\n$ npm init -y\n$ ls\n$ cat package.json\n\n</code></pre><h4 id=\"2-4-使用package-json\"><a href=\"#2-4-使用package-json\" class=\"headerlink\" title=\"2.4 使用package.json\"></a>2.4 使用package.json</h4><ul>\n<li><code>npm install —production</code>：只拉取生产环境的包</li>\n</ul>\n<pre><code>$ npm install underscore --save\n$ cat package.json\n$ npm install lodash --save-dev\n$ cat package.json\n$ rm -rf node_modules\n$ ls\n$ npm install\n$ npm uninstall underscore --save\n$ npm list | grep underscore  // 查看underscore包的树(依赖关系)\n$ cat package.json\n\n</code></pre><blockquote>\n<p>&quot;dependencies&quot;：这些包是你的应用程序在生产环境中所需要的。</p>\n<p>&quot;devDepedencies&quot;：这些包只是在开发和测试中需要的。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdn.net/2018071517553381?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p3bF93aWxsb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"npm\"></p>\n<pre><code>// package.json\n{\n...\n&quot;dependencies&quot;: { // --save / -S\n},\n&quot;devDependencies&quot;: { // --save-dev / -D\n}\n\n}\n\n</code></pre><h4 id=\"2-5-安装指定版本的包\"><a href=\"#2-5-安装指定版本的包\" class=\"headerlink\" title=\"2.5 安装指定版本的包\"></a>2.5 安装指定版本的包</h4><ul>\n<li><code>npm install jquery@2.2.4</code>： 安装指定版本</li>\n<li><code>npm install jquery@1 -S</code>：安装1最高的版本</li>\n</ul>\n<pre><code>$ pwd\n$ npm list\n$ npm info underscore\n$ npm view underscore versions\n$ npm install underscore@1.8.0\n$ npm list\n$ npm uninstall underscore\n$ npm list\n\n</code></pre><h4 id=\"2-6-更新本地安装的包\"><a href=\"#2-6-更新本地安装的包\" class=\"headerlink\" title=\"2.6 更新本地安装的包\"></a>2.6 更新本地安装的包</h4><blockquote>\n<p>-13.4.6</p>\n<p>major: 13（主版本号）,minor: 4（次版本号），patch：6（补丁，单数不稳定，双数稳定）</p>\n</blockquote>\n<ul>\n<li><code>npm outdated</code>：查看哪些包过期</li>\n<li><code>npm update</code>：更新所有的包</li>\n</ul>\n<pre><code>$ npm info underscore\n$ npm view underscore versions // 查看underscore包所有的版本\n$ npm install underscore@1.4.4 --save-dev // 安装1.4.4的underscore到开发环境 \n$ npm list | grep gulp // 查看gulp包的依赖关系\n$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本\n$ npm list | grep gulp\n$ npm update\n\n</code></pre><pre><code class=\"json\">{\n    &quot;dependencies&quot;: {\n        &quot;jquery&quot;: &quot;^1.12.4&quot;, // ^锁定主版本号\n        &quot;jquery&quot;: &quot;~1.12.4&quot;, // ~锁定主版本号和次版本号\n        jquery: &quot;1.12.4&quot;, // 全部锁定\n        jquery: &quot;*&quot; // 最新版本\n    }\n}\n\n</code></pre>\n<h4 id=\"2-7-清除缓存\"><a href=\"#2-7-清除缓存\" class=\"headerlink\" title=\"2.7 清除缓存\"></a>2.7 清除缓存</h4><ul>\n<li><code>npm cache clean --force</code></li>\n</ul>\n<h4 id=\"2-8-上传自己的包\"><a href=\"#2-8-上传自己的包\" class=\"headerlink\" title=\"2.8 上传自己的包\"></a>2.8 上传自己的包</h4><h5 id=\"2-8-1-编写模块\"><a href=\"#2-8-1-编写模块\" class=\"headerlink\" title=\"2.8.1 编写模块\"></a>2.8.1 编写模块</h5><p>保存为index.js</p>\n<pre><code class=\"javascript\">exports.sayHello = function(){ \n  return &#39;Hello World&#39;; \n}\n\n</code></pre>\n<h5 id=\"2-8-2-初始化描述文件\"><a href=\"#2-8-2-初始化描述文件\" class=\"headerlink\" title=\"2.8.2 初始化描述文件\"></a>2.8.2 初始化描述文件</h5><ul>\n<li>npm init package.json</li>\n</ul>\n<pre><code class=\"json\">{ \n  &quot;name&quot;: &quot;gp19-npm&quot;, \n  &quot;version&quot;: &quot;1.0.1&quot;, \n  &quot;description&quot;: &quot;gp19 self module&quot;, \n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: { \n    &quot;test&quot;: &quot;make test&quot; \n  }, \n  &quot;repository&quot;: { \n    &quot;type&quot;: &quot;Git&quot;, \n    &quot;url&quot;: &quot;git+https://github.com/lurongtao/gp19-npm.git&quot; \n  }, \n  &quot;keywords&quot;: [ \n    &quot;demo&quot; \n  ], \n  &quot;author&quot;: &quot;Felixlu&quot;, \n  &quot;license&quot;: &quot;ISC&quot;, \n  &quot;bugs&quot;: { \n    &quot;url&quot;: &quot;https://github.com/lurongtao/gp19-npm/issues&quot; \n  }, \n  &quot;homepage&quot;: &quot;https://github.com/lurongtao/gp19-npm#readme&quot;, \n}\n\n</code></pre>\n<h5 id=\"2-8-3-注册npm仓库账号\"><a href=\"#2-8-3-注册npm仓库账号\" class=\"headerlink\" title=\"2.8.3 注册npm仓库账号\"></a>2.8.3 注册npm仓库账号</h5><ul>\n<li>npm adduser</li>\n</ul>\n<pre><code>https://www.npmjs.com 上面的账号\nfelix_lurt/qqmko09ijn\n$ npm adduser\n\n</code></pre><h5 id=\"2-8-4-上传包\"><a href=\"#2-8-4-上传包\" class=\"headerlink\" title=\"2.8.4 上传包\"></a>2.8.4 上传包</h5><ul>\n<li>npm publish</li>\n</ul>\n<p>坑：403 Forbidden</p>\n<pre><code>查看npm源：npm config get registry\n切换npm源方法一：npm config set registry http://registry.npmjs.org\n切换npm源方法二：nrm use npm\n\n</code></pre><h5 id=\"2-8-5-安装包\"><a href=\"#2-8-5-安装包\" class=\"headerlink\" title=\"2.8.5 安装包\"></a>2.8.5 安装包</h5><ul>\n<li>npm install gp19-npm</li>\n</ul>\n<h5 id=\"2-8-6-卸载包\"><a href=\"#2-8-6-卸载包\" class=\"headerlink\" title=\"2.8.6 卸载包\"></a>2.8.6 卸载包</h5><pre><code>查看当前项目引用了哪些包 ：\nnpm ls\n卸载包：\nnpm unpublish --force\n\n</code></pre><h5 id=\"2-8-7-使用引入包\"><a href=\"#2-8-7-使用引入包\" class=\"headerlink\" title=\"2.8.7 使用引入包\"></a>2.8.7 使用引入包</h5><pre><code>var hello = require(&#39;gp19-npm&#39;)\nhello.sayHello()\n\n</code></pre><h4 id=\"2-9-npm脚本\"><a href=\"#2-9-npm脚本\" class=\"headerlink\" title=\"2.9 npm脚本\"></a>2.9 npm脚本</h4><p>Node开发离不开npm，而脚本功能是npm最强大、最常用的功能之一。</p>\n<h5 id=\"2-9-1-什么是npm脚本？\"><a href=\"#2-9-1-什么是npm脚本？\" class=\"headerlink\" title=\"2.9.1 什么是npm脚本？\"></a>2.9.1 什么是npm脚本？</h5><p>npm允许在package.json文件里面，使用scripts字段定义脚本命令。</p>\n<pre><code class=\"json\">{\n    // ...\n    &quot;scripts&quot;: {\n        &quot;builds&quot;: &quot;node build.js&quot;\n    }\n}\n\n</code></pre>\n<h5 id=\"2-9-2-执行顺序\"><a href=\"#2-9-2-执行顺序\" class=\"headerlink\" title=\"2.9.2 执行顺序\"></a>2.9.2 执行顺序</h5><p>如果npm脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p>\n<blockquote>\n<p>scripts1.js</p>\n</blockquote>\n<pre><code class=\"js\">var x = 0\nconsole.log(x)\n\n</code></pre>\n<blockquote>\n<p>scripts2.js</p>\n</blockquote>\n<pre><code class=\"js\">var y = 0\nconsole.log(y)\n\n</code></pre>\n<pre><code class=\"json\">&quot;scripts&quot; : {\n    &quot;script1&quot;: &quot;node script1.js&quot;,\n    &quot;script2&quot;: &quot;ndoe script2.js&quot;\n}\n\n</code></pre>\n<p>如果是并行执行（即同时的平行执行），可以使用<code>&amp;</code>符号。</p>\n<pre><code>$ npm run script1 &amp; npm run script2\n\n</code></pre><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&amp;&amp;</code>符号。</p>\n<pre><code>$ npm run script1 &amp;&amp; npm run script2\n\n</code></pre><h5 id=\"2-9-3-简写形式\"><a href=\"#2-9-3-简写形式\" class=\"headerlink\" title=\"2.9.3 简写形式\"></a>2.9.3 简写形式</h5><p>常用的npm脚本简写形式</p>\n<pre><code>npm start 是 npm run start\n\n</code></pre><h5 id=\"2-9-4-变量\"><a href=\"#2-9-4-变量\" class=\"headerlink\" title=\"2.9.4 变量\"></a>2.9.4 变量</h5><p>npm脚本有一个非常强大功能，就是可以使用npm的内部变量。</p>\n<p>首先，通过<code>npm _package_</code>前缀，npm脚本可以拿到package.json里面的字段。比如，下面是一个package.json。</p>\n<blockquote>\n<p>注意：一定要在npm脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到的</p>\n</blockquote>\n<pre><code class=\"json\">{\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;version&quot;: &quot;1.2.5&quot;,\n    &quot;scripts&quot;: {\n        &quot;view&quot;: &quot;node view.js&quot;\n    }\n}\n\n</code></pre>\n<p>那么，变量<code>npm_package_name</code>返回foo，变量<code>npm_package_version</code>返回1.2.5。</p>\n<pre><code class=\"js\">// view.js\nconsole.log(process.env.npm_package_name); // foo\nconsole.log(process.env.npm_package_version); // 1.2.5\n\n</code></pre>\n<p>上面代码中，我们通过环境变量<code>process.env</code>对象，拿到<code>package.json</code>的字段值。如果是Bash脚本，可以用<code>$npm_package_name</code>和 <code>$npm_package_version</code>取到这两个值。</p>\n<p>npmpackage前缀也支持嵌套的package.json字段。</p>\n<pre><code class=\"json\">&quot;repository&quot;: {\n    &quot;type&quot;: &#39;git&#39;,\n    &quot;url&quot;: &quot;xxx&quot;\n},\n&quot;scripts&quot;: {\n    &quot;view&quot;: &quot;echo $npm_package_repository_type&quot;\n}\n\n</code></pre>\n<p>上面代码中，repository字段的type属性，可以通过<code>npm_package_repository_type</code>取到。</p>\n<p>下面是另外一个例子。</p>\n<pre><code class=\"json\">&quot;scripts&quot;: {\n    &quot;install&quot;: &quot;foo.js&quot;\n}\n\n</code></pre>\n<p>上面代码中，<code>npm_package_scripts_install</code>变量的值等于foo.js。</p>\n<p>然后，npm脚本还可以通过<code>npmconfig</code>前缀，拿到npm的配置变量，即<code>npm config get xxx</code>命令返回的值。比如，当前模块的发型标签，可以通过<code>npm_config_tag</code>取到。</p>\n<pre><code class=\"json\">&quot;view&quot;: &quot;echo $npm_config_tag&quot;,\n\n</code></pre>\n<p>注意，package.json里面的config对象，可以被环境变量覆盖。</p>\n<pre><code class=\"json\">{\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;config&quot;: {&quot;port&quot;: &quot;8080&quot;},\n    &quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;}\n}\n\n</code></pre>\n<p>上面代码中，<code>npm_package_config_port</code>变量返回的是8080。这个值可以用下面的方法覆盖。</p>\n<pre><code>$ npm config set foo:port 80\n\n</code></pre><p>最后，env命令可以列出所有环境变量。</p>\n<p>&quot;env&quot;:&quot;env&quot; </p>\n<h4 id=\"2-10-npm安装git上发布的包\"><a href=\"#2-10-npm安装git上发布的包\" class=\"headerlink\" title=\"2.10 npm安装git上发布的包\"></a>2.10 npm安装git上发布的包</h4><pre><code># 这样适合安装公司内部的git服务器上的项目\nnpm install git+https://git@github.com:lurongtao/gp-project.git\n\n# 或者以ssh的方式\nnpm install git+ssh://git@github.com:lurongtao/gp-project.git\n\n</code></pre><h4 id=\"2-11-cross-env使用\"><a href=\"#2-11-cross-env使用\" class=\"headerlink\" title=\"2.11 cross-env使用\"></a>2.11 cross-env使用</h4><h5 id=\"2-11-1-cross-env是什么\"><a href=\"#2-11-1-cross-env是什么\" class=\"headerlink\" title=\"2.11.1 cross-env是什么\"></a>2.11.1 cross-env是什么</h5><p>运行跨平台设置和使用环境变量的脚本</p>\n<h5 id=\"2-11-2-出现原因\"><a href=\"#2-11-2-出现原因\" class=\"headerlink\" title=\"2.11.2 出现原因\"></a>2.11.2 出现原因</h5><p>当您使用<code>NODE_ENV=production</code>，来设置环境变量时，大多数Windows命令提示将会阻塞（报错）。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows不支持<code>NOE_ENV=production</code>的设置方式。</p>\n<h5 id=\"2-11-3-解决\"><a href=\"#2-11-3-解决\" class=\"headerlink\" title=\"2.11.3 解决\"></a>2.11.3 解决</h5><p>cross-env使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包（cross-env）能够提供一个设置环境变量的scripts，让你能够以Unix方式设置环境变量，然后在Windows上也能兼容运行。</p>\n<h5 id=\"2-11-4-安装\"><a href=\"#2-11-4-安装\" class=\"headerlink\" title=\"2.11.4 安装\"></a>2.11.4 安装</h5><pre><code>npm install --save-dev cross-env\n\n</code></pre><h5 id=\"2-11-5-使用\"><a href=\"#2-11-5-使用\" class=\"headerlink\" title=\"2.11.5 使用\"></a>2.11.5 使用</h5><pre><code class=\"json\">{\n    &quot;scripts&quot;: {\n        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;\n    }\n}\n\n</code></pre>\n<p><code>NODE_ENV</code>环境变量将由<code>cross-env</code>设置，打印<code>process.env.NODE_ENV === &#39;production&#39;</code></p>\n<h3 id=\"3、NRM：npm-registry-manager\"><a href=\"#3、NRM：npm-registry-manager\" class=\"headerlink\" title=\"3、NRM：npm registry manager\"></a>3、NRM：npm registry manager</h3><h4 id=\"3-1-手工切换源\"><a href=\"#3-1-手工切换源\" class=\"headerlink\" title=\"3.1 手工切换源\"></a>3.1 手工切换源</h4><h5 id=\"3-1-1-查看当前源\"><a href=\"#3-1-1-查看当前源\" class=\"headerlink\" title=\"3.1.1 查看当前源\"></a>3.1.1 查看当前源</h5><pre><code>npm config get registry\n\n</code></pre><h5 id=\"3-1-2-切换淘宝源\"><a href=\"#3-1-2-切换淘宝源\" class=\"headerlink\" title=\"3.1.2 切换淘宝源\"></a>3.1.2 切换淘宝源</h5><pre><code>npm config set registry https://registry.npm.taobao.org\n\n</code></pre><h4 id=\"3-2-NRM管理源\"><a href=\"#3-2-NRM管理源\" class=\"headerlink\" title=\"3.2 NRM管理源\"></a>3.2 NRM管理源</h4><p>NRM是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在npm源间切换。</p>\n<h5 id=\"3-2-1-安装nrm\"><a href=\"#3-2-1-安装nrm\" class=\"headerlink\" title=\"3.2.1 安装nrm\"></a>3.2.1 安装nrm</h5><p>在命令行执行命令，<code>npm install -g nrm</code>，全局安装nrm。</p>\n<h5 id=\"3-2-2-使用nrm\"><a href=\"#3-2-2-使用nrm\" class=\"headerlink\" title=\"3.2.2 使用nrm\"></a>3.2.2 使用nrm</h5><p>执行命令<code>nrm ls</code>查看可选的源。其中，带<code>*</code>的是当前使用的源，上面输出表明当前源是官方源。</p>\n<h5 id=\"3-2-3-切换nrm\"><a href=\"#3-2-3-切换nrm\" class=\"headerlink\" title=\"3.2.3 切换nrm\"></a>3.2.3 切换nrm</h5><p>如果要切换到taobao源，执行命令<code>nrm use taobao</code>。</p>\n<h5 id=\"3-2-4-测试速度\"><a href=\"#3-2-4-测试速度\" class=\"headerlink\" title=\"3.2.4 测试速度\"></a>3.2.4 测试速度</h5><p>你还可以通过<code>nrm test</code>测试相应源的响应时间。</p>\n<h3 id=\"4、-NPX：npm-package-extention\"><a href=\"#4、-NPX：npm-package-extention\" class=\"headerlink\" title=\"4、 NPX：npm package extention\"></a>4、 NPX：npm package extention</h3><p>npm从5.2版开始，增加了npx命令。它有很多用处，本文介绍该命令的主要使用场景。</p>\n<p>Node自带npm模块，所以可以直接使用npx命令。万一不能用，就要手动安装一下。</p>\n<pre><code>$ npm install -g npx\n\n</code></pre><h4 id=\"4-1-调用项目安装的模块\"><a href=\"#4-1-调用项目安装的模块\" class=\"headerlink\" title=\"4.1 调用项目安装的模块\"></a>4.1 调用项目安装的模块</h4><p>npx想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。</p>\n<pre><code>$ npm install -D mocha\n\n</code></pre><p>一般来说，调用Mocha，只能在项目脚本和package.json的scripts字段里面，如果想在命令行下调用，必须像下面这样。</p>\n<pre><code># 项目的根目录下执行\n$ node-modules/.bin/mocha --version\n\n</code></pre><p>npx就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p>\n<pre><code>$ npx mocha --version\n\n</code></pre><p>npx的原理很简单，就是运行的时候，会倒<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p>\n<p>由于npx会检查环境变量$PATH，所以系统命令也可以调用。</p>\n<pre><code># 等同于 ls\n$ npx ls\n\n</code></pre><p>注意，Bash内置的命令不在$PATH里面，所以不能用。比如cd 是Bash命令，因此就不能用npx cd。</p>\n<h4 id=\"4-2-避免全局安装模块\"><a href=\"#4-2-避免全局安装模块\" class=\"headerlink\" title=\"4.2 避免全局安装模块\"></a>4.2 避免全局安装模块</h4><p>除了调用项目内部模块，npx还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx可以运行它，而且不进行全局安装。</p>\n<pre><code>$ npx create-react-app my-react-app\n\n</code></pre><p>上面代码运行时，npx将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。</p>\n<p>注意，只要npx后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个Web服务。</p>\n<pre><code>$ npx http-server\n\n</code></pre><h4 id=\"4-3-no-install参数和-ignore-existing参数\"><a href=\"#4-3-no-install参数和-ignore-existing参数\" class=\"headerlink\" title=\"4.3 --no--install参数和--ignore-existing参数\"></a>4.3 --no--install参数和--ignore-existing参数</h4><p>如果想让npx强制使用本地模块，不下载远程模块，可以使用--no-install参数。如果本地不存在该模块，就会报错。</p>\n<pre><code>$ npx --no-install http-server\n\n</code></pre><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用--ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。</p>\n<pre><code>$ npx --ignore-existing http-server\n\n</code></pre><h3 id=\"5、node的浏览端调试\"><a href=\"#5、node的浏览端调试\" class=\"headerlink\" title=\"5、node的浏览端调试\"></a>5、node的浏览端调试</h3><ul>\n<li><code>node --inspect --inspect-brk server.js</code></li>\n</ul>\n<h3 id=\"6、node进程管理工具\"><a href=\"#6、node进程管理工具\" class=\"headerlink\" title=\"6、node进程管理工具\"></a>6、node进程管理工具</h3><ul>\n<li><p>supervisor</p>\n</li>\n<li><p>nodemon</p>\n<pre><code>npm install nodemon\nnodemon server.js\n\n</code></pre></li>\n</ul>\n<ul>\n<li><p>forever</p>\n</li>\n<li><p>pm2</p>\n</li>\n</ul>\n<h2 id=\"三、模块-包与CommonJS\"><a href=\"#三、模块-包与CommonJS\" class=\"headerlink\" title=\"三、模块/包与CommonJS\"></a>三、模块/包与CommonJS</h2><h3 id=\"1、模块-包分类\"><a href=\"#1、模块-包分类\" class=\"headerlink\" title=\"1、模块/包分类\"></a>1、模块/包分类</h3><p>Node.js有三类模块，即内置的模块、第三方的模块、自定义的模块。</p>\n<h4 id=\"1-1-内置的模块\"><a href=\"#1-1-内置的模块\" class=\"headerlink\" title=\"1.1 内置的模块\"></a>1.1 内置的模块</h4><p>Node.js内置模块又叫核心模块，Node.js安装完成可直接使用。如：</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;)\nvar extname = path.extname(&#39;index.html&#39;)\nconsole.log(extname)\n\n</code></pre>\n<h4 id=\"1-2-第三方的Node-js模块\"><a href=\"#1-2-第三方的Node-js模块\" class=\"headerlink\" title=\"1.2 第三方的Node.js模块\"></a>1.2 第三方的Node.js模块</h4><p>第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如：</p>\n<pre><code>npm install chalk\n\n</code></pre><pre><code class=\"js\">const chalk = require(&#39;chalk&#39;)\nconsole.log(chalk.blue(&#39;Hello world!&#39;))\n\n</code></pre>\n<h4 id=\"1-3-自定义的Node-js模块\"><a href=\"#1-3-自定义的Node-js模块\" class=\"headerlink\" title=\"1.3 自定义的Node.js模块\"></a>1.3 自定义的Node.js模块</h4><p>自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。</p>\n<p>自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。</p>\n<h5 id=\"1-3-1-模块定义、接口暴露和引用接口\"><a href=\"#1-3-1-模块定义、接口暴露和引用接口\" class=\"headerlink\" title=\"1.3.1 模块定义、接口暴露和引用接口\"></a>1.3.1 模块定义、接口暴露和引用接口</h5><p>我们可以把公共的功能抽离成为一个单独的js文件作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过<code>exports</code>或者<code>module.exports</code>暴露属性或者方法。</p>\n<blockquote>\n<p>m1.js</p>\n</blockquote>\n<pre><code class=\"js\">const name = &#39;gp19&#39;\n\nconst sayName = () =&gt; {\n    console.log(name)\n}\n\nconsole.log(&#39;module 1&#39;)\n\n// 接口暴露方法一：\nmodule.exports = {\n    say: sayName\n}\n\n// 接口暴露方法二：\nexports.say = sayName\n\n// 错误！\nexports = {\n    say: sayName\n}\n\n</code></pre>\n<blockquote>\n<p>main.js</p>\n</blockquote>\n<pre><code class=\"js\">const m1 = require(&#39;./m1&#39;)\nm1.say()\n\n</code></pre>\n<h5 id=\"1-3-2-模块的循环引用\"><a href=\"#1-3-2-模块的循环引用\" class=\"headerlink\" title=\"1.3.2 模块的循环引用\"></a>1.3.2 模块的循环引用</h5><p>由于exports使用方式不对，会在两个不同js循环引用的情况下，导致其中一个js无法获取另外一个js的方法，从而导致执行报错。如：</p>\n<ul>\n<li>a.js</li>\n</ul>\n<pre><code class=\"js\">exports.done = false\nconst b = require(&#39;./b.js&#39;)\nconsole.log(&#39;in a, b.done = %j&#39;, b.done)\nexports.done = true\nconsole.log(&#39;a done&#39;)\n\n</code></pre>\n<ul>\n<li>b.js</li>\n</ul>\n<pre><code class=\"js\">console.log(&#39;b starting&#39;)\nexports.done = false\nconst a = require(&#39;./a.js&#39;)\nconsole.log(&#39;in b, a.done= %j&#39;, a.done)\nexports.done = true\nconsole.log(&#39;b done&#39;)\n\n</code></pre>\n<ul>\n<li>main.js</li>\n</ul>\n<pre><code class=\"js\">console.log(&#39;main starting&#39;)\nconst a = require(&#39;./a.js&#39;)\nconst b = require(&#39;./b.js&#39;)\nconsole.log(&#39;in main, a.done = %j, b.done = %j&#39;, a.done, b.done)\n\n</code></pre>\n<p><code>main.js</code>首先会load <code>a.js</code>，此时执行到<code>const b = require(&#39;./b.js&#39;);</code>的时候，程序会转去load<code>b.js</code>, 在<code>b.js</code>中执行到<code>const a = require(&#39;./a.js&#39;);</code> 为了防止无限循环，将<code>a.js</code>exports的未完成副本返回到<code>b.js</code>模块。然后<code>b.js</code>完成加载，并将其导出对象提供给<code>a.js</code>模块。</p>\n<p>我们知道nodeJs的对每个js文件进行了一层包装称为<code>module</code>，<code>module</code>中有一个属性<code>exports</code>，当调用<code>require(&#39;a.js&#39;)</code>的时候其实返回的是<code>module.exports</code>对象，<code>module.exports</code>初始化为一个<code>{}</code>空的object，所以在上面的例子中，执行到<code>b.js</code>中<code>const a = require(&#39;./a.js&#39;);</code>时不会load新的<code>a module</code>, 而是将已经load但是还未完成的<code>a module</code>的<code>exports</code>属性返回给<code>b module</code>，所以<code>b.js</code>拿到的是<code>a module</code>的<code>exports</code>对象，即：<code>{done:false}</code>, 虽然在<code>a.js</code>中<code>exports.done</code>被修改成了<code>true</code>，但是由于此时<code>a.js</code>未<code>load</code>完成，所以在<code>b.js</code>输出的<code>a module</code>的属性<code>done</code>为<code>false</code>，而在<code>main.js</code>中输出的<code>a module</code>的属性<code>done</code>为<code>true</code>. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。</p>\n<h2 id=\"四、常用内置模块\"><a href=\"#四、常用内置模块\" class=\"headerlink\" title=\"四、常用内置模块\"></a>四、常用内置模块</h2><p>这里介绍几个常用的内置模块：url，querystring，http，events，fs，stream，readline，crypto，zlib</p>\n<h3 id=\"1、url\"><a href=\"#1、url\" class=\"headerlink\" title=\"1、url\"></a>1、url</h3><h4 id=\"1-1-parse\"><a href=\"#1-1-parse\" class=\"headerlink\" title=\"1.1 parse\"></a>1.1 parse</h4><blockquote>\n<p>要解析的内容，是否查询字符串</p>\n</blockquote>\n<p><code>url.parse(urlString[,parseQueryString[,slashesDenoteHost]])</code></p>\n<pre><code class=\"js\">const url = require(&#39;url&#39;)\nconst urlString = &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;\nconst parsedStr = url.parse(urlString)\nconsole.log(parsedStr)\n\n=&gt;\n\nUrl {\n  protocol: &#39;https:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;www.baidu.com:443&#39;,\n  port: &#39;443&#39;,\n  hostname: &#39;www.baidu.com&#39;,\n  hash: &#39;#tag=110&#39;,\n  search: &#39;?id=8&amp;name=mouse&#39;,\n  query: [Object: null prototype] { id: &#39;8&#39;, name: &#39;mouse&#39; },\n  pathname: &#39;/ad/index.html&#39;,\n  path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;,\n  href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;\n}\n\n</code></pre>\n<h4 id=\"1-2-format\"><a href=\"#1-2-format\" class=\"headerlink\" title=\"1.2 format\"></a>1.2 format</h4><blockquote>\n<p>将一个解析后的URL对象、转成、一个格式化的URL字符串。</p>\n</blockquote>\n<p><code>url.format(urlObject)</code></p>\n<pre><code class=\"js\">const url = require(&#39;url&#39;)\nconst urlObject = {\n  protocol: &#39;https:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;www.baidu.com:443&#39;,\n  port: &#39;443&#39;,\n  hostname: &#39;www.baidu.com&#39;,\n  hash: &#39;#tag=110&#39;,\n  search: &#39;?id=8&amp;name=mouse&#39;,\n  query: { id: &#39;8&#39;, name: &#39;mouse&#39; },\n  pathname: &#39;/ad/index.html&#39;,\n  path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;,\n  href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;\n}\nconst parsedObj = url.format(urlObject)\nconsole.log(parsedObj)\n\n=&gt; \n&#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;\n\n</code></pre>\n<h4 id=\"1-3-resolve\"><a href=\"#1-3-resolve\" class=\"headerlink\" title=\"1.3 resolve\"></a>1.3 resolve</h4><blockquote>\n<p>用于拼接URL（替换 域名后面第一个<code>/</code>后的内容,如果出现<code>.</code>就向上返回一级之后再拼接，两个<code>..</code>就向上反两级再拼接）</p>\n</blockquote>\n<p><code>url.resolve(from, to)</code></p>\n<pre><code>const url = require(&#39;url&#39;)\nvar a = url.resolve(&#39;/one/two/three&#39;, &#39;four&#39;) \nvar b = url.resolve(&#39;http://example.com/&#39;, &#39;/one&#39;)\nvar c = url.resolve(&#39;http://example.com/one&#39;, &#39;/two&#39;);\nvar d = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;./two&#39;);\nvar e = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;../two&#39;);\nvar f = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;.../two&#39;);\nconsole.log(a +&quot;,&quot;+ b +&quot;,&quot;+ c+&#39;,&#39;+d+&#39;,&#39;+e+&#39;,&#39;+f);\n\n=&gt;\n/one/two/four,\nhttp://example.com/one,\nhttp://example.com/two,\nhttp://example.com/one/ddd/ddd/two,\nhttp://example.com/one/ddd/two\nhttp://example.com/one/ddd/ddd/.../two\n\n</code></pre><h3 id=\"2、querystring\"><a href=\"#2、querystring\" class=\"headerlink\" title=\"2、querystring\"></a>2、querystring</h3><h4 id=\"2-1-parse\"><a href=\"#2-1-parse\" class=\"headerlink\" title=\"2.1 parse\"></a>2.1 parse</h4><blockquote>\n<p>将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。</p>\n</blockquote>\n<p><code>querystring.parse(str[, sep[, eq[, options]]])</code></p>\n<ul>\n<li><code>str</code>：欲转换的字符串</li>\n<li><code>sep</code>：设置分隔符，默认为<code>&amp;</code></li>\n<li><code>eq</code>：设置赋值符，默认为<code>=</code></li>\n<li><code>[options]</code>maxKeys：可接受字符串的最大长度，默认为1000</li>\n</ul>\n<pre><code class=\"js\">const querystring = require(&#39;querystring&#39;)\nvar qs = &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#39;\nvar parsed = querystring.parse(qs)\nconsole.log(parsed)\n\n=&gt;\n\n{ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }\n\n</code></pre>\n<h4 id=\"2-2-stringify\"><a href=\"#2-2-stringify\" class=\"headerlink\" title=\"2.2 stringify\"></a>2.2 stringify</h4><blockquote>\n<p>将对象转换成字符串，字符串里多个参数将用 ‘&amp;&#39; 分隔，将用 ‘=&#39; 赋值。</p>\n</blockquote>\n<p><code>querystring.stringify(obj[, sep[, eq[, options]]])</code></p>\n<ul>\n<li><code>obj</code>：欲转换的对象</li>\n<li><code>sep</code>：设置分隔符，默认为<code>&amp;</code></li>\n<li><code>eq</code>：设置赋值符，默认为<code>=</code></li>\n</ul>\n<pre><code class=\"js\">const querystring = require(&#39;querystring&#39;)\nvar qo = { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }\nvar parsed = querystring.stringify(qo)\nconsole.log(parsed)\n\n==&gt;\n&#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;\n\n\nconst querystring = require(&#39;querystring&#39;)\nvar qo = {foo: &#39;bar&#39;, baz: &#39;qux&#39;}\nvar parsed =querystring.stringify(qo, &#39;;&#39;, &#39;:&#39;)\nconsole.log(parsed)\n\n==&gt;\n&#39;foo:bar;baz:qux&#39;\n\n</code></pre>\n<h4 id=\"2-3-escape-unescape\"><a href=\"#2-3-escape-unescape\" class=\"headerlink\" title=\"2.3 escape/unescape\"></a>2.3 escape/unescape</h4><blockquote>\n<p>以针对网址查询字符串的特定要求优化的方式对给定的 <code>str</code> 执行网址百分比编码</p>\n<p><code>querystring.escape()</code> 方法被 <code>querystring.stringify()</code> 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 <code>querystring.escape</code> 分配给替代函数来提供替换的百分比编码实现。</p>\n</blockquote>\n<p><code>querystring.escape(str)</code></p>\n<pre><code class=\"js\">const querystring = require(&#39;querystring&#39;)\nvar str = &#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39;\nvar escaped = querystring.escape(str)\nconsole.log(escaped)\n\n==&gt; &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39;\n\n</code></pre>\n<blockquote>\n<p>在给定的 <code>str</code> 上执行网址百分比编码字符的解码。</p>\n<p><code>querystring.unescape()</code> 方法被 <code>querystring.parse()</code> 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 <code>querystring.unescape</code> 分配给替代函数来提供替代的解码实现。</p>\n<p>默认情况下，<code>querystring.unescape()</code> 方法将尝试使用 JavaScript 内置的 <code>decodeURIComponent()</code> 方法进行解码。 如果失败，则将使用更安全的不会因格式错误的网址而抛出错误的同类方法。</p>\n</blockquote>\n<p><code>querystring.unescape(str)</code></p>\n<pre><code class=\"js\">const querystring = require(&#39;querystring&#39;)\nvar str = &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39;\nvar unescaped = querystring.unescape(str)\nconsole.log(unescaped)\n\n==&gt;\n&#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39;\n\n</code></pre>\n<h3 id=\"3、http-https\"><a href=\"#3、http-https\" class=\"headerlink\" title=\"3、http/https\"></a>3、http/https</h3><h4 id=\"3-1-get\"><a href=\"#3-1-get\" class=\"headerlink\" title=\"3.1 get\"></a>3.1 get</h4><pre><code class=\"js\">var http = require(&#39;http&#39;)\nvar https = require(&#39;https&#39;)\n\n// 1、接口 2、跨域\nconst server = http.createServer((request, response) =&gt; {\n  var url = request.url.substr(1)\n\n  var data = &#39;&#39;\n\n\n  response.writeHeader(200, {\n    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;,\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;\n  })\n\n  //response.write(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;)\n  //response.end()\n  // 或\n  //response.end(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;)\n\n  https.get(`https://m.lagou.com/listmore.json${url}`, (res) =&gt; {\n\n    res.on(&#39;data&#39;, (chunk) =&gt; {\n      data += chunk\n    })\n\n    res.on(&#39;end&#39;, () =&gt; {\n      response.end(JSON.stringify({\n        ret: true,\n        data\n      }))\n    })\n  })\n\n})\n\nserver.listen(8080, () =&gt; {\n  console.log(&#39;localhost:8080&#39;)\n})\n\n</code></pre>\n<h4 id=\"3-2-post-服务器提交（攻击）\"><a href=\"#3-2-post-服务器提交（攻击）\" class=\"headerlink\" title=\"3.2 post:服务器提交（攻击）\"></a>3.2 post:服务器提交（攻击）</h4><pre><code class=\"js\">const https = require(&#39;https&#39;)\nconst querystring = require(&#39;querystring&#39;)\n\nconst postData = querystring.stringify({\n  province: &#39;上海&#39;,\n  city: &#39;上海&#39;,\n  district: &#39;宝山区&#39;,\n  address: &#39;同济支路199号智慧七立方3号楼2-4层&#39;,\n  latitude: 43.0,\n  longitude: 160.0,\n  message: &#39;求购一条小鱼&#39;,\n  contact: &#39;13666666&#39;,\n  type: &#39;sell&#39;,\n  time: 1571217561\n})\n\nconst options = {\n  protocol: &#39;http:&#39;,\n  hostname: &#39;localhost&#39;,\n  method: &#39;POST&#39;,\n  port: 3000,\n  path: &#39;/index.php/trade/add_item&#39;,\n  headers: {\n    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,\n    &#39;Content-Length&#39;: Buffer.byteLength(postData)\n  }\n}\n\nconst server = http.createServer((req, res) =&gt; {\n    const request = http.request(options, result =&gt; {\n\n    })\n    req.write(postData)\n    req.end()\n\n    res.end()\n})\nserver.listen(8080, ()=&gt; {\n    console.log(&#39;localhost:8080&#39;)\n})\n\n//function doPost() {\n//  let data\n\n//  let req = https.request(options, (res) =&gt; {\n//    res.on(&#39;data&#39;, chunk =&gt; data += chunk)\n//    res.on(&#39;end&#39;, () =&gt; {\n//      console.log(data)\n//    })\n//  })\n\n//  req.write(postData)\n//  req.end()\n//}\n\n// setInterval(() =&gt; {\n//   doPost()\n// }, 1000)\n\n</code></pre>\n<h4 id=\"3-3-跨域：JSONP\"><a href=\"#3-3-跨域：JSONP\" class=\"headerlink\" title=\"3.3 跨域：JSONP\"></a>3.3 跨域：JSONP</h4><pre><code class=\"js\">const http = require(&#39;http&#39;)\nconst url = require(&#39;url&#39;)\n\nconst app = http.createServer((req, res) =&gt; {\n  let urlObj = url.parse(req.url, true)\n\n  switch (urlObj.pathname) {\n    case &#39;/api/user&#39;:\n      res.end(`${urlObj.query.cb}({&quot;name&quot;: &quot;gp145&quot;})`)\n      break\n    default:\n      res.end(&#39;404.&#39;)\n      break\n  }\n})\n\napp.listen(8080, () =&gt; {\n  console.log(&#39;localhost:8080&#39;)\n})\n\n</code></pre>\n<h4 id=\"3-4-跨域：CORS\"><a href=\"#3-4-跨域：CORS\" class=\"headerlink\" title=\"3.4 跨域：CORS\"></a>3.4 跨域：CORS</h4><pre><code class=\"js\">const http = require(&#39;http&#39;)\nconst url = require(&#39;url&#39;)\nconst querystring = require(&#39;querystring&#39;)\n\nconst app = http.createServer((req, res) =&gt; {\n  let data = &#39;&#39;\n  let urlObj = url.parse(req.url, true)\n\n  res.writeHead(200, {\n    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;,\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;\n  })\n\n  req.on(&#39;data&#39;, (chunk) =&gt; {\n    data += chunk\n  })\n\n  req.on(&#39;end&#39;, () =&gt; {\n    responseResult(querystring.parse(data))\n  })\n\n  function responseResult(data) {\n    switch (urlObj.pathname) {\n      case &#39;/api/login&#39;:\n        res.end(JSON.stringify({\n          message: data\n        }))\n        break\n      default:\n        res.end(&#39;404.&#39;)\n        break\n    }\n  }\n})\n\napp.listen(8080, () =&gt; {\n  console.log(&#39;localhost:8080&#39;)\n})\n\n</code></pre>\n<h4 id=\"3-5-跨域：middleware-http-proxy-middware\"><a href=\"#3-5-跨域：middleware-http-proxy-middware\" class=\"headerlink\" title=\"3.5 跨域：middleware(http-proxy-middware)\"></a>3.5 跨域：middleware(http-proxy-middware)</h4><pre><code class=\"js\">const http = require(&#39;http&#39;)\nconst proxy = require(&#39;http-proxy-middleware&#39;)\n\nhttp.createServer((req, res) =&gt; {\n  let url = req.url\n\n  res.writeHead(200, {\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;\n  })\n\n  if (/^\\/api/.test(url)) {\n    let apiProxy = proxy(&#39;/api&#39;, { \n      target: &#39;https://m.lagou.com&#39;,\n      changeOrigin: true,\n      pathRewrite: {\n        &#39;^/api&#39;: &#39;&#39;\n      }\n    })\n\n    // http-proy-middleware 在Node.js中使用的方法\n    apiProxy(req, res)\n  } else {\n    switch (url) {\n      case &#39;/index.html&#39;:\n        res.end(&#39;index.html&#39;)\n        break\n      case &#39;/search.html&#39;:\n        res.end(&#39;search.html&#39;)\n        break\n      default:\n        res.end(&#39;[404]page not found.&#39;)\n    }\n  }\n}).listen(8080)\n\n</code></pre>\n<h4 id=\"3-6-爬虫\"><a href=\"#3-6-爬虫\" class=\"headerlink\" title=\"3.6 爬虫\"></a>3.6 爬虫</h4><pre><code class=\"js\">const https = require(&#39;https&#39;)\nconst http = require(&#39;http&#39;)\nconst cheerio = require(&#39;cheerio&#39;)\n\nhttp.createServer((request, response) =&gt; {\n  response.writeHead(200, {\n    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;\n  })\n\n  const options = {\n    protocol: &#39;https:&#39;,\n    hostname: &#39;maoyan.com&#39;,\n    port: 443,\n    path: &#39;/&#39;,\n    method: &#39;GET&#39;\n  }\n\n  const req = https.request(options, (res) =&gt; {\n    let data = &#39;&#39;\n    res.on(&#39;data&#39;, (chunk) =&gt; {\n      data += chunk\n    })\n\n    res.on(&#39;end&#39;, () =&gt; {\n      filterData(data)\n    })\n  })\n\n  function filterData(data) {\n    let $ = cheerio.load(data)\n    let $movieList = $(&#39;.movie-item&#39;)\n    let movies = []\n    $movieList.each((index, value) =&gt; {\n      movies.push({\n        title: $(value).find(&#39;.movie-title&#39;).attr(&#39;title&#39;),\n        score: $(value).find(&#39;.movie-score i&#39;).text(),\n      })\n    })\n\n    response.end(JSON.stringify(movies))\n  }\n\n  req.end()\n}).listen(9000)\n\n</code></pre>\n<h3 id=\"4、Events\"><a href=\"#4、Events\" class=\"headerlink\" title=\"4、Events\"></a>4、Events</h3><pre><code class=\"js\">const EventEmitter = require(&#39;events&#39;)\n\nclass MyEventEmitter extends EventEmitter {}\n\nconst event = new MyEventEmitter()\n\nevent.on(&#39;play&#39;, (movie) =&gt; {\n  console.log(movie)\n})\n\nevent.emit(&#39;play&#39;, &#39;我和我的祖国&#39;)\nevent.emit(&#39;play&#39;, &#39;中国机长&#39;)\n\n</code></pre>\n<h3 id=\"5、File-System\"><a href=\"#5、File-System\" class=\"headerlink\" title=\"5、File System\"></a>5、File System</h3><pre><code class=\"js\">const fs = require(&#39;fs&#39;)\nconst fsP = require(&#39;fs&#39;).promises\n\n// 创建文件夹\nfs.mkdir(&#39;./logs&#39;, (err) =&gt; {\n  console.log(&#39;done.&#39;)\n})\n\n// 文件夹改名\nfs.rename(&#39;./logs&#39;, &#39;./log&#39;, () =&gt; {\n  console.log(&#39;done&#39;)\n})\n\n// 删除文件夹\nfs.rmdir(&#39;./log&#39;, () =&gt; {\n  console.log(&#39;done.&#39;)\n})\n\n// 写内容到文件里\nfs.writeFile(\n  &#39;./logs/log1.txt&#39;,\n  &#39;hello&#39;,\n  // 错误优先的回调函数\n  (err) =&gt; {\n    if (err) {\n      console.log(err.message)\n    } else {\n      console.log(&#39;文件创建成功&#39;)\n    }\n  }\n)\n\n// 给文件追加内容\nfs.appendFile(&#39;./logs/log1.txt&#39;, &#39;\\nworld&#39;, () =&gt; {\n  console.log(&#39;done.&#39;)\n})\n\n// 读取文件内容\nfs.readFile(&#39;./logs/log1.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; {\n  console.log(data)\n})\n\n// 删除文件\nfs.unlink(&#39;./logs/log1.txt&#39;, (err) =&gt; {\n  console.log(&#39;done.&#39;)\n})\n\n// 批量写文件\nfor (var i = 0; i &lt; 10; i++) {\n  fs.writeFile(`./logs/log-${i}.txt`, `log-${i}`, (err) =&gt; {\n    console.log(&#39;done.&#39;)\n  })\n}\n\n// 读取文件/目录信息\nfs.readdir(&#39;./&#39;, (err, data) =&gt; {\n  data.forEach((value, index) =&gt; {\n    fs.stat(`./${value}`, (err, stats) =&gt; {\n      // console.log(value + &#39;:&#39; + stats.size)\n      console.log(value + &#39; is &#39; + (stats.isDirectory() ? &#39;directory&#39; : &#39;file&#39;))\n    })\n  })\n})\n\n// 同步读取文件\ntry {\n  const content = fs.readFileSync(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;)\n  console.log(content)\n  console.log(0)\n} catch (e) {\n  console.log(e.message)\n}\n\nconsole.log(1)\n\n// 异步读取文件：方法一\nfs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; {\n  console.log(content)\n  console.log(0)\n})\nconsole.log(1)\n\n// 异步读取文件：方法二\nfs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;).then(result =&gt; {\n  console.log(result)\n})\n\n// 异步读取文件：方法三\nfunction getFile() {\n  return new Promise((resolve) =&gt; {\n    fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; {\n      resolve(data)\n    })\n  })\n}\n\n;(async () =&gt; {\n  console.log(await getFile())\n})()\n\n// 异步读取文件：方法四\nconst fsp = fsP.readFile(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;).then((result) =&gt; {\n  console.log(result)\n})\n\nconsole.log(fsP)\n\n// watch 监测文件变化\nfs.watch(&#39;./logs/log-0.txt&#39;, () =&gt; {\n  console.log(0)\n})\n\n</code></pre>\n<h3 id=\"6、Stream\"><a href=\"#6、Stream\" class=\"headerlink\" title=\"6、Stream\"></a>6、Stream</h3><pre><code class=\"js\">const fs = require(&#39;fs&#39;)\n\nconst readstream = fs.createReadStream(&#39;./note.txt&#39;)\nconst writestream = fs.createWriteStream(&#39;./note2.txt&#39;)\n\nwritestream.write(readstream)\n\n</code></pre>\n<h3 id=\"7、Zlib\"><a href=\"#7、Zlib\" class=\"headerlink\" title=\"7、Zlib\"></a>7、Zlib</h3><pre><code class=\"js\">const fs = require(&#39;fs&#39;)\nconst zlib = require(&#39;zlib&#39;)\n\nconst gzip = zlib.createGzip()\n\nconst readstream = fs.createReadStream(&#39;./note.txt&#39;)\nconst writestream = fs.createWriteStream(&#39;./note2.txt&#39;)\n\nreadstream\n  .pipe(gzip)\n  .pipe(writestream)\n\nwritestream.write(readstream)\n\n</code></pre>\n<h3 id=\"8、ReadLine\"><a href=\"#8、ReadLine\" class=\"headerlink\" title=\"8、ReadLine\"></a>8、ReadLine</h3><pre><code class=\"js\">const readline = require(&#39;readline&#39;)\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\n\nrl.question(&#39;What do you think of Node.js? &#39;, (answer) =&gt; {\n  // TODO: Log the answer in a database\n  console.log(`Thank you for your valuable feedback: ${answer}`)\n\n  rl.close()\n})\n\n</code></pre>\n<h3 id=\"9、Crypto\"><a href=\"#9、Crypto\" class=\"headerlink\" title=\"9、Crypto\"></a>9、Crypto</h3><pre><code class=\"js\">const crypto = require(&#39;crypto&#39;)\n\nconst secret = &#39;abcdefg&#39;\nconst hash = crypto.createHmac(&#39;sha256&#39;, secret)\n                   .update(&#39;I love you&#39;)\n                   .digest(&#39;hex&#39;)\nconsole.log(hash)\n\n</code></pre>\n<h2 id=\"五、路由\"><a href=\"#五、路由\" class=\"headerlink\" title=\"五、路由\"></a>五、路由</h2><pre><code class=\"js\">var http = require(&#39;http&#39;)\nvar fs = require(&#39;fs&#39;)\n\nhttp.createServer( function ( req, res ) {\n\n  switch ( req.url ) {\n    case &#39;/home&#39;:\n      res.write(&#39;home&#39;)\n      res.end()\n      break\n    case &#39;/mine&#39;:\n      res.write(&#39;mine&#39;)\n      res.end()\n      break\n    case &#39;/login&#39;: \n      fs.readFile( &#39;./static/login.html&#39;,function ( error , data ) {\n        if ( error ) throw error  \n        res.write( data )\n        res.end()\n      })\n      break\n    case &#39;/fulian.jpg&#39;:\n      fs.readFile( &#39;./static/fulian.jpg&#39;, &#39;binary&#39;, function( error , data ) {\n        if( error ) throw error \n        res.write( data, &#39;binary&#39; )\n        res.end()\n      })\n      break\n    default: \n      break\n   }\n\n }).listen( 8000, &#39;localhost&#39;, function () {\n   console.log( &#39;服务器运行在： http://localhost:8000&#39; )\n })\n\n</code></pre>\n<h2 id=\"六、静态资源服务\"><a href=\"#六、静态资源服务\" class=\"headerlink\" title=\"六、静态资源服务\"></a>六、静态资源服务</h2><h3 id=\"6-1-readStaticFile\"><a href=\"#6-1-readStaticFile\" class=\"headerlink\" title=\"6.1 readStaticFile\"></a>6.1 readStaticFile</h3><p><code>/modules/readStaticFile.js</code></p>\n<pre><code class=\"js\">// 引入依赖的模块\nvar path = require(&#39;path&#39;)\nvar fs = require(&#39;fs&#39;)\nvar mime = require(&#39;mime&#39;)\n\nfunction readStaticFile(res, filePathname) {\n\n  var ext = path.parse(filePathname).ext\n  var mimeType = mime.getType(ext)\n\n  // 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 \n  if (ext) {\n    // 根据传入的目标文件路径来读取对应文件\n    fs.readFile(filePathname, (err, data) =&gt; {\n    // 错误处理\n      if (err) {\n        res.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; })\n        res.write(&quot;404 - NOT FOUND&quot;)\n        res.end()\n      } else {\n        res.writeHead(200, { &quot;Content-Type&quot;: mimeType })\n        res.write(data)\n        res.end()\n      }\n    });\n    // 返回 true 表示, 客户端想要的 是 静态文件\n    return true\n  } else {\n    // 返回 false 表示, 客户端想要的 不是 静态文件\n    return false\n  }\n}\n\n// 导出函数\nmodule.exports = readStaticFile\n\n</code></pre>\n<h3 id=\"6-2-server\"><a href=\"#6-2-server\" class=\"headerlink\" title=\"6.2 server\"></a>6.2 server</h3><p><code>/server.js</code></p>\n<pre><code class=\"js\">// 引入相关模块\nvar http = require(&#39;http&#39;);\nvar url = require(&#39;url&#39;);\nvar path = require(&#39;path&#39;);\nvar readStaticFile = require(&#39;./modules/readStaticFile&#39;);\n\n// 搭建 HTTP 服务器\nvar server = http.createServer(function(req, res) {\n  var urlObj = url.parse(req.url);\n  var urlPathname = urlObj.pathname;\n  var filePathname = path.join(__dirname, &quot;/public&quot;, urlPathname);\n\n  // 读取静态文件\n  readStaticFile(res, filePathname);\n});\n\n// 在 3000 端口监听请求\nserver.listen(3000, function() {\n  console.log(&quot;服务器运行中.&quot;);\n  console.log(&quot;正在监听 3000 端口:&quot;)\n})\n\n</code></pre>\n<h3 id=\"6-3-最终目录结构\"><a href=\"#6-3-最终目录结构\" class=\"headerlink\" title=\"6.3 最终目录结构\"></a>6.3 最终目录结构</h3><p><img src=\"https://lurongtao.gitee.io/felixbooks-gp19-node.js/images/dir.jpg\" alt></p>\n<h1 id=\"02-Express\"><a href=\"#02-Express\" class=\"headerlink\" title=\"02-Express\"></a>02-Express</h1><p>基于Node.js平台，快速、开放、极简的web开发框架。</p>\n<pre><code>$ npm install express --save\n\n</code></pre><h2 id=\"一、特色\"><a href=\"#一、特色\" class=\"headerlink\" title=\"一、特色\"></a>一、特色</h2><h3 id=\"1、Web应用\"><a href=\"#1、Web应用\" class=\"headerlink\" title=\"1、Web应用\"></a>1、Web应用</h3><p>Express是一个基于Node.js平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种Web和移动设备应用。</p>\n<h3 id=\"2、API\"><a href=\"#2、API\" class=\"headerlink\" title=\"2、API\"></a>2、API</h3><p>丰富的HTTP快捷方法和任意排列组合的Connect中间件，让你创建健壮、友好的API变得既快速又简单。</p>\n<h3 id=\"3、性能\"><a href=\"#3、性能\" class=\"headerlink\" title=\"3、性能\"></a>3、性能</h3><p>Express不对Node.js已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的基本性能。</p>\n<h2 id=\"二、安装\"><a href=\"#二、安装\" class=\"headerlink\" title=\"二、安装\"></a>二、安装</h2><p>首先假定你已经安装了Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p>\n<pre><code>$ mkdir myapp\n$ cd myapp\n\n</code></pre><p>通过<code>npm init</code>命令为你的应用创建一个<code>package.json</code>文件。欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。</p>\n<pre><code>$ npm init\n\n</code></pre><p>此命令将要求你输入几个参数，例如此应用的名称和版本。你可以直接按“回车”键接受默认设置即可，下面这个除外：</p>\n<pre><code>entry point: (index.js)\n\n</code></pre><p>键入app.js或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的<code>index.js</code>文件名，只需按“回车”键即可。</p>\n<p>接下来安装Express并将其保存到依赖列表中：</p>\n<pre><code>$ npm install express --save\n\n</code></pre><p>如果只是临时安装Express，不想将它添加到依赖列表中，只需略去--save参数即可：</p>\n<pre><code>$ npm install express\n\n</code></pre><blockquote>\n<p>安装Node模块时，如果指定了<code>--save</code> 参数，那么此模块将被添加到<code>package.json</code>文件中<code>dependencies</code>依赖列表中。然后通过<code>npm install</code> 命令即可</p>\n</blockquote>\n<h2 id=\"三、Hello-World实例\"><a href=\"#三、Hello-World实例\" class=\"headerlink\" title=\"三、Hello World实例\"></a>三、Hello World实例</h2><p>接下来，我们一起创建一个基本的Express应用。</p>\n<p>注意：这里所创建的是一个最最简单的Express应用，并且仅仅只有一个文件 - 和通过Express应用生成器所创建的应用完全不一样，Express应用生成器所创建的应用框架包含多JavaScript文件、Jade模板和针对不同用途的子目录。</p>\n<p>进入myapp目录，创建一个名为app.js的文件，然后将下列代码复制进去：</p>\n<pre><code class=\"js\">var express = require(&#39;express&#39;);\nvar app = express();\n\napp.get(&#39;/&#39;, function (req, res) {\n  res.send(&#39;Hello World!&#39;);\n});\n\nvar server = app.listen(3000, function () {\n  var host = server.address().address;\n  var port = server.address().port;\n\n  console.log(&#39;Example app listening at http://%s:%s&#39;, host, port);\n});\n\n</code></pre>\n<p>上面的代码启动一个服务并监听从3000端口进入的所有连接请求。他将对所有(/)URL或 路由返回“Hello World！”字符串。对于其他所有路径全部返回 404 Not Found。</p>\n<blockquote>\n<p>req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on(&#39;data&#39;, callback) 以及任何 Node 提供的方法。</p>\n</blockquote>\n<p>通过如下命令启动此应用：</p>\n<pre><code>$ node app.js\n\n</code></pre><p>然后在浏览器中打开 <a href=\"http://localhost:3000/\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a> 并查看输出结果。</p>\n<h2 id=\"四、路由\"><a href=\"#四、路由\" class=\"headerlink\" title=\"四、路由\"></a>四、路由</h2><p>路由是指如何定义应用的端点（URls）以及如何响应客户端的请求。</p>\n<p>路由是由一个URI、HTTP请求（GET、POST等）和若干个句柄组成，它的结构如下：app.METHOD(path, [callback..], callback)， app 是 express 对象的一个实例，METHOD是一个 HTTP 请求方法，path 是服务器上的路径， callback 是当路由匹配时要执行的函数。</p>\n<p>下面是一个基本的路由示例：</p>\n<pre><code class=\"js\">var express = require(&#39;express&#39;);\nvar app = express();\n\n// respond with &quot;hello world&quot; when a GET request is made to the homepage\napp.get(&#39;/&#39;, function(req, res) {\n  res.send(&#39;hello world&#39;);\n});\n\n</code></pre>\n<h3 id=\"1、路由方法\"><a href=\"#1、路由方法\" class=\"headerlink\" title=\"1、路由方法\"></a>1、路由方法</h3><p>路由方法源于 HTTP 请求方法，和 express 实例相关联。</p>\n<p>下面这个例子展示了为应用跟路径定义的 GET 和 POST 请求：</p>\n<pre><code class=\"js\">// GET method route\n// 对网站首页的访问返回 &quot;Hello World!&quot; 字样\napp.get(&#39;/&#39;, function (req, res) {\n  res.send(&#39;Hello World!&#39;)\n})\n\n// 网站首页接受 POST 请求\napp.post(&#39;/&#39;, function (req, res) {\n  res.send(&#39;Got a POST request&#39;)\n})\n\n// /user 节点接受 PUT 请求\napp.put(&#39;/user&#39;, function (req, res) {\n  res.send(&#39;Got a PUT request at /user&#39;)\n})\n\n// /user 节点接受 DELETE 请求\napp.delete(&#39;/user&#39;, function (req, res) {\n  res.send(&#39;Got a DELETE request at /user&#39;)\n})\n\n</code></pre>\n<p>Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。</p>\n<blockquote>\n<p>有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如：<code>app[&#39;m-search&#39;](&#39;/&#39;, function ...)</code></p>\n</blockquote>\n<p>app.all()是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。</p>\n<p>在下面的例子中，来自&quot;/secret&quot;的请求，不管使用 GET、POST、PUT、DELETE或其他任何http模块支持的HTTP请求，句柄都会得到执行。</p>\n<pre><code class=\"js\">app.all(&#39;/secret&#39;, function (req, res, next) {\n  console.log(&#39;Accessing the secret section ...&#39;)\n  next(); // pass control to the next handler\n})\n\n</code></pre>\n<h3 id=\"2、路由路径\"><a href=\"#2、路由路径\" class=\"headerlink\" title=\"2、路由路径\"></a>2、路由路径</h3><p>路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。</p>\n<p>Express使用<code>path-to-regexp</code>匹配路由路径，请参考文档查阅所有定义路由路径的方法。Express Route Tester是测试基本Express路径的好工具，但不支持模式匹配。</p>\n<blockquote>\n<p>查询字符串不是路由路径的一部分。</p>\n</blockquote>\n<p>使用字符串的路由路径示例：</p>\n<pre><code class=\"js\">// 匹配根路径的请求\napp.get(&#39;/&#39;, function (req, res) {\n  res.send(&#39;root&#39;);\n});\n\n// 匹配 /about 路径的请求\napp.get(&#39;/about&#39;, function (req, res) {\n  res.send(&#39;about&#39;);\n});\n\n// 匹配 /random.text 路径的请求\napp.get(&#39;/random.text&#39;, function (req, res) {\n  res.send(&#39;random.text&#39;);\n});\n\n</code></pre>\n<p>使用字符串模式的路由路径示例：</p>\n<pre><code class=\"js\">// 匹配 acd 和 abcd\napp.get(&#39;/ab?cd&#39;, function(req, res) {\n  res.send(&#39;ab?cd&#39;);\n});\n\n// 匹配 abcd、abbcd、abbbcd等\napp.get(&#39;/ab+cd&#39;, function(req, res) {\n  res.send(&#39;ab+cd&#39;);\n});\n\n// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等\napp.get(&#39;/ab*cd&#39;, function(req, res) {\n  res.send(&#39;ab*cd&#39;);\n});\n\n// 匹配 /abe 和 /abcde\napp.get(&#39;/ab(cd)?e&#39;, function(req, res) {\n res.send(&#39;ab(cd)?e&#39;);\n});\n\n</code></pre>\n<blockquote>\n<p>字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。</p>\n</blockquote>\n<p>使用正则表达式的路由路径示例：</p>\n<pre><code class=\"js\">// 匹配任何路径中含有 a 的路径：\napp.get(/a/, function(req, res) {\n  res.send(&#39;/a/&#39;);\n});\n\n// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等\napp.get(/.*fly$/, function(req, res) {\n  res.send(&#39;/.*fly$/&#39;);\n});\n\n</code></pre>\n<h3 id=\"3、路由句柄\"><a href=\"#3、路由句柄\" class=\"headerlink\" title=\"3、路由句柄\"></a>3、路由句柄</h3><p>可以为请求处理提供多个回调函数，其行为类似中间件。唯一的区别是这些回调函数有可能调用<code>next(&#39;route&#39;)</code>方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。</p>\n<p>路由句柄有多种形式，可以是一个函数、一个函数数组、或者是两者混合，如下所示。</p>\n<p>使用一个回调函数处理路由：</p>\n<pre><code class=\"js\">app.get(&#39;/example/a&#39;, function(req, res) {\n    res.send(&#39;Hello from A!&#39;)\n})\n\n</code></pre>\n<p>使用多个回调函数处理路由（记得指定next对象）：</p>\n<pre><code class=\"js\">app.get(&#39;/example/b&#39;, function (req, res, next) {\n  console.log(&#39;response will be sent by the next function ...&#39;);\n  next();\n}, function (req, res) {\n  res.send(&#39;Hello from B!&#39;);\n});\n\n</code></pre>\n<p>使用回调函数数组处理路由：</p>\n<pre><code class=\"js\">var cb0 = function (req, res, next) {\n  console.log(&#39;CB0&#39;)\n  next()\n}\n\nvar cb1 = function (req, res, next) {\n  console.log(&#39;CB1&#39;)\n  next()\n}\n\nvar cb2 = function (req, res) {\n  res.send(&#39;Hello from C!&#39;)\n}\n\napp.get(&#39;/example/c&#39;, [cb0, cb1, cb2])\n\n</code></pre>\n<p>混合使用函数和函数数组处理路由：</p>\n<pre><code class=\"js\">var cb0 = function (req, res, next) {\n  console.log(&#39;CB0&#39;)\n  next()\n}\n\nvar cb1 = function (req, res, next) {\n  console.log(&#39;CB1&#39;)\n  next()\n}\n\napp.get(&#39;/example/d&#39;, [cb0, cb1], function (req, res, next) {\n  console.log(&#39;response will be sent by the next function ...&#39;)\n  next()\n}, function (req, res) {\n  res.send(&#39;Hello from D!&#39;)\n})\n\n</code></pre>\n<h3 id=\"4、响应方法\"><a href=\"#4、响应方法\" class=\"headerlink\" title=\"4、响应方法\"></a>4、响应方法</h3><p>下表中响应对象(res)的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">res.download()</td>\n<td style=\"text-align:center\">提示下载文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.end()</td>\n<td style=\"text-align:center\">终结响应处理流程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.json()</td>\n<td style=\"text-align:center\">发送一个JSON格式的响应</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.jsonp()</td>\n<td style=\"text-align:center\">发送一个支持JSONP的JSON格式的响应</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.direct()</td>\n<td style=\"text-align:center\">重定向请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.render()</td>\n<td style=\"text-align:center\">渲染视图模板</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.send()</td>\n<td style=\"text-align:center\">发送各种类型的响应</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.sendFile()</td>\n<td style=\"text-align:center\">以八位字节流的形式发送文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.sendStatus()</td>\n<td style=\"text-align:center\">设置响应状态代码，并将其以字符串形式作为响应体的一部分发送</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"5、app-route\"><a href=\"#5、app-route\" class=\"headerlink\" title=\"5、app.route()\"></a>5、app.route()</h3><p>可使用app.route()创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。</p>\n<p>下面这个示例程序使用app.route()定义了链式路由句柄。</p>\n<pre><code class=\"js\">app.route(&#39;/book&#39;)\n  .get(function(req, res) {\n    res.send(&#39;Get a random book&#39;);\n  })\n  .post(function(req, res) {\n    res.send(&#39;Add a book&#39;);\n  })\n  .put(function(req, res) {\n    res.send(&#39;Update the book&#39;);\n  });\n\n</code></pre>\n<h3 id=\"6、express-Router\"><a href=\"#6、express-Router\" class=\"headerlink\" title=\"6、express.Router\"></a>6、express.Router</h3><p>可使用express.Router类创建模块化、可挂载的路由句柄。Router实例是一个完整的中间件和路由系统，因此常称其为一个&#39;mini-app&#39;。</p>\n<p>下面的实例程序创建了一个路由模块，并加载 了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。</p>\n<p>在app目录下创建名为bird.js的文件，内容如下：</p>\n<pre><code class=\"js\">var express = require(&#39;express&#39;);\nvar router = express.Router();\n\n// 该路由使用的中间件\nrouter.use(function timeLog(req, res, next) {\n  console.log(&#39;Time: &#39;, Date.now());\n  next();\n});\n// 定义网站主页的路由\nrouter.get(&#39;/&#39;, function(req, res) {\n  res.send(&#39;Birds home page&#39;);\n});\n// 定义 about 页面的路由\nrouter.get(&#39;/about&#39;, function(req, res) {\n  res.send(&#39;About birds&#39;);\n});\n\nmodule.exports = router;\n\n</code></pre>\n<p>然后在应用中加载路由模块：</p>\n<pre><code class=\"js\">var birds = require(&#39;./birds&#39;)\n...\napp.use(&#39;/birds&#39;, birds)\n\n</code></pre>\n<p>应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。</p>\n<h2 id=\"五、利用Express托管静态文件\"><a href=\"#五、利用Express托管静态文件\" class=\"headerlink\" title=\"五、利用Express托管静态文件\"></a>五、利用Express托管静态文件</h2><p>通过Express内置的<code>express.static</code>可以方便地托管静态文件，例如图片、CSS、JavaScript文件等。</p>\n<p>将静态资源文件所在的目录作为参数传递给<code>express.static</code>中间件就可以提供静态资源文件的访问了。例如，假设在public目录放置了图片、CSS和JavaScript文件，你就可以：</p>\n<pre><code class=\"js\">app.use(express.static(&#39;public&#39;))\n\n</code></pre>\n<p>现在，public目录下面的文件就可以访问了。</p>\n<pre><code>http://localhost:3000/images/kitten.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/images/bg.png\nhttp://localhost:3000/hello.html\n\n</code></pre><blockquote>\n<p>所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在URL中。</p>\n</blockquote>\n<p>如果你的静态资源存放在多个目录下面，你可以多次调用<code>express.static</code>中间件：</p>\n<pre><code class=\"js\">app.use(express.static(&#39;public&#39;))\napp.use(express.static(&#39;files&#39;))\n\n</code></pre>\n<p>访问静态资源文件时，<code>express.static</code>中间件会根据目录添加的顺序查找所需的文件。</p>\n<p>如果你希望所有通过<code>express.static</code>访问的文件都存放在一个”虚拟(virtual)“目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：</p>\n<pre><code class=\"js\">app.use(&#39;/static&#39;, express.static(&#39;public&#39;))\n\n</code></pre>\n<p>现在，你就可以通过带有”/static“前缀的地址来访问public目录下面的文件了。</p>\n<pre><code class=\"js\">http://localhost:3000/static/images/kitten.jpg\nhttp://localhost:3000/static/css/style.css\nhttp://localhost:3000/static/js/app.js\nhttp://localhost:3000/static/images/bg.png\nhttp://localhost:3000/static/hello.html\n\n</code></pre>\n<h2 id=\"六、使用中间件\"><a href=\"#六、使用中间件\" class=\"headerlink\" title=\"六、使用中间件\"></a>六、使用中间件</h2><p>Express是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。</p>\n<p>中间件（Middleware）是一个函数，它可以访问请求对象（request object(req)），响应对象(response object(res))，和web应用中处于请求-响应循环流程中的中间件，一般被命名为next的变量。</p>\n<p>中间件的功能包括：</p>\n<ul>\n<li>执行任何代码</li>\n<li>修改请求和响应对象</li>\n<li>终结请求-响应循环</li>\n<li>调用堆栈中的下一个中间件</li>\n</ul>\n<p>如果当前中间件没有终结请求-响应循环，则必须调用<code>next()</code>方法将控制权交给下一个中间件，否则请求就会挂起。</p>\n<p>Express应用可使用如下几种中间件：</p>\n<ul>\n<li>应用级中间件</li>\n<li>路由级中间件</li>\n<li>错误处理中间件</li>\n<li>内置中间件</li>\n<li>第三方中间件</li>\n</ul>\n<p>使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。</p>\n<h3 id=\"1、应用级中间件\"><a href=\"#1、应用级中间件\" class=\"headerlink\" title=\"1、应用级中间件\"></a>1、应用级中间件</h3><p>应用级中间件绑定到app对象，使用<code>app.use()</code>和<code>app.METHOD()</code>，其中，<code>METHOD</code>是需要处理的HTTP请求的方法，例如GET,PUT,POST等等，全部小写。例如：</p>\n<pre><code class=\"js\">var app = express()\n\n// 没有挂载路径的中间件，应用的每个请求都会执行该中间件\napp.use(function (req, res, next) {\n    console.log(&#39;Time:&#39;, Date.now())\n    next()\n})\n\n// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它\napp.use(&#39;/user/:id&#39;, function(req, res, next) {\n    console.log(&#39;Request Type:&#39;, req.method)\n    next()\n})\n\n// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    res.send(&#39;USER&#39;)\n})\n\n</code></pre>\n<p>下面这个例子展示了在一个挂载点装载一组中间件。</p>\n<pre><code class=\"js\">// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息\napp.use(&#39;/user/:id&#39;, function(req, res, next) {\n    console.log(&#39;Request URL:&#39;, req.originalUrl)\n    next()\n}, function(req, res, next) {\n    console.log(&#39;Request Type:&#39;, req.method)\n    next()\n})\n\n</code></pre>\n<p>作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。 第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。</p>\n<pre><code class=\"js\">// 一个中间件栈，处理指向 /user/:id 的 GET请求\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    console.log(&#39;ID:&#39;, req.params.id)\n    next()\n}, function(req, res, next) {\n    res.send(&#39;User Info&#39;)\n})\n\n// 处理 /user/:id, 打印出用户id\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    res.end(req.params.id)\n})\n\n</code></pre>\n<p>如果需要在中间件栈中跳过剩余中间件，调用 <code>next(&#39;route&#39;)</code>方法将控制权交给下一个路由。注意：<code>next(&#39;route&#39;)</code>只对使用 <code>app.VERB()</code>  或 <code>router.VERB()</code>加载的中间件有效。</p>\n<pre><code class=\"js\">// 一个中间件栈，处理指向 /user/:id 的 GET 请求\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    // 如果 user id 为0，跳到下一个路由\n    if (req.params.id === 0) next(&#39;route&#39;)\n    // 否则将控制权交给栈中下一个中间件\n    else next()\n}, function(req, res, next) {\n    // 渲染常规页面\n    res.render(&#39;regular&#39;)\n})\n\n// 处理 /user/:id, 渲染一个特殊页面\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    res.render(&#39;special&#39;)\n})\n\n</code></pre>\n<h3 id=\"2、路由级中间件\"><a href=\"#2、路由级中间件\" class=\"headerlink\" title=\"2、路由级中间件\"></a>2、路由级中间件</h3><p>路由级中间件和应用级中间件一样，只是它绑定的对象为 <code>express.Router()</code>。</p>\n<pre><code>var router = express.Router()\n\n</code></pre><p>路由级使用<code>router.use()</code>或<code>router.VERB()</code>加载。</p>\n<p> 上述在应用级创建的中间件系统，可通过如下代码改写为路由级。</p>\n<pre><code class=\"js\">var app = express()\nvar router = express.Router()\n\n// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件\nrouter.use(function (req, res, next) {\n  console.log(&#39;Time:&#39;, Date.now())\n  next()\n})\n\n// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息\nrouter.use(&#39;/user/:id&#39;, function(req, res, next) {\n  console.log(&#39;Request URL:&#39;, req.originalUrl)\n  next()\n}, function (req, res, next) {\n  console.log(&#39;Request Type:&#39;, req.method)\n  next()\n})\n\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\nrouter.get(&#39;/user/:id&#39;, function (req, res, next) {\n  // 如果 user id 为 0, 跳到下一个路由\n  if (req.params.id == 0) next(&#39;route&#39;)\n  // 负责将控制权交给栈中下一个中间件\n  else next() //\n}, function (req, res, next) {\n  // 渲染常规页面\n  res.render(&#39;regular&#39;)\n})\n\n// 处理 /user/:id， 渲染一个特殊页面\nrouter.get(&#39;/user/:id&#39;, function (req, res, next) {\n  console.log(req.params.id)\n  res.render(&#39;special&#39;)\n})\n\n// 将路由挂载至应用\napp.use(&#39;/&#39;, router)\n\n</code></pre>\n<h3 id=\"3、错误处理中间件\"><a href=\"#3、错误处理中间件\" class=\"headerlink\" title=\"3、错误处理中间件\"></a>3、错误处理中间件</h3><blockquote>\n<p>错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。</p>\n</blockquote>\n<p>错误处理中间件和其他中间件定义类似，只是要使用4个参数，而不是3个，其签名如下：(err,req,res,next)。</p>\n<pre><code class=\"js\">app.use(function(err, req, res, next) {\n  console.error(err.stack)\n  res.status(500).send(&#39;Something broke!&#39;)\n})\n\n</code></pre>\n<h3 id=\"4、内置中间件\"><a href=\"#4、内置中间件\" class=\"headerlink\" title=\"4、内置中间件\"></a>4、内置中间件</h3><p>从4.x版本开始，Express已经不再依赖Connect了。除了express.static，Express以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。</p>\n<p><code>express.static(root, [options])</code></p>\n<p>express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在Express应用中提托管静态资源。</p>\n<p>参数 root 指提供静态资源的根目录。</p>\n<p>可选的 options 参数拥有如下属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n<th>缺省值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dotfiles</td>\n<td>是否对外输出文件名以点（.）开头的文件。可选值为”allow“，”deny“和”ignore“。</td>\n<td>String</td>\n<td>”ignore“</td>\n</tr>\n<tr>\n<td>etag</td>\n<td>是否启用etag生成</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>extensions</td>\n<td>设置文件扩展名备份选项</td>\n<td>Array</td>\n<td>[]</td>\n</tr>\n<tr>\n<td>index</td>\n<td>发送目录索引文件，设置为false禁用目录索引</td>\n<td>Mixed</td>\n<td>&quot;index.html&quot;</td>\n</tr>\n<tr>\n<td>lastModified</td>\n<td>设置Last-Modified头为文件在操作系统上的最后修改日期。可能值为true或false</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>maxAge</td>\n<td>以毫秒或者其字符串格式设置Cache-Control头的max-age属性。</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n<tr>\n<td>redirect</td>\n<td>当路径为目录时，重定向至”/“</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>setHeaders</td>\n<td>设置HTTP头以提供文件的函数</td>\n<td>Function</td>\n</tr>\n</tbody>\n</table>\n<p>下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。</p>\n<pre><code class=\"js\">var options = {\n  dotfiles: &#39;ignore&#39;,\n  etag: false,\n  extensions: [&#39;htm&#39;, &#39;html&#39;],\n  index: false,\n  maxAge: &#39;1d&#39;,\n  redirect: false,\n  setHeaders: function (res, path, stat) {\n    res.set(&#39;x-timestamp&#39;, Date.now())\n  }\n}\n\napp.use(express.static(&#39;public&#39;, options))\n\n</code></pre>\n<p>每个应用可有多个静态目录。</p>\n<pre><code class=\"js\">app.use(express.static(&#39;public&#39;))\napp.use(express.static(&#39;uploads&#39;))\napp.use(express.static(&#39;files&#39;))\n\n</code></pre>\n<h3 id=\"5、第三方中间件\"><a href=\"#5、第三方中间件\" class=\"headerlink\" title=\"5、第三方中间件\"></a>5、第三方中间件</h3><p>通过使用第三方中间件从而为 Express 应用增加更多功能。</p>\n<p>安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。</p>\n<p>下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser</p>\n<pre><code>$ npm install cookie-parser\n\n</code></pre><pre><code class=\"js\">var express = require(&#39;express&#39;)\nvar app = express()\nvar cookieParser = require(&#39;cookie-parser&#39;)\n\n// 加载用于解析 cookie 的中间件\napp.use(cookieParser())\n\n</code></pre>\n<h2 id=\"七、在Express中使用模板引擎\"><a href=\"#七、在Express中使用模板引擎\" class=\"headerlink\" title=\"七、在Express中使用模板引擎\"></a>七、在Express中使用模板引擎</h2><p>需要在应用中进行如下设置才能让Express渲染模板文件：</p>\n<ul>\n<li><code>views</code>，放模板文件的目录，比如：<code>app.set(&#39;views&#39;, &#39;./views&#39;)</code></li>\n<li><code>view engine</code>，模板引擎，比如：<code>app.set(&#39;view engine&#39;, &#39;ejs&#39;)</code></li>\n</ul>\n<p><strong>art-template</strong></p>\n<p>art-template for express 4.x.</p>\n<ul>\n<li><p>1、Install</p>\n<pre><code>npm install --save art-template\nnpm install --save express-art-template\n\n</code></pre></li>\n</ul>\n<ul>\n<li><p>2、Example</p>\n<pre><code class=\"js\">var express = require(&#39;express&#39;)\nvar app = express()\n\n// view engine setup\napp.engine(&#39;art&#39;, require(&#39;express-art-template&#39;))\napp.set(&#39;view&#39;, {\n    debug: process.env.NODE_ENV !== &#39;production&#39;\n})\napp.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;))\napp.set(&#39;view engine&#39;, &#39;art&#39;)\n\n// routes\napp.get(&#39;/&#39;, function (req, res) {\n    res.render(&#39;index.art&#39;, {\n        user: {\n            name: &#39;aui&#39;,\n            tags: [&#39;art&#39;, &#39;template&#39;, &#39;nodejs&#39;]\n        }\n    })\n})\n\n</code></pre>\n</li>\n</ul>\n<h1 id=\"03-Koa2\"><a href=\"#03-Koa2\" class=\"headerlink\" title=\"03-Koa2\"></a>03-Koa2</h1><h2 id=\"一、koa2快速开始\"><a href=\"#一、koa2快速开始\" class=\"headerlink\" title=\"一、koa2快速开始\"></a>一、koa2快速开始</h2><p>因为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以上node.js环境 版本v7.6以上 npm 版本3.x以上</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"01-Node-js基础\"><a href=\"#01-Node-js基础\" class=\"headerlink\" title=\"01-Node.js基础\"></a>01-Node.js基础</h1><h2 id=\"一、Node-js是什么\"><a href=\"#一、Node-js是什么\" class=\"headerlink\" title=\"一、Node.js是什么\"></a>一、Node.js是什么</h2><p>Node.js is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine.</p>\n<h3 id=\"1、-特性\"><a href=\"#1、-特性\" class=\"headerlink\" title=\"1、 特性\"></a>1、 特性</h3><p>Node.js可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：</p>\n<ul>\n<li>文件的读写（File System）</li>\n<li>进程的管理（Process）</li>\n<li>网络通信（HTTP/HTTPS）</li>\n</ul>\n<h3 id=\"2、举例\"><a href=\"#2、举例\" class=\"headerlink\" title=\"2、举例\"></a>2、举例</h3><h4 id=\"2-1-浏览器安全级别的限制\"><a href=\"#2-1-浏览器安全级别的限制\" class=\"headerlink\" title=\"2.1 浏览器安全级别的限制\"></a>2.1 浏览器安全级别的限制</h4><h5 id=\"Ajax限制\"><a href=\"#Ajax限制\" class=\"headerlink\" title=\"Ajax限制\"></a>Ajax限制</h5><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;browser-safe-sandbox&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div&gt;browser-safe-sandbox&lt;/div&gt;\n  &lt;script&gt;\n    const xhr = new XMLHttpRequest()\n    xhr.open(&#39;get&#39;, &#39;https://m.maoyan.com/ajax/moreClassicList?sortId=1&amp;showType=3&amp;limit=10&amp;offset=30&amp;optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&amp;optimus_risk_level=71&amp;optimus_code=10&#39;, false)\n    xhr.send()\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h5 id=\"浏览器预览\"><a href=\"#浏览器预览\" class=\"headerlink\" title=\"浏览器预览\"></a>浏览器预览</h5><pre><code>browser-sync start --server --files **/* --directory\n</code></pre><h4 id=\"2-2-文件的读写（File-System）\"><a href=\"#2-2-文件的读写（File-System）\" class=\"headerlink\" title=\"2.2 文件的读写（File System）\"></a>2.2 文件的读写（File System）</h4><pre><code class=\"javascript\">const fs = require(&#39;fs&#39;)\n\nfs.readFile(&#39;./ajax.png&#39;, &#39;utf-8&#39;, (err, content) =&gt; {\n  console.log(content)\n})\n</code></pre>\n<h4 id=\"2-3-进程的管理（Process）\"><a href=\"#2-3-进程的管理（Process）\" class=\"headerlink\" title=\"2.3 进程的管理（Process）\"></a>2.3 进程的管理（Process）</h4><pre><code class=\"javascript\">function main(argv) {\n  console.log(argv)\n}\n\nmain(process.argv.slice(2))\n</code></pre>\n<blockquote>\n<p>运行</p>\n</blockquote>\n<pre><code>node 2.3-process.js argv1 argv2\n</code></pre><h4 id=\"2-4-网络通信（HTTP-HTTPS）\"><a href=\"#2-4-网络通信（HTTP-HTTPS）\" class=\"headerlink\" title=\"2.4 网络通信（HTTP/HTTPS）\"></a>2.4 网络通信（HTTP/HTTPS）</h4><pre><code class=\"javascript\">const http = require(&quot;http&quot;)\n\nhttp.createServer((req,res) =&gt; {\n  res.writeHead(200, {\n    &quot;content-type&quot;: &quot;text/plain&quot;\n  })\n  res.write(&quot;hello nodejs&quot;)\n  res.end()\n}).listen(3000)\n</code></pre>\n<h2 id=\"二、Node相关工具\"><a href=\"#二、Node相关工具\" class=\"headerlink\" title=\"二、Node相关工具\"></a>二、Node相关工具</h2><h3 id=\"1、NVM：Node-Version-Manager\"><a href=\"#1、NVM：Node-Version-Manager\" class=\"headerlink\" title=\"1、NVM：Node Version Manager\"></a>1、NVM：Node Version Manager</h3><h4 id=\"1-1-Mac安装nvm\"><a href=\"#1-1-Mac安装nvm\" class=\"headerlink\" title=\"1.1 Mac安装nvm\"></a>1.1 Mac安装nvm</h4><pre><code>https://github.com/nvm-sh/nvm/blob/master/README.md\n</code></pre><h4 id=\"1-2-Windows安装nvm\"><a href=\"#1-2-Windows安装nvm\" class=\"headerlink\" title=\"1.2 Windows安装nvm\"></a>1.2 Windows安装nvm</h4><pre><code>nvm-windows\nnodist\n</code></pre><h4 id=\"1-3-常用的nvm命令\"><a href=\"#1-3-常用的nvm命令\" class=\"headerlink\" title=\"1.3 常用的nvm命令\"></a>1.3 常用的nvm命令</h4><ul>\n<li><code>nvm list</code>：查看当前环境安装了哪些版本</li>\n<li><code>nvm use 14.15.0</code>：切换node版本</li>\n<li><code>nvm alias default (v)14.15.0</code>：切换node默认版本</li>\n</ul>\n<h3 id=\"2、NPM：Node-Package-Manager\"><a href=\"#2、NPM：Node-Package-Manager\" class=\"headerlink\" title=\"2、NPM：Node Package Manager\"></a>2、NPM：Node Package Manager</h3><ul>\n<li><code>npm view jquery versions</code>：查看包的所有版本</li>\n</ul>\n<h4 id=\"2-1-全局安装package\"><a href=\"#2-1-全局安装package\" class=\"headerlink\" title=\"2.1 全局安装package\"></a>2.1 全局安装package</h4><pre><code>$ npm install forever --global (-g)\n$ forever\n$ npm uninstall forever --global\n$ forever\n\n</code></pre><blockquote>\n<p>全局安装包的目录</p>\n</blockquote>\n<ul>\n<li><p>Mac</p>\n<pre><code>/Users/felix/.nvm/versions/node/nvm各个版本/bin/\n\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Windows</p>\n<pre><code>C:\\Users\\你的用户名\\AppData\\Roaming\\npm\\node_modules\n\n</code></pre></li>\n</ul>\n<h4 id=\"2-2-本地安装package\"><a href=\"#2-2-本地安装package\" class=\"headerlink\" title=\"2.2 本地安装package\"></a>2.2 本地安装package</h4><pre><code>$ cd ~/desktop\n$ mkdir gp-project\n$ cd gp-project\n$ npm install underscore\n$ npm list (ls)\n\n</code></pre><h4 id=\"2-3-package-json初始化\"><a href=\"#2-3-package-json初始化\" class=\"headerlink\" title=\"2.3 package.json初始化\"></a>2.3 package.json初始化</h4><pre><code>$ pwd\n$ npm init -y\n$ ls\n$ cat package.json\n\n</code></pre><h4 id=\"2-4-使用package-json\"><a href=\"#2-4-使用package-json\" class=\"headerlink\" title=\"2.4 使用package.json\"></a>2.4 使用package.json</h4><ul>\n<li><code>npm install —production</code>：只拉取生产环境的包</li>\n</ul>\n<pre><code>$ npm install underscore --save\n$ cat package.json\n$ npm install lodash --save-dev\n$ cat package.json\n$ rm -rf node_modules\n$ ls\n$ npm install\n$ npm uninstall underscore --save\n$ npm list | grep underscore  // 查看underscore包的树(依赖关系)\n$ cat package.json\n\n</code></pre><blockquote>\n<p>&quot;dependencies&quot;：这些包是你的应用程序在生产环境中所需要的。</p>\n<p>&quot;devDepedencies&quot;：这些包只是在开发和测试中需要的。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdn.net/2018071517553381?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p3bF93aWxsb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"npm\"></p>\n<pre><code>// package.json\n{\n...\n&quot;dependencies&quot;: { // --save / -S\n},\n&quot;devDependencies&quot;: { // --save-dev / -D\n}\n\n}\n\n</code></pre><h4 id=\"2-5-安装指定版本的包\"><a href=\"#2-5-安装指定版本的包\" class=\"headerlink\" title=\"2.5 安装指定版本的包\"></a>2.5 安装指定版本的包</h4><ul>\n<li><code>npm install jquery@2.2.4</code>： 安装指定版本</li>\n<li><code>npm install jquery@1 -S</code>：安装1最高的版本</li>\n</ul>\n<pre><code>$ pwd\n$ npm list\n$ npm info underscore\n$ npm view underscore versions\n$ npm install underscore@1.8.0\n$ npm list\n$ npm uninstall underscore\n$ npm list\n\n</code></pre><h4 id=\"2-6-更新本地安装的包\"><a href=\"#2-6-更新本地安装的包\" class=\"headerlink\" title=\"2.6 更新本地安装的包\"></a>2.6 更新本地安装的包</h4><blockquote>\n<p>-13.4.6</p>\n<p>major: 13（主版本号）,minor: 4（次版本号），patch：6（补丁，单数不稳定，双数稳定）</p>\n</blockquote>\n<ul>\n<li><code>npm outdated</code>：查看哪些包过期</li>\n<li><code>npm update</code>：更新所有的包</li>\n</ul>\n<pre><code>$ npm info underscore\n$ npm view underscore versions // 查看underscore包所有的版本\n$ npm install underscore@1.4.4 --save-dev // 安装1.4.4的underscore到开发环境 \n$ npm list | grep gulp // 查看gulp包的依赖关系\n$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本\n$ npm list | grep gulp\n$ npm update\n\n</code></pre><pre><code class=\"json\">{\n    &quot;dependencies&quot;: {\n        &quot;jquery&quot;: &quot;^1.12.4&quot;, // ^锁定主版本号\n        &quot;jquery&quot;: &quot;~1.12.4&quot;, // ~锁定主版本号和次版本号\n        jquery: &quot;1.12.4&quot;, // 全部锁定\n        jquery: &quot;*&quot; // 最新版本\n    }\n}\n\n</code></pre>\n<h4 id=\"2-7-清除缓存\"><a href=\"#2-7-清除缓存\" class=\"headerlink\" title=\"2.7 清除缓存\"></a>2.7 清除缓存</h4><ul>\n<li><code>npm cache clean --force</code></li>\n</ul>\n<h4 id=\"2-8-上传自己的包\"><a href=\"#2-8-上传自己的包\" class=\"headerlink\" title=\"2.8 上传自己的包\"></a>2.8 上传自己的包</h4><h5 id=\"2-8-1-编写模块\"><a href=\"#2-8-1-编写模块\" class=\"headerlink\" title=\"2.8.1 编写模块\"></a>2.8.1 编写模块</h5><p>保存为index.js</p>\n<pre><code class=\"javascript\">exports.sayHello = function(){ \n  return &#39;Hello World&#39;; \n}\n\n</code></pre>\n<h5 id=\"2-8-2-初始化描述文件\"><a href=\"#2-8-2-初始化描述文件\" class=\"headerlink\" title=\"2.8.2 初始化描述文件\"></a>2.8.2 初始化描述文件</h5><ul>\n<li>npm init package.json</li>\n</ul>\n<pre><code class=\"json\">{ \n  &quot;name&quot;: &quot;gp19-npm&quot;, \n  &quot;version&quot;: &quot;1.0.1&quot;, \n  &quot;description&quot;: &quot;gp19 self module&quot;, \n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: { \n    &quot;test&quot;: &quot;make test&quot; \n  }, \n  &quot;repository&quot;: { \n    &quot;type&quot;: &quot;Git&quot;, \n    &quot;url&quot;: &quot;git+https://github.com/lurongtao/gp19-npm.git&quot; \n  }, \n  &quot;keywords&quot;: [ \n    &quot;demo&quot; \n  ], \n  &quot;author&quot;: &quot;Felixlu&quot;, \n  &quot;license&quot;: &quot;ISC&quot;, \n  &quot;bugs&quot;: { \n    &quot;url&quot;: &quot;https://github.com/lurongtao/gp19-npm/issues&quot; \n  }, \n  &quot;homepage&quot;: &quot;https://github.com/lurongtao/gp19-npm#readme&quot;, \n}\n\n</code></pre>\n<h5 id=\"2-8-3-注册npm仓库账号\"><a href=\"#2-8-3-注册npm仓库账号\" class=\"headerlink\" title=\"2.8.3 注册npm仓库账号\"></a>2.8.3 注册npm仓库账号</h5><ul>\n<li>npm adduser</li>\n</ul>\n<pre><code>https://www.npmjs.com 上面的账号\nfelix_lurt/qqmko09ijn\n$ npm adduser\n\n</code></pre><h5 id=\"2-8-4-上传包\"><a href=\"#2-8-4-上传包\" class=\"headerlink\" title=\"2.8.4 上传包\"></a>2.8.4 上传包</h5><ul>\n<li>npm publish</li>\n</ul>\n<p>坑：403 Forbidden</p>\n<pre><code>查看npm源：npm config get registry\n切换npm源方法一：npm config set registry http://registry.npmjs.org\n切换npm源方法二：nrm use npm\n\n</code></pre><h5 id=\"2-8-5-安装包\"><a href=\"#2-8-5-安装包\" class=\"headerlink\" title=\"2.8.5 安装包\"></a>2.8.5 安装包</h5><ul>\n<li>npm install gp19-npm</li>\n</ul>\n<h5 id=\"2-8-6-卸载包\"><a href=\"#2-8-6-卸载包\" class=\"headerlink\" title=\"2.8.6 卸载包\"></a>2.8.6 卸载包</h5><pre><code>查看当前项目引用了哪些包 ：\nnpm ls\n卸载包：\nnpm unpublish --force\n\n</code></pre><h5 id=\"2-8-7-使用引入包\"><a href=\"#2-8-7-使用引入包\" class=\"headerlink\" title=\"2.8.7 使用引入包\"></a>2.8.7 使用引入包</h5><pre><code>var hello = require(&#39;gp19-npm&#39;)\nhello.sayHello()\n\n</code></pre><h4 id=\"2-9-npm脚本\"><a href=\"#2-9-npm脚本\" class=\"headerlink\" title=\"2.9 npm脚本\"></a>2.9 npm脚本</h4><p>Node开发离不开npm，而脚本功能是npm最强大、最常用的功能之一。</p>\n<h5 id=\"2-9-1-什么是npm脚本？\"><a href=\"#2-9-1-什么是npm脚本？\" class=\"headerlink\" title=\"2.9.1 什么是npm脚本？\"></a>2.9.1 什么是npm脚本？</h5><p>npm允许在package.json文件里面，使用scripts字段定义脚本命令。</p>\n<pre><code class=\"json\">{\n    // ...\n    &quot;scripts&quot;: {\n        &quot;builds&quot;: &quot;node build.js&quot;\n    }\n}\n\n</code></pre>\n<h5 id=\"2-9-2-执行顺序\"><a href=\"#2-9-2-执行顺序\" class=\"headerlink\" title=\"2.9.2 执行顺序\"></a>2.9.2 执行顺序</h5><p>如果npm脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p>\n<blockquote>\n<p>scripts1.js</p>\n</blockquote>\n<pre><code class=\"js\">var x = 0\nconsole.log(x)\n\n</code></pre>\n<blockquote>\n<p>scripts2.js</p>\n</blockquote>\n<pre><code class=\"js\">var y = 0\nconsole.log(y)\n\n</code></pre>\n<pre><code class=\"json\">&quot;scripts&quot; : {\n    &quot;script1&quot;: &quot;node script1.js&quot;,\n    &quot;script2&quot;: &quot;ndoe script2.js&quot;\n}\n\n</code></pre>\n<p>如果是并行执行（即同时的平行执行），可以使用<code>&amp;</code>符号。</p>\n<pre><code>$ npm run script1 &amp; npm run script2\n\n</code></pre><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&amp;&amp;</code>符号。</p>\n<pre><code>$ npm run script1 &amp;&amp; npm run script2\n\n</code></pre><h5 id=\"2-9-3-简写形式\"><a href=\"#2-9-3-简写形式\" class=\"headerlink\" title=\"2.9.3 简写形式\"></a>2.9.3 简写形式</h5><p>常用的npm脚本简写形式</p>\n<pre><code>npm start 是 npm run start\n\n</code></pre><h5 id=\"2-9-4-变量\"><a href=\"#2-9-4-变量\" class=\"headerlink\" title=\"2.9.4 变量\"></a>2.9.4 变量</h5><p>npm脚本有一个非常强大功能，就是可以使用npm的内部变量。</p>\n<p>首先，通过<code>npm _package_</code>前缀，npm脚本可以拿到package.json里面的字段。比如，下面是一个package.json。</p>\n<blockquote>\n<p>注意：一定要在npm脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到的</p>\n</blockquote>\n<pre><code class=\"json\">{\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;version&quot;: &quot;1.2.5&quot;,\n    &quot;scripts&quot;: {\n        &quot;view&quot;: &quot;node view.js&quot;\n    }\n}\n\n</code></pre>\n<p>那么，变量<code>npm_package_name</code>返回foo，变量<code>npm_package_version</code>返回1.2.5。</p>\n<pre><code class=\"js\">// view.js\nconsole.log(process.env.npm_package_name); // foo\nconsole.log(process.env.npm_package_version); // 1.2.5\n\n</code></pre>\n<p>上面代码中，我们通过环境变量<code>process.env</code>对象，拿到<code>package.json</code>的字段值。如果是Bash脚本，可以用<code>$npm_package_name</code>和 <code>$npm_package_version</code>取到这两个值。</p>\n<p>npmpackage前缀也支持嵌套的package.json字段。</p>\n<pre><code class=\"json\">&quot;repository&quot;: {\n    &quot;type&quot;: &#39;git&#39;,\n    &quot;url&quot;: &quot;xxx&quot;\n},\n&quot;scripts&quot;: {\n    &quot;view&quot;: &quot;echo $npm_package_repository_type&quot;\n}\n\n</code></pre>\n<p>上面代码中，repository字段的type属性，可以通过<code>npm_package_repository_type</code>取到。</p>\n<p>下面是另外一个例子。</p>\n<pre><code class=\"json\">&quot;scripts&quot;: {\n    &quot;install&quot;: &quot;foo.js&quot;\n}\n\n</code></pre>\n<p>上面代码中，<code>npm_package_scripts_install</code>变量的值等于foo.js。</p>\n<p>然后，npm脚本还可以通过<code>npmconfig</code>前缀，拿到npm的配置变量，即<code>npm config get xxx</code>命令返回的值。比如，当前模块的发型标签，可以通过<code>npm_config_tag</code>取到。</p>\n<pre><code class=\"json\">&quot;view&quot;: &quot;echo $npm_config_tag&quot;,\n\n</code></pre>\n<p>注意，package.json里面的config对象，可以被环境变量覆盖。</p>\n<pre><code class=\"json\">{\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;config&quot;: {&quot;port&quot;: &quot;8080&quot;},\n    &quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;}\n}\n\n</code></pre>\n<p>上面代码中，<code>npm_package_config_port</code>变量返回的是8080。这个值可以用下面的方法覆盖。</p>\n<pre><code>$ npm config set foo:port 80\n\n</code></pre><p>最后，env命令可以列出所有环境变量。</p>\n<p>&quot;env&quot;:&quot;env&quot; </p>\n<h4 id=\"2-10-npm安装git上发布的包\"><a href=\"#2-10-npm安装git上发布的包\" class=\"headerlink\" title=\"2.10 npm安装git上发布的包\"></a>2.10 npm安装git上发布的包</h4><pre><code># 这样适合安装公司内部的git服务器上的项目\nnpm install git+https://git@github.com:lurongtao/gp-project.git\n\n# 或者以ssh的方式\nnpm install git+ssh://git@github.com:lurongtao/gp-project.git\n\n</code></pre><h4 id=\"2-11-cross-env使用\"><a href=\"#2-11-cross-env使用\" class=\"headerlink\" title=\"2.11 cross-env使用\"></a>2.11 cross-env使用</h4><h5 id=\"2-11-1-cross-env是什么\"><a href=\"#2-11-1-cross-env是什么\" class=\"headerlink\" title=\"2.11.1 cross-env是什么\"></a>2.11.1 cross-env是什么</h5><p>运行跨平台设置和使用环境变量的脚本</p>\n<h5 id=\"2-11-2-出现原因\"><a href=\"#2-11-2-出现原因\" class=\"headerlink\" title=\"2.11.2 出现原因\"></a>2.11.2 出现原因</h5><p>当您使用<code>NODE_ENV=production</code>，来设置环境变量时，大多数Windows命令提示将会阻塞（报错）。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows不支持<code>NOE_ENV=production</code>的设置方式。</p>\n<h5 id=\"2-11-3-解决\"><a href=\"#2-11-3-解决\" class=\"headerlink\" title=\"2.11.3 解决\"></a>2.11.3 解决</h5><p>cross-env使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包（cross-env）能够提供一个设置环境变量的scripts，让你能够以Unix方式设置环境变量，然后在Windows上也能兼容运行。</p>\n<h5 id=\"2-11-4-安装\"><a href=\"#2-11-4-安装\" class=\"headerlink\" title=\"2.11.4 安装\"></a>2.11.4 安装</h5><pre><code>npm install --save-dev cross-env\n\n</code></pre><h5 id=\"2-11-5-使用\"><a href=\"#2-11-5-使用\" class=\"headerlink\" title=\"2.11.5 使用\"></a>2.11.5 使用</h5><pre><code class=\"json\">{\n    &quot;scripts&quot;: {\n        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;\n    }\n}\n\n</code></pre>\n<p><code>NODE_ENV</code>环境变量将由<code>cross-env</code>设置，打印<code>process.env.NODE_ENV === &#39;production&#39;</code></p>\n<h3 id=\"3、NRM：npm-registry-manager\"><a href=\"#3、NRM：npm-registry-manager\" class=\"headerlink\" title=\"3、NRM：npm registry manager\"></a>3、NRM：npm registry manager</h3><h4 id=\"3-1-手工切换源\"><a href=\"#3-1-手工切换源\" class=\"headerlink\" title=\"3.1 手工切换源\"></a>3.1 手工切换源</h4><h5 id=\"3-1-1-查看当前源\"><a href=\"#3-1-1-查看当前源\" class=\"headerlink\" title=\"3.1.1 查看当前源\"></a>3.1.1 查看当前源</h5><pre><code>npm config get registry\n\n</code></pre><h5 id=\"3-1-2-切换淘宝源\"><a href=\"#3-1-2-切换淘宝源\" class=\"headerlink\" title=\"3.1.2 切换淘宝源\"></a>3.1.2 切换淘宝源</h5><pre><code>npm config set registry https://registry.npm.taobao.org\n\n</code></pre><h4 id=\"3-2-NRM管理源\"><a href=\"#3-2-NRM管理源\" class=\"headerlink\" title=\"3.2 NRM管理源\"></a>3.2 NRM管理源</h4><p>NRM是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在npm源间切换。</p>\n<h5 id=\"3-2-1-安装nrm\"><a href=\"#3-2-1-安装nrm\" class=\"headerlink\" title=\"3.2.1 安装nrm\"></a>3.2.1 安装nrm</h5><p>在命令行执行命令，<code>npm install -g nrm</code>，全局安装nrm。</p>\n<h5 id=\"3-2-2-使用nrm\"><a href=\"#3-2-2-使用nrm\" class=\"headerlink\" title=\"3.2.2 使用nrm\"></a>3.2.2 使用nrm</h5><p>执行命令<code>nrm ls</code>查看可选的源。其中，带<code>*</code>的是当前使用的源，上面输出表明当前源是官方源。</p>\n<h5 id=\"3-2-3-切换nrm\"><a href=\"#3-2-3-切换nrm\" class=\"headerlink\" title=\"3.2.3 切换nrm\"></a>3.2.3 切换nrm</h5><p>如果要切换到taobao源，执行命令<code>nrm use taobao</code>。</p>\n<h5 id=\"3-2-4-测试速度\"><a href=\"#3-2-4-测试速度\" class=\"headerlink\" title=\"3.2.4 测试速度\"></a>3.2.4 测试速度</h5><p>你还可以通过<code>nrm test</code>测试相应源的响应时间。</p>\n<h3 id=\"4、-NPX：npm-package-extention\"><a href=\"#4、-NPX：npm-package-extention\" class=\"headerlink\" title=\"4、 NPX：npm package extention\"></a>4、 NPX：npm package extention</h3><p>npm从5.2版开始，增加了npx命令。它有很多用处，本文介绍该命令的主要使用场景。</p>\n<p>Node自带npm模块，所以可以直接使用npx命令。万一不能用，就要手动安装一下。</p>\n<pre><code>$ npm install -g npx\n\n</code></pre><h4 id=\"4-1-调用项目安装的模块\"><a href=\"#4-1-调用项目安装的模块\" class=\"headerlink\" title=\"4.1 调用项目安装的模块\"></a>4.1 调用项目安装的模块</h4><p>npx想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。</p>\n<pre><code>$ npm install -D mocha\n\n</code></pre><p>一般来说，调用Mocha，只能在项目脚本和package.json的scripts字段里面，如果想在命令行下调用，必须像下面这样。</p>\n<pre><code># 项目的根目录下执行\n$ node-modules/.bin/mocha --version\n\n</code></pre><p>npx就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p>\n<pre><code>$ npx mocha --version\n\n</code></pre><p>npx的原理很简单，就是运行的时候，会倒<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p>\n<p>由于npx会检查环境变量$PATH，所以系统命令也可以调用。</p>\n<pre><code># 等同于 ls\n$ npx ls\n\n</code></pre><p>注意，Bash内置的命令不在$PATH里面，所以不能用。比如cd 是Bash命令，因此就不能用npx cd。</p>\n<h4 id=\"4-2-避免全局安装模块\"><a href=\"#4-2-避免全局安装模块\" class=\"headerlink\" title=\"4.2 避免全局安装模块\"></a>4.2 避免全局安装模块</h4><p>除了调用项目内部模块，npx还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx可以运行它，而且不进行全局安装。</p>\n<pre><code>$ npx create-react-app my-react-app\n\n</code></pre><p>上面代码运行时，npx将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。</p>\n<p>注意，只要npx后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个Web服务。</p>\n<pre><code>$ npx http-server\n\n</code></pre><h4 id=\"4-3-no-install参数和-ignore-existing参数\"><a href=\"#4-3-no-install参数和-ignore-existing参数\" class=\"headerlink\" title=\"4.3 --no--install参数和--ignore-existing参数\"></a>4.3 --no--install参数和--ignore-existing参数</h4><p>如果想让npx强制使用本地模块，不下载远程模块，可以使用--no-install参数。如果本地不存在该模块，就会报错。</p>\n<pre><code>$ npx --no-install http-server\n\n</code></pre><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用--ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。</p>\n<pre><code>$ npx --ignore-existing http-server\n\n</code></pre><h3 id=\"5、node的浏览端调试\"><a href=\"#5、node的浏览端调试\" class=\"headerlink\" title=\"5、node的浏览端调试\"></a>5、node的浏览端调试</h3><ul>\n<li><code>node --inspect --inspect-brk server.js</code></li>\n</ul>\n<h3 id=\"6、node进程管理工具\"><a href=\"#6、node进程管理工具\" class=\"headerlink\" title=\"6、node进程管理工具\"></a>6、node进程管理工具</h3><ul>\n<li><p>supervisor</p>\n</li>\n<li><p>nodemon</p>\n<pre><code>npm install nodemon\nnodemon server.js\n\n</code></pre></li>\n</ul>\n<ul>\n<li><p>forever</p>\n</li>\n<li><p>pm2</p>\n</li>\n</ul>\n<h2 id=\"三、模块-包与CommonJS\"><a href=\"#三、模块-包与CommonJS\" class=\"headerlink\" title=\"三、模块/包与CommonJS\"></a>三、模块/包与CommonJS</h2><h3 id=\"1、模块-包分类\"><a href=\"#1、模块-包分类\" class=\"headerlink\" title=\"1、模块/包分类\"></a>1、模块/包分类</h3><p>Node.js有三类模块，即内置的模块、第三方的模块、自定义的模块。</p>\n<h4 id=\"1-1-内置的模块\"><a href=\"#1-1-内置的模块\" class=\"headerlink\" title=\"1.1 内置的模块\"></a>1.1 内置的模块</h4><p>Node.js内置模块又叫核心模块，Node.js安装完成可直接使用。如：</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;)\nvar extname = path.extname(&#39;index.html&#39;)\nconsole.log(extname)\n\n</code></pre>\n<h4 id=\"1-2-第三方的Node-js模块\"><a href=\"#1-2-第三方的Node-js模块\" class=\"headerlink\" title=\"1.2 第三方的Node.js模块\"></a>1.2 第三方的Node.js模块</h4><p>第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如：</p>\n<pre><code>npm install chalk\n\n</code></pre><pre><code class=\"js\">const chalk = require(&#39;chalk&#39;)\nconsole.log(chalk.blue(&#39;Hello world!&#39;))\n\n</code></pre>\n<h4 id=\"1-3-自定义的Node-js模块\"><a href=\"#1-3-自定义的Node-js模块\" class=\"headerlink\" title=\"1.3 自定义的Node.js模块\"></a>1.3 自定义的Node.js模块</h4><p>自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。</p>\n<p>自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。</p>\n<h5 id=\"1-3-1-模块定义、接口暴露和引用接口\"><a href=\"#1-3-1-模块定义、接口暴露和引用接口\" class=\"headerlink\" title=\"1.3.1 模块定义、接口暴露和引用接口\"></a>1.3.1 模块定义、接口暴露和引用接口</h5><p>我们可以把公共的功能抽离成为一个单独的js文件作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过<code>exports</code>或者<code>module.exports</code>暴露属性或者方法。</p>\n<blockquote>\n<p>m1.js</p>\n</blockquote>\n<pre><code class=\"js\">const name = &#39;gp19&#39;\n\nconst sayName = () =&gt; {\n    console.log(name)\n}\n\nconsole.log(&#39;module 1&#39;)\n\n// 接口暴露方法一：\nmodule.exports = {\n    say: sayName\n}\n\n// 接口暴露方法二：\nexports.say = sayName\n\n// 错误！\nexports = {\n    say: sayName\n}\n\n</code></pre>\n<blockquote>\n<p>main.js</p>\n</blockquote>\n<pre><code class=\"js\">const m1 = require(&#39;./m1&#39;)\nm1.say()\n\n</code></pre>\n<h5 id=\"1-3-2-模块的循环引用\"><a href=\"#1-3-2-模块的循环引用\" class=\"headerlink\" title=\"1.3.2 模块的循环引用\"></a>1.3.2 模块的循环引用</h5><p>由于exports使用方式不对，会在两个不同js循环引用的情况下，导致其中一个js无法获取另外一个js的方法，从而导致执行报错。如：</p>\n<ul>\n<li>a.js</li>\n</ul>\n<pre><code class=\"js\">exports.done = false\nconst b = require(&#39;./b.js&#39;)\nconsole.log(&#39;in a, b.done = %j&#39;, b.done)\nexports.done = true\nconsole.log(&#39;a done&#39;)\n\n</code></pre>\n<ul>\n<li>b.js</li>\n</ul>\n<pre><code class=\"js\">console.log(&#39;b starting&#39;)\nexports.done = false\nconst a = require(&#39;./a.js&#39;)\nconsole.log(&#39;in b, a.done= %j&#39;, a.done)\nexports.done = true\nconsole.log(&#39;b done&#39;)\n\n</code></pre>\n<ul>\n<li>main.js</li>\n</ul>\n<pre><code class=\"js\">console.log(&#39;main starting&#39;)\nconst a = require(&#39;./a.js&#39;)\nconst b = require(&#39;./b.js&#39;)\nconsole.log(&#39;in main, a.done = %j, b.done = %j&#39;, a.done, b.done)\n\n</code></pre>\n<p><code>main.js</code>首先会load <code>a.js</code>，此时执行到<code>const b = require(&#39;./b.js&#39;);</code>的时候，程序会转去load<code>b.js</code>, 在<code>b.js</code>中执行到<code>const a = require(&#39;./a.js&#39;);</code> 为了防止无限循环，将<code>a.js</code>exports的未完成副本返回到<code>b.js</code>模块。然后<code>b.js</code>完成加载，并将其导出对象提供给<code>a.js</code>模块。</p>\n<p>我们知道nodeJs的对每个js文件进行了一层包装称为<code>module</code>，<code>module</code>中有一个属性<code>exports</code>，当调用<code>require(&#39;a.js&#39;)</code>的时候其实返回的是<code>module.exports</code>对象，<code>module.exports</code>初始化为一个<code>{}</code>空的object，所以在上面的例子中，执行到<code>b.js</code>中<code>const a = require(&#39;./a.js&#39;);</code>时不会load新的<code>a module</code>, 而是将已经load但是还未完成的<code>a module</code>的<code>exports</code>属性返回给<code>b module</code>，所以<code>b.js</code>拿到的是<code>a module</code>的<code>exports</code>对象，即：<code>{done:false}</code>, 虽然在<code>a.js</code>中<code>exports.done</code>被修改成了<code>true</code>，但是由于此时<code>a.js</code>未<code>load</code>完成，所以在<code>b.js</code>输出的<code>a module</code>的属性<code>done</code>为<code>false</code>，而在<code>main.js</code>中输出的<code>a module</code>的属性<code>done</code>为<code>true</code>. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。</p>\n<h2 id=\"四、常用内置模块\"><a href=\"#四、常用内置模块\" class=\"headerlink\" title=\"四、常用内置模块\"></a>四、常用内置模块</h2><p>这里介绍几个常用的内置模块：url，querystring，http，events，fs，stream，readline，crypto，zlib</p>\n<h3 id=\"1、url\"><a href=\"#1、url\" class=\"headerlink\" title=\"1、url\"></a>1、url</h3><h4 id=\"1-1-parse\"><a href=\"#1-1-parse\" class=\"headerlink\" title=\"1.1 parse\"></a>1.1 parse</h4><blockquote>\n<p>要解析的内容，是否查询字符串</p>\n</blockquote>\n<p><code>url.parse(urlString[,parseQueryString[,slashesDenoteHost]])</code></p>\n<pre><code class=\"js\">const url = require(&#39;url&#39;)\nconst urlString = &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;\nconst parsedStr = url.parse(urlString)\nconsole.log(parsedStr)\n\n=&gt;\n\nUrl {\n  protocol: &#39;https:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;www.baidu.com:443&#39;,\n  port: &#39;443&#39;,\n  hostname: &#39;www.baidu.com&#39;,\n  hash: &#39;#tag=110&#39;,\n  search: &#39;?id=8&amp;name=mouse&#39;,\n  query: [Object: null prototype] { id: &#39;8&#39;, name: &#39;mouse&#39; },\n  pathname: &#39;/ad/index.html&#39;,\n  path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;,\n  href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;\n}\n\n</code></pre>\n<h4 id=\"1-2-format\"><a href=\"#1-2-format\" class=\"headerlink\" title=\"1.2 format\"></a>1.2 format</h4><blockquote>\n<p>将一个解析后的URL对象、转成、一个格式化的URL字符串。</p>\n</blockquote>\n<p><code>url.format(urlObject)</code></p>\n<pre><code class=\"js\">const url = require(&#39;url&#39;)\nconst urlObject = {\n  protocol: &#39;https:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;www.baidu.com:443&#39;,\n  port: &#39;443&#39;,\n  hostname: &#39;www.baidu.com&#39;,\n  hash: &#39;#tag=110&#39;,\n  search: &#39;?id=8&amp;name=mouse&#39;,\n  query: { id: &#39;8&#39;, name: &#39;mouse&#39; },\n  pathname: &#39;/ad/index.html&#39;,\n  path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;,\n  href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;\n}\nconst parsedObj = url.format(urlObject)\nconsole.log(parsedObj)\n\n=&gt; \n&#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39;\n\n</code></pre>\n<h4 id=\"1-3-resolve\"><a href=\"#1-3-resolve\" class=\"headerlink\" title=\"1.3 resolve\"></a>1.3 resolve</h4><blockquote>\n<p>用于拼接URL（替换 域名后面第一个<code>/</code>后的内容,如果出现<code>.</code>就向上返回一级之后再拼接，两个<code>..</code>就向上反两级再拼接）</p>\n</blockquote>\n<p><code>url.resolve(from, to)</code></p>\n<pre><code>const url = require(&#39;url&#39;)\nvar a = url.resolve(&#39;/one/two/three&#39;, &#39;four&#39;) \nvar b = url.resolve(&#39;http://example.com/&#39;, &#39;/one&#39;)\nvar c = url.resolve(&#39;http://example.com/one&#39;, &#39;/two&#39;);\nvar d = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;./two&#39;);\nvar e = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;../two&#39;);\nvar f = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;.../two&#39;);\nconsole.log(a +&quot;,&quot;+ b +&quot;,&quot;+ c+&#39;,&#39;+d+&#39;,&#39;+e+&#39;,&#39;+f);\n\n=&gt;\n/one/two/four,\nhttp://example.com/one,\nhttp://example.com/two,\nhttp://example.com/one/ddd/ddd/two,\nhttp://example.com/one/ddd/two\nhttp://example.com/one/ddd/ddd/.../two\n\n</code></pre><h3 id=\"2、querystring\"><a href=\"#2、querystring\" class=\"headerlink\" title=\"2、querystring\"></a>2、querystring</h3><h4 id=\"2-1-parse\"><a href=\"#2-1-parse\" class=\"headerlink\" title=\"2.1 parse\"></a>2.1 parse</h4><blockquote>\n<p>将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。</p>\n</blockquote>\n<p><code>querystring.parse(str[, sep[, eq[, options]]])</code></p>\n<ul>\n<li><code>str</code>：欲转换的字符串</li>\n<li><code>sep</code>：设置分隔符，默认为<code>&amp;</code></li>\n<li><code>eq</code>：设置赋值符，默认为<code>=</code></li>\n<li><code>[options]</code>maxKeys：可接受字符串的最大长度，默认为1000</li>\n</ul>\n<pre><code class=\"js\">const querystring = require(&#39;querystring&#39;)\nvar qs = &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#39;\nvar parsed = querystring.parse(qs)\nconsole.log(parsed)\n\n=&gt;\n\n{ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }\n\n</code></pre>\n<h4 id=\"2-2-stringify\"><a href=\"#2-2-stringify\" class=\"headerlink\" title=\"2.2 stringify\"></a>2.2 stringify</h4><blockquote>\n<p>将对象转换成字符串，字符串里多个参数将用 ‘&amp;&#39; 分隔，将用 ‘=&#39; 赋值。</p>\n</blockquote>\n<p><code>querystring.stringify(obj[, sep[, eq[, options]]])</code></p>\n<ul>\n<li><code>obj</code>：欲转换的对象</li>\n<li><code>sep</code>：设置分隔符，默认为<code>&amp;</code></li>\n<li><code>eq</code>：设置赋值符，默认为<code>=</code></li>\n</ul>\n<pre><code class=\"js\">const querystring = require(&#39;querystring&#39;)\nvar qo = { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }\nvar parsed = querystring.stringify(qo)\nconsole.log(parsed)\n\n==&gt;\n&#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;\n\n\nconst querystring = require(&#39;querystring&#39;)\nvar qo = {foo: &#39;bar&#39;, baz: &#39;qux&#39;}\nvar parsed =querystring.stringify(qo, &#39;;&#39;, &#39;:&#39;)\nconsole.log(parsed)\n\n==&gt;\n&#39;foo:bar;baz:qux&#39;\n\n</code></pre>\n<h4 id=\"2-3-escape-unescape\"><a href=\"#2-3-escape-unescape\" class=\"headerlink\" title=\"2.3 escape/unescape\"></a>2.3 escape/unescape</h4><blockquote>\n<p>以针对网址查询字符串的特定要求优化的方式对给定的 <code>str</code> 执行网址百分比编码</p>\n<p><code>querystring.escape()</code> 方法被 <code>querystring.stringify()</code> 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 <code>querystring.escape</code> 分配给替代函数来提供替换的百分比编码实现。</p>\n</blockquote>\n<p><code>querystring.escape(str)</code></p>\n<pre><code class=\"js\">const querystring = require(&#39;querystring&#39;)\nvar str = &#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39;\nvar escaped = querystring.escape(str)\nconsole.log(escaped)\n\n==&gt; &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39;\n\n</code></pre>\n<blockquote>\n<p>在给定的 <code>str</code> 上执行网址百分比编码字符的解码。</p>\n<p><code>querystring.unescape()</code> 方法被 <code>querystring.parse()</code> 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 <code>querystring.unescape</code> 分配给替代函数来提供替代的解码实现。</p>\n<p>默认情况下，<code>querystring.unescape()</code> 方法将尝试使用 JavaScript 内置的 <code>decodeURIComponent()</code> 方法进行解码。 如果失败，则将使用更安全的不会因格式错误的网址而抛出错误的同类方法。</p>\n</blockquote>\n<p><code>querystring.unescape(str)</code></p>\n<pre><code class=\"js\">const querystring = require(&#39;querystring&#39;)\nvar str = &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39;\nvar unescaped = querystring.unescape(str)\nconsole.log(unescaped)\n\n==&gt;\n&#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39;\n\n</code></pre>\n<h3 id=\"3、http-https\"><a href=\"#3、http-https\" class=\"headerlink\" title=\"3、http/https\"></a>3、http/https</h3><h4 id=\"3-1-get\"><a href=\"#3-1-get\" class=\"headerlink\" title=\"3.1 get\"></a>3.1 get</h4><pre><code class=\"js\">var http = require(&#39;http&#39;)\nvar https = require(&#39;https&#39;)\n\n// 1、接口 2、跨域\nconst server = http.createServer((request, response) =&gt; {\n  var url = request.url.substr(1)\n\n  var data = &#39;&#39;\n\n\n  response.writeHeader(200, {\n    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;,\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;\n  })\n\n  //response.write(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;)\n  //response.end()\n  // 或\n  //response.end(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;)\n\n  https.get(`https://m.lagou.com/listmore.json${url}`, (res) =&gt; {\n\n    res.on(&#39;data&#39;, (chunk) =&gt; {\n      data += chunk\n    })\n\n    res.on(&#39;end&#39;, () =&gt; {\n      response.end(JSON.stringify({\n        ret: true,\n        data\n      }))\n    })\n  })\n\n})\n\nserver.listen(8080, () =&gt; {\n  console.log(&#39;localhost:8080&#39;)\n})\n\n</code></pre>\n<h4 id=\"3-2-post-服务器提交（攻击）\"><a href=\"#3-2-post-服务器提交（攻击）\" class=\"headerlink\" title=\"3.2 post:服务器提交（攻击）\"></a>3.2 post:服务器提交（攻击）</h4><pre><code class=\"js\">const https = require(&#39;https&#39;)\nconst querystring = require(&#39;querystring&#39;)\n\nconst postData = querystring.stringify({\n  province: &#39;上海&#39;,\n  city: &#39;上海&#39;,\n  district: &#39;宝山区&#39;,\n  address: &#39;同济支路199号智慧七立方3号楼2-4层&#39;,\n  latitude: 43.0,\n  longitude: 160.0,\n  message: &#39;求购一条小鱼&#39;,\n  contact: &#39;13666666&#39;,\n  type: &#39;sell&#39;,\n  time: 1571217561\n})\n\nconst options = {\n  protocol: &#39;http:&#39;,\n  hostname: &#39;localhost&#39;,\n  method: &#39;POST&#39;,\n  port: 3000,\n  path: &#39;/index.php/trade/add_item&#39;,\n  headers: {\n    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,\n    &#39;Content-Length&#39;: Buffer.byteLength(postData)\n  }\n}\n\nconst server = http.createServer((req, res) =&gt; {\n    const request = http.request(options, result =&gt; {\n\n    })\n    req.write(postData)\n    req.end()\n\n    res.end()\n})\nserver.listen(8080, ()=&gt; {\n    console.log(&#39;localhost:8080&#39;)\n})\n\n//function doPost() {\n//  let data\n\n//  let req = https.request(options, (res) =&gt; {\n//    res.on(&#39;data&#39;, chunk =&gt; data += chunk)\n//    res.on(&#39;end&#39;, () =&gt; {\n//      console.log(data)\n//    })\n//  })\n\n//  req.write(postData)\n//  req.end()\n//}\n\n// setInterval(() =&gt; {\n//   doPost()\n// }, 1000)\n\n</code></pre>\n<h4 id=\"3-3-跨域：JSONP\"><a href=\"#3-3-跨域：JSONP\" class=\"headerlink\" title=\"3.3 跨域：JSONP\"></a>3.3 跨域：JSONP</h4><pre><code class=\"js\">const http = require(&#39;http&#39;)\nconst url = require(&#39;url&#39;)\n\nconst app = http.createServer((req, res) =&gt; {\n  let urlObj = url.parse(req.url, true)\n\n  switch (urlObj.pathname) {\n    case &#39;/api/user&#39;:\n      res.end(`${urlObj.query.cb}({&quot;name&quot;: &quot;gp145&quot;})`)\n      break\n    default:\n      res.end(&#39;404.&#39;)\n      break\n  }\n})\n\napp.listen(8080, () =&gt; {\n  console.log(&#39;localhost:8080&#39;)\n})\n\n</code></pre>\n<h4 id=\"3-4-跨域：CORS\"><a href=\"#3-4-跨域：CORS\" class=\"headerlink\" title=\"3.4 跨域：CORS\"></a>3.4 跨域：CORS</h4><pre><code class=\"js\">const http = require(&#39;http&#39;)\nconst url = require(&#39;url&#39;)\nconst querystring = require(&#39;querystring&#39;)\n\nconst app = http.createServer((req, res) =&gt; {\n  let data = &#39;&#39;\n  let urlObj = url.parse(req.url, true)\n\n  res.writeHead(200, {\n    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;,\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;\n  })\n\n  req.on(&#39;data&#39;, (chunk) =&gt; {\n    data += chunk\n  })\n\n  req.on(&#39;end&#39;, () =&gt; {\n    responseResult(querystring.parse(data))\n  })\n\n  function responseResult(data) {\n    switch (urlObj.pathname) {\n      case &#39;/api/login&#39;:\n        res.end(JSON.stringify({\n          message: data\n        }))\n        break\n      default:\n        res.end(&#39;404.&#39;)\n        break\n    }\n  }\n})\n\napp.listen(8080, () =&gt; {\n  console.log(&#39;localhost:8080&#39;)\n})\n\n</code></pre>\n<h4 id=\"3-5-跨域：middleware-http-proxy-middware\"><a href=\"#3-5-跨域：middleware-http-proxy-middware\" class=\"headerlink\" title=\"3.5 跨域：middleware(http-proxy-middware)\"></a>3.5 跨域：middleware(http-proxy-middware)</h4><pre><code class=\"js\">const http = require(&#39;http&#39;)\nconst proxy = require(&#39;http-proxy-middleware&#39;)\n\nhttp.createServer((req, res) =&gt; {\n  let url = req.url\n\n  res.writeHead(200, {\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;\n  })\n\n  if (/^\\/api/.test(url)) {\n    let apiProxy = proxy(&#39;/api&#39;, { \n      target: &#39;https://m.lagou.com&#39;,\n      changeOrigin: true,\n      pathRewrite: {\n        &#39;^/api&#39;: &#39;&#39;\n      }\n    })\n\n    // http-proy-middleware 在Node.js中使用的方法\n    apiProxy(req, res)\n  } else {\n    switch (url) {\n      case &#39;/index.html&#39;:\n        res.end(&#39;index.html&#39;)\n        break\n      case &#39;/search.html&#39;:\n        res.end(&#39;search.html&#39;)\n        break\n      default:\n        res.end(&#39;[404]page not found.&#39;)\n    }\n  }\n}).listen(8080)\n\n</code></pre>\n<h4 id=\"3-6-爬虫\"><a href=\"#3-6-爬虫\" class=\"headerlink\" title=\"3.6 爬虫\"></a>3.6 爬虫</h4><pre><code class=\"js\">const https = require(&#39;https&#39;)\nconst http = require(&#39;http&#39;)\nconst cheerio = require(&#39;cheerio&#39;)\n\nhttp.createServer((request, response) =&gt; {\n  response.writeHead(200, {\n    &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;\n  })\n\n  const options = {\n    protocol: &#39;https:&#39;,\n    hostname: &#39;maoyan.com&#39;,\n    port: 443,\n    path: &#39;/&#39;,\n    method: &#39;GET&#39;\n  }\n\n  const req = https.request(options, (res) =&gt; {\n    let data = &#39;&#39;\n    res.on(&#39;data&#39;, (chunk) =&gt; {\n      data += chunk\n    })\n\n    res.on(&#39;end&#39;, () =&gt; {\n      filterData(data)\n    })\n  })\n\n  function filterData(data) {\n    let $ = cheerio.load(data)\n    let $movieList = $(&#39;.movie-item&#39;)\n    let movies = []\n    $movieList.each((index, value) =&gt; {\n      movies.push({\n        title: $(value).find(&#39;.movie-title&#39;).attr(&#39;title&#39;),\n        score: $(value).find(&#39;.movie-score i&#39;).text(),\n      })\n    })\n\n    response.end(JSON.stringify(movies))\n  }\n\n  req.end()\n}).listen(9000)\n\n</code></pre>\n<h3 id=\"4、Events\"><a href=\"#4、Events\" class=\"headerlink\" title=\"4、Events\"></a>4、Events</h3><pre><code class=\"js\">const EventEmitter = require(&#39;events&#39;)\n\nclass MyEventEmitter extends EventEmitter {}\n\nconst event = new MyEventEmitter()\n\nevent.on(&#39;play&#39;, (movie) =&gt; {\n  console.log(movie)\n})\n\nevent.emit(&#39;play&#39;, &#39;我和我的祖国&#39;)\nevent.emit(&#39;play&#39;, &#39;中国机长&#39;)\n\n</code></pre>\n<h3 id=\"5、File-System\"><a href=\"#5、File-System\" class=\"headerlink\" title=\"5、File System\"></a>5、File System</h3><pre><code class=\"js\">const fs = require(&#39;fs&#39;)\nconst fsP = require(&#39;fs&#39;).promises\n\n// 创建文件夹\nfs.mkdir(&#39;./logs&#39;, (err) =&gt; {\n  console.log(&#39;done.&#39;)\n})\n\n// 文件夹改名\nfs.rename(&#39;./logs&#39;, &#39;./log&#39;, () =&gt; {\n  console.log(&#39;done&#39;)\n})\n\n// 删除文件夹\nfs.rmdir(&#39;./log&#39;, () =&gt; {\n  console.log(&#39;done.&#39;)\n})\n\n// 写内容到文件里\nfs.writeFile(\n  &#39;./logs/log1.txt&#39;,\n  &#39;hello&#39;,\n  // 错误优先的回调函数\n  (err) =&gt; {\n    if (err) {\n      console.log(err.message)\n    } else {\n      console.log(&#39;文件创建成功&#39;)\n    }\n  }\n)\n\n// 给文件追加内容\nfs.appendFile(&#39;./logs/log1.txt&#39;, &#39;\\nworld&#39;, () =&gt; {\n  console.log(&#39;done.&#39;)\n})\n\n// 读取文件内容\nfs.readFile(&#39;./logs/log1.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; {\n  console.log(data)\n})\n\n// 删除文件\nfs.unlink(&#39;./logs/log1.txt&#39;, (err) =&gt; {\n  console.log(&#39;done.&#39;)\n})\n\n// 批量写文件\nfor (var i = 0; i &lt; 10; i++) {\n  fs.writeFile(`./logs/log-${i}.txt`, `log-${i}`, (err) =&gt; {\n    console.log(&#39;done.&#39;)\n  })\n}\n\n// 读取文件/目录信息\nfs.readdir(&#39;./&#39;, (err, data) =&gt; {\n  data.forEach((value, index) =&gt; {\n    fs.stat(`./${value}`, (err, stats) =&gt; {\n      // console.log(value + &#39;:&#39; + stats.size)\n      console.log(value + &#39; is &#39; + (stats.isDirectory() ? &#39;directory&#39; : &#39;file&#39;))\n    })\n  })\n})\n\n// 同步读取文件\ntry {\n  const content = fs.readFileSync(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;)\n  console.log(content)\n  console.log(0)\n} catch (e) {\n  console.log(e.message)\n}\n\nconsole.log(1)\n\n// 异步读取文件：方法一\nfs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; {\n  console.log(content)\n  console.log(0)\n})\nconsole.log(1)\n\n// 异步读取文件：方法二\nfs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;).then(result =&gt; {\n  console.log(result)\n})\n\n// 异步读取文件：方法三\nfunction getFile() {\n  return new Promise((resolve) =&gt; {\n    fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; {\n      resolve(data)\n    })\n  })\n}\n\n;(async () =&gt; {\n  console.log(await getFile())\n})()\n\n// 异步读取文件：方法四\nconst fsp = fsP.readFile(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;).then((result) =&gt; {\n  console.log(result)\n})\n\nconsole.log(fsP)\n\n// watch 监测文件变化\nfs.watch(&#39;./logs/log-0.txt&#39;, () =&gt; {\n  console.log(0)\n})\n\n</code></pre>\n<h3 id=\"6、Stream\"><a href=\"#6、Stream\" class=\"headerlink\" title=\"6、Stream\"></a>6、Stream</h3><pre><code class=\"js\">const fs = require(&#39;fs&#39;)\n\nconst readstream = fs.createReadStream(&#39;./note.txt&#39;)\nconst writestream = fs.createWriteStream(&#39;./note2.txt&#39;)\n\nwritestream.write(readstream)\n\n</code></pre>\n<h3 id=\"7、Zlib\"><a href=\"#7、Zlib\" class=\"headerlink\" title=\"7、Zlib\"></a>7、Zlib</h3><pre><code class=\"js\">const fs = require(&#39;fs&#39;)\nconst zlib = require(&#39;zlib&#39;)\n\nconst gzip = zlib.createGzip()\n\nconst readstream = fs.createReadStream(&#39;./note.txt&#39;)\nconst writestream = fs.createWriteStream(&#39;./note2.txt&#39;)\n\nreadstream\n  .pipe(gzip)\n  .pipe(writestream)\n\nwritestream.write(readstream)\n\n</code></pre>\n<h3 id=\"8、ReadLine\"><a href=\"#8、ReadLine\" class=\"headerlink\" title=\"8、ReadLine\"></a>8、ReadLine</h3><pre><code class=\"js\">const readline = require(&#39;readline&#39;)\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\n\nrl.question(&#39;What do you think of Node.js? &#39;, (answer) =&gt; {\n  // TODO: Log the answer in a database\n  console.log(`Thank you for your valuable feedback: ${answer}`)\n\n  rl.close()\n})\n\n</code></pre>\n<h3 id=\"9、Crypto\"><a href=\"#9、Crypto\" class=\"headerlink\" title=\"9、Crypto\"></a>9、Crypto</h3><pre><code class=\"js\">const crypto = require(&#39;crypto&#39;)\n\nconst secret = &#39;abcdefg&#39;\nconst hash = crypto.createHmac(&#39;sha256&#39;, secret)\n                   .update(&#39;I love you&#39;)\n                   .digest(&#39;hex&#39;)\nconsole.log(hash)\n\n</code></pre>\n<h2 id=\"五、路由\"><a href=\"#五、路由\" class=\"headerlink\" title=\"五、路由\"></a>五、路由</h2><pre><code class=\"js\">var http = require(&#39;http&#39;)\nvar fs = require(&#39;fs&#39;)\n\nhttp.createServer( function ( req, res ) {\n\n  switch ( req.url ) {\n    case &#39;/home&#39;:\n      res.write(&#39;home&#39;)\n      res.end()\n      break\n    case &#39;/mine&#39;:\n      res.write(&#39;mine&#39;)\n      res.end()\n      break\n    case &#39;/login&#39;: \n      fs.readFile( &#39;./static/login.html&#39;,function ( error , data ) {\n        if ( error ) throw error  \n        res.write( data )\n        res.end()\n      })\n      break\n    case &#39;/fulian.jpg&#39;:\n      fs.readFile( &#39;./static/fulian.jpg&#39;, &#39;binary&#39;, function( error , data ) {\n        if( error ) throw error \n        res.write( data, &#39;binary&#39; )\n        res.end()\n      })\n      break\n    default: \n      break\n   }\n\n }).listen( 8000, &#39;localhost&#39;, function () {\n   console.log( &#39;服务器运行在： http://localhost:8000&#39; )\n })\n\n</code></pre>\n<h2 id=\"六、静态资源服务\"><a href=\"#六、静态资源服务\" class=\"headerlink\" title=\"六、静态资源服务\"></a>六、静态资源服务</h2><h3 id=\"6-1-readStaticFile\"><a href=\"#6-1-readStaticFile\" class=\"headerlink\" title=\"6.1 readStaticFile\"></a>6.1 readStaticFile</h3><p><code>/modules/readStaticFile.js</code></p>\n<pre><code class=\"js\">// 引入依赖的模块\nvar path = require(&#39;path&#39;)\nvar fs = require(&#39;fs&#39;)\nvar mime = require(&#39;mime&#39;)\n\nfunction readStaticFile(res, filePathname) {\n\n  var ext = path.parse(filePathname).ext\n  var mimeType = mime.getType(ext)\n\n  // 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 \n  if (ext) {\n    // 根据传入的目标文件路径来读取对应文件\n    fs.readFile(filePathname, (err, data) =&gt; {\n    // 错误处理\n      if (err) {\n        res.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; })\n        res.write(&quot;404 - NOT FOUND&quot;)\n        res.end()\n      } else {\n        res.writeHead(200, { &quot;Content-Type&quot;: mimeType })\n        res.write(data)\n        res.end()\n      }\n    });\n    // 返回 true 表示, 客户端想要的 是 静态文件\n    return true\n  } else {\n    // 返回 false 表示, 客户端想要的 不是 静态文件\n    return false\n  }\n}\n\n// 导出函数\nmodule.exports = readStaticFile\n\n</code></pre>\n<h3 id=\"6-2-server\"><a href=\"#6-2-server\" class=\"headerlink\" title=\"6.2 server\"></a>6.2 server</h3><p><code>/server.js</code></p>\n<pre><code class=\"js\">// 引入相关模块\nvar http = require(&#39;http&#39;);\nvar url = require(&#39;url&#39;);\nvar path = require(&#39;path&#39;);\nvar readStaticFile = require(&#39;./modules/readStaticFile&#39;);\n\n// 搭建 HTTP 服务器\nvar server = http.createServer(function(req, res) {\n  var urlObj = url.parse(req.url);\n  var urlPathname = urlObj.pathname;\n  var filePathname = path.join(__dirname, &quot;/public&quot;, urlPathname);\n\n  // 读取静态文件\n  readStaticFile(res, filePathname);\n});\n\n// 在 3000 端口监听请求\nserver.listen(3000, function() {\n  console.log(&quot;服务器运行中.&quot;);\n  console.log(&quot;正在监听 3000 端口:&quot;)\n})\n\n</code></pre>\n<h3 id=\"6-3-最终目录结构\"><a href=\"#6-3-最终目录结构\" class=\"headerlink\" title=\"6.3 最终目录结构\"></a>6.3 最终目录结构</h3><p><img src=\"https://lurongtao.gitee.io/felixbooks-gp19-node.js/images/dir.jpg\" alt></p>\n<h1 id=\"02-Express\"><a href=\"#02-Express\" class=\"headerlink\" title=\"02-Express\"></a>02-Express</h1><p>基于Node.js平台，快速、开放、极简的web开发框架。</p>\n<pre><code>$ npm install express --save\n\n</code></pre><h2 id=\"一、特色\"><a href=\"#一、特色\" class=\"headerlink\" title=\"一、特色\"></a>一、特色</h2><h3 id=\"1、Web应用\"><a href=\"#1、Web应用\" class=\"headerlink\" title=\"1、Web应用\"></a>1、Web应用</h3><p>Express是一个基于Node.js平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种Web和移动设备应用。</p>\n<h3 id=\"2、API\"><a href=\"#2、API\" class=\"headerlink\" title=\"2、API\"></a>2、API</h3><p>丰富的HTTP快捷方法和任意排列组合的Connect中间件，让你创建健壮、友好的API变得既快速又简单。</p>\n<h3 id=\"3、性能\"><a href=\"#3、性能\" class=\"headerlink\" title=\"3、性能\"></a>3、性能</h3><p>Express不对Node.js已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的基本性能。</p>\n<h2 id=\"二、安装\"><a href=\"#二、安装\" class=\"headerlink\" title=\"二、安装\"></a>二、安装</h2><p>首先假定你已经安装了Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p>\n<pre><code>$ mkdir myapp\n$ cd myapp\n\n</code></pre><p>通过<code>npm init</code>命令为你的应用创建一个<code>package.json</code>文件。欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。</p>\n<pre><code>$ npm init\n\n</code></pre><p>此命令将要求你输入几个参数，例如此应用的名称和版本。你可以直接按“回车”键接受默认设置即可，下面这个除外：</p>\n<pre><code>entry point: (index.js)\n\n</code></pre><p>键入app.js或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的<code>index.js</code>文件名，只需按“回车”键即可。</p>\n<p>接下来安装Express并将其保存到依赖列表中：</p>\n<pre><code>$ npm install express --save\n\n</code></pre><p>如果只是临时安装Express，不想将它添加到依赖列表中，只需略去--save参数即可：</p>\n<pre><code>$ npm install express\n\n</code></pre><blockquote>\n<p>安装Node模块时，如果指定了<code>--save</code> 参数，那么此模块将被添加到<code>package.json</code>文件中<code>dependencies</code>依赖列表中。然后通过<code>npm install</code> 命令即可</p>\n</blockquote>\n<h2 id=\"三、Hello-World实例\"><a href=\"#三、Hello-World实例\" class=\"headerlink\" title=\"三、Hello World实例\"></a>三、Hello World实例</h2><p>接下来，我们一起创建一个基本的Express应用。</p>\n<p>注意：这里所创建的是一个最最简单的Express应用，并且仅仅只有一个文件 - 和通过Express应用生成器所创建的应用完全不一样，Express应用生成器所创建的应用框架包含多JavaScript文件、Jade模板和针对不同用途的子目录。</p>\n<p>进入myapp目录，创建一个名为app.js的文件，然后将下列代码复制进去：</p>\n<pre><code class=\"js\">var express = require(&#39;express&#39;);\nvar app = express();\n\napp.get(&#39;/&#39;, function (req, res) {\n  res.send(&#39;Hello World!&#39;);\n});\n\nvar server = app.listen(3000, function () {\n  var host = server.address().address;\n  var port = server.address().port;\n\n  console.log(&#39;Example app listening at http://%s:%s&#39;, host, port);\n});\n\n</code></pre>\n<p>上面的代码启动一个服务并监听从3000端口进入的所有连接请求。他将对所有(/)URL或 路由返回“Hello World！”字符串。对于其他所有路径全部返回 404 Not Found。</p>\n<blockquote>\n<p>req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on(&#39;data&#39;, callback) 以及任何 Node 提供的方法。</p>\n</blockquote>\n<p>通过如下命令启动此应用：</p>\n<pre><code>$ node app.js\n\n</code></pre><p>然后在浏览器中打开 <a href=\"http://localhost:3000/\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a> 并查看输出结果。</p>\n<h2 id=\"四、路由\"><a href=\"#四、路由\" class=\"headerlink\" title=\"四、路由\"></a>四、路由</h2><p>路由是指如何定义应用的端点（URls）以及如何响应客户端的请求。</p>\n<p>路由是由一个URI、HTTP请求（GET、POST等）和若干个句柄组成，它的结构如下：app.METHOD(path, [callback..], callback)， app 是 express 对象的一个实例，METHOD是一个 HTTP 请求方法，path 是服务器上的路径， callback 是当路由匹配时要执行的函数。</p>\n<p>下面是一个基本的路由示例：</p>\n<pre><code class=\"js\">var express = require(&#39;express&#39;);\nvar app = express();\n\n// respond with &quot;hello world&quot; when a GET request is made to the homepage\napp.get(&#39;/&#39;, function(req, res) {\n  res.send(&#39;hello world&#39;);\n});\n\n</code></pre>\n<h3 id=\"1、路由方法\"><a href=\"#1、路由方法\" class=\"headerlink\" title=\"1、路由方法\"></a>1、路由方法</h3><p>路由方法源于 HTTP 请求方法，和 express 实例相关联。</p>\n<p>下面这个例子展示了为应用跟路径定义的 GET 和 POST 请求：</p>\n<pre><code class=\"js\">// GET method route\n// 对网站首页的访问返回 &quot;Hello World!&quot; 字样\napp.get(&#39;/&#39;, function (req, res) {\n  res.send(&#39;Hello World!&#39;)\n})\n\n// 网站首页接受 POST 请求\napp.post(&#39;/&#39;, function (req, res) {\n  res.send(&#39;Got a POST request&#39;)\n})\n\n// /user 节点接受 PUT 请求\napp.put(&#39;/user&#39;, function (req, res) {\n  res.send(&#39;Got a PUT request at /user&#39;)\n})\n\n// /user 节点接受 DELETE 请求\napp.delete(&#39;/user&#39;, function (req, res) {\n  res.send(&#39;Got a DELETE request at /user&#39;)\n})\n\n</code></pre>\n<p>Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。</p>\n<blockquote>\n<p>有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如：<code>app[&#39;m-search&#39;](&#39;/&#39;, function ...)</code></p>\n</blockquote>\n<p>app.all()是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。</p>\n<p>在下面的例子中，来自&quot;/secret&quot;的请求，不管使用 GET、POST、PUT、DELETE或其他任何http模块支持的HTTP请求，句柄都会得到执行。</p>\n<pre><code class=\"js\">app.all(&#39;/secret&#39;, function (req, res, next) {\n  console.log(&#39;Accessing the secret section ...&#39;)\n  next(); // pass control to the next handler\n})\n\n</code></pre>\n<h3 id=\"2、路由路径\"><a href=\"#2、路由路径\" class=\"headerlink\" title=\"2、路由路径\"></a>2、路由路径</h3><p>路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。</p>\n<p>Express使用<code>path-to-regexp</code>匹配路由路径，请参考文档查阅所有定义路由路径的方法。Express Route Tester是测试基本Express路径的好工具，但不支持模式匹配。</p>\n<blockquote>\n<p>查询字符串不是路由路径的一部分。</p>\n</blockquote>\n<p>使用字符串的路由路径示例：</p>\n<pre><code class=\"js\">// 匹配根路径的请求\napp.get(&#39;/&#39;, function (req, res) {\n  res.send(&#39;root&#39;);\n});\n\n// 匹配 /about 路径的请求\napp.get(&#39;/about&#39;, function (req, res) {\n  res.send(&#39;about&#39;);\n});\n\n// 匹配 /random.text 路径的请求\napp.get(&#39;/random.text&#39;, function (req, res) {\n  res.send(&#39;random.text&#39;);\n});\n\n</code></pre>\n<p>使用字符串模式的路由路径示例：</p>\n<pre><code class=\"js\">// 匹配 acd 和 abcd\napp.get(&#39;/ab?cd&#39;, function(req, res) {\n  res.send(&#39;ab?cd&#39;);\n});\n\n// 匹配 abcd、abbcd、abbbcd等\napp.get(&#39;/ab+cd&#39;, function(req, res) {\n  res.send(&#39;ab+cd&#39;);\n});\n\n// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等\napp.get(&#39;/ab*cd&#39;, function(req, res) {\n  res.send(&#39;ab*cd&#39;);\n});\n\n// 匹配 /abe 和 /abcde\napp.get(&#39;/ab(cd)?e&#39;, function(req, res) {\n res.send(&#39;ab(cd)?e&#39;);\n});\n\n</code></pre>\n<blockquote>\n<p>字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。</p>\n</blockquote>\n<p>使用正则表达式的路由路径示例：</p>\n<pre><code class=\"js\">// 匹配任何路径中含有 a 的路径：\napp.get(/a/, function(req, res) {\n  res.send(&#39;/a/&#39;);\n});\n\n// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等\napp.get(/.*fly$/, function(req, res) {\n  res.send(&#39;/.*fly$/&#39;);\n});\n\n</code></pre>\n<h3 id=\"3、路由句柄\"><a href=\"#3、路由句柄\" class=\"headerlink\" title=\"3、路由句柄\"></a>3、路由句柄</h3><p>可以为请求处理提供多个回调函数，其行为类似中间件。唯一的区别是这些回调函数有可能调用<code>next(&#39;route&#39;)</code>方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。</p>\n<p>路由句柄有多种形式，可以是一个函数、一个函数数组、或者是两者混合，如下所示。</p>\n<p>使用一个回调函数处理路由：</p>\n<pre><code class=\"js\">app.get(&#39;/example/a&#39;, function(req, res) {\n    res.send(&#39;Hello from A!&#39;)\n})\n\n</code></pre>\n<p>使用多个回调函数处理路由（记得指定next对象）：</p>\n<pre><code class=\"js\">app.get(&#39;/example/b&#39;, function (req, res, next) {\n  console.log(&#39;response will be sent by the next function ...&#39;);\n  next();\n}, function (req, res) {\n  res.send(&#39;Hello from B!&#39;);\n});\n\n</code></pre>\n<p>使用回调函数数组处理路由：</p>\n<pre><code class=\"js\">var cb0 = function (req, res, next) {\n  console.log(&#39;CB0&#39;)\n  next()\n}\n\nvar cb1 = function (req, res, next) {\n  console.log(&#39;CB1&#39;)\n  next()\n}\n\nvar cb2 = function (req, res) {\n  res.send(&#39;Hello from C!&#39;)\n}\n\napp.get(&#39;/example/c&#39;, [cb0, cb1, cb2])\n\n</code></pre>\n<p>混合使用函数和函数数组处理路由：</p>\n<pre><code class=\"js\">var cb0 = function (req, res, next) {\n  console.log(&#39;CB0&#39;)\n  next()\n}\n\nvar cb1 = function (req, res, next) {\n  console.log(&#39;CB1&#39;)\n  next()\n}\n\napp.get(&#39;/example/d&#39;, [cb0, cb1], function (req, res, next) {\n  console.log(&#39;response will be sent by the next function ...&#39;)\n  next()\n}, function (req, res) {\n  res.send(&#39;Hello from D!&#39;)\n})\n\n</code></pre>\n<h3 id=\"4、响应方法\"><a href=\"#4、响应方法\" class=\"headerlink\" title=\"4、响应方法\"></a>4、响应方法</h3><p>下表中响应对象(res)的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">res.download()</td>\n<td style=\"text-align:center\">提示下载文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.end()</td>\n<td style=\"text-align:center\">终结响应处理流程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.json()</td>\n<td style=\"text-align:center\">发送一个JSON格式的响应</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.jsonp()</td>\n<td style=\"text-align:center\">发送一个支持JSONP的JSON格式的响应</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.direct()</td>\n<td style=\"text-align:center\">重定向请求</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.render()</td>\n<td style=\"text-align:center\">渲染视图模板</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.send()</td>\n<td style=\"text-align:center\">发送各种类型的响应</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.sendFile()</td>\n<td style=\"text-align:center\">以八位字节流的形式发送文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res.sendStatus()</td>\n<td style=\"text-align:center\">设置响应状态代码，并将其以字符串形式作为响应体的一部分发送</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"5、app-route\"><a href=\"#5、app-route\" class=\"headerlink\" title=\"5、app.route()\"></a>5、app.route()</h3><p>可使用app.route()创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。</p>\n<p>下面这个示例程序使用app.route()定义了链式路由句柄。</p>\n<pre><code class=\"js\">app.route(&#39;/book&#39;)\n  .get(function(req, res) {\n    res.send(&#39;Get a random book&#39;);\n  })\n  .post(function(req, res) {\n    res.send(&#39;Add a book&#39;);\n  })\n  .put(function(req, res) {\n    res.send(&#39;Update the book&#39;);\n  });\n\n</code></pre>\n<h3 id=\"6、express-Router\"><a href=\"#6、express-Router\" class=\"headerlink\" title=\"6、express.Router\"></a>6、express.Router</h3><p>可使用express.Router类创建模块化、可挂载的路由句柄。Router实例是一个完整的中间件和路由系统，因此常称其为一个&#39;mini-app&#39;。</p>\n<p>下面的实例程序创建了一个路由模块，并加载 了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。</p>\n<p>在app目录下创建名为bird.js的文件，内容如下：</p>\n<pre><code class=\"js\">var express = require(&#39;express&#39;);\nvar router = express.Router();\n\n// 该路由使用的中间件\nrouter.use(function timeLog(req, res, next) {\n  console.log(&#39;Time: &#39;, Date.now());\n  next();\n});\n// 定义网站主页的路由\nrouter.get(&#39;/&#39;, function(req, res) {\n  res.send(&#39;Birds home page&#39;);\n});\n// 定义 about 页面的路由\nrouter.get(&#39;/about&#39;, function(req, res) {\n  res.send(&#39;About birds&#39;);\n});\n\nmodule.exports = router;\n\n</code></pre>\n<p>然后在应用中加载路由模块：</p>\n<pre><code class=\"js\">var birds = require(&#39;./birds&#39;)\n...\napp.use(&#39;/birds&#39;, birds)\n\n</code></pre>\n<p>应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。</p>\n<h2 id=\"五、利用Express托管静态文件\"><a href=\"#五、利用Express托管静态文件\" class=\"headerlink\" title=\"五、利用Express托管静态文件\"></a>五、利用Express托管静态文件</h2><p>通过Express内置的<code>express.static</code>可以方便地托管静态文件，例如图片、CSS、JavaScript文件等。</p>\n<p>将静态资源文件所在的目录作为参数传递给<code>express.static</code>中间件就可以提供静态资源文件的访问了。例如，假设在public目录放置了图片、CSS和JavaScript文件，你就可以：</p>\n<pre><code class=\"js\">app.use(express.static(&#39;public&#39;))\n\n</code></pre>\n<p>现在，public目录下面的文件就可以访问了。</p>\n<pre><code>http://localhost:3000/images/kitten.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/images/bg.png\nhttp://localhost:3000/hello.html\n\n</code></pre><blockquote>\n<p>所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在URL中。</p>\n</blockquote>\n<p>如果你的静态资源存放在多个目录下面，你可以多次调用<code>express.static</code>中间件：</p>\n<pre><code class=\"js\">app.use(express.static(&#39;public&#39;))\napp.use(express.static(&#39;files&#39;))\n\n</code></pre>\n<p>访问静态资源文件时，<code>express.static</code>中间件会根据目录添加的顺序查找所需的文件。</p>\n<p>如果你希望所有通过<code>express.static</code>访问的文件都存放在一个”虚拟(virtual)“目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：</p>\n<pre><code class=\"js\">app.use(&#39;/static&#39;, express.static(&#39;public&#39;))\n\n</code></pre>\n<p>现在，你就可以通过带有”/static“前缀的地址来访问public目录下面的文件了。</p>\n<pre><code class=\"js\">http://localhost:3000/static/images/kitten.jpg\nhttp://localhost:3000/static/css/style.css\nhttp://localhost:3000/static/js/app.js\nhttp://localhost:3000/static/images/bg.png\nhttp://localhost:3000/static/hello.html\n\n</code></pre>\n<h2 id=\"六、使用中间件\"><a href=\"#六、使用中间件\" class=\"headerlink\" title=\"六、使用中间件\"></a>六、使用中间件</h2><p>Express是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。</p>\n<p>中间件（Middleware）是一个函数，它可以访问请求对象（request object(req)），响应对象(response object(res))，和web应用中处于请求-响应循环流程中的中间件，一般被命名为next的变量。</p>\n<p>中间件的功能包括：</p>\n<ul>\n<li>执行任何代码</li>\n<li>修改请求和响应对象</li>\n<li>终结请求-响应循环</li>\n<li>调用堆栈中的下一个中间件</li>\n</ul>\n<p>如果当前中间件没有终结请求-响应循环，则必须调用<code>next()</code>方法将控制权交给下一个中间件，否则请求就会挂起。</p>\n<p>Express应用可使用如下几种中间件：</p>\n<ul>\n<li>应用级中间件</li>\n<li>路由级中间件</li>\n<li>错误处理中间件</li>\n<li>内置中间件</li>\n<li>第三方中间件</li>\n</ul>\n<p>使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。</p>\n<h3 id=\"1、应用级中间件\"><a href=\"#1、应用级中间件\" class=\"headerlink\" title=\"1、应用级中间件\"></a>1、应用级中间件</h3><p>应用级中间件绑定到app对象，使用<code>app.use()</code>和<code>app.METHOD()</code>，其中，<code>METHOD</code>是需要处理的HTTP请求的方法，例如GET,PUT,POST等等，全部小写。例如：</p>\n<pre><code class=\"js\">var app = express()\n\n// 没有挂载路径的中间件，应用的每个请求都会执行该中间件\napp.use(function (req, res, next) {\n    console.log(&#39;Time:&#39;, Date.now())\n    next()\n})\n\n// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它\napp.use(&#39;/user/:id&#39;, function(req, res, next) {\n    console.log(&#39;Request Type:&#39;, req.method)\n    next()\n})\n\n// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    res.send(&#39;USER&#39;)\n})\n\n</code></pre>\n<p>下面这个例子展示了在一个挂载点装载一组中间件。</p>\n<pre><code class=\"js\">// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息\napp.use(&#39;/user/:id&#39;, function(req, res, next) {\n    console.log(&#39;Request URL:&#39;, req.originalUrl)\n    next()\n}, function(req, res, next) {\n    console.log(&#39;Request Type:&#39;, req.method)\n    next()\n})\n\n</code></pre>\n<p>作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。 第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。</p>\n<pre><code class=\"js\">// 一个中间件栈，处理指向 /user/:id 的 GET请求\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    console.log(&#39;ID:&#39;, req.params.id)\n    next()\n}, function(req, res, next) {\n    res.send(&#39;User Info&#39;)\n})\n\n// 处理 /user/:id, 打印出用户id\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    res.end(req.params.id)\n})\n\n</code></pre>\n<p>如果需要在中间件栈中跳过剩余中间件，调用 <code>next(&#39;route&#39;)</code>方法将控制权交给下一个路由。注意：<code>next(&#39;route&#39;)</code>只对使用 <code>app.VERB()</code>  或 <code>router.VERB()</code>加载的中间件有效。</p>\n<pre><code class=\"js\">// 一个中间件栈，处理指向 /user/:id 的 GET 请求\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    // 如果 user id 为0，跳到下一个路由\n    if (req.params.id === 0) next(&#39;route&#39;)\n    // 否则将控制权交给栈中下一个中间件\n    else next()\n}, function(req, res, next) {\n    // 渲染常规页面\n    res.render(&#39;regular&#39;)\n})\n\n// 处理 /user/:id, 渲染一个特殊页面\napp.get(&#39;/user/:id&#39;, function(req, res, next) {\n    res.render(&#39;special&#39;)\n})\n\n</code></pre>\n<h3 id=\"2、路由级中间件\"><a href=\"#2、路由级中间件\" class=\"headerlink\" title=\"2、路由级中间件\"></a>2、路由级中间件</h3><p>路由级中间件和应用级中间件一样，只是它绑定的对象为 <code>express.Router()</code>。</p>\n<pre><code>var router = express.Router()\n\n</code></pre><p>路由级使用<code>router.use()</code>或<code>router.VERB()</code>加载。</p>\n<p> 上述在应用级创建的中间件系统，可通过如下代码改写为路由级。</p>\n<pre><code class=\"js\">var app = express()\nvar router = express.Router()\n\n// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件\nrouter.use(function (req, res, next) {\n  console.log(&#39;Time:&#39;, Date.now())\n  next()\n})\n\n// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息\nrouter.use(&#39;/user/:id&#39;, function(req, res, next) {\n  console.log(&#39;Request URL:&#39;, req.originalUrl)\n  next()\n}, function (req, res, next) {\n  console.log(&#39;Request Type:&#39;, req.method)\n  next()\n})\n\n// 一个中间件栈，处理指向 /user/:id 的 GET 请求\nrouter.get(&#39;/user/:id&#39;, function (req, res, next) {\n  // 如果 user id 为 0, 跳到下一个路由\n  if (req.params.id == 0) next(&#39;route&#39;)\n  // 负责将控制权交给栈中下一个中间件\n  else next() //\n}, function (req, res, next) {\n  // 渲染常规页面\n  res.render(&#39;regular&#39;)\n})\n\n// 处理 /user/:id， 渲染一个特殊页面\nrouter.get(&#39;/user/:id&#39;, function (req, res, next) {\n  console.log(req.params.id)\n  res.render(&#39;special&#39;)\n})\n\n// 将路由挂载至应用\napp.use(&#39;/&#39;, router)\n\n</code></pre>\n<h3 id=\"3、错误处理中间件\"><a href=\"#3、错误处理中间件\" class=\"headerlink\" title=\"3、错误处理中间件\"></a>3、错误处理中间件</h3><blockquote>\n<p>错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。</p>\n</blockquote>\n<p>错误处理中间件和其他中间件定义类似，只是要使用4个参数，而不是3个，其签名如下：(err,req,res,next)。</p>\n<pre><code class=\"js\">app.use(function(err, req, res, next) {\n  console.error(err.stack)\n  res.status(500).send(&#39;Something broke!&#39;)\n})\n\n</code></pre>\n<h3 id=\"4、内置中间件\"><a href=\"#4、内置中间件\" class=\"headerlink\" title=\"4、内置中间件\"></a>4、内置中间件</h3><p>从4.x版本开始，Express已经不再依赖Connect了。除了express.static，Express以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。</p>\n<p><code>express.static(root, [options])</code></p>\n<p>express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在Express应用中提托管静态资源。</p>\n<p>参数 root 指提供静态资源的根目录。</p>\n<p>可选的 options 参数拥有如下属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n<th>缺省值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dotfiles</td>\n<td>是否对外输出文件名以点（.）开头的文件。可选值为”allow“，”deny“和”ignore“。</td>\n<td>String</td>\n<td>”ignore“</td>\n</tr>\n<tr>\n<td>etag</td>\n<td>是否启用etag生成</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>extensions</td>\n<td>设置文件扩展名备份选项</td>\n<td>Array</td>\n<td>[]</td>\n</tr>\n<tr>\n<td>index</td>\n<td>发送目录索引文件，设置为false禁用目录索引</td>\n<td>Mixed</td>\n<td>&quot;index.html&quot;</td>\n</tr>\n<tr>\n<td>lastModified</td>\n<td>设置Last-Modified头为文件在操作系统上的最后修改日期。可能值为true或false</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>maxAge</td>\n<td>以毫秒或者其字符串格式设置Cache-Control头的max-age属性。</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n<tr>\n<td>redirect</td>\n<td>当路径为目录时，重定向至”/“</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>setHeaders</td>\n<td>设置HTTP头以提供文件的函数</td>\n<td>Function</td>\n</tr>\n</tbody>\n</table>\n<p>下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。</p>\n<pre><code class=\"js\">var options = {\n  dotfiles: &#39;ignore&#39;,\n  etag: false,\n  extensions: [&#39;htm&#39;, &#39;html&#39;],\n  index: false,\n  maxAge: &#39;1d&#39;,\n  redirect: false,\n  setHeaders: function (res, path, stat) {\n    res.set(&#39;x-timestamp&#39;, Date.now())\n  }\n}\n\napp.use(express.static(&#39;public&#39;, options))\n\n</code></pre>\n<p>每个应用可有多个静态目录。</p>\n<pre><code class=\"js\">app.use(express.static(&#39;public&#39;))\napp.use(express.static(&#39;uploads&#39;))\napp.use(express.static(&#39;files&#39;))\n\n</code></pre>\n<h3 id=\"5、第三方中间件\"><a href=\"#5、第三方中间件\" class=\"headerlink\" title=\"5、第三方中间件\"></a>5、第三方中间件</h3><p>通过使用第三方中间件从而为 Express 应用增加更多功能。</p>\n<p>安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。</p>\n<p>下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser</p>\n<pre><code>$ npm install cookie-parser\n\n</code></pre><pre><code class=\"js\">var express = require(&#39;express&#39;)\nvar app = express()\nvar cookieParser = require(&#39;cookie-parser&#39;)\n\n// 加载用于解析 cookie 的中间件\napp.use(cookieParser())\n\n</code></pre>\n<h2 id=\"七、在Express中使用模板引擎\"><a href=\"#七、在Express中使用模板引擎\" class=\"headerlink\" title=\"七、在Express中使用模板引擎\"></a>七、在Express中使用模板引擎</h2><p>需要在应用中进行如下设置才能让Express渲染模板文件：</p>\n<ul>\n<li><code>views</code>，放模板文件的目录，比如：<code>app.set(&#39;views&#39;, &#39;./views&#39;)</code></li>\n<li><code>view engine</code>，模板引擎，比如：<code>app.set(&#39;view engine&#39;, &#39;ejs&#39;)</code></li>\n</ul>\n<p><strong>art-template</strong></p>\n<p>art-template for express 4.x.</p>\n<ul>\n<li><p>1、Install</p>\n<pre><code>npm install --save art-template\nnpm install --save express-art-template\n\n</code></pre></li>\n</ul>\n<ul>\n<li><p>2、Example</p>\n<pre><code class=\"js\">var express = require(&#39;express&#39;)\nvar app = express()\n\n// view engine setup\napp.engine(&#39;art&#39;, require(&#39;express-art-template&#39;))\napp.set(&#39;view&#39;, {\n    debug: process.env.NODE_ENV !== &#39;production&#39;\n})\napp.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;))\napp.set(&#39;view engine&#39;, &#39;art&#39;)\n\n// routes\napp.get(&#39;/&#39;, function (req, res) {\n    res.render(&#39;index.art&#39;, {\n        user: {\n            name: &#39;aui&#39;,\n            tags: [&#39;art&#39;, &#39;template&#39;, &#39;nodejs&#39;]\n        }\n    })\n})\n\n</code></pre>\n</li>\n</ul>\n<h1 id=\"03-Koa2\"><a href=\"#03-Koa2\" class=\"headerlink\" title=\"03-Koa2\"></a>03-Koa2</h1><h2 id=\"一、koa2快速开始\"><a href=\"#一、koa2快速开始\" class=\"headerlink\" title=\"一、koa2快速开始\"></a>一、koa2快速开始</h2><p>因为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以上node.js环境 版本v7.6以上 npm 版本3.x以上</p>\n"},{"title":"JavaScript","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-08-17T08:25:29.827Z","comments":1,"keywords":"javascript","description":"javascript","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg"],"_content":"\n\n## 1、介绍\n\njs全称javascript，是一门运行在浏览器端的脚本语言，现在也可以运行在服务器端（node.js）\n\n## 2、组成\n现在说的javasript包含3个组成部分\n\n1. **ECMAScript** 语法标准，语法规则\n2. **DOM** 专门用于操作页面元素的方法\n3. **BOM** 专门用于操作浏览器的方法\n\n``webapi``有时用来统称1和2\n\n## 3、js书写位置\n1. 直接将内容编写在script标签中\n2. 可以直接在一个单独的js文件中编写，需要引入\n\n>注意点：只要script标签，设置了src属性，标签内的内容将被忽略\n\n## 4、js的注释\n\n注释给开发者看的，浏览器不会执行，方便维护\n\n* 单行注释// 快捷键``ctrl+/``\n* 多行注释/**/ 快捷键``alt+shift+a``\n\n## 5、js的输出语句\n> 指的就是往页面中输出的方式\n* ``alert`` 警告框\n* ``confirm`` 确认框（可以选择的）\n* ``prompt`` 输入框，可以让用户输入内容\n* ``document.write`` 往页面中追加输入内容\n* 支持标签的解析（识别标签）\n* ``console.log`` 在控制台打印内容，专门用于调试的，给开发者看\n\n## 6、变量（就是可以变化的量）\n\n### 6.1 作用\n存储数据，为了将来可以运算使用\n\n1. 先声明，后赋值\n```javascript\nvar age;\nage = 18;\n```\n2. 同时声明和赋值\n```javascript\n\tvar age1 = 18;\n\tconsole.log(age1);\n```\n3.  只声明，不赋值（``undefined``未定义，只要变量声明了但是未赋值，默认值就是undefined）\n4.  不声明，直接赋值(**不推荐**，变量一定要声明了，再使用)\n```javascript\nage3=30;\nconsole.log(age3);\n```\n5. 不声明，不赋值，直接用  xxx is not defined 一定是没有声明赋值的变量直接用了，会报错\n6. 可以同时声明赋值多个变量（本质上，只是省略了var）\n\n### 6.2 变量命名规则和规范\n#### 6.2.1 规则\n\n* 变量名必须由字母 数字 下划线和 $组成，不能以数字开头（后来也引入中文，但是不要这么做）\n* 变量名不能是关键字或者是保留字\n* 变量区分大小写\n\n#### 6.2.2 规范\n\n* 声明的变量要有意义\n* 声明的变量，如果很长，遵循驼峰命名（从第二个字母开始，首字母大写，用于分割单词，可读性高）\n\n### 6.3 变量的作用域（变量起作用的区域）\n* 全局作用域（在script标签内，在函数外的区域）\n\t声明在全局作用域的变量，就叫全局变量\n\t特征：在任何地方都可以使用\n* 局部作用域（函数内部的区域，就是局部作用域）\n\t声明在函数内部的变量，就叫局部变量\n\t特征：只在当前函数内可以使用，出了函数，就不能用了\n\n### 6.4 变量的访问规则\n如果自己的作用域内有这个变量，直接用，改自己的\n如果没有，才会往外面找（找全局）,用外面的，改外面的 \n\n### 6.5 隐式全局变量\n如果一个没有声明过的变量，直接赋值，就叫隐式全局变量（将来要避免）\n\n### 6.6 预解析（预先解析，浏览器会先查看有多少的变量和函数）\n1. 所有的变量声明，都会提升到最顶部，只提升声明，不提升赋值\n2. 所有的函数声明，都会提升到最顶部，只提升声明，不提升调用\n> 补充说明:\n>  1. 多个重名的var声明，后面的var将被忽略\n>\t 2. 多个重名的函数声明，后面的将前面的覆盖\n>\t 3. 如果出现了同名的变量和函数，函数优先，函数的优先级>变量\n>\t 4. 函数内部也会进行预解析\n\n预解析，虽然可以提升我们的声明，但是我们开发时，还是要**先声明，后使用**！！！\n\n## 7、js的数据类型\n\n分为：``简单数据类型``和``复杂数据类型`` （数组、函数、对象）\n\n### 7.1 简单数据类型\n#### 7.1.1 number类型（数字类型）\n\n1. 整数（一般使用的是十进制  逢十进一）\n\n\t``八进制，逢八进一，0开头``\n    ```javascript\n    var num3 = 011  //就是1*8+1 为9;\n    var num4 = 022  //2*8+2 为18\n    ```\n\n\t``十六进制，逢16进一，0x开头的数字  0-9abcdef``\n\n    ```javascript\n    var num2 = 0x11  //1*16+1 为17;\n    var num3 = 0x1a  //16+10为26;\n    ```\n\n2. 浮点数（小数）\n\n3. 科学计数法 \n  ```javascript\n  var num1 = 1e4 就是1*10^4\n  ```\n  > 注意点：计算机对于小数的运算是不准确的，会有很小很小的误差，所以尽量不要用  小数进行比较运算\n\n#### 7.1.2 string类型 字符串类型\n* 通过 '' 或者 \"\" 包裹的就是字符串，js中单双引号，没有区别，推荐''.\n* 字符串通过length，可以获取长度\n```\n\tconsole.log（str.length）;\n```\n\n* 转义字符\t\n  ``\\'`` 表示一个普通的单引号\n\t``\\\"`` 表示一个普通的双引号\n\t``\\n`` 表示换行\n\n* 拼串（拼接字符串）\n> ``+`` 有拼接字符串的功能，也有运算的功能\n\n``+`` 的规则：\n1. 只要两边有字符串（黑色），进行的就是拼串\n2. 只有两边都是数字（蓝色），才进行运算\n\n#### 7.1.3 boolean类型 布尔类型 \n只有两个值，true真 false假\n一般用于比较\n\n#### 7.1.4 undefined 未定义的，变量声明了，但是未赋值，默认值就是underfined\n\n#### 7.1.5 null 空对象\n\n\n\n### 7.2 复杂数据类型\n\n\n\n## 8、变量与简单数据类型的说明\n\n* 对于简单数据类型，浏览器直接认识（直接量 或者 字面量）\n* 若是将字符串当成了变量（未声明，未赋值的变量直接使用，会报错）\n* 字符串需要引号包裹\n\n\n## 9、运算符（操作符）\n\n### 9.1 算术运算符 ``+ - * / %(取余)``\n* ``+`` 不仅有拼串的功能，还可以运算\n* 其他算数运算符，只有运算的功能，如果遇到了字符串，也会转成数字运算\n```javascript\n\"2\" - 1 = >1\n```\n### 9.2 赋值运算符 =\n=（就是赋值）   +=   -=   *=   /=   %=\n```javascript\nvar num = 10;\nnum += 10; //等价 num = num + 10\n```\n\n### 9.3 自增或自减运算符（一元运算符）\n#### 9.3.1 自增：让变量的值，在原来的基础上+1\n* 语法：\n``++num`` 前自增，规则：先让值+1，再返回这个值\n``num++`` 后自增，规则：先返回这个值，再让值+1\n\n* 注意点： \n * 不管是++num 还是num++ 从功能的角度一样的，都是让变量的值+1\n * 虽然++num 或 num++ 都能让变量值+1，但是++num 和 num++这个式子的结果是不一样的\n\n#### 9.3.2 自减：让变量的值，在原来的基础上-1\n*语法：\n``--num``\n``num--``\n\n### 9.4 逻辑运算符（与或非）\n``&&`` 并且 两边都要成立，结果才是 true，只要有一个不成立，就是false\n``||`` 或 两边只要有一个成立，结果就是true\n``!`` 取反\n\n### 9.5 比较运算符 >  <  >=  <=  ==   !=  ===   !==\n``==`` 规则：只看值，不看类型（只要值相等，就是相等）\n``===`` 规则：看值，又看类型（值和类型都要相等）\n``!=`` 规则：只看值，不看类型（只要值不等，就是true）\n``!==`` 规则：看值，又看类型（只要值或者类型有一个不等，就是不等，返回true）\n\t\n> ==有一定规则（如果类型不同，转换成相同类型，然后比较）\n1. NaN，不等于任何值，包括他自己\n2. null，不等于任何值，除了null和undefined\n3. undefined，不等于任何值 ，除了null和undefined\n4. 看是否有数字或布尔，如果有，转成数字比较\n\t  true：1，false:0\n\t  [ ]:0, { }:NaN，'':0\n5. 再看是否有字符串，（字符串和复杂数据类型），转成字符串比较\n\t[ ].toString()--->\"\"\n\tobj.toString()--->'[object Object]'\n6. 都是复杂数据类型，比较的是内存地址\n\t\t\t\t\n### 9.6 运算符优先级\n1. 括号的优先级最高\n2. 一元运算符 ++  --  !\n3. 算数运算符  先乘除%，后加减\n4. 比较运算符\n5. 逻辑运算符  &&  ||\n\n>记忆：（1）括号的优先级最高，逻辑运算符的优先级最低\n>\t\t  （2）先乘除，后加减\n\n## 10、如何判断数据的类型\n\n### 10.1 直接打印看颜色（调试，看颜色）\n蓝色的数字，number\n黑色\t     string\n蓝色的布尔值 boolean\n灰色\t    undefined和null\n\n### 10.2 typeof 变量\t它的返回值，也是一个字符串类型\n1. number\n2. string\n3. boolean\n\n> bug: typeof null = object;\n\n## 11、数据类型转换\n\n### 11.1 转成数字\n* ``Number（xx）`` 如果拿到的是一个非数字，浏览器也不会报错，返回 ``NaN``,not  a number \n* ``parseInt（xx）`` 从第一个字符开始解析，一直解析到第一个非数字为止\n* ``parseFloat（xx）`` 从第一个字符开始解析，可以识别一个``.``  然后解析到非数字为止\n* 直接运算 -  *  /  %    +正号（用的最多，例如+age）  -负号\t\t\n\n### 11.2 转成字符串\n* String（xx）\n* xx.toString()\n* 直接拼串 （常用）\n\tconsole.log(age+ \"\");\n\n### 11.3 转成布尔类型\n**所有的值，都可以转成布尔类型**\n\n**规则**：只有这6种情况， 0  \"\"  NaN  null  undefined   false  可以转成false，其他所有值，都是true\n\n* Boolean（）\n* !!\n\n### 11.4 NaN的说明（表示非数字，指一个无法用数字表示的数字，not a number）\n\n* 如果浏览器遇到了一个无法用数字表示的数值，就用NaN表示\n* 只要看到了NaN，说明代码的执行有问题\n* NaN的类型是number类型\n* NaN不等于任何值，包括他自己\n\n\n## 12、流程控制\n\n### 12.1 顺序结构（从上到下执行的，默认）\n### 12.2 分支结构（选择结构）\n\n#### 12.2.1 if语句\n\t\t\t\n* 语法1\n```javascript\nif（条件）{\n  语句1;\n}\n```\n如果条件成立，执行语句1\n\n* 语法2\n```\nif（条件）{\n  语句1;\n}\nelse {\n  语句2;\n}\n```\n如果条件成立，执行语句1，否则执行语句2\n\n* 语法3\n```\nif（条件1）{\n  语句1;\n}\nelse if（条件2） {\n  语句2;\n}\nelse {\n  语句3;\n}\n```\n\n如果条件1成立，执行语句1\n如果条件1不成立，看条件2，如果条件2成立，执行语句2\n如果都不成立，执行语句3\n\n\n#### 12.2.2 三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）\n\n语法  var 结果 = 条件 ？ A ：B；（如果条件满足，就是A 否则B）\n\n#### 12.2.3 switch-case（根据变量的具体，进行判断）\n```javascript\nswitch（变量）{\n  case 值1:\n\t  语句1;\n\t  break;（break表示跳出switch，接着往下执行）\n  case 值2:\n\t  语句2;\n\t  break;（break表示跳出switch，接着往下执行）\n  case 值3:\n\t  语句3;\n\t  break;（break表示跳出switch，接着往下执行）\n  default:\n\t  默认语句;\n}\n```\n\n**判断变量的值**\n\t如果值，等于值1，执行语句1\n\t如果值，等于值2，执行语句2\n\t。。。\n\t如果都不满足，执行默认语句\n\n**注意点**：\n\t（1）进行的值的比较，进行的是全等比较\n\t（2）养成写break的习惯（不写break，会一直往下执行）\n\n#### 12.2.4 三种分支结构的使用场景：\n* if else\t\t\t适用于范围形的判断\n* 三元运算符\t\t只适用于比较简单的判断，条件只能写一个，但是简洁\n* switch。。 case。。适用于具体值的判断\n\n### 12.3 循环结构\n\n#### 12.3.1 while（当条件成立时，循环执行某件事）\n```javascript\nwhile（条件）{\n  循环体; //循环执行的内容\n}\n```\n条件成立，执行循环体\n判断条件，条案件成立，继续执行循环体\n。。。\n条件不成立，跳出循环\n死循环，永远都没有结束的一个循环，开发中需要避免\n\n* while循环一定要有条件，不然就死循环了\n* i++一般放在{..}的最后面\n* while循环可以用于实现不明确循环次数的循环\n\n#### 12.3.2 do while\n```javascript\ndo {\n  循环体; //重复执行的内容\n}while（条件)\n```\n一上来，直接执行循环体\n再判断条件，如果条件成立，再执行循环体\n。。。\n直到条件不成立，跳出循环\n\t\t\n> do while一般只适合：不管条件成立不成立，都执行一次\n> while 和 do while的区别：\n>\t while 如果条件不成立，一次都不执行\n>\t do while不管条件成立与否，至少执行一次\n\n#### 12.3.3 for（适用于明确范围的循环）\n```\nfor（初始化语句;判断条件;自增或自减）{\n  循环体;\n}\n```\n例：\n```javascript\nfor（var i = 1；i < 5; i++）{\n  console.log(1);\n}\n```\n\n执行语句：\n  1. 初始化语句\n\t2. 判断条件\n\t3. 自增或自减\n\t4. 循环体\n\n执行流程分析：1243 243 243 243...\n执行流程：\n  先初始化语句，判断条件，执行循环体，自增或自减；\n\t判断条件，执行循环体，自增或自减；\n\t。。。\n\t条件不成立，跳出循环；\n\n#### 12.3.4 双重for循环，就是在for循环的外面再套一个for循环\n* 外层控制行数\n* 内层控制一行打印多少个\n\n\tbreak：如果循环遇到了break，跳出整个循环，整个循环就结束了，后面的次数都不执行了\t\t\n\tcontinue：如果循环遇到了continue，跳出本次循环，执行下一次循环\n\n#### 12.3.5 循环的使用场景：\n* while比较适合不明确执行次数的循环（循环表白案例）\n* do while（少用）只适用于不管成立与否，至少执行一次循环体的情况\n* for比较适合于明确范围的循环\n\n## 13、断点调试\n（1）F12打开控制台，sources,点开对应的文件\n（2）在对应行的行号上，点击打断点，刷新后，浏览器会自动执行停留在断点的位置\n操作：\n（1）watch监视，监视变量的变化\n（2）F10，让代码往下一步执行\n（3）F8，从当前位置，执行到下一个断点的位置，如果后面没有断点了，就会一直执行完\n\n\n## 14、数组（是一个有序的值的集合，可以存储大量的数据）\n简单数据类型，在存储大量数据时，一个一个的存，非常的浪费\n\n### 14.1 创建数组的方式\n1. 字面量的方式（字面量，直接量，从字面上直接就能看出是什么值的量）\n\t\t123  false  'abc'  undefined  null  [ ]:表示数组\n``var arr =[ ]``创建一个空数组\n> 注意点：数组里面可以存任意类型的数据，但是规范是存储同类型的数据\n\n2. 构造函数的方式\n```javascript\n\tvar arr = new Array(); ---创建一个空数组\n\tvar arr = new Array(5);---浪费空间，五个空的位置，没有具体值\n```\n### 14.2 数组的长度 arr.length\n### 14.3 数组的下标（索引）：数组中的每一项，都会有一个唯一的下标\n* 从0开始，最大下标arr.length-1\n* 数组中下标的范围：0 -----> arr.length-1\n\n### 14.4 数组的取值和存值\n\n* 取值：\n**语法：数组名[下标]**\n 1. 如果下标存在，直接返回对应项的值\n 2. 如果下标不存在，返回undefined\n\n* 存值（改值）\n**语法：数组名[下标] = ‘新的值’**\n 1. 如果下标存在，直接用新的值覆盖\n 2. 如果下标不存在，新建一个项，进行赋值\n\n* 往数组最后添加项\n\t1. arr[arr.length] = '值';\n\t2. arr.push('值')；\n\n### 14.5 数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项\n* 数组正序遍历\n```javascript\nfor (var i = 0; i < arr.length; i++) {\n`console.log(arr[i]);\n}\n```\n\n* 数组倒叙遍历\n```\nfor (var i = arr.length-1; i >=0; i--) {\n  console.log(arr[i]);\n}\n```\n\n### 14.6 冒泡排序\n1. 冒泡（指得是排序的方式）\n2. 排序（就是讲一组没有按照顺序排列的数，经过排列后，按照一定的顺序排列）\n\t价格排序，成绩排序\n\t编程界，有十大排序\n\t\n### 14.7 初级版\n1. 先排出一趟，排出一个最大值\n\t1. 遍历数组\n\t2. 让arr[i] 和 arr[i+1] 比较\n\t3. 如果arr[i] > arr[i+1] ，交换位置\n2. 双重for循环，多排几次，就排好了\n\n### 14.8 中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次\n\t\t内循环-j\n\n### 14.9 高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了\n1. 在每趟排列前，先假设，已经排好了\n2. 一趟下来，如果一次交换都没有发生，flag值就是true\n```javascript\nvar arr = [7, 6, 5, 4, 3, 2, 1];\n// 外层控制趟数, 一趟可以比出一个最大值, 7个数, 比6趟即可\nfor (var j = 0; j < arr.length-1; j++) {\n  // 在每趟排列前, 先假设, 已经排好了\n  var flag = true;\n  for (var i = 0; i < arr.length-1-j; i++) {\n    if (arr[i] > arr[i + 1]) {\n      var temp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i+1] = temp;\n      // 发生了交换, 说明没有排好\n      flag = false;\n    }\n  }\n  // 一趟下来, 如果一次交换都没有发生, flag值就是 true\n  if (flag) {\n    break; \n  }\n}\nconsole.log(arr);\n```\n\n## 15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）\n**好处**：可维护性高\n\n### 15.1 声明函数\n**函数名的规范**：一般都是动词+名词（一般函数都是要做某一件事情）\n```\nfunction 函数名(){\n  函数体;\n}\n```\n> 函数光声明，是不会执行的。\n\t\n#### 15.1.1 调用函数\n```\n函数();\n```\n\n函数一次声明，可以多次调用！！！\n\n#### 15.1.2 函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）\n* 形参---形式参数（函数在声明时，函数名括号内的参数）\n\t形参默认没有值或类型！！！只在函数调用时，形参才会有具体的值或类型\n\t作用：占位置\n\n* 实参---实际参数（函数调用时传递给函数的参数）\n\t实参有具体的值或者类型\n\t作用：在函数调用时将数据传递给形参\n\n> 注意点：形参和实参一一对应！！！\n\n#### 15.1.3 函数的声明和调用进阶写法\n```javascript\nfunction 函数名（形参1，形参2，形参3...）{\n  函数体;\n}\n```\n\n#### 15.1.4 函数的返回值\n函数内部声明的变量 或者 形参，只能在函数内使用，出了函数就用不了了\n如果希望函数的执行，有结果，需要通过``return``返回内容\n\n> 函数的三要素---决定了一个函数怎么去使用\n> 1. ``函数名``：一个函数一次声明，可以多次调用（规范：动词+名词）\n> 2. ``函数参数``：可有可无，但是如果有需要变化的值，一般需要提取成形参\n> 3. ``返回值``：可有可无，但是如果需要拿到函数的执行结果，就必须要return\n\n#### 15.1.5 函数参数与返回值的说明\n* 开发的时候，函数的参数要一一对应\n  1. 传递的参数，如果少了，没接收到值的形参，值就是undefined（数字和undefined加起来就是NaN）\n  2. 传递的参数，如果多了，多传的参数，会被忽略\n\n* 返回值的问题\n\t1.return的值，就是函数的执行结果\n\t2.return后面的代码，不执行了！return表示函数的结束！！\n\n#### 15.1.6 函数调试说明\n* 函数可以在内部调用函数\n* F10 让代码往下一步执行，如果遇到了函数调用，会跳过函数的执行过程，直接看结果\n* F11让代码往下一步执行，如果遇到了函数调用，会进入函数一步步执行\n* shift + F11 跳出函数的执行（将当前函数的调用的剩余代码全部执行完，直接看结果）\n\n\n#### 15.1.7 声明函数的两种方式\n1. ``函数声明式``（可以先调用，后声明---预解析，会提升函数的声明）\n```javascript\nfunction fn( ) {\n  console.log('嘿嘿');\n}\n```\n\n2. ``函数表达式``（只可以先声明赋值，后调用）---写法相对严格\n```\nvar fn = function( ){\n  console.log('哈哈');\n};\n```\n\n### 15.2 匿名函数（没有名字的函数，不能直接使用）\n使用场景：\n\n1. 函数表达式 var fn = function(){...}\n2. 匿名函数自调用（自执行)\n\t> 直接自调用会报错，可以给整个函数包一个( ),包成了一个整体，就可以调用了\n  ```javascript\n  (function ( ) {\n    console.log(123);\n  })( );\n  ```\n\n**沙箱模式--匿名函数自调用的应用=>可以用于解决全局变量污染问题**\n由于全局变量，可以在任何地方都可以访问，所以不能乱用\n一般都会用函数自调用包裹起来\n```\n（function() {...}）\n```\n\n## 16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）\n### 16.1 概念：无序的键值对的集合\n\n### 16.2 创建对象的方式\n\n1. 字面量 \n1 ‘abc’ true undefined null [ ] { }\n``var obj = { }``创建空对象\n\n键值对的集合，多个键值对通过\"，\"隔开\n特征：对象的属性\n行为：对象的方法---对象的函数\n\n2. 构造函数的方式（了解）\nvar obj = new Object({...});\n\t\t\t\n### 16.3 取值和赋值（点语法）\n* 取值：\n语法：对象名.属性名  对象名.方法名( );---方法的调用，得到整个函数\n * 有这个属性名，返回对应值\n * 如果没有这个属性名，返回undefined\n\t\t\t          \n* 赋值：\n语法：对象名.属性名 = '新的值'\n * 如果有这个属性名，覆盖\n * 如果没有这个属性名，新建一个属性并赋值\n\n\n#### 16.3.1 点语法（简洁方便，不支持变量）\n对象名.属性名\n\n#### 16.3.2 中括号语法（支持字符串或变量，更加的灵活）\n对象的取值：对象名['属性名']\n对象的赋值：对象名['属性名'] = \"新的值\"\n**只要访问对象属性时，需要用到变量，只能用中括号语法**\n\t\n### 16.4 对象的遍历（访问对象的所有属性）\n固定语法 （key就是键，属性名）\n```javascript\nfor （var key in obj）{\n  console.log(key);\n  console.log(obj[key]);---打印属性值\n}\n```\n\n### 16.5 批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）\n设计模式（工厂模式、单例模式、观察者模式）\n在对象的方法中，this指代当前对象（对象名）\n#### 16.5.1 工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）\n通过工厂函数创建的对象，没有具体的类型，都是Object\n```javascript\nfunction Student(sno,name,gender,major){\n    obj=new Object();\n    obj.sno=sno;\n    obj.name=name;\n    obj.gender=gender;\n    obj.major=major;\n    obj.say=function(){\n      console.log(\"hello!\");\n    }\n    return obj;\n}\nvar s=new Student(\"123\",\"张三\",\"男\",\"数学\");\nfor(var i in s){\n    document.write(i+\" : \"+s[i]+\"<br>\");\n}\n```\n这里Student()函数相当于一个工厂，在其内部生产对象。这种方式简化了代码，但是无法细分对象，也会造成共有方法和属性的内存浪费。无法细分对象就是生产出的对象的constructor是Object，而不是自定义的\n```\nconsole.log(s.constructor);\n```\n![](https://img-blog.csdnimg.cn/20200831171959364.png#)\n内存浪费就是因为方法声明在了对象的内部，每一个对象都有同一个方法，造成了浪费。\n\n#### 16.5.2 构造函数（给新建的对象，添加属性和方法----实例化对象）\n1. 就是一个函数\n2. 首字母大写\n3. js中，内置了一些构造函数，比如：``Object``，``Array``\n4. 构造函数可以自定义\n\n* 构造函数的使用步骤\n * 自己声明一个构造函数\n * 结合new一起使用，创建一个有类型的对象\n```javascript\nfunction Student(sno,name,gender,major){\n    this.sno=sno;\n    this.name=name;\n    this.gender=gender;\n    this.major=major;\n    this.say=function(){\n        console.log(\"hello!\");\n    }\n}\nvar s=new Student(\"1234\",\"李四\",\"男\",\"物理\");\nfor(var i in s){\n    document.write(i+\" : \"+s[i]+\"<br>\");\n}\n```\n这种模式解决了对象不能细分问题，此时s的constructor就是Student()构造函数了。\n```\nconsole.log(s.constructor);\n```\n![](https://img-blog.csdnimg.cn/20200831184528158.png#)\n但是还是没有解决公有方法造成的内存浪费问题。\n\n#### 16.5.3 构造函数+原型对象模式\n```javascript\nfunction Student(sno,name,gender,major){\n    this.sno=sno;\n    this.name=name;\n    this.gender=gender;\n    this.major=major;\n}\nStudent.prototype.say=function(){\n    console.log(\"hello!\");\n}\nvar s=new Student(\"12345\",\"王五\",\"男\",\"化学\");\nfor(var i in s){\n    document.write(i+\" : \"+s[i]+\"<br>\");\n}\n```\n这种模式和构造函模式类似，不同点是该模式把公有的属性和方法声明到构造函数的原型对象中，解决了内存浪费。\n\n#### 16.5.4 new的作用（创建对象）\n * 会新建一个对象，指定对象的类型\n * 让构造函数的this，指向新创建的对象----this.name = '张三';\n * 执行构造函数（给新建的对象，添加属性和方法）\n * 将新创建的对象返回\n\n\n### 16.6 内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）\n\n#### 16.6.1 Math对象（提供了一系列和数学相关的属性和方法）\n1. PI Math.PI\n2. 求最大最小值 max min\n  var max = Math.max(3,5,6,110);\n  console.log(max);\n3. 取整 ceil floor round\n  （1）ceil向上取整，取大的那个数---天花板函数\n  （2）floor向下取整，取小的那个数---地板函数\n  （3）round四舍五入，离哪个近取哪个\n4. 随机数random ``[0,1)``可以取到0，取不到1\n  公式：求一个整数范围0~N，parseInt(Math.random()*(N+1))\n5. 绝对值abs\n6. 求次方pow\n7. 求开方sqrt\n\n\n#### 16.6.2 Date日期对象\n\njs中提供的Date构造函数，可以创建日期对象\n\n1. 如何创建日期对象\n```javascript\n  var now = new Date(); // 构造函数不传参，创建的是当前时间\n  var date = new Date('2019-4-22 16:00:00'); // 构造函数传日期字符串，指定具体的日期\n```\n\n2. 日期格式化 （不用）---一般日期格式都是自定义的\n```javascript\n  var now = new Date();---当前时间\n  console.log(now.toString()); // 让日期以标准化的日期字符串格式化输出,'Thu Apr 08 2021 11:13:41 GMT+0800 (GMT+08:00)'\n  console.log(now.toLocaleString()); // 本地化日期字符串格式输出,'2021-4-8 11:13:41'\n  console.log(now.toLocaleDateString()); //只显示日期,'2021-4-8'\n  console.log(now.toLocaleTimeString()); //只显示时间,'11:13:41'\n```\n\n3. 日期格式的自定义，xx年xx月xx日--获取日期里面的各个组成部分\n可以封装一个函数，专门给小于10的数，前面加上0\n```javascript\nfunction addZero（n）{\n  if(n<10) {\n    return '0' + n;\n  }\n  else {\n    return n;\n  }\n}\nvar now = new Date(); // 当前时间\nvar year = now.getFullYear(); // 年\nvar month = now.getMonth()+1; // 获取月，getMonth从0开始，范围0-11\nmonth = addZero(month);\n// 获取日getDate\n// 获取一周中的第几天，getDay,范围0-6，周日0，周一1\nvar hours = now.getHours(); // 时，getHours\nvar minutes = now.getMinutes(); // 分，getMinutes\nvar seconds = now.getSeconds(); // 秒，getSeconds\n// now.getMilliseconds毫秒\n```\n\n4. 时间戳（就是数字格式的日期，便于运算，一般用于求时间差）---距离1970年1月1日 0时0分0秒，所过去的毫秒数\n```javascript\n  var now = new Date();\n  console.log(+now);\n```\n\n**应用**\n* 统计一段代码的执行时间---性能优化\n```javascript\nvar begin = new Date();\nvar end = new Date();\nconsole.log(end - begin);\n```\n* 用于秒杀倒计时\n\n## 17、数组对象Array\n\n1. ``.join(分隔符)``：将数组中的值拼接成一个字符串，返回这个字符串\n默认分隔符\" , \"\n\n2. 数组的增删操作``push`` ``pop`` ``unshift``  ``shift`` ***会更改原数组***\n  .push在数组的最后面，添加一个或多个项，返回数组的长度\n  .pop在数组的最后面，删除一个项，返回删除的项\n  .unshift在数组的最前面，添加一个或多个项，返回数组的长度\n  .shift在数组的最前面，删除一项，返回删除的项\n\n3. 翻转``reverse`` ***会更改原数组***\n4. 排序``sort``（默认按照字符串的方式进行排序，先比较第一个字符）***会更改原数组***\n\t**如果要制定排序规则，是需要传参的（参数：一个函数）** \n  ```javascript\n  arr.sort(function(a,b) {\n    return a-b;---从小往大\n    return b-a;---从大往小\n  })\n  ```\n  > a表示前一项，b表示后一项\n  > 函数的返回值>0,a和b交换位置\n  > 函数的返回值=0，不换位置\n  > 函数的返回值<0,不换位置\n\t\n5. 合并 ``arr.concat(arr2,arr3....)``，返回合并后的新数组\n6. 截取``arr.slice``（从数组中，截取一部分出来，返回一个新数组）\n\t* arr.slice();从开始一直截取到最后（将整个数组截取，复制一份）\n\t* arr.slice(begin)从begin（下标）开始一直截取到最后\t\n\t* arr.slice(begin,end)从begin（下标）开始一直截取到end结束（**包括begin,不包括end**）\n\n7. ``splice``方法，可以在数组的任意位置添加、删除、替换任意项---会更改原数组\n  ```\n\tsplice（从哪开始删，删几个，添加的项1，添加的项2...）\n\tsplice(begin,deleteCounts,item1,item2...)\n  ```\n\n8. ``indexOf``查找值在数组中第一次出现的下标（可以用来查重）\n\t``lastIndexOf``查找值在数组中最后一次出现的下标\n如果值在数组中不存在，返回 ``-1``\n\t\n9. 清空一个数组\n```javascript\narr = [ ];\narr.length = 0;\narr.splice(0,arr.length)\n```\n\n\n## 18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）\n\n**js内部，对于除了undefined和null的简单数据类型，都提供了一个对应的复杂数据类型**\n\n简答数据类型：没有属性和方法，只有值\n复杂数据类型：可以有多个属性和方法\n\t\n* 在js中，如果简单数据类型，在访问复杂数据类型的属性或方法时\n* 为了方便，自动将简单数据类型，包装成复杂数据类型，然后获取对应的值\n* 会将值变回简单数据类型\t\n\t\n### 18.1 Number\n\t通过new Number()创建的对象，``toString``   ``toFixed``两个方法\n\tnum.toFixed(3) 保留3位小数\n\n### 18.2 Boolean\t\n\t\t通过new Boolean()创建的对象，toString\n\n### 18.3 String\n1. 字符串可以和数组一样，进行遍历，字符串不是数组，不能混用方法\n2. ``indexOf``和``lastIndexOf`` 查找值在字符串中第一次/最后一次出现的下标\n3. ``trim``去除字符串``首尾``的空格\n4. 转大小写\n ``toUpperCase``转大写\n ``toLowerCase``转小写\n5. 拼接``.concat``将字符串进行拼接，返回新的字符串）\n  一般用``+``\n6. 截取\n  * slice(begin,end) \n    > 从begin开始截取，截取到end结束，包括begin，不包括end\n    > begin（必需）：规定从何处开始选取。如果是负数，那么它规定从字符串尾部开始算起的位置。也就是说，-1 指最后一个字符，-2 指倒数第二个字符，以此类推。\n    > end（可选）：规定从何处结束选取，即结束处的字符下标。如果没有指定该参数，那么截取的字符串包含从 start 到结束的所有字符。如果这个参数是负数，那么它规定的是从数组尾部开始算起的字符。\n    ```javascript\n      var str = \"0123456789\";\n      console.log(\"原始字符串：\", str);\n      console.log(\"从索引为3的字符起一直到结束：\", str.slice(3));  //3456789\n      console.log(\"从倒数第3个字符起一直到结束：\", str.slice(-3));  //789\n      console.log(\"从开始一直到索引为5的前一个字符：\", str.slice(0,5));  //01234\n      console.log(\"从开始一直到倒数第3个字符的前一个字符：\", str.slice(0,-3));  //0123456\n      console.log(\"从索引为3的字符起到索引为5的前一个字符：\", str.slice(3,5));  //34\n      console.log(\"从索引为3的字符起到倒数第3个字符的前一个字符：\", str.slice(3,-3));  //3456\n    ```\n  * substring(begin,end) 从begin开始截取，截取到end结束，包括begin，不包括end\n    ```javascript\n      var str = \"0123456789\";\n      console.log(\"原始字符串：\", str);\n      console.log(\"从索引为3的字符起一直到结束：\", str.substring(3));  //3456789\n      console.log(\"从索引为20的字符起一直到结束：\", str.substring(20));  //\n      console.log(\"从索引为3的字符起到索引为5的前一个字符结束：\", str.substring(3,5));  //34\n      console.log(\"start比end大会自动交换，结果同上：\", str.substring(5,3));  //34\n      console.log(\"从索引为3的字符起到索引为20的前一个字符结束：\", str.substring(3,20));  //3456789\n      console.log(\"substring将负数转化为0:\", str.substring(-3)); //\n    ```\n  * substr(begin,length) 从begin开始截取，截取length个\n    ```javascript\n      var str = \"0123456789\";\n      console.log(\"原始字符串：\", str);\n      console.log(\"从索引为3的字符起一直到结束：\", str.substr(3));  //3456789\n      console.log(\"从索引为20的字符起一直到结束：\", str.substr(20));  //\n      console.log(\"从索引为3的字符起截取长度为5的字符串：\", str.substr(3,5));  //34567\n      console.log(\"从索引为3的字符起截取长度为20的字符串：\", str.substr(3,20));  //3456789\n    ```\n  * 三者比较\n  ```javascript\n    var str = '中华人民共和国万岁'\n    // 一，start为负数，end不传\n    str.slice(-3) // '国万岁'\n    str.substring(-3) // '中华人民共和国万岁'\n    str.substr(-3) // '国万岁'\n    // 说明： 1，slice与substr第一个参数为负数时，将从字符串反方向开始计数，末位记为-1,等同于str.slice(6)，str.substr(6)\n    //       2，substring将负数转化为0，既str.substring(0)\n\n    // 二，start为负数，end为负数时\n    str.slice(-3,-1) // '国万'\n    str.substring(-3,-1) // ''\n    str.substr(-3,-1) // ''\n    // 说明：\n    //    1，slice正常截取字符串，相比substring灵活很多\n    //    2，substring将所有参数转化为0，既str.substring(0,0)\n    //    3，substr end参数不能为负数\n\n    // 三，start与end均大于零，且start > end\n    str.slice(5,3) // ''\n    str.substring(5,3) // '民共'\n    str.substr(5,3) // '和国万'\n    // 说明：\n    //   1，substr正常截取字符串，代表从第五位开始，截取字符串长度为3\n    //   2，当start>end时，substring在提取子串之前会先交换这两个参数，既转换为substring(3,5)；而slice不能进行此转换，所以截取的为空字符串\n\n    // 四，start与end均大于零，且start < end\n    str.slice(3,5) //'民共'\n    str.substring(3,5) // '民共'\n    str.substr(3,5) // '民共和国万' \n    // 说明：三种方法均正常截取字符串，只是substr第二个参数含义不同，代表截取的字符串长度而不是终止位置。\n\n  ```\n7. 通过.split(分隔符):可以将字符串拆分成数组，会返回一个拆分得到的数组\n    通过join:可以将数组的值，拼成字符串，会返回一个拼接成的字符串\n\n8. replace替换，会返回替换的结果\n```javascript\nstr.replace('aa','bb'); // 将字符串中的第一个aa替换成bb\n```\n\n想要全部替换，需要用到正则``str.replace(/aa/g,'bb')``;\n\n\t\n## 19、值类型和引用类型\n从内存的存储角度，分成了``值类型``和``引用类型``（内存是可以释放，可以重复利用的）\n\n**值类型（简单数据类型）**：存储在变量中，存的是值本身\n**引用类型（复杂数据类型）**：存储在变量中，存的是``内存地址``----会单独在内存中开辟一块空间存储\n\n### 19.1 值类型和引用类型的赋值类型\n* 值类型：存储在变量中 ，存的是``值本身``，所以在赋值给其他变量时，赋值的是``值本身``\n* 引用类型：存储在变量中，存的是``内存地址``，所以在赋值给其他变量时，赋值的是``内存地址``\n\n### 19.2 值类型和引用类型的值传递（让值作为函数的参数进行传递）\n* 值类型：存储在变量中，存的是值本身，所以在值传递时，传的也是值本身\n* 引用类型：存储在变量中，存的是内存地址，所以在值传递时，传的也是内存地址\n\t\n\t\t\n\n\t\t\t\t\n## 20、typeof 关键字\n1. typeof获取简单数据类型，可以直接返回对应的类型\n***特例***：typeof null  返回object\n2. typeof获取复杂数据类型，一般返回object\n***特例***：typeof 函数  返回function    函数是js的一等公民\n\n## 21、逻辑中断（短路运算）&& ||\n&&找假值，只要遇到了假值，就中断短路（后面的不看了）\n||找真值，只要看到了真值，就中断短路（后面的不看了）\n\n```javascript\nfunction demo(fn){\n  fn&&fn(); //fn存在，才去调用\n}\t\ndemo(function(){\n  console.log(111);\n});\ndemo();\n```\n\t\n**逻辑``或``，一般可以用于设置默认值,也可以解决兼容性**\n```javascript\nfunction getSum(a,b){\n  a=a || 0;\n  b=b || 0;\n  var sum = a+b;\n  return sum;\n}\n```\n\n\n## 22、如何拷贝一个对象\n封装一个方法，可以拷贝一个对象，返回（浅拷贝，只拷贝了 一层）\n```javascript\nfunction copy(obj){\n  var newObj = {};\n  for (var k in obj){\n    newObj[k] = obj[k];\n  }\n}\n```\n\n* 浅拷贝，只拷贝了一层，如果全是简单类型的属性，没有问题\n\t但是如果有复杂类型的属性（对象），此时拷贝的只是地址，需要处理的\n* 深拷贝\n```\n\tnewObj[k] = typeof obj[k] === 'object' ? copy(obj[k]) : obj[k];\n```\n\n```javascript\n// 1.遍历+递归\nfunction deepClone(obj){\n  let newObj =  {}\n  for(let key in obj){\n      if(obj.hasOwnProperty(key)){\n          if(typeof(obj[key]) === 'object' && obj[key] !== null){\n            newObj[key] = (Array.isArray(obj[key])  ? [] : {})\n            newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : deepClone(obj[key]));  \n          }else{\n              newObj[key] = obj[key];\n          }\n      }\n  }\n  return newObj;\n}\n\n// 2.Object.assign + 递归\nfunction deepClone(obj){\n  let newObj = {}\n  for(let key in obj){\n    if(obj.hasOwnProperty(key)){\n      newObj[key] = (typeof obj[key] === 'object' ? Object.assign(obj[key]) : obj[key])\n    }\n  }\n  return newObj\n}\n\n// 3.对象扩展+递归\nfunction deepClone(obj){\n  var newObj ={}\n  for(let key in obj){\n    if(obj.hasOwnProperty(key)){\n      if(typeof obj[key] === 'object'){\n        newObj[key] = (Array.isArray(obj[key]) ? [] : {})\n        newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : {...obj[key]}) \n      } \n      else{\n        newObj[key] = obj[key]\n      }\n    }\n  }\n  return newObj\n}\n\n// 4.JSON复制（对NaN和undefined无法正确复制，会丢失）\nfunction deepClone(obj) {\n  var newObj = JSON.parse(JSON.stringify(obj))\n  return newObj\n}\n```\n\n\n## 23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！\n## 24、面向对象：关注的是找一个对象，去做某件事\n***面向对象不是面向过程的替代，是面向过程的封装***\n### 24.1 特性：\n1. 封装性\n2. 继承性\n3. 多态性（js中没有）\n\t\n## 25、原型\n\nJavaScript是一门基于原型的语言，在软件设计模式中，有一种模式叫做原型模式，JavaScript正是利用这种模式而被创建出来\n\n### 25.1 原型模式 \n原型模式是用于创建重复的对象，同时又能保证性能，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。\n原型模式的``目的``是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，也就是说利用已有的一个原型对象，可以快速地生成和原型对象一样的新对象实例\n\n### 25.2 原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板\n1. 原型是定义了一些公用的属性和方法，利用原型创建出来的新对象实例会共享原型的所有属性和方法\n实例代码：\n```javascript\n// 创建原型\nvar Person = function(name){\n    this.name = name;\n};\n\n// 原型的方法\nPerson.prototype.sayHello = function(){\n    console.log(this.name+\",hello\");\n};\n\n// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法\nvar person1 = new Person(\"zhangsan\");\nvar person2 = new Person(\"lisi\");\n\n// zhangsan,hello\nperson1.sayHello();\n// lisi,hello\nperson2.sayHello();\n```\n\n2. 严格模式下，原型的属性和方法还是会被原型实例所共享的\n实例代码：\n```javascript\n// 开启严格模式，原型的属性和方法还是会被原型实例所共享的\n\"use strict\";\n\n// 创建原型\nvar Person = function(name){\n    this.name = name;\n};\n\n// 原型的方法\nPerson.prototype.sayHello = function(){\n    console.log(this.name+\",hello\");\n};\n\n// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法\nvar person1 = new Person(\"zhangsan\");\nvar person2 = new Person(\"lisi\");\n\n// zhangsan,hello\nperson1.sayHello();\n// lisi,hello\nperson2.sayHello();\n```\n\n3. 通过原型创建的新对象实例是相互独立的，为新对象实例添加的方法只有该实例拥有这个方法，其它实例是没有这个方法的\n实例代码：\n```javascript\n// 创建原型\nvar Person = function(name){\n  this.name = name;\n};\n\n// 原型的方法\nPerson.prototype.sayHello = function(){\n  console.log(this.name+\",hello\");\n};\n\n// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法\nvar person1 = new Person(\"zhangsan\");\nvar person2 = new Person(\"lisi\");\n\n// zhangsan,hello\nperson1.sayHello();\n// lisi,hello\nperson2.sayHello();\n\n\n// 为新对象实例添加方法\n// 通过原型创建的新对象实例是相互独立的\nperson1.getName = function(){\n    console.log(this.name);\n}\n\n// zhangsan\nperson1.getName();\n// Uncaught TypeError: person2.getName is not a function\nperson2.getName();\n```\n\n4. 原型的总结：\n\n* 所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象\n* 所有函数都有一个prototype(原型)属性，属性值是一个普通的对象\n* 所有引用类型的__proto__属性指向它构造函数的prototype\n\n5. 函数的原型prototype：函数才有prototype，prototype是一个对象，指向了当前构造函数的引用地址\n6. 函数的原型对象__proto__：所有对象都有__proto__属性， 当用构造函数实例化（new）一个对象时，会将新对象的__proto__属性指向 构造函数的prototype\n\n7. 原型对象和函数的原型的关系\n![原型对象和函数的原型的关系](https://img-blog.csdnimg.cn/20190623221321362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)\n\n> 说明：\n> * 所有函数的__proto__都是指向Function的prototype\n> * 构造函数new出来的对象__proto__指向构造函数的prototype\n> * 非构造函数实例化出的对象或者对象的prototype的__proto__指向Object的prototype\n>   Object的prototype指向null\n\n8. 所有的原型对象都会自动获得一个``constructor``（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）\n9. 实例的构造函数属性（constructor）指向构造函数 ：person1.constructor == Person\n10. 原型对象（Person.prototype）是 构造函数（Person）的一个实例\n11. 原型的分类：\n* ``隐式原型（_proto_）``：上面说的这个原型是JavaScript中的内置属性[[prototype]]，此属性继承自object对象，在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_，隐式原型的作用是用来构成原型链，实现基于原型的继承\n* ``显示原型``（prototype）``：每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享\n12. 原型的使用方式：\n通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型\n在赋值原型prototype的时候使用function立即执行的表达式来赋值，可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果\n\n#### 25.2.1 原型链\n原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构\n\n#### 25.2.2 原型设计的问题\n当查找一个对象的属性时，JavaScript 会根据原型链向上遍历对象的原型，直到找到给定名称的属性为止，直到到达原型链的顶部仍然没有找到指定的属性，就会返回 undefined\n也可以理解为原型链继承时查找属性的过程是先查找自身属性，当自身属性不存在时，会在原型链中逐级查找\n\n#### 25.2.3 hasOwnProperty 函数：\n可以用来检查对象自身是否含有某个属性，返回值是布尔值，当属性不存在时不会向上查找对象原型链，*hasOwnProperty是 JavaScript 中``唯一一个``处理属性但是不查找原型链的函数*\n\n#### 25.2.4 getOwnPropertyNames 函数\n可以获取对象所有的自身属性，返回值是由对象自身属性名称组成的数组，同样不会向上查找对象原型链\n\n#### 25.2.5 原型链的小结：\n一直往上层查找，直到到null还没有找到，则返回undefined\nObject.prototype.__proto__ === null\n所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象\n\n6）JavaScript的原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法\n\n#### 25.2.6 常见面试题\n\n* 谈谈你对原型的理解？\n在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法\n\n* 什么是原型链？原型链解决的是什么问题？\n 1. 原型链解决的主要是继承问题\n 2. 每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法\n 3. 构造函数 Parent、Parent.prototype 和 实例 p 的关系如下:(p.__proto__ === Parent.prototype)\n![](https://img-blog.csdnimg.cn/20190623221912165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)\n\n* prototype 和 proto 区别是什么？\n 1. prototype是构造函数的属性\n 2. __proto__是每个实例都有的属性，可以访问 [[prototype]] 属性\n 3. 实例的__proto__与其构造函数的prototype指向的是同一个对象\n\n### 25.3 补充（原先的）\n#### 25.3.1 属性搜索原则：自己有就访问自己的，自己没有，去原型链中就近查找\n1. 如果自己有这个属性，就访问自己的\n2. 如果自己没有这个属性，会到原型中找，如果找到，不找了，直接返回\n3. 如果原型中也没有，会到原型的原型中找...\n4. 一直找到Object.prototype，如果老祖宗也没有，返回undefined\n\n#### 25.3.2 设置属性：\n如果有这个属性，直接修改赋值\n如果自己没有这个属性，给自己添加一个新属性（不会改到原型）\n\n#### 25.3.3 Object.prototype的成员\n1. ``hasOwnProperty``\n\t语法：``对象.hasOwnProperty('属性名')`` ---判断属性是否是自己的，而不是原型的（不是继承来的）\n\tfor in 遍历，不仅自己的属性可以遍历，原型上的属性也会遍历到（对于constructor等浏览器内置的属性，被浏览器进行来了处理，不会被for in便利出来）\n\t遍历时，只打印自身的（用hasOwnProperty进行判断）\n\tin操作符：判断属性是否可以被对象所访问（只要能够访问到这个属性，就返回true）---这个不是成员\n\t语法：'属性名' in 对象\n\n2. ``A.isPrototypeOf(B)``:判断A是不是B的原型\n\t\n3. ``对象.propertyIsEnumerable('属性名')`` 判断属性是否可以遍历（可枚举）\n4. toSting()\n5. valueof()\n\n6. instanceof运算符\n\t语法：A instanceof B（判断A是否是B的实例，B构造函数）\n\t进阶原理：判断B.prototype在不在A的原型链上\n\t使用typeof无法区分具体的对象类型！！！\n\n```javascript\nconsole.log(p.constructor.name)---可以用来打印类型\nObject.prototype.toString.call([]) ---可以用来获取复杂数据是什么类型 ---[object Array]\n```\n\n\n## 26、js数据类型\n堆和栈（只是将Java中概念，拿过来类比了）\njs中没有特别明确的堆和栈的概念，而且js的实现，也不需要堆和栈的概念\njava中堆内存和栈内存\n1.所有的``简单数据``类型，存在``栈``中\n2.所有的``复杂数据``类型，存在``堆``中---真实存在变量中的，也是地址\n\n\n\n## 27、this的规则：\nxx.fn();---fn函数调用时里面的this，指向调用者（谁调用的，this就指向谁）\n1. 如果是直接调用的方法，this指向window\n\t\t（1）function fn(){console.log(this)}\n\t\t         fn();\n\t\t（2）setInterval(function(){console.log(this)},2000)---定时器中的this指向window\n2. 如果对象中的方法，被调用了，this指向调用者，谁调用的，指向谁\n3. 特例，构造函数中执行的this，this指向新创建的对象\n\n全局的var a = 123;  等价于 window.a = 123;\n\n\n## 28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️\n### 28.1 原型链继承\n```javascript\nfunction Person() {\n  this.name = 'Hello World';\n}\nPerson.prototype.getName = function() {\n  console.log(this.name)\n}\nfunction Child() {\n\n}\nChild.prototype = new Person()\nvar child1 = new Child()\nchild1.getName() // Hello World\n```\n***重点：***\n让新实例的原型等于父类的实例。\n\n***优点：***\n实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的 属性！）\n\n***缺点：***\n1. 新实例无法向父类构造函数传参。\n2. 继承单一。\n3. 所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性 也会被修改！）\n\n### 28.2 构造函数继承\n```javascript\nfunction Person(){\n  this.name = 'xiaoming';\n  this.colors = ['red', 'blue', 'green'];\n}\n\nPerson.prototype.getName = function(){\n  console.log(this.name);\n}\n\nfunction Child(age){\n  Person.call(this);\n  this.age = age\n}\n\nvar child1 = new Child(23);\nvar child2 = new Child(12);\nchild1.colors.push('yellow');\nconsole.log(child1.name); // xiaoming\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(child2.colors); // [\"red\", \"blue\", \"green\"]\n```\n\n***重点：***\n用.call()和.apply()将父类构造函数引入子类函数（在子类 函数中做了父类函数的自执行（复制））\n\n***优点：***\n 1. 只继承了父类构造函数的属性，没有继承父类原型的属性。\n 2. 解决了原型链继承缺点1、2、3。\n 3. 可以继承多个构造函数属性（call多个）。\n 4. 在子实例中可向父实例传参。\n\n***缺点：***\n 1. 只能继承父类构造函数的属性。\n 2. 无法实现构造函数的复用。（每次用每次都要重新调用）\n 3. 每个新实例都有父类构造函数的副本，臃肿。\n\n### 28.3 组合继承（组合原型链继承和借用构造函数继承）（常用）\n```javascript\nfunction Parent(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function(){\n    console.log(this.name);\n}\n\nfunction Child(name,age){\n    Parent.call(this,name);// 第二次调用 Parent()\n    this.age = age;\n}\n\nChild.prototype = new Parent(); // 第一次调用 Parent()\n\nvar child1 = new Child('xiaopao',18);\nvar child2 = new Child('lulu',19);\n```\n\n***重点：***\n结合了两种模式的优点，传参和复用\n\n***优点：***\n1. 可以继承父类原型上的属性，可以传参，可复用。\n2、每个新实例引入的构造函数属性是私有的。\n\n***缺点：***\n调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。\n\n### 28.4 原型式继承\n```javascript\nfunction CreateObj(o){\n    function F(){}\n    F.prototype = o;\n    console.log(o.__proto__ === Object.prototype);\n    console.log(F.prototype.constructor === Object); // true\n    return new F();\n}\n\nvar person = {\n    name: 'xiaopao',\n    friend: ['daisy','kelly']\n}\n\nvar person1 = CreateObj(person);\n\n// var person2 = CreateObj(person);\n\nperson1.name = 'person1';\n// console.log(person2.name); // xiaopao\nperson1.friend.push('taylor');\n// console.log(person2.friend); // [\"daisy\", \"kelly\", \"taylor\"]\n// console.log(person); // {name: \"xiaopao\", friend: Array(3)}\nperson1.friend = ['lulu'];\n// console.log(person1.friend); // [\"lulu\"]\n// console.log(person.friend); //  [\"daisy\", \"kelly\", \"taylor\"]\n// 注意： 这里修改了person1.name的值，person2.name的值并未改变，并不是因为person1和person2有独立的name值，而是person1.name='person1'是给person1添加了name值，并非修改了原型上的name值\n// 因为我们找对象上的属性时，总是先找实例上对象，没有找到的话再去原型对象上的属性。实例对象和原型对象上如果有同名属性，总是先取实例对象上的值\n```\n\n***重点：***\n用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。\n\n***优点：***\n类似于复制一个对象，用函数来包装。\n\n***缺点：***\n1. 所有实例都会继承原型上的属性。\n2. 无法实现复用。（新实例属性都是后面添加的）\n\n### 28.5 寄生式继承\n```javascript\nvar ob = {\n    name: 'xiaopao',\n    friends: ['lulu','huahua']\n}\n\nfunction CreateObj(o){\n    function F(){};  // 创建一个构造函数F\n    F.prototype = o;\n    return new F();\n}\n\n// 上面CreateObj函数 在ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的 , 看下面代码\nvar ob1 = CreateObj(ob);\nvar ob2 = Object.create(ob);\nconsole.log(ob1.name); // xiaopao\nconsole.log(ob2.name); // xiaopao\n\nfunction CreateChild(o){\n    var newob = CreateObj(o); // 创建对象 或者用 var newob = Object.create(ob)\n    newob.sayName = function(){ // 增强对象\n        console.log(this.name);\n    }\n    return newob; // 指定对象\n}\n\nvar p1 = CreateChild(ob);\np1.sayName(); // xiaopao \n```\n***重点：***\n就是给原型式继承外面套了个壳子。\n\n***优点：***\n没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。\n\n***缺点：***\n没用到原型，无法复用。\n\n### 28.6 寄生组合式继承（常用）\n```javascript\nfunction Parent(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nfunction Child(name,age){\n    Parent.call(this,name); \n    this.age = age;\n}\n\nfunction CreateObj(o){\n    function F(){};\n    F.prototype = o;\n    return new F();\n}\n\n// Child.prototype = new Parent(); // 这里换成下面\nfunction prototype(child,parent){\n    var prototype = CreateObj(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\nprototype(Child,Parent);\n\nvar child1 = new Child('xiaopao', 18);\nconsole.log(child1); \n```\n***重点：***\n修复了组合继承的问题\n\n### 28.7 class继承\n```javascript\nclass Parent5 {\n  constructor() {\n    this.name = ['super5']\n  }\n  reName() {\n    this.name.push('new 5')\n  }\n}\nclass Child5 extends Parent5 {\n  constructor() {\n    super()\n  }\n}\nvar child51 = new Child5()\nvar child52 = new Child5()\n```\n\n## 29、定义函数的三种方式\n### 29.1 函数声明式\n```\nfunction fn(){}\nfn();\n```\n### 29.2 函数表达式\n```\nvar fn = function(){};\nfn();\n```\n### 29.3 构造函数的方式 \n```\nnew Function(...)\n```\n作用：可以直接执行字符串\n参数：都是字符串类型，最后一个参数是函数体，前面其他所有参数是定义的形参\n\t\t 只有一个参数，就会当成函数体\n```javascript\nvar fn = new Function('a' , 'b' , 'console.log(a+b)');\nfn(1,2);\n```\n\n## 30、try和catch\n\t\n* try和catch必须一起使用\n*\ttry表示尝试执行某段代码，就算发生了错误，js也会继续执行\n*\tcatch，只要try中代码发生了错误，就会执行catch中的代码\n*\tfinally:不管try中的代码执行是否成功，都会执行finally的代码\n```javascript\n\ttry {  ----尝试执行某段代码\n\t\tvar fn = new Function(value);\n\t\tfn();\n\t}\n\tcatch（e）{ ---- 抓取，可以抓取到try执行中的错误，可以进行处理，可以不处理\n\t\tconsole.log(e)\n\t}\n\tfinally{\n\t}\t\n```\n\n## 31、eval(str)可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）\n```javascript\nvar a = 100;\nvar str = 'var a = 1; var b = 2; console.log(a + b)';\neval(str); \n```\n\n## 32、四种调用模式\n\n* 函数：指的是普通的，不属于任何对象的函数\n* 方法：作为对象的属性存在的函数（对象中的函数）\n*\t函数内的this指向谁，只跟怎么调用有关系，跟函数定义在什么地方，没有任何关系\n\n### 32.1 函数调用模式\n```javascript\nfn( );   // this指向window\n```    \n\n### 32.2 方法调用模式\n```javascript\nobj.fn();  // this指向obj，谁调用指向谁\n```\n> 可以把数组当成一个对象，访问0属性，就是方法，方法调用模式，指向arr\n\n### 32.3 构造函数调用模式\n```javascript\nvar p = new Person();  // this指向实例p---new改变了this的指向，让this指向了新的实例\n```\n\t\n### 32.4 上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）\n\n1. call\n\t\t\n * 任何函数（都可以看成一个特殊的对象，也可以设置属性和方法）都有一个call方法\n * call方法也可以用于调用函数,还可以指定函数执行的this的指向---fn.call(this指向);\n * 如果不传参，默认this指向window，如果传递第一个参数，那么就会指定this的指向\n\t\t\n ***使用call来调用函数和普通调用函数的方式，唯一的区别，就是多了一个参数，call的第一个参数用于指定this指向***\n\n``数组``：有着数组的方法，可以遍历\n``伪数组``，本质上是对象，不是数组，数组的方法不能直接调用，但是伪数组是可以遍历的\n常见的伪数组：``arguments`` ``document.querySelector()``  ``jQuery``\n\n> 小结：学习call方法，fn.call(this指向,x,y,z);\n>\t\t   call方法调用函数和普通函数调用的唯一区别，在于多了一个参数，第一个参数，用于指定this\n>\t\t   call方法，可以用于函数借调（借用别人的函数，借来调用）\n>\t\t   别人.方法.call(自己)；将this改成自己，借用别人的方法\n\n2. apply\n\t\t\n * apply的功能和call的功能是一样的，只是调用的方法不同了\n * 每个函数，都有一个apply方法，可以用于调用函数，且可以指定this指向\n * ***apply的语法：fn.apply(this指向，[x,y,z]);***\n   * 参数1：用于指定this的指向\n   * 参数2：接收一个数组，里面存放着所有传递的参数\n\t\n\t> 如果参数比较少，一般使用call，比较简单\n\t> 如果参数比较多，一般使用apply，可以将所有需要传递的参数，放在一个数组中，一次性传递\n\t\n3. bind（复制一个新函数，并且将新函数的this固定死指向传入的this值）\n  ```javascript\n\t\tvar newFn = fn.bind(this指向)\n  ```\n\n4. arguments\n\n* 任何一个函数，都有一个对象，arguments，是一个伪数组，用于收集所有传递的参数（实参）\n* 一般用于参数不确定的情况\n\n  new会和最近的 函数名() 结合，是一个整体，new fn()\n\n> 补充：（1）定时器中的this ，指向window\n>       (2）事件处理函数中，浏览器让this指向了事件源\n\n\n\t\t\t\n## 33、函数也是对象\n函数也是一种特殊的对象，可以添加属性和方法\n\n## 34、js的规则：\n1. 任何``函数``，都是由``Function``创建出来的，包括他自己，包括Object函数\n2. 任何的``原型对象``，都是直接由``Object``创建出来的\n\njs中的作用域：词法作用域，静态作用域，函数的作用域在函数声明时，就已经确定好了，跟调用没有关系\n作用域链：每个函数都有自己的作用域，如果是定义在函数内的函数，里面的函数又会有自己的作用域（一层套一层，形成了作用域链）\n变量的查询规则：先看自己作用域有没有这个变量，如果没有，往外一层一层的就近查找，如果一直找到全局都没有找到，就会报错\n\n\n\n## 35、递归函数：在一个函数内部，自己调用自己\n\n函数在调用时，其实是占用内存，函数在调用时，会开辟一块内存，进行执行\n\n**特点：**\n1. 自己调用自己\n2. 必须要有结束条件，要有出口\n\n*递归：是一种算法，一种思想 ，化归思想，复杂的问题简单化*\n\n### 35.1 斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和\n```javascript\n// 直接这么写会有性能问题\nfunction getFib(n) {\n  if (n === 1 || n === 2) {\n    return 1;\n  }\n  return getFib(n-1) + getFib(n-2);\n}\n```\n\n***为什么会有性能问题？***\n一个函数内部，调用了两次自己，真正执行时进行了大量的重复运算\n\n***如何优化：将已经算过的第n个斐波那契数列存起来***\n运算过程中：\n 1. 先判断这个数，有没有算过，如果算过了，直接用\n 2. 如果没有算过，接着自己算，算完，存起来\n```javascript\n// 找规律: getFib(n) = getFib(n-1) + getFib(n-2);\nvar arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数\nfunction getFib(n) {\n  if (n === 1 || n === 2) {\n    return 1;\n  }\n\n  if (arr[n]) {\n    return arr[n];\n  }\n  else {\n    arr[n] = getFib(n-1) + getFib(n-2);\n    return arr[n];\n  }\n}\n```\n  \n  \n***利用闭包解决斐波那契数列***\n```javascript\n// 省去了外部的函数名, 利用函数自调用\n\nvar result = (function() {\n  var arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数\n  function getFib(n) {\n    if (n === 1 || n === 2) {\n      return 1;\n    }\n\n    if (arr[n]) {\n      return arr[n];\n    }\n    else {\n      arr[n] = getFib(n - 1) + getFib(n - 2);\n      return arr[n];\n    }\n  }\n  return getFib;\n})();\n```\n\n## 36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包\n* 作用：保护变量（变量私有化）\n*\t闭包的内存，不会直接释放（会占用内存）\n*\t函数执行调用时，必然会开辟一快内存空间，一般来说，执行完就会释放\n\n***闭包的基本模型：***\n1. outer里面包inner\n2. 匿名函数自调用\n```javascript\nvar result = (function(){\n  var count = 0;\n  return function(){\n    count++;\n    console.log(count);\n  }\n})();\n```\n\n## 37、js垃圾回收机制（会将一些不用的内存空间，释放掉）\n\n**内存泄漏：**如果一块内存空间，一直得不到释放，就认为这块内存泄漏了\n**机制：**\n 1. 引用计数：如果一块空间的引用次数，最终变成0，就会被释放掉\n\t\tbug：如果两个对象，互相引用，形成了循环引用，使用引用计数，就会得不到释放（内存泄漏）\n 2. 标记清除：如果一块内存空间，可以访问到，就不释放；如果访问不到了，就会释放掉\n\t\t闭包用完了，只需要将指向函数内部的引用干掉，此时内存就会释放了\n\n\t\n## 38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）\n\n### 38.1 创建正则表达式：\n1. 通过构造函数 \n```javascript\nvar reg = new RegExp(//);\n```\n\\d 表示数字，0-9，/\\d/可以匹配所有的数字\n通过 ``test`` 方法，判断字符串，是否符合正则规则\n2. 字面量\n```javascript\nvar reg = /\\d/;\n```\n\n\t\n### 38.2 正则-元字符\n\n#### 38.2.1 普通字符：a b c\n#### 38.2.2 元字符：有特殊含义的\n\n1. ``\\d`` 数字，0-9\n2. ``\\D`` 非数字\n3. ``\\w`` 匹配单词字符（字母数字下划线），0-9  a-z  A-Z  _\n4. ``\\W`` 非\\w（只要不是\\w中的字符，都匹配）\n5. ``\\s`` 匹配不可见字符（换行``\\n`` ``空格`` ）\n6. ``\\S`` 匹配可见字符\n7. ``.`` 匹配任意字符（除了``\\n``）----a.b可以匹配acb  aab a1b......\n  有时，就需要匹配点，需要转义 \\.-->表示普通的点\n\n### 38.3 正则表达式的优先级\n``|`` 表示或，优先级最低\n``()`` 优先级最高，一般用于提升优先级\n\n### 38.4 正则表达式的字符\n``[ ]``这个位置，可以出现的字符---[abc]，这个位置，可以出现a或者b或者c\n``[a-z]``，这个位置，可以出现a-z的所有小写字符\n``[a-zA-Z0-9_]``，这个位置，可以出现所有的字母、数字、下划线\n[ ]内的 ^ 表示非\n\t\n### 38.5 正则的边界（严格匹配）\n``^``必须以...开头\n``$`` 必须以...结尾\nconsole.log(/^$/);---严格匹配，严格到字符数都是确定的\n\n### 38.6 正则的量词\n``*`` 出现0次或多次\n``+`` 出现1次或多次\n``?`` 出现0次或1次\n``{m,n}`` 表示可以出现m次到n次\n``{m,}`` 表示至少出现m次\n``{m}`` 出现m次\n汉字也是字符的一种，也有范围[\\u4e00-u9fa5\\]---一 yu\n\t\n### 38.7 正则的replace（不严格的替换）\n正则也比较懒，不加参数，只替换一次（加上g，表示 全局替换）\n```javascript\nstr.replace(/aa/g,'xx')\n```\n\n## 39、js校正计算\n/**\n ** 加法函数，用来得到精确的加法结果\n ** 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。\n ** 调用：accAdd(arg1,arg2)\n ** 返回值：arg1加上arg2的精确结果\n **/\n```javascript\nfunction accAdd(arg1, arg2) {\n    var r1, r2, m, c;\n    try {\n        r1 = arg1.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = arg2.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n        r2 = 0;\n    }\n    c = Math.abs(r1 - r2);\n    m = Math.pow(10, Math.max(r1, r2));\n    if (c > 0) {\n        var cm = Math.pow(10, c);\n        if (r1 > r2) {\n            arg1 = Number(arg1.toString().replace(\".\", \"\"));\n            arg2 = Number(arg2.toString().replace(\".\", \"\")) * cm;\n        } else {\n            arg1 = Number(arg1.toString().replace(\".\", \"\")) * cm;\n            arg2 = Number(arg2.toString().replace(\".\", \"\"));\n        }\n    } else {\n        arg1 = Number(arg1.toString().replace(\".\", \"\"));\n        arg2 = Number(arg2.toString().replace(\".\", \"\"));\n    }\n    return (arg1 + arg2) / m;\n}\n \n//给Number类型增加一个add方法，调用起来更加方便。\nNumber.prototype.add = function (arg) {\n    return accAdd(arg, this);\n};\n```\n\n\n\n/**\n ** 减法函数，用来得到精确的减法结果\n ** 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。\n ** 调用：accSub(arg1,arg2)\n ** 返回值：arg1加上arg2的精确结果\n **/\n```javascript\nfunction accSub(arg1, arg2) {\n    var r1, r2, m, n;\n    try {\n        r1 = arg1.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = arg2.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n        r2 = 0;\n    }\n    m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度\n    n = (r1 >= r2) ? r1 : r2;\n    return ((arg2 * m - arg1 * m) / m).toFixed(n);\n}\n \n// 给Number类型增加一个mul方法，调用起来更加方便。\nNumber.prototype.sub = function (arg) {\n    return accSub(arg, this);\n};\n```\n\n\n\n/**\n ** 乘法函数，用来得到精确的乘法结果\n ** 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。\n ** 调用：accMul(arg1,arg2)\n ** 返回值：arg1乘以 arg2的精确结果\n **/\n```javascript\nfunction accMul(arg1, arg2) {\n    var m = 0, s1 = arg1.toString(), s2 = arg2.toString();\n    try {\n        m += s1.split(\".\")[1].length;\n    }\n    catch (e) {\n    }\n    try {\n        m += s2.split(\".\")[1].length;\n    }\n    catch (e) {\n    }\n    return Number(s1.replace(\".\", \"\")) * Number(s2.replace(\".\", \"\")) / Math.pow(10, m);\n}\n \n// 给Number类型增加一个mul方法，调用起来更加方便。\nNumber.prototype.mul = function (arg) {\n    return accMul(arg, this);\n};\n```\n\n\n\n\n/** \n ** 除法函数，用来得到精确的除法结果\n ** 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。\n ** 调用：accDiv(arg1,arg2)\n ** 返回值：arg1除以arg2的精确结果\n **/\n```javascript\nfunction accDiv(arg1, arg2) {\n    var t1 = 0, t2 = 0, r1, r2;\n    try {\n        t1 = arg1.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n    }\n    try {\n        t2 = arg2.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n    }\n    with (Math) {\n        r1 = Number(arg1.toString().replace(\".\", \"\"));\n        r2 = Number(arg2.toString().replace(\".\", \"\"));\n        return (r1 / r2) * pow(10, t2 - t1);\n    }\n}\n \n//给Number类型增加一个div方法，调用起来更加方便。\nNumber.prototype.div = function (arg) {\n    return accDiv(this, arg);\n};\n```\n\t\t\n","source":"_posts/javascript.md","raw":"---\ntitle: JavaScript\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 08：38：25\ncomments: true\ntags: \n - web\nkeywords: javascript\ndescription: javascript\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg\n---\n\n\n## 1、介绍\n\njs全称javascript，是一门运行在浏览器端的脚本语言，现在也可以运行在服务器端（node.js）\n\n## 2、组成\n现在说的javasript包含3个组成部分\n\n1. **ECMAScript** 语法标准，语法规则\n2. **DOM** 专门用于操作页面元素的方法\n3. **BOM** 专门用于操作浏览器的方法\n\n``webapi``有时用来统称1和2\n\n## 3、js书写位置\n1. 直接将内容编写在script标签中\n2. 可以直接在一个单独的js文件中编写，需要引入\n\n>注意点：只要script标签，设置了src属性，标签内的内容将被忽略\n\n## 4、js的注释\n\n注释给开发者看的，浏览器不会执行，方便维护\n\n* 单行注释// 快捷键``ctrl+/``\n* 多行注释/**/ 快捷键``alt+shift+a``\n\n## 5、js的输出语句\n> 指的就是往页面中输出的方式\n* ``alert`` 警告框\n* ``confirm`` 确认框（可以选择的）\n* ``prompt`` 输入框，可以让用户输入内容\n* ``document.write`` 往页面中追加输入内容\n* 支持标签的解析（识别标签）\n* ``console.log`` 在控制台打印内容，专门用于调试的，给开发者看\n\n## 6、变量（就是可以变化的量）\n\n### 6.1 作用\n存储数据，为了将来可以运算使用\n\n1. 先声明，后赋值\n```javascript\nvar age;\nage = 18;\n```\n2. 同时声明和赋值\n```javascript\n\tvar age1 = 18;\n\tconsole.log(age1);\n```\n3.  只声明，不赋值（``undefined``未定义，只要变量声明了但是未赋值，默认值就是undefined）\n4.  不声明，直接赋值(**不推荐**，变量一定要声明了，再使用)\n```javascript\nage3=30;\nconsole.log(age3);\n```\n5. 不声明，不赋值，直接用  xxx is not defined 一定是没有声明赋值的变量直接用了，会报错\n6. 可以同时声明赋值多个变量（本质上，只是省略了var）\n\n### 6.2 变量命名规则和规范\n#### 6.2.1 规则\n\n* 变量名必须由字母 数字 下划线和 $组成，不能以数字开头（后来也引入中文，但是不要这么做）\n* 变量名不能是关键字或者是保留字\n* 变量区分大小写\n\n#### 6.2.2 规范\n\n* 声明的变量要有意义\n* 声明的变量，如果很长，遵循驼峰命名（从第二个字母开始，首字母大写，用于分割单词，可读性高）\n\n### 6.3 变量的作用域（变量起作用的区域）\n* 全局作用域（在script标签内，在函数外的区域）\n\t声明在全局作用域的变量，就叫全局变量\n\t特征：在任何地方都可以使用\n* 局部作用域（函数内部的区域，就是局部作用域）\n\t声明在函数内部的变量，就叫局部变量\n\t特征：只在当前函数内可以使用，出了函数，就不能用了\n\n### 6.4 变量的访问规则\n如果自己的作用域内有这个变量，直接用，改自己的\n如果没有，才会往外面找（找全局）,用外面的，改外面的 \n\n### 6.5 隐式全局变量\n如果一个没有声明过的变量，直接赋值，就叫隐式全局变量（将来要避免）\n\n### 6.6 预解析（预先解析，浏览器会先查看有多少的变量和函数）\n1. 所有的变量声明，都会提升到最顶部，只提升声明，不提升赋值\n2. 所有的函数声明，都会提升到最顶部，只提升声明，不提升调用\n> 补充说明:\n>  1. 多个重名的var声明，后面的var将被忽略\n>\t 2. 多个重名的函数声明，后面的将前面的覆盖\n>\t 3. 如果出现了同名的变量和函数，函数优先，函数的优先级>变量\n>\t 4. 函数内部也会进行预解析\n\n预解析，虽然可以提升我们的声明，但是我们开发时，还是要**先声明，后使用**！！！\n\n## 7、js的数据类型\n\n分为：``简单数据类型``和``复杂数据类型`` （数组、函数、对象）\n\n### 7.1 简单数据类型\n#### 7.1.1 number类型（数字类型）\n\n1. 整数（一般使用的是十进制  逢十进一）\n\n\t``八进制，逢八进一，0开头``\n    ```javascript\n    var num3 = 011  //就是1*8+1 为9;\n    var num4 = 022  //2*8+2 为18\n    ```\n\n\t``十六进制，逢16进一，0x开头的数字  0-9abcdef``\n\n    ```javascript\n    var num2 = 0x11  //1*16+1 为17;\n    var num3 = 0x1a  //16+10为26;\n    ```\n\n2. 浮点数（小数）\n\n3. 科学计数法 \n  ```javascript\n  var num1 = 1e4 就是1*10^4\n  ```\n  > 注意点：计算机对于小数的运算是不准确的，会有很小很小的误差，所以尽量不要用  小数进行比较运算\n\n#### 7.1.2 string类型 字符串类型\n* 通过 '' 或者 \"\" 包裹的就是字符串，js中单双引号，没有区别，推荐''.\n* 字符串通过length，可以获取长度\n```\n\tconsole.log（str.length）;\n```\n\n* 转义字符\t\n  ``\\'`` 表示一个普通的单引号\n\t``\\\"`` 表示一个普通的双引号\n\t``\\n`` 表示换行\n\n* 拼串（拼接字符串）\n> ``+`` 有拼接字符串的功能，也有运算的功能\n\n``+`` 的规则：\n1. 只要两边有字符串（黑色），进行的就是拼串\n2. 只有两边都是数字（蓝色），才进行运算\n\n#### 7.1.3 boolean类型 布尔类型 \n只有两个值，true真 false假\n一般用于比较\n\n#### 7.1.4 undefined 未定义的，变量声明了，但是未赋值，默认值就是underfined\n\n#### 7.1.5 null 空对象\n\n\n\n### 7.2 复杂数据类型\n\n\n\n## 8、变量与简单数据类型的说明\n\n* 对于简单数据类型，浏览器直接认识（直接量 或者 字面量）\n* 若是将字符串当成了变量（未声明，未赋值的变量直接使用，会报错）\n* 字符串需要引号包裹\n\n\n## 9、运算符（操作符）\n\n### 9.1 算术运算符 ``+ - * / %(取余)``\n* ``+`` 不仅有拼串的功能，还可以运算\n* 其他算数运算符，只有运算的功能，如果遇到了字符串，也会转成数字运算\n```javascript\n\"2\" - 1 = >1\n```\n### 9.2 赋值运算符 =\n=（就是赋值）   +=   -=   *=   /=   %=\n```javascript\nvar num = 10;\nnum += 10; //等价 num = num + 10\n```\n\n### 9.3 自增或自减运算符（一元运算符）\n#### 9.3.1 自增：让变量的值，在原来的基础上+1\n* 语法：\n``++num`` 前自增，规则：先让值+1，再返回这个值\n``num++`` 后自增，规则：先返回这个值，再让值+1\n\n* 注意点： \n * 不管是++num 还是num++ 从功能的角度一样的，都是让变量的值+1\n * 虽然++num 或 num++ 都能让变量值+1，但是++num 和 num++这个式子的结果是不一样的\n\n#### 9.3.2 自减：让变量的值，在原来的基础上-1\n*语法：\n``--num``\n``num--``\n\n### 9.4 逻辑运算符（与或非）\n``&&`` 并且 两边都要成立，结果才是 true，只要有一个不成立，就是false\n``||`` 或 两边只要有一个成立，结果就是true\n``!`` 取反\n\n### 9.5 比较运算符 >  <  >=  <=  ==   !=  ===   !==\n``==`` 规则：只看值，不看类型（只要值相等，就是相等）\n``===`` 规则：看值，又看类型（值和类型都要相等）\n``!=`` 规则：只看值，不看类型（只要值不等，就是true）\n``!==`` 规则：看值，又看类型（只要值或者类型有一个不等，就是不等，返回true）\n\t\n> ==有一定规则（如果类型不同，转换成相同类型，然后比较）\n1. NaN，不等于任何值，包括他自己\n2. null，不等于任何值，除了null和undefined\n3. undefined，不等于任何值 ，除了null和undefined\n4. 看是否有数字或布尔，如果有，转成数字比较\n\t  true：1，false:0\n\t  [ ]:0, { }:NaN，'':0\n5. 再看是否有字符串，（字符串和复杂数据类型），转成字符串比较\n\t[ ].toString()--->\"\"\n\tobj.toString()--->'[object Object]'\n6. 都是复杂数据类型，比较的是内存地址\n\t\t\t\t\n### 9.6 运算符优先级\n1. 括号的优先级最高\n2. 一元运算符 ++  --  !\n3. 算数运算符  先乘除%，后加减\n4. 比较运算符\n5. 逻辑运算符  &&  ||\n\n>记忆：（1）括号的优先级最高，逻辑运算符的优先级最低\n>\t\t  （2）先乘除，后加减\n\n## 10、如何判断数据的类型\n\n### 10.1 直接打印看颜色（调试，看颜色）\n蓝色的数字，number\n黑色\t     string\n蓝色的布尔值 boolean\n灰色\t    undefined和null\n\n### 10.2 typeof 变量\t它的返回值，也是一个字符串类型\n1. number\n2. string\n3. boolean\n\n> bug: typeof null = object;\n\n## 11、数据类型转换\n\n### 11.1 转成数字\n* ``Number（xx）`` 如果拿到的是一个非数字，浏览器也不会报错，返回 ``NaN``,not  a number \n* ``parseInt（xx）`` 从第一个字符开始解析，一直解析到第一个非数字为止\n* ``parseFloat（xx）`` 从第一个字符开始解析，可以识别一个``.``  然后解析到非数字为止\n* 直接运算 -  *  /  %    +正号（用的最多，例如+age）  -负号\t\t\n\n### 11.2 转成字符串\n* String（xx）\n* xx.toString()\n* 直接拼串 （常用）\n\tconsole.log(age+ \"\");\n\n### 11.3 转成布尔类型\n**所有的值，都可以转成布尔类型**\n\n**规则**：只有这6种情况， 0  \"\"  NaN  null  undefined   false  可以转成false，其他所有值，都是true\n\n* Boolean（）\n* !!\n\n### 11.4 NaN的说明（表示非数字，指一个无法用数字表示的数字，not a number）\n\n* 如果浏览器遇到了一个无法用数字表示的数值，就用NaN表示\n* 只要看到了NaN，说明代码的执行有问题\n* NaN的类型是number类型\n* NaN不等于任何值，包括他自己\n\n\n## 12、流程控制\n\n### 12.1 顺序结构（从上到下执行的，默认）\n### 12.2 分支结构（选择结构）\n\n#### 12.2.1 if语句\n\t\t\t\n* 语法1\n```javascript\nif（条件）{\n  语句1;\n}\n```\n如果条件成立，执行语句1\n\n* 语法2\n```\nif（条件）{\n  语句1;\n}\nelse {\n  语句2;\n}\n```\n如果条件成立，执行语句1，否则执行语句2\n\n* 语法3\n```\nif（条件1）{\n  语句1;\n}\nelse if（条件2） {\n  语句2;\n}\nelse {\n  语句3;\n}\n```\n\n如果条件1成立，执行语句1\n如果条件1不成立，看条件2，如果条件2成立，执行语句2\n如果都不成立，执行语句3\n\n\n#### 12.2.2 三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）\n\n语法  var 结果 = 条件 ？ A ：B；（如果条件满足，就是A 否则B）\n\n#### 12.2.3 switch-case（根据变量的具体，进行判断）\n```javascript\nswitch（变量）{\n  case 值1:\n\t  语句1;\n\t  break;（break表示跳出switch，接着往下执行）\n  case 值2:\n\t  语句2;\n\t  break;（break表示跳出switch，接着往下执行）\n  case 值3:\n\t  语句3;\n\t  break;（break表示跳出switch，接着往下执行）\n  default:\n\t  默认语句;\n}\n```\n\n**判断变量的值**\n\t如果值，等于值1，执行语句1\n\t如果值，等于值2，执行语句2\n\t。。。\n\t如果都不满足，执行默认语句\n\n**注意点**：\n\t（1）进行的值的比较，进行的是全等比较\n\t（2）养成写break的习惯（不写break，会一直往下执行）\n\n#### 12.2.4 三种分支结构的使用场景：\n* if else\t\t\t适用于范围形的判断\n* 三元运算符\t\t只适用于比较简单的判断，条件只能写一个，但是简洁\n* switch。。 case。。适用于具体值的判断\n\n### 12.3 循环结构\n\n#### 12.3.1 while（当条件成立时，循环执行某件事）\n```javascript\nwhile（条件）{\n  循环体; //循环执行的内容\n}\n```\n条件成立，执行循环体\n判断条件，条案件成立，继续执行循环体\n。。。\n条件不成立，跳出循环\n死循环，永远都没有结束的一个循环，开发中需要避免\n\n* while循环一定要有条件，不然就死循环了\n* i++一般放在{..}的最后面\n* while循环可以用于实现不明确循环次数的循环\n\n#### 12.3.2 do while\n```javascript\ndo {\n  循环体; //重复执行的内容\n}while（条件)\n```\n一上来，直接执行循环体\n再判断条件，如果条件成立，再执行循环体\n。。。\n直到条件不成立，跳出循环\n\t\t\n> do while一般只适合：不管条件成立不成立，都执行一次\n> while 和 do while的区别：\n>\t while 如果条件不成立，一次都不执行\n>\t do while不管条件成立与否，至少执行一次\n\n#### 12.3.3 for（适用于明确范围的循环）\n```\nfor（初始化语句;判断条件;自增或自减）{\n  循环体;\n}\n```\n例：\n```javascript\nfor（var i = 1；i < 5; i++）{\n  console.log(1);\n}\n```\n\n执行语句：\n  1. 初始化语句\n\t2. 判断条件\n\t3. 自增或自减\n\t4. 循环体\n\n执行流程分析：1243 243 243 243...\n执行流程：\n  先初始化语句，判断条件，执行循环体，自增或自减；\n\t判断条件，执行循环体，自增或自减；\n\t。。。\n\t条件不成立，跳出循环；\n\n#### 12.3.4 双重for循环，就是在for循环的外面再套一个for循环\n* 外层控制行数\n* 内层控制一行打印多少个\n\n\tbreak：如果循环遇到了break，跳出整个循环，整个循环就结束了，后面的次数都不执行了\t\t\n\tcontinue：如果循环遇到了continue，跳出本次循环，执行下一次循环\n\n#### 12.3.5 循环的使用场景：\n* while比较适合不明确执行次数的循环（循环表白案例）\n* do while（少用）只适用于不管成立与否，至少执行一次循环体的情况\n* for比较适合于明确范围的循环\n\n## 13、断点调试\n（1）F12打开控制台，sources,点开对应的文件\n（2）在对应行的行号上，点击打断点，刷新后，浏览器会自动执行停留在断点的位置\n操作：\n（1）watch监视，监视变量的变化\n（2）F10，让代码往下一步执行\n（3）F8，从当前位置，执行到下一个断点的位置，如果后面没有断点了，就会一直执行完\n\n\n## 14、数组（是一个有序的值的集合，可以存储大量的数据）\n简单数据类型，在存储大量数据时，一个一个的存，非常的浪费\n\n### 14.1 创建数组的方式\n1. 字面量的方式（字面量，直接量，从字面上直接就能看出是什么值的量）\n\t\t123  false  'abc'  undefined  null  [ ]:表示数组\n``var arr =[ ]``创建一个空数组\n> 注意点：数组里面可以存任意类型的数据，但是规范是存储同类型的数据\n\n2. 构造函数的方式\n```javascript\n\tvar arr = new Array(); ---创建一个空数组\n\tvar arr = new Array(5);---浪费空间，五个空的位置，没有具体值\n```\n### 14.2 数组的长度 arr.length\n### 14.3 数组的下标（索引）：数组中的每一项，都会有一个唯一的下标\n* 从0开始，最大下标arr.length-1\n* 数组中下标的范围：0 -----> arr.length-1\n\n### 14.4 数组的取值和存值\n\n* 取值：\n**语法：数组名[下标]**\n 1. 如果下标存在，直接返回对应项的值\n 2. 如果下标不存在，返回undefined\n\n* 存值（改值）\n**语法：数组名[下标] = ‘新的值’**\n 1. 如果下标存在，直接用新的值覆盖\n 2. 如果下标不存在，新建一个项，进行赋值\n\n* 往数组最后添加项\n\t1. arr[arr.length] = '值';\n\t2. arr.push('值')；\n\n### 14.5 数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项\n* 数组正序遍历\n```javascript\nfor (var i = 0; i < arr.length; i++) {\n`console.log(arr[i]);\n}\n```\n\n* 数组倒叙遍历\n```\nfor (var i = arr.length-1; i >=0; i--) {\n  console.log(arr[i]);\n}\n```\n\n### 14.6 冒泡排序\n1. 冒泡（指得是排序的方式）\n2. 排序（就是讲一组没有按照顺序排列的数，经过排列后，按照一定的顺序排列）\n\t价格排序，成绩排序\n\t编程界，有十大排序\n\t\n### 14.7 初级版\n1. 先排出一趟，排出一个最大值\n\t1. 遍历数组\n\t2. 让arr[i] 和 arr[i+1] 比较\n\t3. 如果arr[i] > arr[i+1] ，交换位置\n2. 双重for循环，多排几次，就排好了\n\n### 14.8 中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次\n\t\t内循环-j\n\n### 14.9 高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了\n1. 在每趟排列前，先假设，已经排好了\n2. 一趟下来，如果一次交换都没有发生，flag值就是true\n```javascript\nvar arr = [7, 6, 5, 4, 3, 2, 1];\n// 外层控制趟数, 一趟可以比出一个最大值, 7个数, 比6趟即可\nfor (var j = 0; j < arr.length-1; j++) {\n  // 在每趟排列前, 先假设, 已经排好了\n  var flag = true;\n  for (var i = 0; i < arr.length-1-j; i++) {\n    if (arr[i] > arr[i + 1]) {\n      var temp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i+1] = temp;\n      // 发生了交换, 说明没有排好\n      flag = false;\n    }\n  }\n  // 一趟下来, 如果一次交换都没有发生, flag值就是 true\n  if (flag) {\n    break; \n  }\n}\nconsole.log(arr);\n```\n\n## 15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）\n**好处**：可维护性高\n\n### 15.1 声明函数\n**函数名的规范**：一般都是动词+名词（一般函数都是要做某一件事情）\n```\nfunction 函数名(){\n  函数体;\n}\n```\n> 函数光声明，是不会执行的。\n\t\n#### 15.1.1 调用函数\n```\n函数();\n```\n\n函数一次声明，可以多次调用！！！\n\n#### 15.1.2 函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）\n* 形参---形式参数（函数在声明时，函数名括号内的参数）\n\t形参默认没有值或类型！！！只在函数调用时，形参才会有具体的值或类型\n\t作用：占位置\n\n* 实参---实际参数（函数调用时传递给函数的参数）\n\t实参有具体的值或者类型\n\t作用：在函数调用时将数据传递给形参\n\n> 注意点：形参和实参一一对应！！！\n\n#### 15.1.3 函数的声明和调用进阶写法\n```javascript\nfunction 函数名（形参1，形参2，形参3...）{\n  函数体;\n}\n```\n\n#### 15.1.4 函数的返回值\n函数内部声明的变量 或者 形参，只能在函数内使用，出了函数就用不了了\n如果希望函数的执行，有结果，需要通过``return``返回内容\n\n> 函数的三要素---决定了一个函数怎么去使用\n> 1. ``函数名``：一个函数一次声明，可以多次调用（规范：动词+名词）\n> 2. ``函数参数``：可有可无，但是如果有需要变化的值，一般需要提取成形参\n> 3. ``返回值``：可有可无，但是如果需要拿到函数的执行结果，就必须要return\n\n#### 15.1.5 函数参数与返回值的说明\n* 开发的时候，函数的参数要一一对应\n  1. 传递的参数，如果少了，没接收到值的形参，值就是undefined（数字和undefined加起来就是NaN）\n  2. 传递的参数，如果多了，多传的参数，会被忽略\n\n* 返回值的问题\n\t1.return的值，就是函数的执行结果\n\t2.return后面的代码，不执行了！return表示函数的结束！！\n\n#### 15.1.6 函数调试说明\n* 函数可以在内部调用函数\n* F10 让代码往下一步执行，如果遇到了函数调用，会跳过函数的执行过程，直接看结果\n* F11让代码往下一步执行，如果遇到了函数调用，会进入函数一步步执行\n* shift + F11 跳出函数的执行（将当前函数的调用的剩余代码全部执行完，直接看结果）\n\n\n#### 15.1.7 声明函数的两种方式\n1. ``函数声明式``（可以先调用，后声明---预解析，会提升函数的声明）\n```javascript\nfunction fn( ) {\n  console.log('嘿嘿');\n}\n```\n\n2. ``函数表达式``（只可以先声明赋值，后调用）---写法相对严格\n```\nvar fn = function( ){\n  console.log('哈哈');\n};\n```\n\n### 15.2 匿名函数（没有名字的函数，不能直接使用）\n使用场景：\n\n1. 函数表达式 var fn = function(){...}\n2. 匿名函数自调用（自执行)\n\t> 直接自调用会报错，可以给整个函数包一个( ),包成了一个整体，就可以调用了\n  ```javascript\n  (function ( ) {\n    console.log(123);\n  })( );\n  ```\n\n**沙箱模式--匿名函数自调用的应用=>可以用于解决全局变量污染问题**\n由于全局变量，可以在任何地方都可以访问，所以不能乱用\n一般都会用函数自调用包裹起来\n```\n（function() {...}）\n```\n\n## 16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）\n### 16.1 概念：无序的键值对的集合\n\n### 16.2 创建对象的方式\n\n1. 字面量 \n1 ‘abc’ true undefined null [ ] { }\n``var obj = { }``创建空对象\n\n键值对的集合，多个键值对通过\"，\"隔开\n特征：对象的属性\n行为：对象的方法---对象的函数\n\n2. 构造函数的方式（了解）\nvar obj = new Object({...});\n\t\t\t\n### 16.3 取值和赋值（点语法）\n* 取值：\n语法：对象名.属性名  对象名.方法名( );---方法的调用，得到整个函数\n * 有这个属性名，返回对应值\n * 如果没有这个属性名，返回undefined\n\t\t\t          \n* 赋值：\n语法：对象名.属性名 = '新的值'\n * 如果有这个属性名，覆盖\n * 如果没有这个属性名，新建一个属性并赋值\n\n\n#### 16.3.1 点语法（简洁方便，不支持变量）\n对象名.属性名\n\n#### 16.3.2 中括号语法（支持字符串或变量，更加的灵活）\n对象的取值：对象名['属性名']\n对象的赋值：对象名['属性名'] = \"新的值\"\n**只要访问对象属性时，需要用到变量，只能用中括号语法**\n\t\n### 16.4 对象的遍历（访问对象的所有属性）\n固定语法 （key就是键，属性名）\n```javascript\nfor （var key in obj）{\n  console.log(key);\n  console.log(obj[key]);---打印属性值\n}\n```\n\n### 16.5 批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）\n设计模式（工厂模式、单例模式、观察者模式）\n在对象的方法中，this指代当前对象（对象名）\n#### 16.5.1 工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）\n通过工厂函数创建的对象，没有具体的类型，都是Object\n```javascript\nfunction Student(sno,name,gender,major){\n    obj=new Object();\n    obj.sno=sno;\n    obj.name=name;\n    obj.gender=gender;\n    obj.major=major;\n    obj.say=function(){\n      console.log(\"hello!\");\n    }\n    return obj;\n}\nvar s=new Student(\"123\",\"张三\",\"男\",\"数学\");\nfor(var i in s){\n    document.write(i+\" : \"+s[i]+\"<br>\");\n}\n```\n这里Student()函数相当于一个工厂，在其内部生产对象。这种方式简化了代码，但是无法细分对象，也会造成共有方法和属性的内存浪费。无法细分对象就是生产出的对象的constructor是Object，而不是自定义的\n```\nconsole.log(s.constructor);\n```\n![](https://img-blog.csdnimg.cn/20200831171959364.png#)\n内存浪费就是因为方法声明在了对象的内部，每一个对象都有同一个方法，造成了浪费。\n\n#### 16.5.2 构造函数（给新建的对象，添加属性和方法----实例化对象）\n1. 就是一个函数\n2. 首字母大写\n3. js中，内置了一些构造函数，比如：``Object``，``Array``\n4. 构造函数可以自定义\n\n* 构造函数的使用步骤\n * 自己声明一个构造函数\n * 结合new一起使用，创建一个有类型的对象\n```javascript\nfunction Student(sno,name,gender,major){\n    this.sno=sno;\n    this.name=name;\n    this.gender=gender;\n    this.major=major;\n    this.say=function(){\n        console.log(\"hello!\");\n    }\n}\nvar s=new Student(\"1234\",\"李四\",\"男\",\"物理\");\nfor(var i in s){\n    document.write(i+\" : \"+s[i]+\"<br>\");\n}\n```\n这种模式解决了对象不能细分问题，此时s的constructor就是Student()构造函数了。\n```\nconsole.log(s.constructor);\n```\n![](https://img-blog.csdnimg.cn/20200831184528158.png#)\n但是还是没有解决公有方法造成的内存浪费问题。\n\n#### 16.5.3 构造函数+原型对象模式\n```javascript\nfunction Student(sno,name,gender,major){\n    this.sno=sno;\n    this.name=name;\n    this.gender=gender;\n    this.major=major;\n}\nStudent.prototype.say=function(){\n    console.log(\"hello!\");\n}\nvar s=new Student(\"12345\",\"王五\",\"男\",\"化学\");\nfor(var i in s){\n    document.write(i+\" : \"+s[i]+\"<br>\");\n}\n```\n这种模式和构造函模式类似，不同点是该模式把公有的属性和方法声明到构造函数的原型对象中，解决了内存浪费。\n\n#### 16.5.4 new的作用（创建对象）\n * 会新建一个对象，指定对象的类型\n * 让构造函数的this，指向新创建的对象----this.name = '张三';\n * 执行构造函数（给新建的对象，添加属性和方法）\n * 将新创建的对象返回\n\n\n### 16.6 内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）\n\n#### 16.6.1 Math对象（提供了一系列和数学相关的属性和方法）\n1. PI Math.PI\n2. 求最大最小值 max min\n  var max = Math.max(3,5,6,110);\n  console.log(max);\n3. 取整 ceil floor round\n  （1）ceil向上取整，取大的那个数---天花板函数\n  （2）floor向下取整，取小的那个数---地板函数\n  （3）round四舍五入，离哪个近取哪个\n4. 随机数random ``[0,1)``可以取到0，取不到1\n  公式：求一个整数范围0~N，parseInt(Math.random()*(N+1))\n5. 绝对值abs\n6. 求次方pow\n7. 求开方sqrt\n\n\n#### 16.6.2 Date日期对象\n\njs中提供的Date构造函数，可以创建日期对象\n\n1. 如何创建日期对象\n```javascript\n  var now = new Date(); // 构造函数不传参，创建的是当前时间\n  var date = new Date('2019-4-22 16:00:00'); // 构造函数传日期字符串，指定具体的日期\n```\n\n2. 日期格式化 （不用）---一般日期格式都是自定义的\n```javascript\n  var now = new Date();---当前时间\n  console.log(now.toString()); // 让日期以标准化的日期字符串格式化输出,'Thu Apr 08 2021 11:13:41 GMT+0800 (GMT+08:00)'\n  console.log(now.toLocaleString()); // 本地化日期字符串格式输出,'2021-4-8 11:13:41'\n  console.log(now.toLocaleDateString()); //只显示日期,'2021-4-8'\n  console.log(now.toLocaleTimeString()); //只显示时间,'11:13:41'\n```\n\n3. 日期格式的自定义，xx年xx月xx日--获取日期里面的各个组成部分\n可以封装一个函数，专门给小于10的数，前面加上0\n```javascript\nfunction addZero（n）{\n  if(n<10) {\n    return '0' + n;\n  }\n  else {\n    return n;\n  }\n}\nvar now = new Date(); // 当前时间\nvar year = now.getFullYear(); // 年\nvar month = now.getMonth()+1; // 获取月，getMonth从0开始，范围0-11\nmonth = addZero(month);\n// 获取日getDate\n// 获取一周中的第几天，getDay,范围0-6，周日0，周一1\nvar hours = now.getHours(); // 时，getHours\nvar minutes = now.getMinutes(); // 分，getMinutes\nvar seconds = now.getSeconds(); // 秒，getSeconds\n// now.getMilliseconds毫秒\n```\n\n4. 时间戳（就是数字格式的日期，便于运算，一般用于求时间差）---距离1970年1月1日 0时0分0秒，所过去的毫秒数\n```javascript\n  var now = new Date();\n  console.log(+now);\n```\n\n**应用**\n* 统计一段代码的执行时间---性能优化\n```javascript\nvar begin = new Date();\nvar end = new Date();\nconsole.log(end - begin);\n```\n* 用于秒杀倒计时\n\n## 17、数组对象Array\n\n1. ``.join(分隔符)``：将数组中的值拼接成一个字符串，返回这个字符串\n默认分隔符\" , \"\n\n2. 数组的增删操作``push`` ``pop`` ``unshift``  ``shift`` ***会更改原数组***\n  .push在数组的最后面，添加一个或多个项，返回数组的长度\n  .pop在数组的最后面，删除一个项，返回删除的项\n  .unshift在数组的最前面，添加一个或多个项，返回数组的长度\n  .shift在数组的最前面，删除一项，返回删除的项\n\n3. 翻转``reverse`` ***会更改原数组***\n4. 排序``sort``（默认按照字符串的方式进行排序，先比较第一个字符）***会更改原数组***\n\t**如果要制定排序规则，是需要传参的（参数：一个函数）** \n  ```javascript\n  arr.sort(function(a,b) {\n    return a-b;---从小往大\n    return b-a;---从大往小\n  })\n  ```\n  > a表示前一项，b表示后一项\n  > 函数的返回值>0,a和b交换位置\n  > 函数的返回值=0，不换位置\n  > 函数的返回值<0,不换位置\n\t\n5. 合并 ``arr.concat(arr2,arr3....)``，返回合并后的新数组\n6. 截取``arr.slice``（从数组中，截取一部分出来，返回一个新数组）\n\t* arr.slice();从开始一直截取到最后（将整个数组截取，复制一份）\n\t* arr.slice(begin)从begin（下标）开始一直截取到最后\t\n\t* arr.slice(begin,end)从begin（下标）开始一直截取到end结束（**包括begin,不包括end**）\n\n7. ``splice``方法，可以在数组的任意位置添加、删除、替换任意项---会更改原数组\n  ```\n\tsplice（从哪开始删，删几个，添加的项1，添加的项2...）\n\tsplice(begin,deleteCounts,item1,item2...)\n  ```\n\n8. ``indexOf``查找值在数组中第一次出现的下标（可以用来查重）\n\t``lastIndexOf``查找值在数组中最后一次出现的下标\n如果值在数组中不存在，返回 ``-1``\n\t\n9. 清空一个数组\n```javascript\narr = [ ];\narr.length = 0;\narr.splice(0,arr.length)\n```\n\n\n## 18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）\n\n**js内部，对于除了undefined和null的简单数据类型，都提供了一个对应的复杂数据类型**\n\n简答数据类型：没有属性和方法，只有值\n复杂数据类型：可以有多个属性和方法\n\t\n* 在js中，如果简单数据类型，在访问复杂数据类型的属性或方法时\n* 为了方便，自动将简单数据类型，包装成复杂数据类型，然后获取对应的值\n* 会将值变回简单数据类型\t\n\t\n### 18.1 Number\n\t通过new Number()创建的对象，``toString``   ``toFixed``两个方法\n\tnum.toFixed(3) 保留3位小数\n\n### 18.2 Boolean\t\n\t\t通过new Boolean()创建的对象，toString\n\n### 18.3 String\n1. 字符串可以和数组一样，进行遍历，字符串不是数组，不能混用方法\n2. ``indexOf``和``lastIndexOf`` 查找值在字符串中第一次/最后一次出现的下标\n3. ``trim``去除字符串``首尾``的空格\n4. 转大小写\n ``toUpperCase``转大写\n ``toLowerCase``转小写\n5. 拼接``.concat``将字符串进行拼接，返回新的字符串）\n  一般用``+``\n6. 截取\n  * slice(begin,end) \n    > 从begin开始截取，截取到end结束，包括begin，不包括end\n    > begin（必需）：规定从何处开始选取。如果是负数，那么它规定从字符串尾部开始算起的位置。也就是说，-1 指最后一个字符，-2 指倒数第二个字符，以此类推。\n    > end（可选）：规定从何处结束选取，即结束处的字符下标。如果没有指定该参数，那么截取的字符串包含从 start 到结束的所有字符。如果这个参数是负数，那么它规定的是从数组尾部开始算起的字符。\n    ```javascript\n      var str = \"0123456789\";\n      console.log(\"原始字符串：\", str);\n      console.log(\"从索引为3的字符起一直到结束：\", str.slice(3));  //3456789\n      console.log(\"从倒数第3个字符起一直到结束：\", str.slice(-3));  //789\n      console.log(\"从开始一直到索引为5的前一个字符：\", str.slice(0,5));  //01234\n      console.log(\"从开始一直到倒数第3个字符的前一个字符：\", str.slice(0,-3));  //0123456\n      console.log(\"从索引为3的字符起到索引为5的前一个字符：\", str.slice(3,5));  //34\n      console.log(\"从索引为3的字符起到倒数第3个字符的前一个字符：\", str.slice(3,-3));  //3456\n    ```\n  * substring(begin,end) 从begin开始截取，截取到end结束，包括begin，不包括end\n    ```javascript\n      var str = \"0123456789\";\n      console.log(\"原始字符串：\", str);\n      console.log(\"从索引为3的字符起一直到结束：\", str.substring(3));  //3456789\n      console.log(\"从索引为20的字符起一直到结束：\", str.substring(20));  //\n      console.log(\"从索引为3的字符起到索引为5的前一个字符结束：\", str.substring(3,5));  //34\n      console.log(\"start比end大会自动交换，结果同上：\", str.substring(5,3));  //34\n      console.log(\"从索引为3的字符起到索引为20的前一个字符结束：\", str.substring(3,20));  //3456789\n      console.log(\"substring将负数转化为0:\", str.substring(-3)); //\n    ```\n  * substr(begin,length) 从begin开始截取，截取length个\n    ```javascript\n      var str = \"0123456789\";\n      console.log(\"原始字符串：\", str);\n      console.log(\"从索引为3的字符起一直到结束：\", str.substr(3));  //3456789\n      console.log(\"从索引为20的字符起一直到结束：\", str.substr(20));  //\n      console.log(\"从索引为3的字符起截取长度为5的字符串：\", str.substr(3,5));  //34567\n      console.log(\"从索引为3的字符起截取长度为20的字符串：\", str.substr(3,20));  //3456789\n    ```\n  * 三者比较\n  ```javascript\n    var str = '中华人民共和国万岁'\n    // 一，start为负数，end不传\n    str.slice(-3) // '国万岁'\n    str.substring(-3) // '中华人民共和国万岁'\n    str.substr(-3) // '国万岁'\n    // 说明： 1，slice与substr第一个参数为负数时，将从字符串反方向开始计数，末位记为-1,等同于str.slice(6)，str.substr(6)\n    //       2，substring将负数转化为0，既str.substring(0)\n\n    // 二，start为负数，end为负数时\n    str.slice(-3,-1) // '国万'\n    str.substring(-3,-1) // ''\n    str.substr(-3,-1) // ''\n    // 说明：\n    //    1，slice正常截取字符串，相比substring灵活很多\n    //    2，substring将所有参数转化为0，既str.substring(0,0)\n    //    3，substr end参数不能为负数\n\n    // 三，start与end均大于零，且start > end\n    str.slice(5,3) // ''\n    str.substring(5,3) // '民共'\n    str.substr(5,3) // '和国万'\n    // 说明：\n    //   1，substr正常截取字符串，代表从第五位开始，截取字符串长度为3\n    //   2，当start>end时，substring在提取子串之前会先交换这两个参数，既转换为substring(3,5)；而slice不能进行此转换，所以截取的为空字符串\n\n    // 四，start与end均大于零，且start < end\n    str.slice(3,5) //'民共'\n    str.substring(3,5) // '民共'\n    str.substr(3,5) // '民共和国万' \n    // 说明：三种方法均正常截取字符串，只是substr第二个参数含义不同，代表截取的字符串长度而不是终止位置。\n\n  ```\n7. 通过.split(分隔符):可以将字符串拆分成数组，会返回一个拆分得到的数组\n    通过join:可以将数组的值，拼成字符串，会返回一个拼接成的字符串\n\n8. replace替换，会返回替换的结果\n```javascript\nstr.replace('aa','bb'); // 将字符串中的第一个aa替换成bb\n```\n\n想要全部替换，需要用到正则``str.replace(/aa/g,'bb')``;\n\n\t\n## 19、值类型和引用类型\n从内存的存储角度，分成了``值类型``和``引用类型``（内存是可以释放，可以重复利用的）\n\n**值类型（简单数据类型）**：存储在变量中，存的是值本身\n**引用类型（复杂数据类型）**：存储在变量中，存的是``内存地址``----会单独在内存中开辟一块空间存储\n\n### 19.1 值类型和引用类型的赋值类型\n* 值类型：存储在变量中 ，存的是``值本身``，所以在赋值给其他变量时，赋值的是``值本身``\n* 引用类型：存储在变量中，存的是``内存地址``，所以在赋值给其他变量时，赋值的是``内存地址``\n\n### 19.2 值类型和引用类型的值传递（让值作为函数的参数进行传递）\n* 值类型：存储在变量中，存的是值本身，所以在值传递时，传的也是值本身\n* 引用类型：存储在变量中，存的是内存地址，所以在值传递时，传的也是内存地址\n\t\n\t\t\n\n\t\t\t\t\n## 20、typeof 关键字\n1. typeof获取简单数据类型，可以直接返回对应的类型\n***特例***：typeof null  返回object\n2. typeof获取复杂数据类型，一般返回object\n***特例***：typeof 函数  返回function    函数是js的一等公民\n\n## 21、逻辑中断（短路运算）&& ||\n&&找假值，只要遇到了假值，就中断短路（后面的不看了）\n||找真值，只要看到了真值，就中断短路（后面的不看了）\n\n```javascript\nfunction demo(fn){\n  fn&&fn(); //fn存在，才去调用\n}\t\ndemo(function(){\n  console.log(111);\n});\ndemo();\n```\n\t\n**逻辑``或``，一般可以用于设置默认值,也可以解决兼容性**\n```javascript\nfunction getSum(a,b){\n  a=a || 0;\n  b=b || 0;\n  var sum = a+b;\n  return sum;\n}\n```\n\n\n## 22、如何拷贝一个对象\n封装一个方法，可以拷贝一个对象，返回（浅拷贝，只拷贝了 一层）\n```javascript\nfunction copy(obj){\n  var newObj = {};\n  for (var k in obj){\n    newObj[k] = obj[k];\n  }\n}\n```\n\n* 浅拷贝，只拷贝了一层，如果全是简单类型的属性，没有问题\n\t但是如果有复杂类型的属性（对象），此时拷贝的只是地址，需要处理的\n* 深拷贝\n```\n\tnewObj[k] = typeof obj[k] === 'object' ? copy(obj[k]) : obj[k];\n```\n\n```javascript\n// 1.遍历+递归\nfunction deepClone(obj){\n  let newObj =  {}\n  for(let key in obj){\n      if(obj.hasOwnProperty(key)){\n          if(typeof(obj[key]) === 'object' && obj[key] !== null){\n            newObj[key] = (Array.isArray(obj[key])  ? [] : {})\n            newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : deepClone(obj[key]));  \n          }else{\n              newObj[key] = obj[key];\n          }\n      }\n  }\n  return newObj;\n}\n\n// 2.Object.assign + 递归\nfunction deepClone(obj){\n  let newObj = {}\n  for(let key in obj){\n    if(obj.hasOwnProperty(key)){\n      newObj[key] = (typeof obj[key] === 'object' ? Object.assign(obj[key]) : obj[key])\n    }\n  }\n  return newObj\n}\n\n// 3.对象扩展+递归\nfunction deepClone(obj){\n  var newObj ={}\n  for(let key in obj){\n    if(obj.hasOwnProperty(key)){\n      if(typeof obj[key] === 'object'){\n        newObj[key] = (Array.isArray(obj[key]) ? [] : {})\n        newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : {...obj[key]}) \n      } \n      else{\n        newObj[key] = obj[key]\n      }\n    }\n  }\n  return newObj\n}\n\n// 4.JSON复制（对NaN和undefined无法正确复制，会丢失）\nfunction deepClone(obj) {\n  var newObj = JSON.parse(JSON.stringify(obj))\n  return newObj\n}\n```\n\n\n## 23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！\n## 24、面向对象：关注的是找一个对象，去做某件事\n***面向对象不是面向过程的替代，是面向过程的封装***\n### 24.1 特性：\n1. 封装性\n2. 继承性\n3. 多态性（js中没有）\n\t\n## 25、原型\n\nJavaScript是一门基于原型的语言，在软件设计模式中，有一种模式叫做原型模式，JavaScript正是利用这种模式而被创建出来\n\n### 25.1 原型模式 \n原型模式是用于创建重复的对象，同时又能保证性能，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。\n原型模式的``目的``是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，也就是说利用已有的一个原型对象，可以快速地生成和原型对象一样的新对象实例\n\n### 25.2 原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板\n1. 原型是定义了一些公用的属性和方法，利用原型创建出来的新对象实例会共享原型的所有属性和方法\n实例代码：\n```javascript\n// 创建原型\nvar Person = function(name){\n    this.name = name;\n};\n\n// 原型的方法\nPerson.prototype.sayHello = function(){\n    console.log(this.name+\",hello\");\n};\n\n// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法\nvar person1 = new Person(\"zhangsan\");\nvar person2 = new Person(\"lisi\");\n\n// zhangsan,hello\nperson1.sayHello();\n// lisi,hello\nperson2.sayHello();\n```\n\n2. 严格模式下，原型的属性和方法还是会被原型实例所共享的\n实例代码：\n```javascript\n// 开启严格模式，原型的属性和方法还是会被原型实例所共享的\n\"use strict\";\n\n// 创建原型\nvar Person = function(name){\n    this.name = name;\n};\n\n// 原型的方法\nPerson.prototype.sayHello = function(){\n    console.log(this.name+\",hello\");\n};\n\n// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法\nvar person1 = new Person(\"zhangsan\");\nvar person2 = new Person(\"lisi\");\n\n// zhangsan,hello\nperson1.sayHello();\n// lisi,hello\nperson2.sayHello();\n```\n\n3. 通过原型创建的新对象实例是相互独立的，为新对象实例添加的方法只有该实例拥有这个方法，其它实例是没有这个方法的\n实例代码：\n```javascript\n// 创建原型\nvar Person = function(name){\n  this.name = name;\n};\n\n// 原型的方法\nPerson.prototype.sayHello = function(){\n  console.log(this.name+\",hello\");\n};\n\n// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法\nvar person1 = new Person(\"zhangsan\");\nvar person2 = new Person(\"lisi\");\n\n// zhangsan,hello\nperson1.sayHello();\n// lisi,hello\nperson2.sayHello();\n\n\n// 为新对象实例添加方法\n// 通过原型创建的新对象实例是相互独立的\nperson1.getName = function(){\n    console.log(this.name);\n}\n\n// zhangsan\nperson1.getName();\n// Uncaught TypeError: person2.getName is not a function\nperson2.getName();\n```\n\n4. 原型的总结：\n\n* 所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象\n* 所有函数都有一个prototype(原型)属性，属性值是一个普通的对象\n* 所有引用类型的__proto__属性指向它构造函数的prototype\n\n5. 函数的原型prototype：函数才有prototype，prototype是一个对象，指向了当前构造函数的引用地址\n6. 函数的原型对象__proto__：所有对象都有__proto__属性， 当用构造函数实例化（new）一个对象时，会将新对象的__proto__属性指向 构造函数的prototype\n\n7. 原型对象和函数的原型的关系\n![原型对象和函数的原型的关系](https://img-blog.csdnimg.cn/20190623221321362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)\n\n> 说明：\n> * 所有函数的__proto__都是指向Function的prototype\n> * 构造函数new出来的对象__proto__指向构造函数的prototype\n> * 非构造函数实例化出的对象或者对象的prototype的__proto__指向Object的prototype\n>   Object的prototype指向null\n\n8. 所有的原型对象都会自动获得一个``constructor``（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）\n9. 实例的构造函数属性（constructor）指向构造函数 ：person1.constructor == Person\n10. 原型对象（Person.prototype）是 构造函数（Person）的一个实例\n11. 原型的分类：\n* ``隐式原型（_proto_）``：上面说的这个原型是JavaScript中的内置属性[[prototype]]，此属性继承自object对象，在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_，隐式原型的作用是用来构成原型链，实现基于原型的继承\n* ``显示原型``（prototype）``：每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享\n12. 原型的使用方式：\n通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型\n在赋值原型prototype的时候使用function立即执行的表达式来赋值，可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果\n\n#### 25.2.1 原型链\n原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构\n\n#### 25.2.2 原型设计的问题\n当查找一个对象的属性时，JavaScript 会根据原型链向上遍历对象的原型，直到找到给定名称的属性为止，直到到达原型链的顶部仍然没有找到指定的属性，就会返回 undefined\n也可以理解为原型链继承时查找属性的过程是先查找自身属性，当自身属性不存在时，会在原型链中逐级查找\n\n#### 25.2.3 hasOwnProperty 函数：\n可以用来检查对象自身是否含有某个属性，返回值是布尔值，当属性不存在时不会向上查找对象原型链，*hasOwnProperty是 JavaScript 中``唯一一个``处理属性但是不查找原型链的函数*\n\n#### 25.2.4 getOwnPropertyNames 函数\n可以获取对象所有的自身属性，返回值是由对象自身属性名称组成的数组，同样不会向上查找对象原型链\n\n#### 25.2.5 原型链的小结：\n一直往上层查找，直到到null还没有找到，则返回undefined\nObject.prototype.__proto__ === null\n所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象\n\n6）JavaScript的原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法\n\n#### 25.2.6 常见面试题\n\n* 谈谈你对原型的理解？\n在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法\n\n* 什么是原型链？原型链解决的是什么问题？\n 1. 原型链解决的主要是继承问题\n 2. 每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法\n 3. 构造函数 Parent、Parent.prototype 和 实例 p 的关系如下:(p.__proto__ === Parent.prototype)\n![](https://img-blog.csdnimg.cn/20190623221912165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)\n\n* prototype 和 proto 区别是什么？\n 1. prototype是构造函数的属性\n 2. __proto__是每个实例都有的属性，可以访问 [[prototype]] 属性\n 3. 实例的__proto__与其构造函数的prototype指向的是同一个对象\n\n### 25.3 补充（原先的）\n#### 25.3.1 属性搜索原则：自己有就访问自己的，自己没有，去原型链中就近查找\n1. 如果自己有这个属性，就访问自己的\n2. 如果自己没有这个属性，会到原型中找，如果找到，不找了，直接返回\n3. 如果原型中也没有，会到原型的原型中找...\n4. 一直找到Object.prototype，如果老祖宗也没有，返回undefined\n\n#### 25.3.2 设置属性：\n如果有这个属性，直接修改赋值\n如果自己没有这个属性，给自己添加一个新属性（不会改到原型）\n\n#### 25.3.3 Object.prototype的成员\n1. ``hasOwnProperty``\n\t语法：``对象.hasOwnProperty('属性名')`` ---判断属性是否是自己的，而不是原型的（不是继承来的）\n\tfor in 遍历，不仅自己的属性可以遍历，原型上的属性也会遍历到（对于constructor等浏览器内置的属性，被浏览器进行来了处理，不会被for in便利出来）\n\t遍历时，只打印自身的（用hasOwnProperty进行判断）\n\tin操作符：判断属性是否可以被对象所访问（只要能够访问到这个属性，就返回true）---这个不是成员\n\t语法：'属性名' in 对象\n\n2. ``A.isPrototypeOf(B)``:判断A是不是B的原型\n\t\n3. ``对象.propertyIsEnumerable('属性名')`` 判断属性是否可以遍历（可枚举）\n4. toSting()\n5. valueof()\n\n6. instanceof运算符\n\t语法：A instanceof B（判断A是否是B的实例，B构造函数）\n\t进阶原理：判断B.prototype在不在A的原型链上\n\t使用typeof无法区分具体的对象类型！！！\n\n```javascript\nconsole.log(p.constructor.name)---可以用来打印类型\nObject.prototype.toString.call([]) ---可以用来获取复杂数据是什么类型 ---[object Array]\n```\n\n\n## 26、js数据类型\n堆和栈（只是将Java中概念，拿过来类比了）\njs中没有特别明确的堆和栈的概念，而且js的实现，也不需要堆和栈的概念\njava中堆内存和栈内存\n1.所有的``简单数据``类型，存在``栈``中\n2.所有的``复杂数据``类型，存在``堆``中---真实存在变量中的，也是地址\n\n\n\n## 27、this的规则：\nxx.fn();---fn函数调用时里面的this，指向调用者（谁调用的，this就指向谁）\n1. 如果是直接调用的方法，this指向window\n\t\t（1）function fn(){console.log(this)}\n\t\t         fn();\n\t\t（2）setInterval(function(){console.log(this)},2000)---定时器中的this指向window\n2. 如果对象中的方法，被调用了，this指向调用者，谁调用的，指向谁\n3. 特例，构造函数中执行的this，this指向新创建的对象\n\n全局的var a = 123;  等价于 window.a = 123;\n\n\n## 28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️\n### 28.1 原型链继承\n```javascript\nfunction Person() {\n  this.name = 'Hello World';\n}\nPerson.prototype.getName = function() {\n  console.log(this.name)\n}\nfunction Child() {\n\n}\nChild.prototype = new Person()\nvar child1 = new Child()\nchild1.getName() // Hello World\n```\n***重点：***\n让新实例的原型等于父类的实例。\n\n***优点：***\n实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的 属性！）\n\n***缺点：***\n1. 新实例无法向父类构造函数传参。\n2. 继承单一。\n3. 所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性 也会被修改！）\n\n### 28.2 构造函数继承\n```javascript\nfunction Person(){\n  this.name = 'xiaoming';\n  this.colors = ['red', 'blue', 'green'];\n}\n\nPerson.prototype.getName = function(){\n  console.log(this.name);\n}\n\nfunction Child(age){\n  Person.call(this);\n  this.age = age\n}\n\nvar child1 = new Child(23);\nvar child2 = new Child(12);\nchild1.colors.push('yellow');\nconsole.log(child1.name); // xiaoming\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(child2.colors); // [\"red\", \"blue\", \"green\"]\n```\n\n***重点：***\n用.call()和.apply()将父类构造函数引入子类函数（在子类 函数中做了父类函数的自执行（复制））\n\n***优点：***\n 1. 只继承了父类构造函数的属性，没有继承父类原型的属性。\n 2. 解决了原型链继承缺点1、2、3。\n 3. 可以继承多个构造函数属性（call多个）。\n 4. 在子实例中可向父实例传参。\n\n***缺点：***\n 1. 只能继承父类构造函数的属性。\n 2. 无法实现构造函数的复用。（每次用每次都要重新调用）\n 3. 每个新实例都有父类构造函数的副本，臃肿。\n\n### 28.3 组合继承（组合原型链继承和借用构造函数继承）（常用）\n```javascript\nfunction Parent(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function(){\n    console.log(this.name);\n}\n\nfunction Child(name,age){\n    Parent.call(this,name);// 第二次调用 Parent()\n    this.age = age;\n}\n\nChild.prototype = new Parent(); // 第一次调用 Parent()\n\nvar child1 = new Child('xiaopao',18);\nvar child2 = new Child('lulu',19);\n```\n\n***重点：***\n结合了两种模式的优点，传参和复用\n\n***优点：***\n1. 可以继承父类原型上的属性，可以传参，可复用。\n2、每个新实例引入的构造函数属性是私有的。\n\n***缺点：***\n调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。\n\n### 28.4 原型式继承\n```javascript\nfunction CreateObj(o){\n    function F(){}\n    F.prototype = o;\n    console.log(o.__proto__ === Object.prototype);\n    console.log(F.prototype.constructor === Object); // true\n    return new F();\n}\n\nvar person = {\n    name: 'xiaopao',\n    friend: ['daisy','kelly']\n}\n\nvar person1 = CreateObj(person);\n\n// var person2 = CreateObj(person);\n\nperson1.name = 'person1';\n// console.log(person2.name); // xiaopao\nperson1.friend.push('taylor');\n// console.log(person2.friend); // [\"daisy\", \"kelly\", \"taylor\"]\n// console.log(person); // {name: \"xiaopao\", friend: Array(3)}\nperson1.friend = ['lulu'];\n// console.log(person1.friend); // [\"lulu\"]\n// console.log(person.friend); //  [\"daisy\", \"kelly\", \"taylor\"]\n// 注意： 这里修改了person1.name的值，person2.name的值并未改变，并不是因为person1和person2有独立的name值，而是person1.name='person1'是给person1添加了name值，并非修改了原型上的name值\n// 因为我们找对象上的属性时，总是先找实例上对象，没有找到的话再去原型对象上的属性。实例对象和原型对象上如果有同名属性，总是先取实例对象上的值\n```\n\n***重点：***\n用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。\n\n***优点：***\n类似于复制一个对象，用函数来包装。\n\n***缺点：***\n1. 所有实例都会继承原型上的属性。\n2. 无法实现复用。（新实例属性都是后面添加的）\n\n### 28.5 寄生式继承\n```javascript\nvar ob = {\n    name: 'xiaopao',\n    friends: ['lulu','huahua']\n}\n\nfunction CreateObj(o){\n    function F(){};  // 创建一个构造函数F\n    F.prototype = o;\n    return new F();\n}\n\n// 上面CreateObj函数 在ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的 , 看下面代码\nvar ob1 = CreateObj(ob);\nvar ob2 = Object.create(ob);\nconsole.log(ob1.name); // xiaopao\nconsole.log(ob2.name); // xiaopao\n\nfunction CreateChild(o){\n    var newob = CreateObj(o); // 创建对象 或者用 var newob = Object.create(ob)\n    newob.sayName = function(){ // 增强对象\n        console.log(this.name);\n    }\n    return newob; // 指定对象\n}\n\nvar p1 = CreateChild(ob);\np1.sayName(); // xiaopao \n```\n***重点：***\n就是给原型式继承外面套了个壳子。\n\n***优点：***\n没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。\n\n***缺点：***\n没用到原型，无法复用。\n\n### 28.6 寄生组合式继承（常用）\n```javascript\nfunction Parent(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nfunction Child(name,age){\n    Parent.call(this,name); \n    this.age = age;\n}\n\nfunction CreateObj(o){\n    function F(){};\n    F.prototype = o;\n    return new F();\n}\n\n// Child.prototype = new Parent(); // 这里换成下面\nfunction prototype(child,parent){\n    var prototype = CreateObj(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\nprototype(Child,Parent);\n\nvar child1 = new Child('xiaopao', 18);\nconsole.log(child1); \n```\n***重点：***\n修复了组合继承的问题\n\n### 28.7 class继承\n```javascript\nclass Parent5 {\n  constructor() {\n    this.name = ['super5']\n  }\n  reName() {\n    this.name.push('new 5')\n  }\n}\nclass Child5 extends Parent5 {\n  constructor() {\n    super()\n  }\n}\nvar child51 = new Child5()\nvar child52 = new Child5()\n```\n\n## 29、定义函数的三种方式\n### 29.1 函数声明式\n```\nfunction fn(){}\nfn();\n```\n### 29.2 函数表达式\n```\nvar fn = function(){};\nfn();\n```\n### 29.3 构造函数的方式 \n```\nnew Function(...)\n```\n作用：可以直接执行字符串\n参数：都是字符串类型，最后一个参数是函数体，前面其他所有参数是定义的形参\n\t\t 只有一个参数，就会当成函数体\n```javascript\nvar fn = new Function('a' , 'b' , 'console.log(a+b)');\nfn(1,2);\n```\n\n## 30、try和catch\n\t\n* try和catch必须一起使用\n*\ttry表示尝试执行某段代码，就算发生了错误，js也会继续执行\n*\tcatch，只要try中代码发生了错误，就会执行catch中的代码\n*\tfinally:不管try中的代码执行是否成功，都会执行finally的代码\n```javascript\n\ttry {  ----尝试执行某段代码\n\t\tvar fn = new Function(value);\n\t\tfn();\n\t}\n\tcatch（e）{ ---- 抓取，可以抓取到try执行中的错误，可以进行处理，可以不处理\n\t\tconsole.log(e)\n\t}\n\tfinally{\n\t}\t\n```\n\n## 31、eval(str)可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）\n```javascript\nvar a = 100;\nvar str = 'var a = 1; var b = 2; console.log(a + b)';\neval(str); \n```\n\n## 32、四种调用模式\n\n* 函数：指的是普通的，不属于任何对象的函数\n* 方法：作为对象的属性存在的函数（对象中的函数）\n*\t函数内的this指向谁，只跟怎么调用有关系，跟函数定义在什么地方，没有任何关系\n\n### 32.1 函数调用模式\n```javascript\nfn( );   // this指向window\n```    \n\n### 32.2 方法调用模式\n```javascript\nobj.fn();  // this指向obj，谁调用指向谁\n```\n> 可以把数组当成一个对象，访问0属性，就是方法，方法调用模式，指向arr\n\n### 32.3 构造函数调用模式\n```javascript\nvar p = new Person();  // this指向实例p---new改变了this的指向，让this指向了新的实例\n```\n\t\n### 32.4 上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）\n\n1. call\n\t\t\n * 任何函数（都可以看成一个特殊的对象，也可以设置属性和方法）都有一个call方法\n * call方法也可以用于调用函数,还可以指定函数执行的this的指向---fn.call(this指向);\n * 如果不传参，默认this指向window，如果传递第一个参数，那么就会指定this的指向\n\t\t\n ***使用call来调用函数和普通调用函数的方式，唯一的区别，就是多了一个参数，call的第一个参数用于指定this指向***\n\n``数组``：有着数组的方法，可以遍历\n``伪数组``，本质上是对象，不是数组，数组的方法不能直接调用，但是伪数组是可以遍历的\n常见的伪数组：``arguments`` ``document.querySelector()``  ``jQuery``\n\n> 小结：学习call方法，fn.call(this指向,x,y,z);\n>\t\t   call方法调用函数和普通函数调用的唯一区别，在于多了一个参数，第一个参数，用于指定this\n>\t\t   call方法，可以用于函数借调（借用别人的函数，借来调用）\n>\t\t   别人.方法.call(自己)；将this改成自己，借用别人的方法\n\n2. apply\n\t\t\n * apply的功能和call的功能是一样的，只是调用的方法不同了\n * 每个函数，都有一个apply方法，可以用于调用函数，且可以指定this指向\n * ***apply的语法：fn.apply(this指向，[x,y,z]);***\n   * 参数1：用于指定this的指向\n   * 参数2：接收一个数组，里面存放着所有传递的参数\n\t\n\t> 如果参数比较少，一般使用call，比较简单\n\t> 如果参数比较多，一般使用apply，可以将所有需要传递的参数，放在一个数组中，一次性传递\n\t\n3. bind（复制一个新函数，并且将新函数的this固定死指向传入的this值）\n  ```javascript\n\t\tvar newFn = fn.bind(this指向)\n  ```\n\n4. arguments\n\n* 任何一个函数，都有一个对象，arguments，是一个伪数组，用于收集所有传递的参数（实参）\n* 一般用于参数不确定的情况\n\n  new会和最近的 函数名() 结合，是一个整体，new fn()\n\n> 补充：（1）定时器中的this ，指向window\n>       (2）事件处理函数中，浏览器让this指向了事件源\n\n\n\t\t\t\n## 33、函数也是对象\n函数也是一种特殊的对象，可以添加属性和方法\n\n## 34、js的规则：\n1. 任何``函数``，都是由``Function``创建出来的，包括他自己，包括Object函数\n2. 任何的``原型对象``，都是直接由``Object``创建出来的\n\njs中的作用域：词法作用域，静态作用域，函数的作用域在函数声明时，就已经确定好了，跟调用没有关系\n作用域链：每个函数都有自己的作用域，如果是定义在函数内的函数，里面的函数又会有自己的作用域（一层套一层，形成了作用域链）\n变量的查询规则：先看自己作用域有没有这个变量，如果没有，往外一层一层的就近查找，如果一直找到全局都没有找到，就会报错\n\n\n\n## 35、递归函数：在一个函数内部，自己调用自己\n\n函数在调用时，其实是占用内存，函数在调用时，会开辟一块内存，进行执行\n\n**特点：**\n1. 自己调用自己\n2. 必须要有结束条件，要有出口\n\n*递归：是一种算法，一种思想 ，化归思想，复杂的问题简单化*\n\n### 35.1 斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和\n```javascript\n// 直接这么写会有性能问题\nfunction getFib(n) {\n  if (n === 1 || n === 2) {\n    return 1;\n  }\n  return getFib(n-1) + getFib(n-2);\n}\n```\n\n***为什么会有性能问题？***\n一个函数内部，调用了两次自己，真正执行时进行了大量的重复运算\n\n***如何优化：将已经算过的第n个斐波那契数列存起来***\n运算过程中：\n 1. 先判断这个数，有没有算过，如果算过了，直接用\n 2. 如果没有算过，接着自己算，算完，存起来\n```javascript\n// 找规律: getFib(n) = getFib(n-1) + getFib(n-2);\nvar arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数\nfunction getFib(n) {\n  if (n === 1 || n === 2) {\n    return 1;\n  }\n\n  if (arr[n]) {\n    return arr[n];\n  }\n  else {\n    arr[n] = getFib(n-1) + getFib(n-2);\n    return arr[n];\n  }\n}\n```\n  \n  \n***利用闭包解决斐波那契数列***\n```javascript\n// 省去了外部的函数名, 利用函数自调用\n\nvar result = (function() {\n  var arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数\n  function getFib(n) {\n    if (n === 1 || n === 2) {\n      return 1;\n    }\n\n    if (arr[n]) {\n      return arr[n];\n    }\n    else {\n      arr[n] = getFib(n - 1) + getFib(n - 2);\n      return arr[n];\n    }\n  }\n  return getFib;\n})();\n```\n\n## 36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包\n* 作用：保护变量（变量私有化）\n*\t闭包的内存，不会直接释放（会占用内存）\n*\t函数执行调用时，必然会开辟一快内存空间，一般来说，执行完就会释放\n\n***闭包的基本模型：***\n1. outer里面包inner\n2. 匿名函数自调用\n```javascript\nvar result = (function(){\n  var count = 0;\n  return function(){\n    count++;\n    console.log(count);\n  }\n})();\n```\n\n## 37、js垃圾回收机制（会将一些不用的内存空间，释放掉）\n\n**内存泄漏：**如果一块内存空间，一直得不到释放，就认为这块内存泄漏了\n**机制：**\n 1. 引用计数：如果一块空间的引用次数，最终变成0，就会被释放掉\n\t\tbug：如果两个对象，互相引用，形成了循环引用，使用引用计数，就会得不到释放（内存泄漏）\n 2. 标记清除：如果一块内存空间，可以访问到，就不释放；如果访问不到了，就会释放掉\n\t\t闭包用完了，只需要将指向函数内部的引用干掉，此时内存就会释放了\n\n\t\n## 38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）\n\n### 38.1 创建正则表达式：\n1. 通过构造函数 \n```javascript\nvar reg = new RegExp(//);\n```\n\\d 表示数字，0-9，/\\d/可以匹配所有的数字\n通过 ``test`` 方法，判断字符串，是否符合正则规则\n2. 字面量\n```javascript\nvar reg = /\\d/;\n```\n\n\t\n### 38.2 正则-元字符\n\n#### 38.2.1 普通字符：a b c\n#### 38.2.2 元字符：有特殊含义的\n\n1. ``\\d`` 数字，0-9\n2. ``\\D`` 非数字\n3. ``\\w`` 匹配单词字符（字母数字下划线），0-9  a-z  A-Z  _\n4. ``\\W`` 非\\w（只要不是\\w中的字符，都匹配）\n5. ``\\s`` 匹配不可见字符（换行``\\n`` ``空格`` ）\n6. ``\\S`` 匹配可见字符\n7. ``.`` 匹配任意字符（除了``\\n``）----a.b可以匹配acb  aab a1b......\n  有时，就需要匹配点，需要转义 \\.-->表示普通的点\n\n### 38.3 正则表达式的优先级\n``|`` 表示或，优先级最低\n``()`` 优先级最高，一般用于提升优先级\n\n### 38.4 正则表达式的字符\n``[ ]``这个位置，可以出现的字符---[abc]，这个位置，可以出现a或者b或者c\n``[a-z]``，这个位置，可以出现a-z的所有小写字符\n``[a-zA-Z0-9_]``，这个位置，可以出现所有的字母、数字、下划线\n[ ]内的 ^ 表示非\n\t\n### 38.5 正则的边界（严格匹配）\n``^``必须以...开头\n``$`` 必须以...结尾\nconsole.log(/^$/);---严格匹配，严格到字符数都是确定的\n\n### 38.6 正则的量词\n``*`` 出现0次或多次\n``+`` 出现1次或多次\n``?`` 出现0次或1次\n``{m,n}`` 表示可以出现m次到n次\n``{m,}`` 表示至少出现m次\n``{m}`` 出现m次\n汉字也是字符的一种，也有范围[\\u4e00-u9fa5\\]---一 yu\n\t\n### 38.7 正则的replace（不严格的替换）\n正则也比较懒，不加参数，只替换一次（加上g，表示 全局替换）\n```javascript\nstr.replace(/aa/g,'xx')\n```\n\n## 39、js校正计算\n/**\n ** 加法函数，用来得到精确的加法结果\n ** 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。\n ** 调用：accAdd(arg1,arg2)\n ** 返回值：arg1加上arg2的精确结果\n **/\n```javascript\nfunction accAdd(arg1, arg2) {\n    var r1, r2, m, c;\n    try {\n        r1 = arg1.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = arg2.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n        r2 = 0;\n    }\n    c = Math.abs(r1 - r2);\n    m = Math.pow(10, Math.max(r1, r2));\n    if (c > 0) {\n        var cm = Math.pow(10, c);\n        if (r1 > r2) {\n            arg1 = Number(arg1.toString().replace(\".\", \"\"));\n            arg2 = Number(arg2.toString().replace(\".\", \"\")) * cm;\n        } else {\n            arg1 = Number(arg1.toString().replace(\".\", \"\")) * cm;\n            arg2 = Number(arg2.toString().replace(\".\", \"\"));\n        }\n    } else {\n        arg1 = Number(arg1.toString().replace(\".\", \"\"));\n        arg2 = Number(arg2.toString().replace(\".\", \"\"));\n    }\n    return (arg1 + arg2) / m;\n}\n \n//给Number类型增加一个add方法，调用起来更加方便。\nNumber.prototype.add = function (arg) {\n    return accAdd(arg, this);\n};\n```\n\n\n\n/**\n ** 减法函数，用来得到精确的减法结果\n ** 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。\n ** 调用：accSub(arg1,arg2)\n ** 返回值：arg1加上arg2的精确结果\n **/\n```javascript\nfunction accSub(arg1, arg2) {\n    var r1, r2, m, n;\n    try {\n        r1 = arg1.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = arg2.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n        r2 = 0;\n    }\n    m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度\n    n = (r1 >= r2) ? r1 : r2;\n    return ((arg2 * m - arg1 * m) / m).toFixed(n);\n}\n \n// 给Number类型增加一个mul方法，调用起来更加方便。\nNumber.prototype.sub = function (arg) {\n    return accSub(arg, this);\n};\n```\n\n\n\n/**\n ** 乘法函数，用来得到精确的乘法结果\n ** 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。\n ** 调用：accMul(arg1,arg2)\n ** 返回值：arg1乘以 arg2的精确结果\n **/\n```javascript\nfunction accMul(arg1, arg2) {\n    var m = 0, s1 = arg1.toString(), s2 = arg2.toString();\n    try {\n        m += s1.split(\".\")[1].length;\n    }\n    catch (e) {\n    }\n    try {\n        m += s2.split(\".\")[1].length;\n    }\n    catch (e) {\n    }\n    return Number(s1.replace(\".\", \"\")) * Number(s2.replace(\".\", \"\")) / Math.pow(10, m);\n}\n \n// 给Number类型增加一个mul方法，调用起来更加方便。\nNumber.prototype.mul = function (arg) {\n    return accMul(arg, this);\n};\n```\n\n\n\n\n/** \n ** 除法函数，用来得到精确的除法结果\n ** 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。\n ** 调用：accDiv(arg1,arg2)\n ** 返回值：arg1除以arg2的精确结果\n **/\n```javascript\nfunction accDiv(arg1, arg2) {\n    var t1 = 0, t2 = 0, r1, r2;\n    try {\n        t1 = arg1.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n    }\n    try {\n        t2 = arg2.toString().split(\".\")[1].length;\n    }\n    catch (e) {\n    }\n    with (Math) {\n        r1 = Number(arg1.toString().replace(\".\", \"\"));\n        r2 = Number(arg2.toString().replace(\".\", \"\"));\n        return (r1 / r2) * pow(10, t2 - t1);\n    }\n}\n \n//给Number类型增加一个div方法，调用起来更加方便。\nNumber.prototype.div = function (arg) {\n    return accDiv(this, arg);\n};\n```\n\t\t\n","slug":"javascript","published":1,"updated":"2021-08-18T08:21:26.755Z","layout":"post","link":"","_id":"cku2cstrn001k4v9kv2ikpvfe","content":"<h2 id=\"1、介绍\"><a href=\"#1、介绍\" class=\"headerlink\" title=\"1、介绍\"></a>1、介绍</h2><p>js全称javascript，是一门运行在浏览器端的脚本语言，现在也可以运行在服务器端（node.js）</p>\n<h2 id=\"2、组成\"><a href=\"#2、组成\" class=\"headerlink\" title=\"2、组成\"></a>2、组成</h2><p>现在说的javasript包含3个组成部分</p>\n<ol>\n<li><strong>ECMAScript</strong> 语法标准，语法规则</li>\n<li><strong>DOM</strong> 专门用于操作页面元素的方法</li>\n<li><strong>BOM</strong> 专门用于操作浏览器的方法</li>\n</ol>\n<p><code>webapi</code>有时用来统称1和2</p>\n<h2 id=\"3、js书写位置\"><a href=\"#3、js书写位置\" class=\"headerlink\" title=\"3、js书写位置\"></a>3、js书写位置</h2><ol>\n<li>直接将内容编写在script标签中</li>\n<li>可以直接在一个单独的js文件中编写，需要引入</li>\n</ol>\n<blockquote>\n<p>注意点：只要script标签，设置了src属性，标签内的内容将被忽略</p>\n</blockquote>\n<h2 id=\"4、js的注释\"><a href=\"#4、js的注释\" class=\"headerlink\" title=\"4、js的注释\"></a>4、js的注释</h2><p>注释给开发者看的，浏览器不会执行，方便维护</p>\n<ul>\n<li>单行注释// 快捷键<code>ctrl+/</code></li>\n<li>多行注释/**/ 快捷键<code>alt+shift+a</code></li>\n</ul>\n<h2 id=\"5、js的输出语句\"><a href=\"#5、js的输出语句\" class=\"headerlink\" title=\"5、js的输出语句\"></a>5、js的输出语句</h2><blockquote>\n<p>指的就是往页面中输出的方式</p>\n<ul>\n<li><code>alert</code> 警告框</li>\n<li><code>confirm</code> 确认框（可以选择的）</li>\n<li><code>prompt</code> 输入框，可以让用户输入内容</li>\n<li><code>document.write</code> 往页面中追加输入内容</li>\n<li>支持标签的解析（识别标签）</li>\n<li><code>console.log</code> 在控制台打印内容，专门用于调试的，给开发者看</li>\n</ul>\n</blockquote>\n<h2 id=\"6、变量（就是可以变化的量）\"><a href=\"#6、变量（就是可以变化的量）\" class=\"headerlink\" title=\"6、变量（就是可以变化的量）\"></a>6、变量（就是可以变化的量）</h2><h3 id=\"6-1-作用\"><a href=\"#6-1-作用\" class=\"headerlink\" title=\"6.1 作用\"></a>6.1 作用</h3><p>存储数据，为了将来可以运算使用</p>\n<ol>\n<li>先声明，后赋值<pre><code class=\"javascript\">var age;\nage = 18;\n</code></pre>\n</li>\n<li>同时声明和赋值<pre><code class=\"javascript\"> var age1 = 18;\n console.log(age1);\n</code></pre>\n</li>\n<li>只声明，不赋值（<code>undefined</code>未定义，只要变量声明了但是未赋值，默认值就是undefined）</li>\n<li>不声明，直接赋值(<strong>不推荐</strong>，变量一定要声明了，再使用)<pre><code class=\"javascript\">age3=30;\nconsole.log(age3);\n</code></pre>\n</li>\n<li>不声明，不赋值，直接用  xxx is not defined 一定是没有声明赋值的变量直接用了，会报错</li>\n<li>可以同时声明赋值多个变量（本质上，只是省略了var）</li>\n</ol>\n<h3 id=\"6-2-变量命名规则和规范\"><a href=\"#6-2-变量命名规则和规范\" class=\"headerlink\" title=\"6.2 变量命名规则和规范\"></a>6.2 变量命名规则和规范</h3><h4 id=\"6-2-1-规则\"><a href=\"#6-2-1-规则\" class=\"headerlink\" title=\"6.2.1 规则\"></a>6.2.1 规则</h4><ul>\n<li>变量名必须由字母 数字 下划线和 $组成，不能以数字开头（后来也引入中文，但是不要这么做）</li>\n<li>变量名不能是关键字或者是保留字</li>\n<li>变量区分大小写</li>\n</ul>\n<h4 id=\"6-2-2-规范\"><a href=\"#6-2-2-规范\" class=\"headerlink\" title=\"6.2.2 规范\"></a>6.2.2 规范</h4><ul>\n<li>声明的变量要有意义</li>\n<li>声明的变量，如果很长，遵循驼峰命名（从第二个字母开始，首字母大写，用于分割单词，可读性高）</li>\n</ul>\n<h3 id=\"6-3-变量的作用域（变量起作用的区域）\"><a href=\"#6-3-变量的作用域（变量起作用的区域）\" class=\"headerlink\" title=\"6.3 变量的作用域（变量起作用的区域）\"></a>6.3 变量的作用域（变量起作用的区域）</h3><ul>\n<li>全局作用域（在script标签内，在函数外的区域）<br>  声明在全局作用域的变量，就叫全局变量<br>  特征：在任何地方都可以使用</li>\n<li>局部作用域（函数内部的区域，就是局部作用域）<br>  声明在函数内部的变量，就叫局部变量<br>  特征：只在当前函数内可以使用，出了函数，就不能用了</li>\n</ul>\n<h3 id=\"6-4-变量的访问规则\"><a href=\"#6-4-变量的访问规则\" class=\"headerlink\" title=\"6.4 变量的访问规则\"></a>6.4 变量的访问规则</h3><p>如果自己的作用域内有这个变量，直接用，改自己的<br>如果没有，才会往外面找（找全局）,用外面的，改外面的 </p>\n<h3 id=\"6-5-隐式全局变量\"><a href=\"#6-5-隐式全局变量\" class=\"headerlink\" title=\"6.5 隐式全局变量\"></a>6.5 隐式全局变量</h3><p>如果一个没有声明过的变量，直接赋值，就叫隐式全局变量（将来要避免）</p>\n<h3 id=\"6-6-预解析（预先解析，浏览器会先查看有多少的变量和函数）\"><a href=\"#6-6-预解析（预先解析，浏览器会先查看有多少的变量和函数）\" class=\"headerlink\" title=\"6.6 预解析（预先解析，浏览器会先查看有多少的变量和函数）\"></a>6.6 预解析（预先解析，浏览器会先查看有多少的变量和函数）</h3><ol>\n<li>所有的变量声明，都会提升到最顶部，只提升声明，不提升赋值</li>\n<li>所有的函数声明，都会提升到最顶部，只提升声明，不提升调用<blockquote>\n<p>补充说明:</p>\n<ol>\n<li>多个重名的var声明，后面的var将被忽略<ol start=\"2\">\n<li>多个重名的函数声明，后面的将前面的覆盖</li>\n<li>如果出现了同名的变量和函数，函数优先，函数的优先级&gt;变量</li>\n<li>函数内部也会进行预解析</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p>预解析，虽然可以提升我们的声明，但是我们开发时，还是要<strong>先声明，后使用</strong>！！！</p>\n<h2 id=\"7、js的数据类型\"><a href=\"#7、js的数据类型\" class=\"headerlink\" title=\"7、js的数据类型\"></a>7、js的数据类型</h2><p>分为：<code>简单数据类型</code>和<code>复杂数据类型</code> （数组、函数、对象）</p>\n<h3 id=\"7-1-简单数据类型\"><a href=\"#7-1-简单数据类型\" class=\"headerlink\" title=\"7.1 简单数据类型\"></a>7.1 简单数据类型</h3><h4 id=\"7-1-1-number类型（数字类型）\"><a href=\"#7-1-1-number类型（数字类型）\" class=\"headerlink\" title=\"7.1.1 number类型（数字类型）\"></a>7.1.1 number类型（数字类型）</h4><ol>\n<li><p>整数（一般使用的是十进制  逢十进一）</p>\n<p> <code>八进制，逢八进一，0开头</code></p>\n<pre><code class=\"javascript\"> var num3 = 011  //就是1*8+1 为9;\n var num4 = 022  //2*8+2 为18\n</code></pre>\n<p> <code>十六进制，逢16进一，0x开头的数字  0-9abcdef</code></p>\n<pre><code class=\"javascript\"> var num2 = 0x11  //1*16+1 为17;\n var num3 = 0x1a  //16+10为26;\n</code></pre>\n</li>\n<li><p>浮点数（小数）</p>\n</li>\n<li><p>科学计数法 </p>\n<pre><code class=\"javascript\">var num1 = 1e4 就是1*10^4\n</code></pre>\n<blockquote>\n<p>注意点：计算机对于小数的运算是不准确的，会有很小很小的误差，所以尽量不要用  小数进行比较运算</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"7-1-2-string类型-字符串类型\"><a href=\"#7-1-2-string类型-字符串类型\" class=\"headerlink\" title=\"7.1.2 string类型 字符串类型\"></a>7.1.2 string类型 字符串类型</h4><ul>\n<li>通过 &#39;&#39; 或者 &quot;&quot; 包裹的就是字符串，js中单双引号，没有区别，推荐&#39;&#39;.</li>\n<li><p>字符串通过length，可以获取长度</p>\n<pre><code>  console.log（str.length）;\n</code></pre></li>\n<li><p>转义字符<br><code>\\&#39;</code> 表示一个普通的单引号<br>  <code>\\&quot;</code> 表示一个普通的双引号<br>  <code>\\n</code> 表示换行</p>\n</li>\n<li><p>拼串（拼接字符串）</p>\n<blockquote>\n<p><code>+</code> 有拼接字符串的功能，也有运算的功能</p>\n</blockquote>\n</li>\n</ul>\n<p><code>+</code> 的规则：</p>\n<ol>\n<li>只要两边有字符串（黑色），进行的就是拼串</li>\n<li>只有两边都是数字（蓝色），才进行运算</li>\n</ol>\n<h4 id=\"7-1-3-boolean类型-布尔类型\"><a href=\"#7-1-3-boolean类型-布尔类型\" class=\"headerlink\" title=\"7.1.3 boolean类型 布尔类型\"></a>7.1.3 boolean类型 布尔类型</h4><p>只有两个值，true真 false假<br>一般用于比较</p>\n<h4 id=\"7-1-4-undefined-未定义的，变量声明了，但是未赋值，默认值就是underfined\"><a href=\"#7-1-4-undefined-未定义的，变量声明了，但是未赋值，默认值就是underfined\" class=\"headerlink\" title=\"7.1.4 undefined 未定义的，变量声明了，但是未赋值，默认值就是underfined\"></a>7.1.4 undefined 未定义的，变量声明了，但是未赋值，默认值就是underfined</h4><h4 id=\"7-1-5-null-空对象\"><a href=\"#7-1-5-null-空对象\" class=\"headerlink\" title=\"7.1.5 null 空对象\"></a>7.1.5 null 空对象</h4><h3 id=\"7-2-复杂数据类型\"><a href=\"#7-2-复杂数据类型\" class=\"headerlink\" title=\"7.2 复杂数据类型\"></a>7.2 复杂数据类型</h3><h2 id=\"8、变量与简单数据类型的说明\"><a href=\"#8、变量与简单数据类型的说明\" class=\"headerlink\" title=\"8、变量与简单数据类型的说明\"></a>8、变量与简单数据类型的说明</h2><ul>\n<li>对于简单数据类型，浏览器直接认识（直接量 或者 字面量）</li>\n<li>若是将字符串当成了变量（未声明，未赋值的变量直接使用，会报错）</li>\n<li>字符串需要引号包裹</li>\n</ul>\n<h2 id=\"9、运算符（操作符）\"><a href=\"#9、运算符（操作符）\" class=\"headerlink\" title=\"9、运算符（操作符）\"></a>9、运算符（操作符）</h2><h3 id=\"9-1-算术运算符-取余\"><a href=\"#9-1-算术运算符-取余\" class=\"headerlink\" title=\"9.1 算术运算符 + - * / %(取余)\"></a>9.1 算术运算符 <code>+ - * / %(取余)</code></h3><ul>\n<li><code>+</code> 不仅有拼串的功能，还可以运算</li>\n<li>其他算数运算符，只有运算的功能，如果遇到了字符串，也会转成数字运算<pre><code class=\"javascript\">&quot;2&quot; - 1 = &gt;1\n</code></pre>\n<h3 id=\"9-2-赋值运算符\"><a href=\"#9-2-赋值运算符\" class=\"headerlink\" title=\"9.2 赋值运算符 =\"></a>9.2 赋值运算符 =</h3>=（就是赋值）   +=   -=   *=   /=   %=<pre><code class=\"javascript\">var num = 10;\nnum += 10; //等价 num = num + 10\n</code></pre>\n</li>\n</ul>\n<h3 id=\"9-3-自增或自减运算符（一元运算符）\"><a href=\"#9-3-自增或自减运算符（一元运算符）\" class=\"headerlink\" title=\"9.3 自增或自减运算符（一元运算符）\"></a>9.3 自增或自减运算符（一元运算符）</h3><h4 id=\"9-3-1-自增：让变量的值，在原来的基础上-1\"><a href=\"#9-3-1-自增：让变量的值，在原来的基础上-1\" class=\"headerlink\" title=\"9.3.1 自增：让变量的值，在原来的基础上+1\"></a>9.3.1 自增：让变量的值，在原来的基础上+1</h4><ul>\n<li><p>语法：<br><code>++num</code> 前自增，规则：先让值+1，再返回这个值<br><code>num++</code> 后自增，规则：先返回这个值，再让值+1</p>\n</li>\n<li><p>注意点： </p>\n<ul>\n<li>不管是++num 还是num++ 从功能的角度一样的，都是让变量的值+1</li>\n<li>虽然++num 或 num++ 都能让变量值+1，但是++num 和 num++这个式子的结果是不一样的</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"9-3-2-自减：让变量的值，在原来的基础上-1\"><a href=\"#9-3-2-自减：让变量的值，在原来的基础上-1\" class=\"headerlink\" title=\"9.3.2 自减：让变量的值，在原来的基础上-1\"></a>9.3.2 自减：让变量的值，在原来的基础上-1</h4><p>*语法：<br><code>--num</code><br><code>num--</code></p>\n<h3 id=\"9-4-逻辑运算符（与或非）\"><a href=\"#9-4-逻辑运算符（与或非）\" class=\"headerlink\" title=\"9.4 逻辑运算符（与或非）\"></a>9.4 逻辑运算符（与或非）</h3><p><code>&amp;&amp;</code> 并且 两边都要成立，结果才是 true，只要有一个不成立，就是false<br><code>||</code> 或 两边只要有一个成立，结果就是true<br><code>!</code> 取反</p>\n<h3 id=\"9-5-比较运算符-gt-lt-gt-lt\"><a href=\"#9-5-比较运算符-gt-lt-gt-lt\" class=\"headerlink\" title=\"9.5 比较运算符 &gt;  &lt;  &gt;=  &lt;=  ==   !=  ===   !==\"></a>9.5 比较运算符 &gt;  &lt;  &gt;=  &lt;=  ==   !=  ===   !==</h3><p><code>==</code> 规则：只看值，不看类型（只要值相等，就是相等）<br><code>===</code> 规则：看值，又看类型（值和类型都要相等）<br><code>!=</code> 规则：只看值，不看类型（只要值不等，就是true）<br><code>!==</code> 规则：看值，又看类型（只要值或者类型有一个不等，就是不等，返回true）</p>\n<blockquote>\n<p>==有一定规则（如果类型不同，转换成相同类型，然后比较）</p>\n<ol>\n<li>NaN，不等于任何值，包括他自己</li>\n<li>null，不等于任何值，除了null和undefined</li>\n<li>undefined，不等于任何值 ，除了null和undefined</li>\n<li>看是否有数字或布尔，如果有，转成数字比较<br>   true：1，false:0<br>   [ ]:0, { }:NaN，&#39;&#39;:0</li>\n<li>再看是否有字符串，（字符串和复杂数据类型），转成字符串比较<br> [ ].toString()---&gt;&quot;&quot;<br> obj.toString()---&gt;&#39;[object Object]&#39;</li>\n<li>都是复杂数据类型，比较的是内存地址</li>\n</ol>\n</blockquote>\n<h3 id=\"9-6-运算符优先级\"><a href=\"#9-6-运算符优先级\" class=\"headerlink\" title=\"9.6 运算符优先级\"></a>9.6 运算符优先级</h3><ol>\n<li>括号的优先级最高</li>\n<li>一元运算符 ++  --  !</li>\n<li>算数运算符  先乘除%，后加减</li>\n<li>比较运算符</li>\n<li>逻辑运算符  &amp;&amp;  ||</li>\n</ol>\n<blockquote>\n<p>记忆：（1）括号的优先级最高，逻辑运算符的优先级最低<br>         （2）先乘除，后加减</p>\n</blockquote>\n<h2 id=\"10、如何判断数据的类型\"><a href=\"#10、如何判断数据的类型\" class=\"headerlink\" title=\"10、如何判断数据的类型\"></a>10、如何判断数据的类型</h2><h3 id=\"10-1-直接打印看颜色（调试，看颜色）\"><a href=\"#10-1-直接打印看颜色（调试，看颜色）\" class=\"headerlink\" title=\"10.1 直接打印看颜色（调试，看颜色）\"></a>10.1 直接打印看颜色（调试，看颜色）</h3><p>蓝色的数字，number<br>黑色         string<br>蓝色的布尔值 boolean<br>灰色        undefined和null</p>\n<h3 id=\"10-2-typeof-变量-它的返回值，也是一个字符串类型\"><a href=\"#10-2-typeof-变量-它的返回值，也是一个字符串类型\" class=\"headerlink\" title=\"10.2 typeof 变量    它的返回值，也是一个字符串类型\"></a>10.2 typeof 变量    它的返回值，也是一个字符串类型</h3><ol>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n</ol>\n<blockquote>\n<p>bug: typeof null = object;</p>\n</blockquote>\n<h2 id=\"11、数据类型转换\"><a href=\"#11、数据类型转换\" class=\"headerlink\" title=\"11、数据类型转换\"></a>11、数据类型转换</h2><h3 id=\"11-1-转成数字\"><a href=\"#11-1-转成数字\" class=\"headerlink\" title=\"11.1 转成数字\"></a>11.1 转成数字</h3><ul>\n<li><code>Number（xx）</code> 如果拿到的是一个非数字，浏览器也不会报错，返回 <code>NaN</code>,not  a number </li>\n<li><code>parseInt（xx）</code> 从第一个字符开始解析，一直解析到第一个非数字为止</li>\n<li><code>parseFloat（xx）</code> 从第一个字符开始解析，可以识别一个<code>.</code>  然后解析到非数字为止</li>\n<li>直接运算 -  *  /  %    +正号（用的最多，例如+age）  -负号        </li>\n</ul>\n<h3 id=\"11-2-转成字符串\"><a href=\"#11-2-转成字符串\" class=\"headerlink\" title=\"11.2 转成字符串\"></a>11.2 转成字符串</h3><ul>\n<li>String（xx）</li>\n<li>xx.toString()</li>\n<li>直接拼串 （常用）<br>  console.log(age+ &quot;&quot;);</li>\n</ul>\n<h3 id=\"11-3-转成布尔类型\"><a href=\"#11-3-转成布尔类型\" class=\"headerlink\" title=\"11.3 转成布尔类型\"></a>11.3 转成布尔类型</h3><p><strong>所有的值，都可以转成布尔类型</strong></p>\n<p><strong>规则</strong>：只有这6种情况， 0  &quot;&quot;  NaN  null  undefined   false  可以转成false，其他所有值，都是true</p>\n<ul>\n<li>Boolean（）</li>\n<li>!!</li>\n</ul>\n<h3 id=\"11-4-NaN的说明（表示非数字，指一个无法用数字表示的数字，not-a-number）\"><a href=\"#11-4-NaN的说明（表示非数字，指一个无法用数字表示的数字，not-a-number）\" class=\"headerlink\" title=\"11.4 NaN的说明（表示非数字，指一个无法用数字表示的数字，not a number）\"></a>11.4 NaN的说明（表示非数字，指一个无法用数字表示的数字，not a number）</h3><ul>\n<li>如果浏览器遇到了一个无法用数字表示的数值，就用NaN表示</li>\n<li>只要看到了NaN，说明代码的执行有问题</li>\n<li>NaN的类型是number类型</li>\n<li>NaN不等于任何值，包括他自己</li>\n</ul>\n<h2 id=\"12、流程控制\"><a href=\"#12、流程控制\" class=\"headerlink\" title=\"12、流程控制\"></a>12、流程控制</h2><h3 id=\"12-1-顺序结构（从上到下执行的，默认）\"><a href=\"#12-1-顺序结构（从上到下执行的，默认）\" class=\"headerlink\" title=\"12.1 顺序结构（从上到下执行的，默认）\"></a>12.1 顺序结构（从上到下执行的，默认）</h3><h3 id=\"12-2-分支结构（选择结构）\"><a href=\"#12-2-分支结构（选择结构）\" class=\"headerlink\" title=\"12.2 分支结构（选择结构）\"></a>12.2 分支结构（选择结构）</h3><h4 id=\"12-2-1-if语句\"><a href=\"#12-2-1-if语句\" class=\"headerlink\" title=\"12.2.1 if语句\"></a>12.2.1 if语句</h4><ul>\n<li><p>语法1</p>\n<pre><code class=\"javascript\">if（条件）{\n语句1;\n}\n</code></pre>\n<p>如果条件成立，执行语句1</p>\n</li>\n<li><p>语法2</p>\n<pre><code>if（条件）{\n语句1;\n}\nelse {\n语句2;\n}\n</code></pre><p>如果条件成立，执行语句1，否则执行语句2</p>\n</li>\n<li><p>语法3</p>\n<pre><code>if（条件1）{\n语句1;\n}\nelse if（条件2） {\n语句2;\n}\nelse {\n语句3;\n}\n</code></pre></li>\n</ul>\n<p>如果条件1成立，执行语句1<br>如果条件1不成立，看条件2，如果条件2成立，执行语句2<br>如果都不成立，执行语句3</p>\n<h4 id=\"12-2-2-三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）\"><a href=\"#12-2-2-三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）\" class=\"headerlink\" title=\"12.2.2 三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）\"></a>12.2.2 三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）</h4><p>语法  var 结果 = 条件 ？ A ：B；（如果条件满足，就是A 否则B）</p>\n<h4 id=\"12-2-3-switch-case（根据变量的具体，进行判断）\"><a href=\"#12-2-3-switch-case（根据变量的具体，进行判断）\" class=\"headerlink\" title=\"12.2.3 switch-case（根据变量的具体，进行判断）\"></a>12.2.3 switch-case（根据变量的具体，进行判断）</h4><pre><code class=\"javascript\">switch（变量）{\n  case 值1:\n      语句1;\n      break;（break表示跳出switch，接着往下执行）\n  case 值2:\n      语句2;\n      break;（break表示跳出switch，接着往下执行）\n  case 值3:\n      语句3;\n      break;（break表示跳出switch，接着往下执行）\n  default:\n      默认语句;\n}\n</code></pre>\n<p><strong>判断变量的值</strong><br>    如果值，等于值1，执行语句1<br>    如果值，等于值2，执行语句2<br>    。。。<br>    如果都不满足，执行默认语句</p>\n<p><strong>注意点</strong>：<br>    （1）进行的值的比较，进行的是全等比较<br>    （2）养成写break的习惯（不写break，会一直往下执行）</p>\n<h4 id=\"12-2-4-三种分支结构的使用场景：\"><a href=\"#12-2-4-三种分支结构的使用场景：\" class=\"headerlink\" title=\"12.2.4 三种分支结构的使用场景：\"></a>12.2.4 三种分支结构的使用场景：</h4><ul>\n<li>if else            适用于范围形的判断</li>\n<li>三元运算符        只适用于比较简单的判断，条件只能写一个，但是简洁</li>\n<li>switch。。 case。。适用于具体值的判断</li>\n</ul>\n<h3 id=\"12-3-循环结构\"><a href=\"#12-3-循环结构\" class=\"headerlink\" title=\"12.3 循环结构\"></a>12.3 循环结构</h3><h4 id=\"12-3-1-while（当条件成立时，循环执行某件事）\"><a href=\"#12-3-1-while（当条件成立时，循环执行某件事）\" class=\"headerlink\" title=\"12.3.1 while（当条件成立时，循环执行某件事）\"></a>12.3.1 while（当条件成立时，循环执行某件事）</h4><pre><code class=\"javascript\">while（条件）{\n  循环体; //循环执行的内容\n}\n</code></pre>\n<p>条件成立，执行循环体<br>判断条件，条案件成立，继续执行循环体<br>。。。<br>条件不成立，跳出循环<br>死循环，永远都没有结束的一个循环，开发中需要避免</p>\n<ul>\n<li>while循环一定要有条件，不然就死循环了</li>\n<li>i++一般放在{..}的最后面</li>\n<li>while循环可以用于实现不明确循环次数的循环</li>\n</ul>\n<h4 id=\"12-3-2-do-while\"><a href=\"#12-3-2-do-while\" class=\"headerlink\" title=\"12.3.2 do while\"></a>12.3.2 do while</h4><pre><code class=\"javascript\">do {\n  循环体; //重复执行的内容\n}while（条件)\n</code></pre>\n<p>一上来，直接执行循环体<br>再判断条件，如果条件成立，再执行循环体<br>。。。<br>直到条件不成立，跳出循环</p>\n<blockquote>\n<p>do while一般只适合：不管条件成立不成立，都执行一次<br>while 和 do while的区别：<br>    while 如果条件不成立，一次都不执行<br>    do while不管条件成立与否，至少执行一次</p>\n</blockquote>\n<h4 id=\"12-3-3-for（适用于明确范围的循环）\"><a href=\"#12-3-3-for（适用于明确范围的循环）\" class=\"headerlink\" title=\"12.3.3 for（适用于明确范围的循环）\"></a>12.3.3 for（适用于明确范围的循环）</h4><pre><code>for（初始化语句;判断条件;自增或自减）{\n  循环体;\n}\n</code></pre><p>例：</p>\n<pre><code class=\"javascript\">for（var i = 1；i &lt; 5; i++）{\n  console.log(1);\n}\n</code></pre>\n<p>执行语句：</p>\n<ol>\n<li>初始化语句<ol start=\"2\">\n<li>判断条件</li>\n<li>自增或自减</li>\n<li>循环体</li>\n</ol>\n</li>\n</ol>\n<p>执行流程分析：1243 243 243 243...<br>执行流程：<br>  先初始化语句，判断条件，执行循环体，自增或自减；<br>    判断条件，执行循环体，自增或自减；<br>    。。。<br>    条件不成立，跳出循环；</p>\n<h4 id=\"12-3-4-双重for循环，就是在for循环的外面再套一个for循环\"><a href=\"#12-3-4-双重for循环，就是在for循环的外面再套一个for循环\" class=\"headerlink\" title=\"12.3.4 双重for循环，就是在for循环的外面再套一个for循环\"></a>12.3.4 双重for循环，就是在for循环的外面再套一个for循环</h4><ul>\n<li>外层控制行数</li>\n<li><p>内层控制一行打印多少个</p>\n<p>  break：如果循环遇到了break，跳出整个循环，整个循环就结束了，后面的次数都不执行了<br>  continue：如果循环遇到了continue，跳出本次循环，执行下一次循环</p>\n</li>\n</ul>\n<h4 id=\"12-3-5-循环的使用场景：\"><a href=\"#12-3-5-循环的使用场景：\" class=\"headerlink\" title=\"12.3.5 循环的使用场景：\"></a>12.3.5 循环的使用场景：</h4><ul>\n<li>while比较适合不明确执行次数的循环（循环表白案例）</li>\n<li>do while（少用）只适用于不管成立与否，至少执行一次循环体的情况</li>\n<li>for比较适合于明确范围的循环</li>\n</ul>\n<h2 id=\"13、断点调试\"><a href=\"#13、断点调试\" class=\"headerlink\" title=\"13、断点调试\"></a>13、断点调试</h2><p>（1）F12打开控制台，sources,点开对应的文件<br>（2）在对应行的行号上，点击打断点，刷新后，浏览器会自动执行停留在断点的位置<br>操作：<br>（1）watch监视，监视变量的变化<br>（2）F10，让代码往下一步执行<br>（3）F8，从当前位置，执行到下一个断点的位置，如果后面没有断点了，就会一直执行完</p>\n<h2 id=\"14、数组（是一个有序的值的集合，可以存储大量的数据）\"><a href=\"#14、数组（是一个有序的值的集合，可以存储大量的数据）\" class=\"headerlink\" title=\"14、数组（是一个有序的值的集合，可以存储大量的数据）\"></a>14、数组（是一个有序的值的集合，可以存储大量的数据）</h2><p>简单数据类型，在存储大量数据时，一个一个的存，非常的浪费</p>\n<h3 id=\"14-1-创建数组的方式\"><a href=\"#14-1-创建数组的方式\" class=\"headerlink\" title=\"14.1 创建数组的方式\"></a>14.1 创建数组的方式</h3><ol>\n<li><p>字面量的方式（字面量，直接量，从字面上直接就能看出是什么值的量）</p>\n<pre><code> 123  false  &#39;abc&#39;  undefined  null  [ ]:表示数组\n</code></pre><p><code>var arr =[ ]</code>创建一个空数组</p>\n<blockquote>\n<p>注意点：数组里面可以存任意类型的数据，但是规范是存储同类型的数据</p>\n</blockquote>\n</li>\n<li><p>构造函数的方式</p>\n<pre><code class=\"javascript\"> var arr = new Array(); ---创建一个空数组\n var arr = new Array(5);---浪费空间，五个空的位置，没有具体值\n</code></pre>\n<h3 id=\"14-2-数组的长度-arr-length\"><a href=\"#14-2-数组的长度-arr-length\" class=\"headerlink\" title=\"14.2 数组的长度 arr.length\"></a>14.2 数组的长度 arr.length</h3><h3 id=\"14-3-数组的下标（索引）：数组中的每一项，都会有一个唯一的下标\"><a href=\"#14-3-数组的下标（索引）：数组中的每一项，都会有一个唯一的下标\" class=\"headerlink\" title=\"14.3 数组的下标（索引）：数组中的每一项，都会有一个唯一的下标\"></a>14.3 数组的下标（索引）：数组中的每一项，都会有一个唯一的下标</h3></li>\n</ol>\n<ul>\n<li>从0开始，最大下标arr.length-1</li>\n<li>数组中下标的范围：0 -----&gt; arr.length-1</li>\n</ul>\n<h3 id=\"14-4-数组的取值和存值\"><a href=\"#14-4-数组的取值和存值\" class=\"headerlink\" title=\"14.4 数组的取值和存值\"></a>14.4 数组的取值和存值</h3><ul>\n<li><p>取值：<br><strong>语法：数组名[下标]</strong></p>\n<ol>\n<li>如果下标存在，直接返回对应项的值</li>\n<li>如果下标不存在，返回undefined</li>\n</ol>\n</li>\n<li><p>存值（改值）<br><strong>语法：数组名[下标] = ‘新的值’</strong></p>\n<ol>\n<li>如果下标存在，直接用新的值覆盖</li>\n<li>如果下标不存在，新建一个项，进行赋值</li>\n</ol>\n</li>\n<li><p>往数组最后添加项</p>\n<ol>\n<li>arr[arr.length] = &#39;值&#39;;</li>\n<li>arr.push(&#39;值&#39;)；</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"14-5-数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项\"><a href=\"#14-5-数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项\" class=\"headerlink\" title=\"14.5 数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项\"></a>14.5 数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项</h3><ul>\n<li><p>数组正序遍历</p>\n<pre><code class=\"javascript\">for (var i = 0; i &lt; arr.length; i++) {\n`console.log(arr[i]);\n}\n</code></pre>\n</li>\n<li><p>数组倒叙遍历</p>\n<pre><code>for (var i = arr.length-1; i &gt;=0; i--) {\nconsole.log(arr[i]);\n}\n</code></pre></li>\n</ul>\n<h3 id=\"14-6-冒泡排序\"><a href=\"#14-6-冒泡排序\" class=\"headerlink\" title=\"14.6 冒泡排序\"></a>14.6 冒泡排序</h3><ol>\n<li>冒泡（指得是排序的方式）</li>\n<li>排序（就是讲一组没有按照顺序排列的数，经过排列后，按照一定的顺序排列）<br> 价格排序，成绩排序<br> 编程界，有十大排序</li>\n</ol>\n<h3 id=\"14-7-初级版\"><a href=\"#14-7-初级版\" class=\"headerlink\" title=\"14.7 初级版\"></a>14.7 初级版</h3><ol>\n<li>先排出一趟，排出一个最大值<ol>\n<li>遍历数组</li>\n<li>让arr[i] 和 arr[i+1] 比较</li>\n<li>如果arr[i] &gt; arr[i+1] ，交换位置</li>\n</ol>\n</li>\n<li>双重for循环，多排几次，就排好了</li>\n</ol>\n<h3 id=\"14-8-中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次\"><a href=\"#14-8-中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次\" class=\"headerlink\" title=\"14.8 中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次\"></a>14.8 中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次</h3><pre><code>    内循环-j\n</code></pre><h3 id=\"14-9-高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了\"><a href=\"#14-9-高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了\" class=\"headerlink\" title=\"14.9 高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了\"></a>14.9 高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了</h3><ol>\n<li>在每趟排列前，先假设，已经排好了</li>\n<li>一趟下来，如果一次交换都没有发生，flag值就是true<pre><code class=\"javascript\">var arr = [7, 6, 5, 4, 3, 2, 1];\n// 外层控制趟数, 一趟可以比出一个最大值, 7个数, 比6趟即可\nfor (var j = 0; j &lt; arr.length-1; j++) {\n// 在每趟排列前, 先假设, 已经排好了\nvar flag = true;\nfor (var i = 0; i &lt; arr.length-1-j; i++) {\n if (arr[i] &gt; arr[i + 1]) {\n   var temp = arr[i];\n   arr[i] = arr[i + 1];\n   arr[i+1] = temp;\n   // 发生了交换, 说明没有排好\n   flag = false;\n }\n}\n// 一趟下来, 如果一次交换都没有发生, flag值就是 true\nif (flag) {\n break; \n}\n}\nconsole.log(arr);\n</code></pre>\n</li>\n</ol>\n<h2 id=\"15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）\"><a href=\"#15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）\" class=\"headerlink\" title=\"15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）\"></a>15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）</h2><p><strong>好处</strong>：可维护性高</p>\n<h3 id=\"15-1-声明函数\"><a href=\"#15-1-声明函数\" class=\"headerlink\" title=\"15.1 声明函数\"></a>15.1 声明函数</h3><p><strong>函数名的规范</strong>：一般都是动词+名词（一般函数都是要做某一件事情）</p>\n<pre><code>function 函数名(){\n  函数体;\n}\n</code></pre><blockquote>\n<p>函数光声明，是不会执行的。</p>\n</blockquote>\n<h4 id=\"15-1-1-调用函数\"><a href=\"#15-1-1-调用函数\" class=\"headerlink\" title=\"15.1.1 调用函数\"></a>15.1.1 调用函数</h4><pre><code>函数();\n</code></pre><p>函数一次声明，可以多次调用！！！</p>\n<h4 id=\"15-1-2-函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）\"><a href=\"#15-1-2-函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）\" class=\"headerlink\" title=\"15.1.2 函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）\"></a>15.1.2 函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）</h4><ul>\n<li><p>形参---形式参数（函数在声明时，函数名括号内的参数）<br>  形参默认没有值或类型！！！只在函数调用时，形参才会有具体的值或类型<br>  作用：占位置</p>\n</li>\n<li><p>实参---实际参数（函数调用时传递给函数的参数）<br>  实参有具体的值或者类型<br>  作用：在函数调用时将数据传递给形参</p>\n</li>\n</ul>\n<blockquote>\n<p>注意点：形参和实参一一对应！！！</p>\n</blockquote>\n<h4 id=\"15-1-3-函数的声明和调用进阶写法\"><a href=\"#15-1-3-函数的声明和调用进阶写法\" class=\"headerlink\" title=\"15.1.3 函数的声明和调用进阶写法\"></a>15.1.3 函数的声明和调用进阶写法</h4><pre><code class=\"javascript\">function 函数名（形参1，形参2，形参3...）{\n  函数体;\n}\n</code></pre>\n<h4 id=\"15-1-4-函数的返回值\"><a href=\"#15-1-4-函数的返回值\" class=\"headerlink\" title=\"15.1.4 函数的返回值\"></a>15.1.4 函数的返回值</h4><p>函数内部声明的变量 或者 形参，只能在函数内使用，出了函数就用不了了<br>如果希望函数的执行，有结果，需要通过<code>return</code>返回内容</p>\n<blockquote>\n<p>函数的三要素---决定了一个函数怎么去使用</p>\n<ol>\n<li><code>函数名</code>：一个函数一次声明，可以多次调用（规范：动词+名词）</li>\n<li><code>函数参数</code>：可有可无，但是如果有需要变化的值，一般需要提取成形参</li>\n<li><code>返回值</code>：可有可无，但是如果需要拿到函数的执行结果，就必须要return</li>\n</ol>\n</blockquote>\n<h4 id=\"15-1-5-函数参数与返回值的说明\"><a href=\"#15-1-5-函数参数与返回值的说明\" class=\"headerlink\" title=\"15.1.5 函数参数与返回值的说明\"></a>15.1.5 函数参数与返回值的说明</h4><ul>\n<li><p>开发的时候，函数的参数要一一对应</p>\n<ol>\n<li>传递的参数，如果少了，没接收到值的形参，值就是undefined（数字和undefined加起来就是NaN）</li>\n<li>传递的参数，如果多了，多传的参数，会被忽略</li>\n</ol>\n</li>\n<li><p>返回值的问题<br>  1.return的值，就是函数的执行结果<br>  2.return后面的代码，不执行了！return表示函数的结束！！</p>\n</li>\n</ul>\n<h4 id=\"15-1-6-函数调试说明\"><a href=\"#15-1-6-函数调试说明\" class=\"headerlink\" title=\"15.1.6 函数调试说明\"></a>15.1.6 函数调试说明</h4><ul>\n<li>函数可以在内部调用函数</li>\n<li>F10 让代码往下一步执行，如果遇到了函数调用，会跳过函数的执行过程，直接看结果</li>\n<li>F11让代码往下一步执行，如果遇到了函数调用，会进入函数一步步执行</li>\n<li>shift + F11 跳出函数的执行（将当前函数的调用的剩余代码全部执行完，直接看结果）</li>\n</ul>\n<h4 id=\"15-1-7-声明函数的两种方式\"><a href=\"#15-1-7-声明函数的两种方式\" class=\"headerlink\" title=\"15.1.7 声明函数的两种方式\"></a>15.1.7 声明函数的两种方式</h4><ol>\n<li><p><code>函数声明式</code>（可以先调用，后声明---预解析，会提升函数的声明）</p>\n<pre><code class=\"javascript\">function fn( ) {\nconsole.log(&#39;嘿嘿&#39;);\n}\n</code></pre>\n</li>\n<li><p><code>函数表达式</code>（只可以先声明赋值，后调用）---写法相对严格</p>\n<pre><code>var fn = function( ){\nconsole.log(&#39;哈哈&#39;);\n};\n</code></pre></li>\n</ol>\n<h3 id=\"15-2-匿名函数（没有名字的函数，不能直接使用）\"><a href=\"#15-2-匿名函数（没有名字的函数，不能直接使用）\" class=\"headerlink\" title=\"15.2 匿名函数（没有名字的函数，不能直接使用）\"></a>15.2 匿名函数（没有名字的函数，不能直接使用）</h3><p>使用场景：</p>\n<ol>\n<li>函数表达式 var fn = function(){...}</li>\n<li>匿名函数自调用（自执行)<blockquote>\n<p>直接自调用会报错，可以给整个函数包一个( ),包成了一个整体，就可以调用了</p>\n<pre><code class=\"javascript\">(function ( ) {\n console.log(123);\n})( );\n</code></pre>\n</blockquote>\n</li>\n</ol>\n<p><strong>沙箱模式--匿名函数自调用的应用=&gt;可以用于解决全局变量污染问题</strong><br>由于全局变量，可以在任何地方都可以访问，所以不能乱用<br>一般都会用函数自调用包裹起来</p>\n<pre><code>（function() {...}）\n</code></pre><h2 id=\"16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）\"><a href=\"#16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）\" class=\"headerlink\" title=\"16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）\"></a>16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）</h2><h3 id=\"16-1-概念：无序的键值对的集合\"><a href=\"#16-1-概念：无序的键值对的集合\" class=\"headerlink\" title=\"16.1 概念：无序的键值对的集合\"></a>16.1 概念：无序的键值对的集合</h3><h3 id=\"16-2-创建对象的方式\"><a href=\"#16-2-创建对象的方式\" class=\"headerlink\" title=\"16.2 创建对象的方式\"></a>16.2 创建对象的方式</h3><ol>\n<li>字面量<br>1 ‘abc’ true undefined null [ ] { }<br><code>var obj = { }</code>创建空对象</li>\n</ol>\n<p>键值对的集合，多个键值对通过&quot;，&quot;隔开<br>特征：对象的属性<br>行为：对象的方法---对象的函数</p>\n<ol start=\"2\">\n<li>构造函数的方式（了解）<br>var obj = new Object({...});</li>\n</ol>\n<h3 id=\"16-3-取值和赋值（点语法）\"><a href=\"#16-3-取值和赋值（点语法）\" class=\"headerlink\" title=\"16.3 取值和赋值（点语法）\"></a>16.3 取值和赋值（点语法）</h3><ul>\n<li><p>取值：<br>语法：对象名.属性名  对象名.方法名( );---方法的调用，得到整个函数</p>\n<ul>\n<li>有这个属性名，返回对应值</li>\n<li>如果没有这个属性名，返回undefined</li>\n</ul>\n</li>\n<li><p>赋值：<br>语法：对象名.属性名 = &#39;新的值&#39;</p>\n<ul>\n<li>如果有这个属性名，覆盖</li>\n<li>如果没有这个属性名，新建一个属性并赋值</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"16-3-1-点语法（简洁方便，不支持变量）\"><a href=\"#16-3-1-点语法（简洁方便，不支持变量）\" class=\"headerlink\" title=\"16.3.1 点语法（简洁方便，不支持变量）\"></a>16.3.1 点语法（简洁方便，不支持变量）</h4><p>对象名.属性名</p>\n<h4 id=\"16-3-2-中括号语法（支持字符串或变量，更加的灵活）\"><a href=\"#16-3-2-中括号语法（支持字符串或变量，更加的灵活）\" class=\"headerlink\" title=\"16.3.2 中括号语法（支持字符串或变量，更加的灵活）\"></a>16.3.2 中括号语法（支持字符串或变量，更加的灵活）</h4><p>对象的取值：对象名[&#39;属性名&#39;]<br>对象的赋值：对象名[&#39;属性名&#39;] = &quot;新的值&quot;<br><strong>只要访问对象属性时，需要用到变量，只能用中括号语法</strong></p>\n<h3 id=\"16-4-对象的遍历（访问对象的所有属性）\"><a href=\"#16-4-对象的遍历（访问对象的所有属性）\" class=\"headerlink\" title=\"16.4 对象的遍历（访问对象的所有属性）\"></a>16.4 对象的遍历（访问对象的所有属性）</h3><p>固定语法 （key就是键，属性名）</p>\n<pre><code class=\"javascript\">for （var key in obj）{\n  console.log(key);\n  console.log(obj[key]);---打印属性值\n}\n</code></pre>\n<h3 id=\"16-5-批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）\"><a href=\"#16-5-批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）\" class=\"headerlink\" title=\"16.5 批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）\"></a>16.5 批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）</h3><p>设计模式（工厂模式、单例模式、观察者模式）<br>在对象的方法中，this指代当前对象（对象名）</p>\n<h4 id=\"16-5-1-工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）\"><a href=\"#16-5-1-工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）\" class=\"headerlink\" title=\"16.5.1 工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）\"></a>16.5.1 工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）</h4><p>通过工厂函数创建的对象，没有具体的类型，都是Object</p>\n<pre><code class=\"javascript\">function Student(sno,name,gender,major){\n    obj=new Object();\n    obj.sno=sno;\n    obj.name=name;\n    obj.gender=gender;\n    obj.major=major;\n    obj.say=function(){\n      console.log(&quot;hello!&quot;);\n    }\n    return obj;\n}\nvar s=new Student(&quot;123&quot;,&quot;张三&quot;,&quot;男&quot;,&quot;数学&quot;);\nfor(var i in s){\n    document.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);\n}\n</code></pre>\n<p>这里Student()函数相当于一个工厂，在其内部生产对象。这种方式简化了代码，但是无法细分对象，也会造成共有方法和属性的内存浪费。无法细分对象就是生产出的对象的constructor是Object，而不是自定义的</p>\n<pre><code>console.log(s.constructor);\n</code></pre><p><img src=\"https://img-blog.csdnimg.cn/20200831171959364.png#\" alt><br>内存浪费就是因为方法声明在了对象的内部，每一个对象都有同一个方法，造成了浪费。</p>\n<h4 id=\"16-5-2-构造函数（给新建的对象，添加属性和方法-实例化对象）\"><a href=\"#16-5-2-构造函数（给新建的对象，添加属性和方法-实例化对象）\" class=\"headerlink\" title=\"16.5.2 构造函数（给新建的对象，添加属性和方法----实例化对象）\"></a>16.5.2 构造函数（给新建的对象，添加属性和方法----实例化对象）</h4><ol>\n<li>就是一个函数</li>\n<li>首字母大写</li>\n<li>js中，内置了一些构造函数，比如：<code>Object</code>，<code>Array</code></li>\n<li>构造函数可以自定义</li>\n</ol>\n<ul>\n<li>构造函数的使用步骤<ul>\n<li>自己声明一个构造函数</li>\n<li>结合new一起使用，创建一个有类型的对象<pre><code class=\"javascript\">function Student(sno,name,gender,major){\nthis.sno=sno;\nthis.name=name;\nthis.gender=gender;\nthis.major=major;\nthis.say=function(){\n    console.log(&quot;hello!&quot;);\n}\n}\nvar s=new Student(&quot;1234&quot;,&quot;李四&quot;,&quot;男&quot;,&quot;物理&quot;);\nfor(var i in s){\ndocument.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);\n}\n</code></pre>\n这种模式解决了对象不能细分问题，此时s的constructor就是Student()构造函数了。<pre><code>console.log(s.constructor);\n</code></pre><img src=\"https://img-blog.csdnimg.cn/20200831184528158.png#\" alt><br>但是还是没有解决公有方法造成的内存浪费问题。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"16-5-3-构造函数-原型对象模式\"><a href=\"#16-5-3-构造函数-原型对象模式\" class=\"headerlink\" title=\"16.5.3 构造函数+原型对象模式\"></a>16.5.3 构造函数+原型对象模式</h4><pre><code class=\"javascript\">function Student(sno,name,gender,major){\n    this.sno=sno;\n    this.name=name;\n    this.gender=gender;\n    this.major=major;\n}\nStudent.prototype.say=function(){\n    console.log(&quot;hello!&quot;);\n}\nvar s=new Student(&quot;12345&quot;,&quot;王五&quot;,&quot;男&quot;,&quot;化学&quot;);\nfor(var i in s){\n    document.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);\n}\n</code></pre>\n<p>这种模式和构造函模式类似，不同点是该模式把公有的属性和方法声明到构造函数的原型对象中，解决了内存浪费。</p>\n<h4 id=\"16-5-4-new的作用（创建对象）\"><a href=\"#16-5-4-new的作用（创建对象）\" class=\"headerlink\" title=\"16.5.4 new的作用（创建对象）\"></a>16.5.4 new的作用（创建对象）</h4><ul>\n<li>会新建一个对象，指定对象的类型</li>\n<li>让构造函数的this，指向新创建的对象----this.name = &#39;张三&#39;;</li>\n<li>执行构造函数（给新建的对象，添加属性和方法）</li>\n<li>将新创建的对象返回</li>\n</ul>\n<h3 id=\"16-6-内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）\"><a href=\"#16-6-内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）\" class=\"headerlink\" title=\"16.6 内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）\"></a>16.6 内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）</h3><h4 id=\"16-6-1-Math对象（提供了一系列和数学相关的属性和方法）\"><a href=\"#16-6-1-Math对象（提供了一系列和数学相关的属性和方法）\" class=\"headerlink\" title=\"16.6.1 Math对象（提供了一系列和数学相关的属性和方法）\"></a>16.6.1 Math对象（提供了一系列和数学相关的属性和方法）</h4><ol>\n<li>PI Math.PI</li>\n<li>求最大最小值 max min<br>var max = Math.max(3,5,6,110);<br>console.log(max);</li>\n<li>取整 ceil floor round<br>（1）ceil向上取整，取大的那个数---天花板函数<br>（2）floor向下取整，取小的那个数---地板函数<br>（3）round四舍五入，离哪个近取哪个</li>\n<li>随机数random <code>[0,1)</code>可以取到0，取不到1<br>公式：求一个整数范围0~N，parseInt(Math.random()*(N+1))</li>\n<li>绝对值abs</li>\n<li>求次方pow</li>\n<li>求开方sqrt</li>\n</ol>\n<h4 id=\"16-6-2-Date日期对象\"><a href=\"#16-6-2-Date日期对象\" class=\"headerlink\" title=\"16.6.2 Date日期对象\"></a>16.6.2 Date日期对象</h4><p>js中提供的Date构造函数，可以创建日期对象</p>\n<ol>\n<li><p>如何创建日期对象</p>\n<pre><code class=\"javascript\">var now = new Date(); // 构造函数不传参，创建的是当前时间\nvar date = new Date(&#39;2019-4-22 16:00:00&#39;); // 构造函数传日期字符串，指定具体的日期\n</code></pre>\n</li>\n<li><p>日期格式化 （不用）---一般日期格式都是自定义的</p>\n<pre><code class=\"javascript\">var now = new Date();---当前时间\nconsole.log(now.toString()); // 让日期以标准化的日期字符串格式化输出,&#39;Thu Apr 08 2021 11:13:41 GMT+0800 (GMT+08:00)&#39;\nconsole.log(now.toLocaleString()); // 本地化日期字符串格式输出,&#39;2021-4-8 11:13:41&#39;\nconsole.log(now.toLocaleDateString()); //只显示日期,&#39;2021-4-8&#39;\nconsole.log(now.toLocaleTimeString()); //只显示时间,&#39;11:13:41&#39;\n</code></pre>\n</li>\n<li><p>日期格式的自定义，xx年xx月xx日--获取日期里面的各个组成部分<br>可以封装一个函数，专门给小于10的数，前面加上0</p>\n<pre><code class=\"javascript\">function addZero（n）{\nif(n&lt;10) {\n return &#39;0&#39; + n;\n}\nelse {\n return n;\n}\n}\nvar now = new Date(); // 当前时间\nvar year = now.getFullYear(); // 年\nvar month = now.getMonth()+1; // 获取月，getMonth从0开始，范围0-11\nmonth = addZero(month);\n// 获取日getDate\n// 获取一周中的第几天，getDay,范围0-6，周日0，周一1\nvar hours = now.getHours(); // 时，getHours\nvar minutes = now.getMinutes(); // 分，getMinutes\nvar seconds = now.getSeconds(); // 秒，getSeconds\n// now.getMilliseconds毫秒\n</code></pre>\n</li>\n<li><p>时间戳（就是数字格式的日期，便于运算，一般用于求时间差）---距离1970年1月1日 0时0分0秒，所过去的毫秒数</p>\n<pre><code class=\"javascript\">var now = new Date();\nconsole.log(+now);\n</code></pre>\n</li>\n</ol>\n<p><strong>应用</strong></p>\n<ul>\n<li>统计一段代码的执行时间---性能优化<pre><code class=\"javascript\">var begin = new Date();\nvar end = new Date();\nconsole.log(end - begin);\n</code></pre>\n</li>\n<li>用于秒杀倒计时</li>\n</ul>\n<h2 id=\"17、数组对象Array\"><a href=\"#17、数组对象Array\" class=\"headerlink\" title=\"17、数组对象Array\"></a>17、数组对象Array</h2><ol>\n<li><p><code>.join(分隔符)</code>：将数组中的值拼接成一个字符串，返回这个字符串<br>默认分隔符&quot; , &quot;</p>\n</li>\n<li><p>数组的增删操作<code>push</code> <code>pop</code> <code>unshift</code>  <code>shift</code> <strong><em>会更改原数组</em></strong><br>.push在数组的最后面，添加一个或多个项，返回数组的长度<br>.pop在数组的最后面，删除一个项，返回删除的项<br>.unshift在数组的最前面，添加一个或多个项，返回数组的长度<br>.shift在数组的最前面，删除一项，返回删除的项</p>\n</li>\n<li><p>翻转<code>reverse</code> <strong><em>会更改原数组</em></strong></p>\n</li>\n<li><p>排序<code>sort</code>（默认按照字符串的方式进行排序，先比较第一个字符）<strong><em>会更改原数组</em></strong><br> <strong>如果要制定排序规则，是需要传参的（参数：一个函数）</strong> </p>\n<pre><code class=\"javascript\">arr.sort(function(a,b) {\n return a-b;---从小往大\n return b-a;---从大往小\n})\n</code></pre>\n<blockquote>\n<p>a表示前一项，b表示后一项<br>函数的返回值&gt;0,a和b交换位置<br>函数的返回值=0，不换位置<br>函数的返回值&lt;0,不换位置</p>\n</blockquote>\n</li>\n<li><p>合并 <code>arr.concat(arr2,arr3....)</code>，返回合并后的新数组</p>\n</li>\n<li><p>截取<code>arr.slice</code>（从数组中，截取一部分出来，返回一个新数组）</p>\n<ul>\n<li>arr.slice();从开始一直截取到最后（将整个数组截取，复制一份）</li>\n<li>arr.slice(begin)从begin（下标）开始一直截取到最后    </li>\n<li>arr.slice(begin,end)从begin（下标）开始一直截取到end结束（<strong>包括begin,不包括end</strong>）</li>\n</ul>\n</li>\n<li><p><code>splice</code>方法，可以在数组的任意位置添加、删除、替换任意项---会更改原数组</p>\n<pre><code> splice（从哪开始删，删几个，添加的项1，添加的项2...）\n splice(begin,deleteCounts,item1,item2...)\n</code></pre></li>\n<li><p><code>indexOf</code>查找值在数组中第一次出现的下标（可以用来查重）<br> <code>lastIndexOf</code>查找值在数组中最后一次出现的下标<br>如果值在数组中不存在，返回 <code>-1</code></p>\n</li>\n<li><p>清空一个数组</p>\n<pre><code class=\"javascript\">arr = [ ];\narr.length = 0;\narr.splice(0,arr.length)\n</code></pre>\n</li>\n</ol>\n<h2 id=\"18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）\"><a href=\"#18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）\" class=\"headerlink\" title=\"18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）\"></a>18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）</h2><p><strong>js内部，对于除了undefined和null的简单数据类型，都提供了一个对应的复杂数据类型</strong></p>\n<p>简答数据类型：没有属性和方法，只有值<br>复杂数据类型：可以有多个属性和方法</p>\n<ul>\n<li>在js中，如果简单数据类型，在访问复杂数据类型的属性或方法时</li>\n<li>为了方便，自动将简单数据类型，包装成复杂数据类型，然后获取对应的值</li>\n<li>会将值变回简单数据类型    </li>\n</ul>\n<h3 id=\"18-1-Number\"><a href=\"#18-1-Number\" class=\"headerlink\" title=\"18.1 Number\"></a>18.1 Number</h3><pre><code>通过new Number()创建的对象，``toString``   ``toFixed``两个方法\nnum.toFixed(3) 保留3位小数\n</code></pre><h3 id=\"18-2-Boolean\"><a href=\"#18-2-Boolean\" class=\"headerlink\" title=\"18.2 Boolean\"></a>18.2 Boolean</h3><pre><code>    通过new Boolean()创建的对象，toString\n</code></pre><h3 id=\"18-3-String\"><a href=\"#18-3-String\" class=\"headerlink\" title=\"18.3 String\"></a>18.3 String</h3><ol>\n<li>字符串可以和数组一样，进行遍历，字符串不是数组，不能混用方法</li>\n<li><code>indexOf</code>和<code>lastIndexOf</code> 查找值在字符串中第一次/最后一次出现的下标</li>\n<li><code>trim</code>去除字符串<code>首尾</code>的空格</li>\n<li>转大小写<br><code>toUpperCase</code>转大写<br><code>toLowerCase</code>转小写</li>\n<li>拼接<code>.concat</code>将字符串进行拼接，返回新的字符串）<br>一般用<code>+</code></li>\n<li><p>截取</p>\n<ul>\n<li>slice(begin,end) <blockquote>\n<p>从begin开始截取，截取到end结束，包括begin，不包括end<br>begin（必需）：规定从何处开始选取。如果是负数，那么它规定从字符串尾部开始算起的位置。也就是说，-1 指最后一个字符，-2 指倒数第二个字符，以此类推。<br>end（可选）：规定从何处结束选取，即结束处的字符下标。如果没有指定该参数，那么截取的字符串包含从 start 到结束的所有字符。如果这个参数是负数，那么它规定的是从数组尾部开始算起的字符。</p>\n<pre><code class=\"javascript\"> var str = &quot;0123456789&quot;;\n console.log(&quot;原始字符串：&quot;, str);\n console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.slice(3));  //3456789\n console.log(&quot;从倒数第3个字符起一直到结束：&quot;, str.slice(-3));  //789\n console.log(&quot;从开始一直到索引为5的前一个字符：&quot;, str.slice(0,5));  //01234\n console.log(&quot;从开始一直到倒数第3个字符的前一个字符：&quot;, str.slice(0,-3));  //0123456\n console.log(&quot;从索引为3的字符起到索引为5的前一个字符：&quot;, str.slice(3,5));  //34\n console.log(&quot;从索引为3的字符起到倒数第3个字符的前一个字符：&quot;, str.slice(3,-3));  //3456\n</code></pre>\n</blockquote>\n</li>\n<li>substring(begin,end) 从begin开始截取，截取到end结束，包括begin，不包括end<pre><code class=\"javascript\"> var str = &quot;0123456789&quot;;\n console.log(&quot;原始字符串：&quot;, str);\n console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.substring(3));  //3456789\n console.log(&quot;从索引为20的字符起一直到结束：&quot;, str.substring(20));  //\n console.log(&quot;从索引为3的字符起到索引为5的前一个字符结束：&quot;, str.substring(3,5));  //34\n console.log(&quot;start比end大会自动交换，结果同上：&quot;, str.substring(5,3));  //34\n console.log(&quot;从索引为3的字符起到索引为20的前一个字符结束：&quot;, str.substring(3,20));  //3456789\n console.log(&quot;substring将负数转化为0:&quot;, str.substring(-3)); //\n</code></pre>\n</li>\n<li>substr(begin,length) 从begin开始截取，截取length个<pre><code class=\"javascript\"> var str = &quot;0123456789&quot;;\n console.log(&quot;原始字符串：&quot;, str);\n console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.substr(3));  //3456789\n console.log(&quot;从索引为20的字符起一直到结束：&quot;, str.substr(20));  //\n console.log(&quot;从索引为3的字符起截取长度为5的字符串：&quot;, str.substr(3,5));  //34567\n console.log(&quot;从索引为3的字符起截取长度为20的字符串：&quot;, str.substr(3,20));  //3456789\n</code></pre>\n</li>\n<li><p>三者比较<br><code>`</code>javascript<br>var str = &#39;中华人民共和国万岁&#39;<br>// 一，start为负数，end不传<br>str.slice(-3) // &#39;国万岁&#39;<br>str.substring(-3) // &#39;中华人民共和国万岁&#39;<br>str.substr(-3) // &#39;国万岁&#39;<br>// 说明： 1，slice与substr第一个参数为负数时，将从字符串反方向开始计数，末位记为-1,等同于str.slice(6)，str.substr(6)<br>//       2，substring将负数转化为0，既str.substring(0)</p>\n<p>// 二，start为负数，end为负数时<br>str.slice(-3,-1) // &#39;国万&#39;<br>str.substring(-3,-1) // &#39;&#39;<br>str.substr(-3,-1) // &#39;&#39;<br>// 说明：<br>//    1，slice正常截取字符串，相比substring灵活很多<br>//    2，substring将所有参数转化为0，既str.substring(0,0)<br>//    3，substr end参数不能为负数</p>\n<p>// 三，start与end均大于零，且start &gt; end<br>str.slice(5,3) // &#39;&#39;<br>str.substring(5,3) // &#39;民共&#39;<br>str.substr(5,3) // &#39;和国万&#39;<br>// 说明：<br>//   1，substr正常截取字符串，代表从第五位开始，截取字符串长度为3<br>//   2，当start&gt;end时，substring在提取子串之前会先交换这两个参数，既转换为substring(3,5)；而slice不能进行此转换，所以截取的为空字符串</p>\n<p>// 四，start与end均大于零，且start &lt; end<br>str.slice(3,5) //&#39;民共&#39;<br>str.substring(3,5) // &#39;民共&#39;<br>str.substr(3,5) // &#39;民共和国万&#39;<br>// 说明：三种方法均正常截取字符串，只是substr第二个参数含义不同，代表截取的字符串长度而不是终止位置。</p>\n</li>\n</ul>\n<p><code>`</code></p>\n</li>\n<li><p>通过.split(分隔符):可以将字符串拆分成数组，会返回一个拆分得到的数组<br> 通过join:可以将数组的值，拼成字符串，会返回一个拼接成的字符串</p>\n</li>\n<li><p>replace替换，会返回替换的结果</p>\n<pre><code class=\"javascript\">str.replace(&#39;aa&#39;,&#39;bb&#39;); // 将字符串中的第一个aa替换成bb\n</code></pre>\n</li>\n</ol>\n<p>想要全部替换，需要用到正则<code>str.replace(/aa/g,&#39;bb&#39;)</code>;</p>\n<h2 id=\"19、值类型和引用类型\"><a href=\"#19、值类型和引用类型\" class=\"headerlink\" title=\"19、值类型和引用类型\"></a>19、值类型和引用类型</h2><p>从内存的存储角度，分成了<code>值类型</code>和<code>引用类型</code>（内存是可以释放，可以重复利用的）</p>\n<p><strong>值类型（简单数据类型）</strong>：存储在变量中，存的是值本身<br><strong>引用类型（复杂数据类型）</strong>：存储在变量中，存的是<code>内存地址</code>----会单独在内存中开辟一块空间存储</p>\n<h3 id=\"19-1-值类型和引用类型的赋值类型\"><a href=\"#19-1-值类型和引用类型的赋值类型\" class=\"headerlink\" title=\"19.1 值类型和引用类型的赋值类型\"></a>19.1 值类型和引用类型的赋值类型</h3><ul>\n<li>值类型：存储在变量中 ，存的是<code>值本身</code>，所以在赋值给其他变量时，赋值的是<code>值本身</code></li>\n<li>引用类型：存储在变量中，存的是<code>内存地址</code>，所以在赋值给其他变量时，赋值的是<code>内存地址</code></li>\n</ul>\n<h3 id=\"19-2-值类型和引用类型的值传递（让值作为函数的参数进行传递）\"><a href=\"#19-2-值类型和引用类型的值传递（让值作为函数的参数进行传递）\" class=\"headerlink\" title=\"19.2 值类型和引用类型的值传递（让值作为函数的参数进行传递）\"></a>19.2 值类型和引用类型的值传递（让值作为函数的参数进行传递）</h3><ul>\n<li>值类型：存储在变量中，存的是值本身，所以在值传递时，传的也是值本身</li>\n<li>引用类型：存储在变量中，存的是内存地址，所以在值传递时，传的也是内存地址</li>\n</ul>\n<h2 id=\"20、typeof-关键字\"><a href=\"#20、typeof-关键字\" class=\"headerlink\" title=\"20、typeof 关键字\"></a>20、typeof 关键字</h2><ol>\n<li>typeof获取简单数据类型，可以直接返回对应的类型<br><strong><em>特例</em></strong>：typeof null  返回object</li>\n<li>typeof获取复杂数据类型，一般返回object<br><strong><em>特例</em></strong>：typeof 函数  返回function    函数是js的一等公民</li>\n</ol>\n<h2 id=\"21、逻辑中断（短路运算）-amp-amp\"><a href=\"#21、逻辑中断（短路运算）-amp-amp\" class=\"headerlink\" title=\"21、逻辑中断（短路运算）&amp;&amp; ||\"></a>21、逻辑中断（短路运算）&amp;&amp; ||</h2><p>&amp;&amp;找假值，只要遇到了假值，就中断短路（后面的不看了）<br>||找真值，只要看到了真值，就中断短路（后面的不看了）</p>\n<pre><code class=\"javascript\">function demo(fn){\n  fn&amp;&amp;fn(); //fn存在，才去调用\n}    \ndemo(function(){\n  console.log(111);\n});\ndemo();\n</code></pre>\n<p><strong>逻辑<code>或</code>，一般可以用于设置默认值,也可以解决兼容性</strong></p>\n<pre><code class=\"javascript\">function getSum(a,b){\n  a=a || 0;\n  b=b || 0;\n  var sum = a+b;\n  return sum;\n}\n</code></pre>\n<h2 id=\"22、如何拷贝一个对象\"><a href=\"#22、如何拷贝一个对象\" class=\"headerlink\" title=\"22、如何拷贝一个对象\"></a>22、如何拷贝一个对象</h2><p>封装一个方法，可以拷贝一个对象，返回（浅拷贝，只拷贝了 一层）</p>\n<pre><code class=\"javascript\">function copy(obj){\n  var newObj = {};\n  for (var k in obj){\n    newObj[k] = obj[k];\n  }\n}\n</code></pre>\n<ul>\n<li>浅拷贝，只拷贝了一层，如果全是简单类型的属性，没有问题<br>  但是如果有复杂类型的属性（对象），此时拷贝的只是地址，需要处理的</li>\n<li>深拷贝<pre><code>  newObj[k] = typeof obj[k] === &#39;object&#39; ? copy(obj[k]) : obj[k];\n</code></pre></li>\n</ul>\n<pre><code class=\"javascript\">// 1.遍历+递归\nfunction deepClone(obj){\n  let newObj =  {}\n  for(let key in obj){\n      if(obj.hasOwnProperty(key)){\n          if(typeof(obj[key]) === &#39;object&#39; &amp;&amp; obj[key] !== null){\n            newObj[key] = (Array.isArray(obj[key])  ? [] : {})\n            newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : deepClone(obj[key]));  \n          }else{\n              newObj[key] = obj[key];\n          }\n      }\n  }\n  return newObj;\n}\n\n// 2.Object.assign + 递归\nfunction deepClone(obj){\n  let newObj = {}\n  for(let key in obj){\n    if(obj.hasOwnProperty(key)){\n      newObj[key] = (typeof obj[key] === &#39;object&#39; ? Object.assign(obj[key]) : obj[key])\n    }\n  }\n  return newObj\n}\n\n// 3.对象扩展+递归\nfunction deepClone(obj){\n  var newObj ={}\n  for(let key in obj){\n    if(obj.hasOwnProperty(key)){\n      if(typeof obj[key] === &#39;object&#39;){\n        newObj[key] = (Array.isArray(obj[key]) ? [] : {})\n        newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : {...obj[key]}) \n      } \n      else{\n        newObj[key] = obj[key]\n      }\n    }\n  }\n  return newObj\n}\n\n// 4.JSON复制（对NaN和undefined无法正确复制，会丢失）\nfunction deepClone(obj) {\n  var newObj = JSON.parse(JSON.stringify(obj))\n  return newObj\n}\n</code></pre>\n<h2 id=\"23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！\"><a href=\"#23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！\" class=\"headerlink\" title=\"23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！\"></a>23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！</h2><h2 id=\"24、面向对象：关注的是找一个对象，去做某件事\"><a href=\"#24、面向对象：关注的是找一个对象，去做某件事\" class=\"headerlink\" title=\"24、面向对象：关注的是找一个对象，去做某件事\"></a>24、面向对象：关注的是找一个对象，去做某件事</h2><p><strong><em>面向对象不是面向过程的替代，是面向过程的封装</em></strong></p>\n<h3 id=\"24-1-特性：\"><a href=\"#24-1-特性：\" class=\"headerlink\" title=\"24.1 特性：\"></a>24.1 特性：</h3><ol>\n<li>封装性</li>\n<li>继承性</li>\n<li>多态性（js中没有）</li>\n</ol>\n<h2 id=\"25、原型\"><a href=\"#25、原型\" class=\"headerlink\" title=\"25、原型\"></a>25、原型</h2><p>JavaScript是一门基于原型的语言，在软件设计模式中，有一种模式叫做原型模式，JavaScript正是利用这种模式而被创建出来</p>\n<h3 id=\"25-1-原型模式\"><a href=\"#25-1-原型模式\" class=\"headerlink\" title=\"25.1 原型模式\"></a>25.1 原型模式</h3><p>原型模式是用于创建重复的对象，同时又能保证性能，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。<br>原型模式的<code>目的</code>是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，也就是说利用已有的一个原型对象，可以快速地生成和原型对象一样的新对象实例</p>\n<h3 id=\"25-2-原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板\"><a href=\"#25-2-原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板\" class=\"headerlink\" title=\"25.2 原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板\"></a>25.2 原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板</h3><ol>\n<li>原型是定义了一些公用的属性和方法，利用原型创建出来的新对象实例会共享原型的所有属性和方法<br>实例代码：<br><code>`</code>javascript<br>// 创建原型<br>var Person = function(name){<br> this.name = name;<br>};</li>\n</ol>\n<p>// 原型的方法<br>Person.prototype.sayHello = function(){<br>    console.log(this.name+&quot;,hello&quot;);<br>};</p>\n<p>// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法<br>var person1 = new Person(&quot;zhangsan&quot;);<br>var person2 = new Person(&quot;lisi&quot;);</p>\n<p>// zhangsan,hello<br>person1.sayHello();<br>// lisi,hello<br>person2.sayHello();</p>\n<pre><code>\n2. 严格模式下，原型的属性和方法还是会被原型实例所共享的\n实例代码：\n```javascript\n// 开启严格模式，原型的属性和方法还是会被原型实例所共享的\n&quot;use strict&quot;;\n\n// 创建原型\nvar Person = function(name){\n    this.name = name;\n};\n\n// 原型的方法\nPerson.prototype.sayHello = function(){\n    console.log(this.name+&quot;,hello&quot;);\n};\n\n// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法\nvar person1 = new Person(&quot;zhangsan&quot;);\nvar person2 = new Person(&quot;lisi&quot;);\n\n// zhangsan,hello\nperson1.sayHello();\n// lisi,hello\nperson2.sayHello();\n</code></pre><ol start=\"3\">\n<li>通过原型创建的新对象实例是相互独立的，为新对象实例添加的方法只有该实例拥有这个方法，其它实例是没有这个方法的<br>实例代码：<br><code>`</code>javascript<br>// 创建原型<br>var Person = function(name){<br>this.name = name;<br>};</li>\n</ol>\n<p>// 原型的方法<br>Person.prototype.sayHello = function(){<br>  console.log(this.name+&quot;,hello&quot;);<br>};</p>\n<p>// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法<br>var person1 = new Person(&quot;zhangsan&quot;);<br>var person2 = new Person(&quot;lisi&quot;);</p>\n<p>// zhangsan,hello<br>person1.sayHello();<br>// lisi,hello<br>person2.sayHello();</p>\n<p>// 为新对象实例添加方法<br>// 通过原型创建的新对象实例是相互独立的<br>person1.getName = function(){<br>    console.log(this.name);<br>}</p>\n<p>// zhangsan<br>person1.getName();<br>// Uncaught TypeError: person2.getName is not a function<br>person2.getName();</p>\n<pre><code>\n4. 原型的总结：\n\n* 所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象\n* 所有函数都有一个prototype(原型)属性，属性值是一个普通的对象\n* 所有引用类型的__proto__属性指向它构造函数的prototype\n\n5. 函数的原型prototype：函数才有prototype，prototype是一个对象，指向了当前构造函数的引用地址\n6. 函数的原型对象__proto__：所有对象都有__proto__属性， 当用构造函数实例化（new）一个对象时，会将新对象的__proto__属性指向 构造函数的prototype\n\n7. 原型对象和函数的原型的关系\n![原型对象和函数的原型的关系](https://img-blog.csdnimg.cn/20190623221321362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)\n\n&gt; 说明：\n&gt; * 所有函数的__proto__都是指向Function的prototype\n&gt; * 构造函数new出来的对象__proto__指向构造函数的prototype\n&gt; * 非构造函数实例化出的对象或者对象的prototype的__proto__指向Object的prototype\n&gt;   Object的prototype指向null\n\n8. 所有的原型对象都会自动获得一个``constructor``（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）\n9. 实例的构造函数属性（constructor）指向构造函数 ：person1.constructor == Person\n10. 原型对象（Person.prototype）是 构造函数（Person）的一个实例\n11. 原型的分类：\n* ``隐式原型（_proto_）``：上面说的这个原型是JavaScript中的内置属性[[prototype]]，此属性继承自object对象，在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_，隐式原型的作用是用来构成原型链，实现基于原型的继承\n* ``显示原型``（prototype）``：每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享\n12. 原型的使用方式：\n通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型\n在赋值原型prototype的时候使用function立即执行的表达式来赋值，可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果\n\n#### 25.2.1 原型链\n原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构\n\n#### 25.2.2 原型设计的问题\n当查找一个对象的属性时，JavaScript 会根据原型链向上遍历对象的原型，直到找到给定名称的属性为止，直到到达原型链的顶部仍然没有找到指定的属性，就会返回 undefined\n也可以理解为原型链继承时查找属性的过程是先查找自身属性，当自身属性不存在时，会在原型链中逐级查找\n\n#### 25.2.3 hasOwnProperty 函数：\n可以用来检查对象自身是否含有某个属性，返回值是布尔值，当属性不存在时不会向上查找对象原型链，*hasOwnProperty是 JavaScript 中``唯一一个``处理属性但是不查找原型链的函数*\n\n#### 25.2.4 getOwnPropertyNames 函数\n可以获取对象所有的自身属性，返回值是由对象自身属性名称组成的数组，同样不会向上查找对象原型链\n\n#### 25.2.5 原型链的小结：\n一直往上层查找，直到到null还没有找到，则返回undefined\nObject.prototype.__proto__ === null\n所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象\n\n6）JavaScript的原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法\n\n#### 25.2.6 常见面试题\n\n* 谈谈你对原型的理解？\n在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法\n\n* 什么是原型链？原型链解决的是什么问题？\n 1. 原型链解决的主要是继承问题\n 2. 每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法\n 3. 构造函数 Parent、Parent.prototype 和 实例 p 的关系如下:(p.__proto__ === Parent.prototype)\n![](https://img-blog.csdnimg.cn/20190623221912165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)\n\n* prototype 和 proto 区别是什么？\n 1. prototype是构造函数的属性\n 2. __proto__是每个实例都有的属性，可以访问 [[prototype]] 属性\n 3. 实例的__proto__与其构造函数的prototype指向的是同一个对象\n\n### 25.3 补充（原先的）\n#### 25.3.1 属性搜索原则：自己有就访问自己的，自己没有，去原型链中就近查找\n1. 如果自己有这个属性，就访问自己的\n2. 如果自己没有这个属性，会到原型中找，如果找到，不找了，直接返回\n3. 如果原型中也没有，会到原型的原型中找...\n4. 一直找到Object.prototype，如果老祖宗也没有，返回undefined\n\n#### 25.3.2 设置属性：\n如果有这个属性，直接修改赋值\n如果自己没有这个属性，给自己添加一个新属性（不会改到原型）\n\n#### 25.3.3 Object.prototype的成员\n1. ``hasOwnProperty``\n    语法：``对象.hasOwnProperty(&#39;属性名&#39;)`` ---判断属性是否是自己的，而不是原型的（不是继承来的）\n    for in 遍历，不仅自己的属性可以遍历，原型上的属性也会遍历到（对于constructor等浏览器内置的属性，被浏览器进行来了处理，不会被for in便利出来）\n    遍历时，只打印自身的（用hasOwnProperty进行判断）\n    in操作符：判断属性是否可以被对象所访问（只要能够访问到这个属性，就返回true）---这个不是成员\n    语法：&#39;属性名&#39; in 对象\n\n2. ``A.isPrototypeOf(B)``:判断A是不是B的原型\n\n3. ``对象.propertyIsEnumerable(&#39;属性名&#39;)`` 判断属性是否可以遍历（可枚举）\n4. toSting()\n5. valueof()\n\n6. instanceof运算符\n    语法：A instanceof B（判断A是否是B的实例，B构造函数）\n    进阶原理：判断B.prototype在不在A的原型链上\n    使用typeof无法区分具体的对象类型！！！\n\n```javascript\nconsole.log(p.constructor.name)---可以用来打印类型\nObject.prototype.toString.call([]) ---可以用来获取复杂数据是什么类型 ---[object Array]\n</code></pre><h2 id=\"26、js数据类型\"><a href=\"#26、js数据类型\" class=\"headerlink\" title=\"26、js数据类型\"></a>26、js数据类型</h2><p>堆和栈（只是将Java中概念，拿过来类比了）<br>js中没有特别明确的堆和栈的概念，而且js的实现，也不需要堆和栈的概念<br>java中堆内存和栈内存<br>1.所有的<code>简单数据</code>类型，存在<code>栈</code>中<br>2.所有的<code>复杂数据</code>类型，存在<code>堆</code>中---真实存在变量中的，也是地址</p>\n<h2 id=\"27、this的规则：\"><a href=\"#27、this的规则：\" class=\"headerlink\" title=\"27、this的规则：\"></a>27、this的规则：</h2><p>xx.fn();---fn函数调用时里面的this，指向调用者（谁调用的，this就指向谁）</p>\n<ol>\n<li>如果是直接调用的方法，this指向window<pre><code> （1）function fn(){console.log(this)}\n          fn();\n （2）setInterval(function(){console.log(this)},2000)---定时器中的this指向window\n</code></pre></li>\n<li>如果对象中的方法，被调用了，this指向调用者，谁调用的，指向谁</li>\n<li>特例，构造函数中执行的this，this指向新创建的对象</li>\n</ol>\n<p>全局的var a = 123;  等价于 window.a = 123;</p>\n<h2 id=\"28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️\"><a href=\"#28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️\" class=\"headerlink\" title=\"28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️\"></a>28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️</h2><h3 id=\"28-1-原型链继承\"><a href=\"#28-1-原型链继承\" class=\"headerlink\" title=\"28.1 原型链继承\"></a>28.1 原型链继承</h3><pre><code class=\"javascript\">function Person() {\n  this.name = &#39;Hello World&#39;;\n}\nPerson.prototype.getName = function() {\n  console.log(this.name)\n}\nfunction Child() {\n\n}\nChild.prototype = new Person()\nvar child1 = new Child()\nchild1.getName() // Hello World\n</code></pre>\n<p><strong><em>重点：</em></strong><br>让新实例的原型等于父类的实例。</p>\n<p><strong><em>优点：</em></strong><br>实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的 属性！）</p>\n<p><strong><em>缺点：</em></strong></p>\n<ol>\n<li>新实例无法向父类构造函数传参。</li>\n<li>继承单一。</li>\n<li>所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性 也会被修改！）</li>\n</ol>\n<h3 id=\"28-2-构造函数继承\"><a href=\"#28-2-构造函数继承\" class=\"headerlink\" title=\"28.2 构造函数继承\"></a>28.2 构造函数继承</h3><pre><code class=\"javascript\">function Person(){\n  this.name = &#39;xiaoming&#39;;\n  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];\n}\n\nPerson.prototype.getName = function(){\n  console.log(this.name);\n}\n\nfunction Child(age){\n  Person.call(this);\n  this.age = age\n}\n\nvar child1 = new Child(23);\nvar child2 = new Child(12);\nchild1.colors.push(&#39;yellow&#39;);\nconsole.log(child1.name); // xiaoming\nconsole.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]\nconsole.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]\n</code></pre>\n<p><strong><em>重点：</em></strong><br>用.call()和.apply()将父类构造函数引入子类函数（在子类 函数中做了父类函数的自执行（复制））</p>\n<p><strong><em>优点：</em></strong></p>\n<ol>\n<li>只继承了父类构造函数的属性，没有继承父类原型的属性。</li>\n<li>解决了原型链继承缺点1、2、3。</li>\n<li>可以继承多个构造函数属性（call多个）。</li>\n<li>在子实例中可向父实例传参。</li>\n</ol>\n<p><strong><em>缺点：</em></strong></p>\n<ol>\n<li>只能继承父类构造函数的属性。</li>\n<li>无法实现构造函数的复用。（每次用每次都要重新调用）</li>\n<li>每个新实例都有父类构造函数的副本，臃肿。</li>\n</ol>\n<h3 id=\"28-3-组合继承（组合原型链继承和借用构造函数继承）（常用）\"><a href=\"#28-3-组合继承（组合原型链继承和借用构造函数继承）（常用）\" class=\"headerlink\" title=\"28.3 组合继承（组合原型链继承和借用构造函数继承）（常用）\"></a>28.3 组合继承（组合原型链继承和借用构造函数继承）（常用）</h3><pre><code class=\"javascript\">function Parent(name){\n    this.name = name;\n    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];\n}\n\nParent.prototype.getName = function(){\n    console.log(this.name);\n}\n\nfunction Child(name,age){\n    Parent.call(this,name);// 第二次调用 Parent()\n    this.age = age;\n}\n\nChild.prototype = new Parent(); // 第一次调用 Parent()\n\nvar child1 = new Child(&#39;xiaopao&#39;,18);\nvar child2 = new Child(&#39;lulu&#39;,19);\n</code></pre>\n<p><strong><em>重点：</em></strong><br>结合了两种模式的优点，传参和复用</p>\n<p><strong><em>优点：</em></strong></p>\n<ol>\n<li>可以继承父类原型上的属性，可以传参，可复用。<br>2、每个新实例引入的构造函数属性是私有的。</li>\n</ol>\n<p><strong><em>缺点：</em></strong><br>调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p>\n<h3 id=\"28-4-原型式继承\"><a href=\"#28-4-原型式继承\" class=\"headerlink\" title=\"28.4 原型式继承\"></a>28.4 原型式继承</h3><pre><code class=\"javascript\">function CreateObj(o){\n    function F(){}\n    F.prototype = o;\n    console.log(o.__proto__ === Object.prototype);\n    console.log(F.prototype.constructor === Object); // true\n    return new F();\n}\n\nvar person = {\n    name: &#39;xiaopao&#39;,\n    friend: [&#39;daisy&#39;,&#39;kelly&#39;]\n}\n\nvar person1 = CreateObj(person);\n\n// var person2 = CreateObj(person);\n\nperson1.name = &#39;person1&#39;;\n// console.log(person2.name); // xiaopao\nperson1.friend.push(&#39;taylor&#39;);\n// console.log(person2.friend); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]\n// console.log(person); // {name: &quot;xiaopao&quot;, friend: Array(3)}\nperson1.friend = [&#39;lulu&#39;];\n// console.log(person1.friend); // [&quot;lulu&quot;]\n// console.log(person.friend); //  [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]\n// 注意： 这里修改了person1.name的值，person2.name的值并未改变，并不是因为person1和person2有独立的name值，而是person1.name=&#39;person1&#39;是给person1添加了name值，并非修改了原型上的name值\n// 因为我们找对象上的属性时，总是先找实例上对象，没有找到的话再去原型对象上的属性。实例对象和原型对象上如果有同名属性，总是先取实例对象上的值\n</code></pre>\n<p><strong><em>重点：</em></strong><br>用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</p>\n<p><strong><em>优点：</em></strong><br>类似于复制一个对象，用函数来包装。</p>\n<p><strong><em>缺点：</em></strong></p>\n<ol>\n<li>所有实例都会继承原型上的属性。</li>\n<li>无法实现复用。（新实例属性都是后面添加的）</li>\n</ol>\n<h3 id=\"28-5-寄生式继承\"><a href=\"#28-5-寄生式继承\" class=\"headerlink\" title=\"28.5 寄生式继承\"></a>28.5 寄生式继承</h3><pre><code class=\"javascript\">var ob = {\n    name: &#39;xiaopao&#39;,\n    friends: [&#39;lulu&#39;,&#39;huahua&#39;]\n}\n\nfunction CreateObj(o){\n    function F(){};  // 创建一个构造函数F\n    F.prototype = o;\n    return new F();\n}\n\n// 上面CreateObj函数 在ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的 , 看下面代码\nvar ob1 = CreateObj(ob);\nvar ob2 = Object.create(ob);\nconsole.log(ob1.name); // xiaopao\nconsole.log(ob2.name); // xiaopao\n\nfunction CreateChild(o){\n    var newob = CreateObj(o); // 创建对象 或者用 var newob = Object.create(ob)\n    newob.sayName = function(){ // 增强对象\n        console.log(this.name);\n    }\n    return newob; // 指定对象\n}\n\nvar p1 = CreateChild(ob);\np1.sayName(); // xiaopao \n</code></pre>\n<p><strong><em>重点：</em></strong><br>就是给原型式继承外面套了个壳子。</p>\n<p><strong><em>优点：</em></strong><br>没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</p>\n<p><strong><em>缺点：</em></strong><br>没用到原型，无法复用。</p>\n<h3 id=\"28-6-寄生组合式继承（常用）\"><a href=\"#28-6-寄生组合式继承（常用）\" class=\"headerlink\" title=\"28.6 寄生组合式继承（常用）\"></a>28.6 寄生组合式继承（常用）</h3><pre><code class=\"javascript\">function Parent(name){\n    this.name = name;\n    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];\n}\n\nParent.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nfunction Child(name,age){\n    Parent.call(this,name); \n    this.age = age;\n}\n\nfunction CreateObj(o){\n    function F(){};\n    F.prototype = o;\n    return new F();\n}\n\n// Child.prototype = new Parent(); // 这里换成下面\nfunction prototype(child,parent){\n    var prototype = CreateObj(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\nprototype(Child,Parent);\n\nvar child1 = new Child(&#39;xiaopao&#39;, 18);\nconsole.log(child1); \n</code></pre>\n<p><strong><em>重点：</em></strong><br>修复了组合继承的问题</p>\n<h3 id=\"28-7-class继承\"><a href=\"#28-7-class继承\" class=\"headerlink\" title=\"28.7 class继承\"></a>28.7 class继承</h3><pre><code class=\"javascript\">class Parent5 {\n  constructor() {\n    this.name = [&#39;super5&#39;]\n  }\n  reName() {\n    this.name.push(&#39;new 5&#39;)\n  }\n}\nclass Child5 extends Parent5 {\n  constructor() {\n    super()\n  }\n}\nvar child51 = new Child5()\nvar child52 = new Child5()\n</code></pre>\n<h2 id=\"29、定义函数的三种方式\"><a href=\"#29、定义函数的三种方式\" class=\"headerlink\" title=\"29、定义函数的三种方式\"></a>29、定义函数的三种方式</h2><h3 id=\"29-1-函数声明式\"><a href=\"#29-1-函数声明式\" class=\"headerlink\" title=\"29.1 函数声明式\"></a>29.1 函数声明式</h3><pre><code>function fn(){}\nfn();\n</code></pre><h3 id=\"29-2-函数表达式\"><a href=\"#29-2-函数表达式\" class=\"headerlink\" title=\"29.2 函数表达式\"></a>29.2 函数表达式</h3><pre><code>var fn = function(){};\nfn();\n</code></pre><h3 id=\"29-3-构造函数的方式\"><a href=\"#29-3-构造函数的方式\" class=\"headerlink\" title=\"29.3 构造函数的方式\"></a>29.3 构造函数的方式</h3><pre><code>new Function(...)\n</code></pre><p>作用：可以直接执行字符串<br>参数：都是字符串类型，最后一个参数是函数体，前面其他所有参数是定义的形参<br>         只有一个参数，就会当成函数体</p>\n<pre><code class=\"javascript\">var fn = new Function(&#39;a&#39; , &#39;b&#39; , &#39;console.log(a+b)&#39;);\nfn(1,2);\n</code></pre>\n<h2 id=\"30、try和catch\"><a href=\"#30、try和catch\" class=\"headerlink\" title=\"30、try和catch\"></a>30、try和catch</h2><ul>\n<li>try和catch必须一起使用</li>\n<li>try表示尝试执行某段代码，就算发生了错误，js也会继续执行</li>\n<li>catch，只要try中代码发生了错误，就会执行catch中的代码</li>\n<li>finally:不管try中的代码执行是否成功，都会执行finally的代码<pre><code class=\"javascript\">try {  ----尝试执行某段代码\n   var fn = new Function(value);\n   fn();\n}\ncatch（e）{ ---- 抓取，可以抓取到try执行中的错误，可以进行处理，可以不处理\n   console.log(e)\n}\nfinally{\n}    \n</code></pre>\n</li>\n</ul>\n<h2 id=\"31、eval-str-可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）\"><a href=\"#31、eval-str-可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）\" class=\"headerlink\" title=\"31、eval(str)可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）\"></a>31、eval(str)可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）</h2><pre><code class=\"javascript\">var a = 100;\nvar str = &#39;var a = 1; var b = 2; console.log(a + b)&#39;;\neval(str); \n</code></pre>\n<h2 id=\"32、四种调用模式\"><a href=\"#32、四种调用模式\" class=\"headerlink\" title=\"32、四种调用模式\"></a>32、四种调用模式</h2><ul>\n<li>函数：指的是普通的，不属于任何对象的函数</li>\n<li>方法：作为对象的属性存在的函数（对象中的函数）</li>\n<li>函数内的this指向谁，只跟怎么调用有关系，跟函数定义在什么地方，没有任何关系</li>\n</ul>\n<h3 id=\"32-1-函数调用模式\"><a href=\"#32-1-函数调用模式\" class=\"headerlink\" title=\"32.1 函数调用模式\"></a>32.1 函数调用模式</h3><pre><code class=\"javascript\">fn( );   // this指向window\n</code></pre>\n<h3 id=\"32-2-方法调用模式\"><a href=\"#32-2-方法调用模式\" class=\"headerlink\" title=\"32.2 方法调用模式\"></a>32.2 方法调用模式</h3><pre><code class=\"javascript\">obj.fn();  // this指向obj，谁调用指向谁\n</code></pre>\n<blockquote>\n<p>可以把数组当成一个对象，访问0属性，就是方法，方法调用模式，指向arr</p>\n</blockquote>\n<h3 id=\"32-3-构造函数调用模式\"><a href=\"#32-3-构造函数调用模式\" class=\"headerlink\" title=\"32.3 构造函数调用模式\"></a>32.3 构造函数调用模式</h3><pre><code class=\"javascript\">var p = new Person();  // this指向实例p---new改变了this的指向，让this指向了新的实例\n</code></pre>\n<h3 id=\"32-4-上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）\"><a href=\"#32-4-上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）\" class=\"headerlink\" title=\"32.4 上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）\"></a>32.4 上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）</h3><ol>\n<li><p>call</p>\n<ul>\n<li>任何函数（都可以看成一个特殊的对象，也可以设置属性和方法）都有一个call方法</li>\n<li>call方法也可以用于调用函数,还可以指定函数执行的this的指向---fn.call(this指向);</li>\n<li>如果不传参，默认this指向window，如果传递第一个参数，那么就会指定this的指向</li>\n</ul>\n<p><strong><em>使用call来调用函数和普通调用函数的方式，唯一的区别，就是多了一个参数，call的第一个参数用于指定this指向</em></strong></p>\n</li>\n</ol>\n<p><code>数组</code>：有着数组的方法，可以遍历<br><code>伪数组</code>，本质上是对象，不是数组，数组的方法不能直接调用，但是伪数组是可以遍历的<br>常见的伪数组：<code>arguments</code> <code>document.querySelector()</code>  <code>jQuery</code></p>\n<blockquote>\n<p>小结：学习call方法，fn.call(this指向,x,y,z);<br>          call方法调用函数和普通函数调用的唯一区别，在于多了一个参数，第一个参数，用于指定this<br>          call方法，可以用于函数借调（借用别人的函数，借来调用）<br>          别人.方法.call(自己)；将this改成自己，借用别人的方法</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>apply</p>\n<ul>\n<li>apply的功能和call的功能是一样的，只是调用的方法不同了</li>\n<li>每个函数，都有一个apply方法，可以用于调用函数，且可以指定this指向</li>\n<li><strong><em>apply的语法：fn.apply(this指向，[x,y,z]);</em></strong></li>\n<li>参数1：用于指定this的指向</li>\n<li><p>参数2：接收一个数组，里面存放着所有传递的参数</p>\n<blockquote>\n<p>如果参数比较少，一般使用call，比较简单<br>如果参数比较多，一般使用apply，可以将所有需要传递的参数，放在一个数组中，一次性传递</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>bind（复制一个新函数，并且将新函数的this固定死指向传入的this值）</p>\n<pre><code class=\"javascript\">     var newFn = fn.bind(this指向)\n</code></pre>\n</li>\n<li><p>arguments</p>\n</li>\n</ol>\n<ul>\n<li>任何一个函数，都有一个对象，arguments，是一个伪数组，用于收集所有传递的参数（实参）</li>\n<li><p>一般用于参数不确定的情况</p>\n<p>new会和最近的 函数名() 结合，是一个整体，new fn()</p>\n</li>\n</ul>\n<blockquote>\n<p>补充：（1）定时器中的this ，指向window<br>      (2）事件处理函数中，浏览器让this指向了事件源</p>\n</blockquote>\n<h2 id=\"33、函数也是对象\"><a href=\"#33、函数也是对象\" class=\"headerlink\" title=\"33、函数也是对象\"></a>33、函数也是对象</h2><p>函数也是一种特殊的对象，可以添加属性和方法</p>\n<h2 id=\"34、js的规则：\"><a href=\"#34、js的规则：\" class=\"headerlink\" title=\"34、js的规则：\"></a>34、js的规则：</h2><ol>\n<li>任何<code>函数</code>，都是由<code>Function</code>创建出来的，包括他自己，包括Object函数</li>\n<li>任何的<code>原型对象</code>，都是直接由<code>Object</code>创建出来的</li>\n</ol>\n<p>js中的作用域：词法作用域，静态作用域，函数的作用域在函数声明时，就已经确定好了，跟调用没有关系<br>作用域链：每个函数都有自己的作用域，如果是定义在函数内的函数，里面的函数又会有自己的作用域（一层套一层，形成了作用域链）<br>变量的查询规则：先看自己作用域有没有这个变量，如果没有，往外一层一层的就近查找，如果一直找到全局都没有找到，就会报错</p>\n<h2 id=\"35、递归函数：在一个函数内部，自己调用自己\"><a href=\"#35、递归函数：在一个函数内部，自己调用自己\" class=\"headerlink\" title=\"35、递归函数：在一个函数内部，自己调用自己\"></a>35、递归函数：在一个函数内部，自己调用自己</h2><p>函数在调用时，其实是占用内存，函数在调用时，会开辟一块内存，进行执行</p>\n<p><strong>特点：</strong></p>\n<ol>\n<li>自己调用自己</li>\n<li>必须要有结束条件，要有出口</li>\n</ol>\n<p><em>递归：是一种算法，一种思想 ，化归思想，复杂的问题简单化</em></p>\n<h3 id=\"35-1-斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和\"><a href=\"#35-1-斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和\" class=\"headerlink\" title=\"35.1 斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和\"></a>35.1 斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和</h3><pre><code class=\"javascript\">// 直接这么写会有性能问题\nfunction getFib(n) {\n  if (n === 1 || n === 2) {\n    return 1;\n  }\n  return getFib(n-1) + getFib(n-2);\n}\n</code></pre>\n<p><strong><em>为什么会有性能问题？</em></strong><br>一个函数内部，调用了两次自己，真正执行时进行了大量的重复运算</p>\n<p><strong><em>如何优化：将已经算过的第n个斐波那契数列存起来</em></strong><br>运算过程中：</p>\n<ol>\n<li>先判断这个数，有没有算过，如果算过了，直接用</li>\n<li><p>如果没有算过，接着自己算，算完，存起来</p>\n<pre><code class=\"javascript\">// 找规律: getFib(n) = getFib(n-1) + getFib(n-2);\nvar arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数\nfunction getFib(n) {\nif (n === 1 || n === 2) {\nreturn 1;\n}\n\nif (arr[n]) {\nreturn arr[n];\n}\nelse {\narr[n] = getFib(n-1) + getFib(n-2);\nreturn arr[n];\n}\n}\n</code></pre>\n</li>\n</ol>\n<p><strong><em>利用闭包解决斐波那契数列</em></strong></p>\n<pre><code class=\"javascript\">// 省去了外部的函数名, 利用函数自调用\n\nvar result = (function() {\n  var arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数\n  function getFib(n) {\n    if (n === 1 || n === 2) {\n      return 1;\n    }\n\n    if (arr[n]) {\n      return arr[n];\n    }\n    else {\n      arr[n] = getFib(n - 1) + getFib(n - 2);\n      return arr[n];\n    }\n  }\n  return getFib;\n})();\n</code></pre>\n<h2 id=\"36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包\"><a href=\"#36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包\" class=\"headerlink\" title=\"36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包\"></a>36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包</h2><ul>\n<li>作用：保护变量（变量私有化）</li>\n<li>闭包的内存，不会直接释放（会占用内存）</li>\n<li>函数执行调用时，必然会开辟一快内存空间，一般来说，执行完就会释放</li>\n</ul>\n<p><strong><em>闭包的基本模型：</em></strong></p>\n<ol>\n<li>outer里面包inner</li>\n<li>匿名函数自调用<pre><code class=\"javascript\">var result = (function(){\nvar count = 0;\nreturn function(){\n count++;\n console.log(count);\n}\n})();\n</code></pre>\n</li>\n</ol>\n<h2 id=\"37、js垃圾回收机制（会将一些不用的内存空间，释放掉）\"><a href=\"#37、js垃圾回收机制（会将一些不用的内存空间，释放掉）\" class=\"headerlink\" title=\"37、js垃圾回收机制（会将一些不用的内存空间，释放掉）\"></a>37、js垃圾回收机制（会将一些不用的内存空间，释放掉）</h2><p><strong>内存泄漏：</strong>如果一块内存空间，一直得不到释放，就认为这块内存泄漏了<br><strong>机制：</strong></p>\n<ol>\n<li>引用计数：如果一块空间的引用次数，最终变成0，就会被释放掉<pre><code>bug：如果两个对象，互相引用，形成了循环引用，使用引用计数，就会得不到释放（内存泄漏）\n</code></pre></li>\n<li>标记清除：如果一块内存空间，可以访问到，就不释放；如果访问不到了，就会释放掉<pre><code>闭包用完了，只需要将指向函数内部的引用干掉，此时内存就会释放了\n</code></pre></li>\n</ol>\n<h2 id=\"38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）\"><a href=\"#38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）\" class=\"headerlink\" title=\"38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）\"></a>38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）</h2><h3 id=\"38-1-创建正则表达式：\"><a href=\"#38-1-创建正则表达式：\" class=\"headerlink\" title=\"38.1 创建正则表达式：\"></a>38.1 创建正则表达式：</h3><ol>\n<li>通过构造函数 <pre><code class=\"javascript\">var reg = new RegExp(//);\n</code></pre>\n\\d 表示数字，0-9，/\\d/可以匹配所有的数字<br>通过 <code>test</code> 方法，判断字符串，是否符合正则规则</li>\n<li>字面量<pre><code class=\"javascript\">var reg = /\\d/;\n</code></pre>\n</li>\n</ol>\n<h3 id=\"38-2-正则-元字符\"><a href=\"#38-2-正则-元字符\" class=\"headerlink\" title=\"38.2 正则-元字符\"></a>38.2 正则-元字符</h3><h4 id=\"38-2-1-普通字符：a-b-c\"><a href=\"#38-2-1-普通字符：a-b-c\" class=\"headerlink\" title=\"38.2.1 普通字符：a b c\"></a>38.2.1 普通字符：a b c</h4><h4 id=\"38-2-2-元字符：有特殊含义的\"><a href=\"#38-2-2-元字符：有特殊含义的\" class=\"headerlink\" title=\"38.2.2 元字符：有特殊含义的\"></a>38.2.2 元字符：有特殊含义的</h4><ol>\n<li><code>\\d</code> 数字，0-9</li>\n<li><code>\\D</code> 非数字</li>\n<li><code>\\w</code> 匹配单词字符（字母数字下划线），0-9  a-z  A-Z  _</li>\n<li><code>\\W</code> 非\\w（只要不是\\w中的字符，都匹配）</li>\n<li><code>\\s</code> 匹配不可见字符（换行<code>\\n</code> <code>空格</code> ）</li>\n<li><code>\\S</code> 匹配可见字符</li>\n<li><code>.</code> 匹配任意字符（除了<code>\\n</code>）----a.b可以匹配acb  aab a1b......<br>有时，就需要匹配点，需要转义 .--&gt;表示普通的点</li>\n</ol>\n<h3 id=\"38-3-正则表达式的优先级\"><a href=\"#38-3-正则表达式的优先级\" class=\"headerlink\" title=\"38.3 正则表达式的优先级\"></a>38.3 正则表达式的优先级</h3><p><code>|</code> 表示或，优先级最低<br><code>()</code> 优先级最高，一般用于提升优先级</p>\n<h3 id=\"38-4-正则表达式的字符\"><a href=\"#38-4-正则表达式的字符\" class=\"headerlink\" title=\"38.4 正则表达式的字符\"></a>38.4 正则表达式的字符</h3><p><code>[ ]</code>这个位置，可以出现的字符---[abc]，这个位置，可以出现a或者b或者c<br><code>[a-z]</code>，这个位置，可以出现a-z的所有小写字符<br><code>[a-zA-Z0-9_]</code>，这个位置，可以出现所有的字母、数字、下划线<br>[ ]内的 ^ 表示非</p>\n<h3 id=\"38-5-正则的边界（严格匹配）\"><a href=\"#38-5-正则的边界（严格匹配）\" class=\"headerlink\" title=\"38.5 正则的边界（严格匹配）\"></a>38.5 正则的边界（严格匹配）</h3><p><code>^</code>必须以...开头<br><code>$</code> 必须以...结尾<br>console.log(/^$/);---严格匹配，严格到字符数都是确定的</p>\n<h3 id=\"38-6-正则的量词\"><a href=\"#38-6-正则的量词\" class=\"headerlink\" title=\"38.6 正则的量词\"></a>38.6 正则的量词</h3><p><code>*</code> 出现0次或多次<br><code>+</code> 出现1次或多次<br><code>?</code> 出现0次或1次<br><code>{m,n}</code> 表示可以出现m次到n次<br><code>{m,}</code> 表示至少出现m次<br><code>{m}</code> 出现m次<br>汉字也是字符的一种，也有范围[\\u4e00-u9fa5]---一 yu</p>\n<h3 id=\"38-7-正则的replace（不严格的替换）\"><a href=\"#38-7-正则的replace（不严格的替换）\" class=\"headerlink\" title=\"38.7 正则的replace（不严格的替换）\"></a>38.7 正则的replace（不严格的替换）</h3><p>正则也比较懒，不加参数，只替换一次（加上g，表示 全局替换）</p>\n<pre><code class=\"javascript\">str.replace(/aa/g,&#39;xx&#39;)\n</code></pre>\n<h2 id=\"39、js校正计算\"><a href=\"#39、js校正计算\" class=\"headerlink\" title=\"39、js校正计算\"></a>39、js校正计算</h2><p>/<strong>\n </strong> 加法函数，用来得到精确的加法结果<br> <strong> 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。\n </strong> 调用：accAdd(arg1,arg2)<br> <strong> 返回值：arg1加上arg2的精确结果\n </strong>/</p>\n<pre><code class=\"javascript\">function accAdd(arg1, arg2) {\n    var r1, r2, m, c;\n    try {\n        r1 = arg1.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = arg2.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n        r2 = 0;\n    }\n    c = Math.abs(r1 - r2);\n    m = Math.pow(10, Math.max(r1, r2));\n    if (c &gt; 0) {\n        var cm = Math.pow(10, c);\n        if (r1 &gt; r2) {\n            arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));\n            arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;)) * cm;\n        } else {\n            arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;)) * cm;\n            arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));\n        }\n    } else {\n        arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));\n        arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));\n    }\n    return (arg1 + arg2) / m;\n}\n\n//给Number类型增加一个add方法，调用起来更加方便。\nNumber.prototype.add = function (arg) {\n    return accAdd(arg, this);\n};\n</code></pre>\n<p>/<strong>\n </strong> 减法函数，用来得到精确的减法结果<br> <strong> 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。\n </strong> 调用：accSub(arg1,arg2)<br> <strong> 返回值：arg1加上arg2的精确结果\n </strong>/</p>\n<pre><code class=\"javascript\">function accSub(arg1, arg2) {\n    var r1, r2, m, n;\n    try {\n        r1 = arg1.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = arg2.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n        r2 = 0;\n    }\n    m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度\n    n = (r1 &gt;= r2) ? r1 : r2;\n    return ((arg2 * m - arg1 * m) / m).toFixed(n);\n}\n\n// 给Number类型增加一个mul方法，调用起来更加方便。\nNumber.prototype.sub = function (arg) {\n    return accSub(arg, this);\n};\n</code></pre>\n<p>/<strong>\n </strong> 乘法函数，用来得到精确的乘法结果<br> <strong> 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。\n </strong> 调用：accMul(arg1,arg2)<br> <strong> 返回值：arg1乘以 arg2的精确结果\n </strong>/</p>\n<pre><code class=\"javascript\">function accMul(arg1, arg2) {\n    var m = 0, s1 = arg1.toString(), s2 = arg2.toString();\n    try {\n        m += s1.split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n    }\n    try {\n        m += s2.split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n    }\n    return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) / Math.pow(10, m);\n}\n\n// 给Number类型增加一个mul方法，调用起来更加方便。\nNumber.prototype.mul = function (arg) {\n    return accMul(arg, this);\n};\n</code></pre>\n<p>/<strong> \n </strong> 除法函数，用来得到精确的除法结果<br> <strong> 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。\n </strong> 调用：accDiv(arg1,arg2)<br> <strong> 返回值：arg1除以arg2的精确结果\n </strong>/</p>\n<pre><code class=\"javascript\">function accDiv(arg1, arg2) {\n    var t1 = 0, t2 = 0, r1, r2;\n    try {\n        t1 = arg1.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n    }\n    try {\n        t2 = arg2.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n    }\n    with (Math) {\n        r1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));\n        r2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));\n        return (r1 / r2) * pow(10, t2 - t1);\n    }\n}\n\n//给Number类型增加一个div方法，调用起来更加方便。\nNumber.prototype.div = function (arg) {\n    return accDiv(this, arg);\n};\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、介绍\"><a href=\"#1、介绍\" class=\"headerlink\" title=\"1、介绍\"></a>1、介绍</h2><p>js全称javascript，是一门运行在浏览器端的脚本语言，现在也可以运行在服务器端（node.js）</p>\n<h2 id=\"2、组成\"><a href=\"#2、组成\" class=\"headerlink\" title=\"2、组成\"></a>2、组成</h2><p>现在说的javasript包含3个组成部分</p>\n<ol>\n<li><strong>ECMAScript</strong> 语法标准，语法规则</li>\n<li><strong>DOM</strong> 专门用于操作页面元素的方法</li>\n<li><strong>BOM</strong> 专门用于操作浏览器的方法</li>\n</ol>\n<p><code>webapi</code>有时用来统称1和2</p>\n<h2 id=\"3、js书写位置\"><a href=\"#3、js书写位置\" class=\"headerlink\" title=\"3、js书写位置\"></a>3、js书写位置</h2><ol>\n<li>直接将内容编写在script标签中</li>\n<li>可以直接在一个单独的js文件中编写，需要引入</li>\n</ol>\n<blockquote>\n<p>注意点：只要script标签，设置了src属性，标签内的内容将被忽略</p>\n</blockquote>\n<h2 id=\"4、js的注释\"><a href=\"#4、js的注释\" class=\"headerlink\" title=\"4、js的注释\"></a>4、js的注释</h2><p>注释给开发者看的，浏览器不会执行，方便维护</p>\n<ul>\n<li>单行注释// 快捷键<code>ctrl+/</code></li>\n<li>多行注释/**/ 快捷键<code>alt+shift+a</code></li>\n</ul>\n<h2 id=\"5、js的输出语句\"><a href=\"#5、js的输出语句\" class=\"headerlink\" title=\"5、js的输出语句\"></a>5、js的输出语句</h2><blockquote>\n<p>指的就是往页面中输出的方式</p>\n<ul>\n<li><code>alert</code> 警告框</li>\n<li><code>confirm</code> 确认框（可以选择的）</li>\n<li><code>prompt</code> 输入框，可以让用户输入内容</li>\n<li><code>document.write</code> 往页面中追加输入内容</li>\n<li>支持标签的解析（识别标签）</li>\n<li><code>console.log</code> 在控制台打印内容，专门用于调试的，给开发者看</li>\n</ul>\n</blockquote>\n<h2 id=\"6、变量（就是可以变化的量）\"><a href=\"#6、变量（就是可以变化的量）\" class=\"headerlink\" title=\"6、变量（就是可以变化的量）\"></a>6、变量（就是可以变化的量）</h2><h3 id=\"6-1-作用\"><a href=\"#6-1-作用\" class=\"headerlink\" title=\"6.1 作用\"></a>6.1 作用</h3><p>存储数据，为了将来可以运算使用</p>\n<ol>\n<li>先声明，后赋值<pre><code class=\"javascript\">var age;\nage = 18;\n</code></pre>\n</li>\n<li>同时声明和赋值<pre><code class=\"javascript\"> var age1 = 18;\n console.log(age1);\n</code></pre>\n</li>\n<li>只声明，不赋值（<code>undefined</code>未定义，只要变量声明了但是未赋值，默认值就是undefined）</li>\n<li>不声明，直接赋值(<strong>不推荐</strong>，变量一定要声明了，再使用)<pre><code class=\"javascript\">age3=30;\nconsole.log(age3);\n</code></pre>\n</li>\n<li>不声明，不赋值，直接用  xxx is not defined 一定是没有声明赋值的变量直接用了，会报错</li>\n<li>可以同时声明赋值多个变量（本质上，只是省略了var）</li>\n</ol>\n<h3 id=\"6-2-变量命名规则和规范\"><a href=\"#6-2-变量命名规则和规范\" class=\"headerlink\" title=\"6.2 变量命名规则和规范\"></a>6.2 变量命名规则和规范</h3><h4 id=\"6-2-1-规则\"><a href=\"#6-2-1-规则\" class=\"headerlink\" title=\"6.2.1 规则\"></a>6.2.1 规则</h4><ul>\n<li>变量名必须由字母 数字 下划线和 $组成，不能以数字开头（后来也引入中文，但是不要这么做）</li>\n<li>变量名不能是关键字或者是保留字</li>\n<li>变量区分大小写</li>\n</ul>\n<h4 id=\"6-2-2-规范\"><a href=\"#6-2-2-规范\" class=\"headerlink\" title=\"6.2.2 规范\"></a>6.2.2 规范</h4><ul>\n<li>声明的变量要有意义</li>\n<li>声明的变量，如果很长，遵循驼峰命名（从第二个字母开始，首字母大写，用于分割单词，可读性高）</li>\n</ul>\n<h3 id=\"6-3-变量的作用域（变量起作用的区域）\"><a href=\"#6-3-变量的作用域（变量起作用的区域）\" class=\"headerlink\" title=\"6.3 变量的作用域（变量起作用的区域）\"></a>6.3 变量的作用域（变量起作用的区域）</h3><ul>\n<li>全局作用域（在script标签内，在函数外的区域）<br>  声明在全局作用域的变量，就叫全局变量<br>  特征：在任何地方都可以使用</li>\n<li>局部作用域（函数内部的区域，就是局部作用域）<br>  声明在函数内部的变量，就叫局部变量<br>  特征：只在当前函数内可以使用，出了函数，就不能用了</li>\n</ul>\n<h3 id=\"6-4-变量的访问规则\"><a href=\"#6-4-变量的访问规则\" class=\"headerlink\" title=\"6.4 变量的访问规则\"></a>6.4 变量的访问规则</h3><p>如果自己的作用域内有这个变量，直接用，改自己的<br>如果没有，才会往外面找（找全局）,用外面的，改外面的 </p>\n<h3 id=\"6-5-隐式全局变量\"><a href=\"#6-5-隐式全局变量\" class=\"headerlink\" title=\"6.5 隐式全局变量\"></a>6.5 隐式全局变量</h3><p>如果一个没有声明过的变量，直接赋值，就叫隐式全局变量（将来要避免）</p>\n<h3 id=\"6-6-预解析（预先解析，浏览器会先查看有多少的变量和函数）\"><a href=\"#6-6-预解析（预先解析，浏览器会先查看有多少的变量和函数）\" class=\"headerlink\" title=\"6.6 预解析（预先解析，浏览器会先查看有多少的变量和函数）\"></a>6.6 预解析（预先解析，浏览器会先查看有多少的变量和函数）</h3><ol>\n<li>所有的变量声明，都会提升到最顶部，只提升声明，不提升赋值</li>\n<li>所有的函数声明，都会提升到最顶部，只提升声明，不提升调用<blockquote>\n<p>补充说明:</p>\n<ol>\n<li>多个重名的var声明，后面的var将被忽略<ol start=\"2\">\n<li>多个重名的函数声明，后面的将前面的覆盖</li>\n<li>如果出现了同名的变量和函数，函数优先，函数的优先级&gt;变量</li>\n<li>函数内部也会进行预解析</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p>预解析，虽然可以提升我们的声明，但是我们开发时，还是要<strong>先声明，后使用</strong>！！！</p>\n<h2 id=\"7、js的数据类型\"><a href=\"#7、js的数据类型\" class=\"headerlink\" title=\"7、js的数据类型\"></a>7、js的数据类型</h2><p>分为：<code>简单数据类型</code>和<code>复杂数据类型</code> （数组、函数、对象）</p>\n<h3 id=\"7-1-简单数据类型\"><a href=\"#7-1-简单数据类型\" class=\"headerlink\" title=\"7.1 简单数据类型\"></a>7.1 简单数据类型</h3><h4 id=\"7-1-1-number类型（数字类型）\"><a href=\"#7-1-1-number类型（数字类型）\" class=\"headerlink\" title=\"7.1.1 number类型（数字类型）\"></a>7.1.1 number类型（数字类型）</h4><ol>\n<li><p>整数（一般使用的是十进制  逢十进一）</p>\n<p> <code>八进制，逢八进一，0开头</code></p>\n<pre><code class=\"javascript\"> var num3 = 011  //就是1*8+1 为9;\n var num4 = 022  //2*8+2 为18\n</code></pre>\n<p> <code>十六进制，逢16进一，0x开头的数字  0-9abcdef</code></p>\n<pre><code class=\"javascript\"> var num2 = 0x11  //1*16+1 为17;\n var num3 = 0x1a  //16+10为26;\n</code></pre>\n</li>\n<li><p>浮点数（小数）</p>\n</li>\n<li><p>科学计数法 </p>\n<pre><code class=\"javascript\">var num1 = 1e4 就是1*10^4\n</code></pre>\n<blockquote>\n<p>注意点：计算机对于小数的运算是不准确的，会有很小很小的误差，所以尽量不要用  小数进行比较运算</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"7-1-2-string类型-字符串类型\"><a href=\"#7-1-2-string类型-字符串类型\" class=\"headerlink\" title=\"7.1.2 string类型 字符串类型\"></a>7.1.2 string类型 字符串类型</h4><ul>\n<li>通过 &#39;&#39; 或者 &quot;&quot; 包裹的就是字符串，js中单双引号，没有区别，推荐&#39;&#39;.</li>\n<li><p>字符串通过length，可以获取长度</p>\n<pre><code>  console.log（str.length）;\n</code></pre></li>\n<li><p>转义字符<br><code>\\&#39;</code> 表示一个普通的单引号<br>  <code>\\&quot;</code> 表示一个普通的双引号<br>  <code>\\n</code> 表示换行</p>\n</li>\n<li><p>拼串（拼接字符串）</p>\n<blockquote>\n<p><code>+</code> 有拼接字符串的功能，也有运算的功能</p>\n</blockquote>\n</li>\n</ul>\n<p><code>+</code> 的规则：</p>\n<ol>\n<li>只要两边有字符串（黑色），进行的就是拼串</li>\n<li>只有两边都是数字（蓝色），才进行运算</li>\n</ol>\n<h4 id=\"7-1-3-boolean类型-布尔类型\"><a href=\"#7-1-3-boolean类型-布尔类型\" class=\"headerlink\" title=\"7.1.3 boolean类型 布尔类型\"></a>7.1.3 boolean类型 布尔类型</h4><p>只有两个值，true真 false假<br>一般用于比较</p>\n<h4 id=\"7-1-4-undefined-未定义的，变量声明了，但是未赋值，默认值就是underfined\"><a href=\"#7-1-4-undefined-未定义的，变量声明了，但是未赋值，默认值就是underfined\" class=\"headerlink\" title=\"7.1.4 undefined 未定义的，变量声明了，但是未赋值，默认值就是underfined\"></a>7.1.4 undefined 未定义的，变量声明了，但是未赋值，默认值就是underfined</h4><h4 id=\"7-1-5-null-空对象\"><a href=\"#7-1-5-null-空对象\" class=\"headerlink\" title=\"7.1.5 null 空对象\"></a>7.1.5 null 空对象</h4><h3 id=\"7-2-复杂数据类型\"><a href=\"#7-2-复杂数据类型\" class=\"headerlink\" title=\"7.2 复杂数据类型\"></a>7.2 复杂数据类型</h3><h2 id=\"8、变量与简单数据类型的说明\"><a href=\"#8、变量与简单数据类型的说明\" class=\"headerlink\" title=\"8、变量与简单数据类型的说明\"></a>8、变量与简单数据类型的说明</h2><ul>\n<li>对于简单数据类型，浏览器直接认识（直接量 或者 字面量）</li>\n<li>若是将字符串当成了变量（未声明，未赋值的变量直接使用，会报错）</li>\n<li>字符串需要引号包裹</li>\n</ul>\n<h2 id=\"9、运算符（操作符）\"><a href=\"#9、运算符（操作符）\" class=\"headerlink\" title=\"9、运算符（操作符）\"></a>9、运算符（操作符）</h2><h3 id=\"9-1-算术运算符-取余\"><a href=\"#9-1-算术运算符-取余\" class=\"headerlink\" title=\"9.1 算术运算符 + - * / %(取余)\"></a>9.1 算术运算符 <code>+ - * / %(取余)</code></h3><ul>\n<li><code>+</code> 不仅有拼串的功能，还可以运算</li>\n<li>其他算数运算符，只有运算的功能，如果遇到了字符串，也会转成数字运算<pre><code class=\"javascript\">&quot;2&quot; - 1 = &gt;1\n</code></pre>\n<h3 id=\"9-2-赋值运算符\"><a href=\"#9-2-赋值运算符\" class=\"headerlink\" title=\"9.2 赋值运算符 =\"></a>9.2 赋值运算符 =</h3>=（就是赋值）   +=   -=   *=   /=   %=<pre><code class=\"javascript\">var num = 10;\nnum += 10; //等价 num = num + 10\n</code></pre>\n</li>\n</ul>\n<h3 id=\"9-3-自增或自减运算符（一元运算符）\"><a href=\"#9-3-自增或自减运算符（一元运算符）\" class=\"headerlink\" title=\"9.3 自增或自减运算符（一元运算符）\"></a>9.3 自增或自减运算符（一元运算符）</h3><h4 id=\"9-3-1-自增：让变量的值，在原来的基础上-1\"><a href=\"#9-3-1-自增：让变量的值，在原来的基础上-1\" class=\"headerlink\" title=\"9.3.1 自增：让变量的值，在原来的基础上+1\"></a>9.3.1 自增：让变量的值，在原来的基础上+1</h4><ul>\n<li><p>语法：<br><code>++num</code> 前自增，规则：先让值+1，再返回这个值<br><code>num++</code> 后自增，规则：先返回这个值，再让值+1</p>\n</li>\n<li><p>注意点： </p>\n<ul>\n<li>不管是++num 还是num++ 从功能的角度一样的，都是让变量的值+1</li>\n<li>虽然++num 或 num++ 都能让变量值+1，但是++num 和 num++这个式子的结果是不一样的</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"9-3-2-自减：让变量的值，在原来的基础上-1\"><a href=\"#9-3-2-自减：让变量的值，在原来的基础上-1\" class=\"headerlink\" title=\"9.3.2 自减：让变量的值，在原来的基础上-1\"></a>9.3.2 自减：让变量的值，在原来的基础上-1</h4><p>*语法：<br><code>--num</code><br><code>num--</code></p>\n<h3 id=\"9-4-逻辑运算符（与或非）\"><a href=\"#9-4-逻辑运算符（与或非）\" class=\"headerlink\" title=\"9.4 逻辑运算符（与或非）\"></a>9.4 逻辑运算符（与或非）</h3><p><code>&amp;&amp;</code> 并且 两边都要成立，结果才是 true，只要有一个不成立，就是false<br><code>||</code> 或 两边只要有一个成立，结果就是true<br><code>!</code> 取反</p>\n<h3 id=\"9-5-比较运算符-gt-lt-gt-lt\"><a href=\"#9-5-比较运算符-gt-lt-gt-lt\" class=\"headerlink\" title=\"9.5 比较运算符 &gt;  &lt;  &gt;=  &lt;=  ==   !=  ===   !==\"></a>9.5 比较运算符 &gt;  &lt;  &gt;=  &lt;=  ==   !=  ===   !==</h3><p><code>==</code> 规则：只看值，不看类型（只要值相等，就是相等）<br><code>===</code> 规则：看值，又看类型（值和类型都要相等）<br><code>!=</code> 规则：只看值，不看类型（只要值不等，就是true）<br><code>!==</code> 规则：看值，又看类型（只要值或者类型有一个不等，就是不等，返回true）</p>\n<blockquote>\n<p>==有一定规则（如果类型不同，转换成相同类型，然后比较）</p>\n<ol>\n<li>NaN，不等于任何值，包括他自己</li>\n<li>null，不等于任何值，除了null和undefined</li>\n<li>undefined，不等于任何值 ，除了null和undefined</li>\n<li>看是否有数字或布尔，如果有，转成数字比较<br>   true：1，false:0<br>   [ ]:0, { }:NaN，&#39;&#39;:0</li>\n<li>再看是否有字符串，（字符串和复杂数据类型），转成字符串比较<br> [ ].toString()---&gt;&quot;&quot;<br> obj.toString()---&gt;&#39;[object Object]&#39;</li>\n<li>都是复杂数据类型，比较的是内存地址</li>\n</ol>\n</blockquote>\n<h3 id=\"9-6-运算符优先级\"><a href=\"#9-6-运算符优先级\" class=\"headerlink\" title=\"9.6 运算符优先级\"></a>9.6 运算符优先级</h3><ol>\n<li>括号的优先级最高</li>\n<li>一元运算符 ++  --  !</li>\n<li>算数运算符  先乘除%，后加减</li>\n<li>比较运算符</li>\n<li>逻辑运算符  &amp;&amp;  ||</li>\n</ol>\n<blockquote>\n<p>记忆：（1）括号的优先级最高，逻辑运算符的优先级最低<br>         （2）先乘除，后加减</p>\n</blockquote>\n<h2 id=\"10、如何判断数据的类型\"><a href=\"#10、如何判断数据的类型\" class=\"headerlink\" title=\"10、如何判断数据的类型\"></a>10、如何判断数据的类型</h2><h3 id=\"10-1-直接打印看颜色（调试，看颜色）\"><a href=\"#10-1-直接打印看颜色（调试，看颜色）\" class=\"headerlink\" title=\"10.1 直接打印看颜色（调试，看颜色）\"></a>10.1 直接打印看颜色（调试，看颜色）</h3><p>蓝色的数字，number<br>黑色         string<br>蓝色的布尔值 boolean<br>灰色        undefined和null</p>\n<h3 id=\"10-2-typeof-变量-它的返回值，也是一个字符串类型\"><a href=\"#10-2-typeof-变量-它的返回值，也是一个字符串类型\" class=\"headerlink\" title=\"10.2 typeof 变量    它的返回值，也是一个字符串类型\"></a>10.2 typeof 变量    它的返回值，也是一个字符串类型</h3><ol>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n</ol>\n<blockquote>\n<p>bug: typeof null = object;</p>\n</blockquote>\n<h2 id=\"11、数据类型转换\"><a href=\"#11、数据类型转换\" class=\"headerlink\" title=\"11、数据类型转换\"></a>11、数据类型转换</h2><h3 id=\"11-1-转成数字\"><a href=\"#11-1-转成数字\" class=\"headerlink\" title=\"11.1 转成数字\"></a>11.1 转成数字</h3><ul>\n<li><code>Number（xx）</code> 如果拿到的是一个非数字，浏览器也不会报错，返回 <code>NaN</code>,not  a number </li>\n<li><code>parseInt（xx）</code> 从第一个字符开始解析，一直解析到第一个非数字为止</li>\n<li><code>parseFloat（xx）</code> 从第一个字符开始解析，可以识别一个<code>.</code>  然后解析到非数字为止</li>\n<li>直接运算 -  *  /  %    +正号（用的最多，例如+age）  -负号        </li>\n</ul>\n<h3 id=\"11-2-转成字符串\"><a href=\"#11-2-转成字符串\" class=\"headerlink\" title=\"11.2 转成字符串\"></a>11.2 转成字符串</h3><ul>\n<li>String（xx）</li>\n<li>xx.toString()</li>\n<li>直接拼串 （常用）<br>  console.log(age+ &quot;&quot;);</li>\n</ul>\n<h3 id=\"11-3-转成布尔类型\"><a href=\"#11-3-转成布尔类型\" class=\"headerlink\" title=\"11.3 转成布尔类型\"></a>11.3 转成布尔类型</h3><p><strong>所有的值，都可以转成布尔类型</strong></p>\n<p><strong>规则</strong>：只有这6种情况， 0  &quot;&quot;  NaN  null  undefined   false  可以转成false，其他所有值，都是true</p>\n<ul>\n<li>Boolean（）</li>\n<li>!!</li>\n</ul>\n<h3 id=\"11-4-NaN的说明（表示非数字，指一个无法用数字表示的数字，not-a-number）\"><a href=\"#11-4-NaN的说明（表示非数字，指一个无法用数字表示的数字，not-a-number）\" class=\"headerlink\" title=\"11.4 NaN的说明（表示非数字，指一个无法用数字表示的数字，not a number）\"></a>11.4 NaN的说明（表示非数字，指一个无法用数字表示的数字，not a number）</h3><ul>\n<li>如果浏览器遇到了一个无法用数字表示的数值，就用NaN表示</li>\n<li>只要看到了NaN，说明代码的执行有问题</li>\n<li>NaN的类型是number类型</li>\n<li>NaN不等于任何值，包括他自己</li>\n</ul>\n<h2 id=\"12、流程控制\"><a href=\"#12、流程控制\" class=\"headerlink\" title=\"12、流程控制\"></a>12、流程控制</h2><h3 id=\"12-1-顺序结构（从上到下执行的，默认）\"><a href=\"#12-1-顺序结构（从上到下执行的，默认）\" class=\"headerlink\" title=\"12.1 顺序结构（从上到下执行的，默认）\"></a>12.1 顺序结构（从上到下执行的，默认）</h3><h3 id=\"12-2-分支结构（选择结构）\"><a href=\"#12-2-分支结构（选择结构）\" class=\"headerlink\" title=\"12.2 分支结构（选择结构）\"></a>12.2 分支结构（选择结构）</h3><h4 id=\"12-2-1-if语句\"><a href=\"#12-2-1-if语句\" class=\"headerlink\" title=\"12.2.1 if语句\"></a>12.2.1 if语句</h4><ul>\n<li><p>语法1</p>\n<pre><code class=\"javascript\">if（条件）{\n语句1;\n}\n</code></pre>\n<p>如果条件成立，执行语句1</p>\n</li>\n<li><p>语法2</p>\n<pre><code>if（条件）{\n语句1;\n}\nelse {\n语句2;\n}\n</code></pre><p>如果条件成立，执行语句1，否则执行语句2</p>\n</li>\n<li><p>语法3</p>\n<pre><code>if（条件1）{\n语句1;\n}\nelse if（条件2） {\n语句2;\n}\nelse {\n语句3;\n}\n</code></pre></li>\n</ul>\n<p>如果条件1成立，执行语句1<br>如果条件1不成立，看条件2，如果条件2成立，执行语句2<br>如果都不成立，执行语句3</p>\n<h4 id=\"12-2-2-三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）\"><a href=\"#12-2-2-三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）\" class=\"headerlink\" title=\"12.2.2 三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）\"></a>12.2.2 三元运算符（三个值参与运算，只适用于比较简单的判断，可以更加简洁）</h4><p>语法  var 结果 = 条件 ？ A ：B；（如果条件满足，就是A 否则B）</p>\n<h4 id=\"12-2-3-switch-case（根据变量的具体，进行判断）\"><a href=\"#12-2-3-switch-case（根据变量的具体，进行判断）\" class=\"headerlink\" title=\"12.2.3 switch-case（根据变量的具体，进行判断）\"></a>12.2.3 switch-case（根据变量的具体，进行判断）</h4><pre><code class=\"javascript\">switch（变量）{\n  case 值1:\n      语句1;\n      break;（break表示跳出switch，接着往下执行）\n  case 值2:\n      语句2;\n      break;（break表示跳出switch，接着往下执行）\n  case 值3:\n      语句3;\n      break;（break表示跳出switch，接着往下执行）\n  default:\n      默认语句;\n}\n</code></pre>\n<p><strong>判断变量的值</strong><br>    如果值，等于值1，执行语句1<br>    如果值，等于值2，执行语句2<br>    。。。<br>    如果都不满足，执行默认语句</p>\n<p><strong>注意点</strong>：<br>    （1）进行的值的比较，进行的是全等比较<br>    （2）养成写break的习惯（不写break，会一直往下执行）</p>\n<h4 id=\"12-2-4-三种分支结构的使用场景：\"><a href=\"#12-2-4-三种分支结构的使用场景：\" class=\"headerlink\" title=\"12.2.4 三种分支结构的使用场景：\"></a>12.2.4 三种分支结构的使用场景：</h4><ul>\n<li>if else            适用于范围形的判断</li>\n<li>三元运算符        只适用于比较简单的判断，条件只能写一个，但是简洁</li>\n<li>switch。。 case。。适用于具体值的判断</li>\n</ul>\n<h3 id=\"12-3-循环结构\"><a href=\"#12-3-循环结构\" class=\"headerlink\" title=\"12.3 循环结构\"></a>12.3 循环结构</h3><h4 id=\"12-3-1-while（当条件成立时，循环执行某件事）\"><a href=\"#12-3-1-while（当条件成立时，循环执行某件事）\" class=\"headerlink\" title=\"12.3.1 while（当条件成立时，循环执行某件事）\"></a>12.3.1 while（当条件成立时，循环执行某件事）</h4><pre><code class=\"javascript\">while（条件）{\n  循环体; //循环执行的内容\n}\n</code></pre>\n<p>条件成立，执行循环体<br>判断条件，条案件成立，继续执行循环体<br>。。。<br>条件不成立，跳出循环<br>死循环，永远都没有结束的一个循环，开发中需要避免</p>\n<ul>\n<li>while循环一定要有条件，不然就死循环了</li>\n<li>i++一般放在{..}的最后面</li>\n<li>while循环可以用于实现不明确循环次数的循环</li>\n</ul>\n<h4 id=\"12-3-2-do-while\"><a href=\"#12-3-2-do-while\" class=\"headerlink\" title=\"12.3.2 do while\"></a>12.3.2 do while</h4><pre><code class=\"javascript\">do {\n  循环体; //重复执行的内容\n}while（条件)\n</code></pre>\n<p>一上来，直接执行循环体<br>再判断条件，如果条件成立，再执行循环体<br>。。。<br>直到条件不成立，跳出循环</p>\n<blockquote>\n<p>do while一般只适合：不管条件成立不成立，都执行一次<br>while 和 do while的区别：<br>    while 如果条件不成立，一次都不执行<br>    do while不管条件成立与否，至少执行一次</p>\n</blockquote>\n<h4 id=\"12-3-3-for（适用于明确范围的循环）\"><a href=\"#12-3-3-for（适用于明确范围的循环）\" class=\"headerlink\" title=\"12.3.3 for（适用于明确范围的循环）\"></a>12.3.3 for（适用于明确范围的循环）</h4><pre><code>for（初始化语句;判断条件;自增或自减）{\n  循环体;\n}\n</code></pre><p>例：</p>\n<pre><code class=\"javascript\">for（var i = 1；i &lt; 5; i++）{\n  console.log(1);\n}\n</code></pre>\n<p>执行语句：</p>\n<ol>\n<li>初始化语句<ol start=\"2\">\n<li>判断条件</li>\n<li>自增或自减</li>\n<li>循环体</li>\n</ol>\n</li>\n</ol>\n<p>执行流程分析：1243 243 243 243...<br>执行流程：<br>  先初始化语句，判断条件，执行循环体，自增或自减；<br>    判断条件，执行循环体，自增或自减；<br>    。。。<br>    条件不成立，跳出循环；</p>\n<h4 id=\"12-3-4-双重for循环，就是在for循环的外面再套一个for循环\"><a href=\"#12-3-4-双重for循环，就是在for循环的外面再套一个for循环\" class=\"headerlink\" title=\"12.3.4 双重for循环，就是在for循环的外面再套一个for循环\"></a>12.3.4 双重for循环，就是在for循环的外面再套一个for循环</h4><ul>\n<li>外层控制行数</li>\n<li><p>内层控制一行打印多少个</p>\n<p>  break：如果循环遇到了break，跳出整个循环，整个循环就结束了，后面的次数都不执行了<br>  continue：如果循环遇到了continue，跳出本次循环，执行下一次循环</p>\n</li>\n</ul>\n<h4 id=\"12-3-5-循环的使用场景：\"><a href=\"#12-3-5-循环的使用场景：\" class=\"headerlink\" title=\"12.3.5 循环的使用场景：\"></a>12.3.5 循环的使用场景：</h4><ul>\n<li>while比较适合不明确执行次数的循环（循环表白案例）</li>\n<li>do while（少用）只适用于不管成立与否，至少执行一次循环体的情况</li>\n<li>for比较适合于明确范围的循环</li>\n</ul>\n<h2 id=\"13、断点调试\"><a href=\"#13、断点调试\" class=\"headerlink\" title=\"13、断点调试\"></a>13、断点调试</h2><p>（1）F12打开控制台，sources,点开对应的文件<br>（2）在对应行的行号上，点击打断点，刷新后，浏览器会自动执行停留在断点的位置<br>操作：<br>（1）watch监视，监视变量的变化<br>（2）F10，让代码往下一步执行<br>（3）F8，从当前位置，执行到下一个断点的位置，如果后面没有断点了，就会一直执行完</p>\n<h2 id=\"14、数组（是一个有序的值的集合，可以存储大量的数据）\"><a href=\"#14、数组（是一个有序的值的集合，可以存储大量的数据）\" class=\"headerlink\" title=\"14、数组（是一个有序的值的集合，可以存储大量的数据）\"></a>14、数组（是一个有序的值的集合，可以存储大量的数据）</h2><p>简单数据类型，在存储大量数据时，一个一个的存，非常的浪费</p>\n<h3 id=\"14-1-创建数组的方式\"><a href=\"#14-1-创建数组的方式\" class=\"headerlink\" title=\"14.1 创建数组的方式\"></a>14.1 创建数组的方式</h3><ol>\n<li><p>字面量的方式（字面量，直接量，从字面上直接就能看出是什么值的量）</p>\n<pre><code> 123  false  &#39;abc&#39;  undefined  null  [ ]:表示数组\n</code></pre><p><code>var arr =[ ]</code>创建一个空数组</p>\n<blockquote>\n<p>注意点：数组里面可以存任意类型的数据，但是规范是存储同类型的数据</p>\n</blockquote>\n</li>\n<li><p>构造函数的方式</p>\n<pre><code class=\"javascript\"> var arr = new Array(); ---创建一个空数组\n var arr = new Array(5);---浪费空间，五个空的位置，没有具体值\n</code></pre>\n<h3 id=\"14-2-数组的长度-arr-length\"><a href=\"#14-2-数组的长度-arr-length\" class=\"headerlink\" title=\"14.2 数组的长度 arr.length\"></a>14.2 数组的长度 arr.length</h3><h3 id=\"14-3-数组的下标（索引）：数组中的每一项，都会有一个唯一的下标\"><a href=\"#14-3-数组的下标（索引）：数组中的每一项，都会有一个唯一的下标\" class=\"headerlink\" title=\"14.3 数组的下标（索引）：数组中的每一项，都会有一个唯一的下标\"></a>14.3 数组的下标（索引）：数组中的每一项，都会有一个唯一的下标</h3></li>\n</ol>\n<ul>\n<li>从0开始，最大下标arr.length-1</li>\n<li>数组中下标的范围：0 -----&gt; arr.length-1</li>\n</ul>\n<h3 id=\"14-4-数组的取值和存值\"><a href=\"#14-4-数组的取值和存值\" class=\"headerlink\" title=\"14.4 数组的取值和存值\"></a>14.4 数组的取值和存值</h3><ul>\n<li><p>取值：<br><strong>语法：数组名[下标]</strong></p>\n<ol>\n<li>如果下标存在，直接返回对应项的值</li>\n<li>如果下标不存在，返回undefined</li>\n</ol>\n</li>\n<li><p>存值（改值）<br><strong>语法：数组名[下标] = ‘新的值’</strong></p>\n<ol>\n<li>如果下标存在，直接用新的值覆盖</li>\n<li>如果下标不存在，新建一个项，进行赋值</li>\n</ol>\n</li>\n<li><p>往数组最后添加项</p>\n<ol>\n<li>arr[arr.length] = &#39;值&#39;;</li>\n<li>arr.push(&#39;值&#39;)；</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"14-5-数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项\"><a href=\"#14-5-数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项\" class=\"headerlink\" title=\"14.5 数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项\"></a>14.5 数组的遍历：遍及所有，从数组的第一项，访问到数组的最后一项</h3><ul>\n<li><p>数组正序遍历</p>\n<pre><code class=\"javascript\">for (var i = 0; i &lt; arr.length; i++) {\n`console.log(arr[i]);\n}\n</code></pre>\n</li>\n<li><p>数组倒叙遍历</p>\n<pre><code>for (var i = arr.length-1; i &gt;=0; i--) {\nconsole.log(arr[i]);\n}\n</code></pre></li>\n</ul>\n<h3 id=\"14-6-冒泡排序\"><a href=\"#14-6-冒泡排序\" class=\"headerlink\" title=\"14.6 冒泡排序\"></a>14.6 冒泡排序</h3><ol>\n<li>冒泡（指得是排序的方式）</li>\n<li>排序（就是讲一组没有按照顺序排列的数，经过排列后，按照一定的顺序排列）<br> 价格排序，成绩排序<br> 编程界，有十大排序</li>\n</ol>\n<h3 id=\"14-7-初级版\"><a href=\"#14-7-初级版\" class=\"headerlink\" title=\"14.7 初级版\"></a>14.7 初级版</h3><ol>\n<li>先排出一趟，排出一个最大值<ol>\n<li>遍历数组</li>\n<li>让arr[i] 和 arr[i+1] 比较</li>\n<li>如果arr[i] &gt; arr[i+1] ，交换位置</li>\n</ol>\n</li>\n<li>双重for循环，多排几次，就排好了</li>\n</ol>\n<h3 id=\"14-8-中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次\"><a href=\"#14-8-中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次\" class=\"headerlink\" title=\"14.8 中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次\"></a>14.8 中级版（优化）：一趟可以比出一个最大值，每趟下来都可以少比一次</h3><pre><code>    内循环-j\n</code></pre><h3 id=\"14-9-高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了\"><a href=\"#14-9-高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了\" class=\"headerlink\" title=\"14.9 高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了\"></a>14.9 高级版（优化）：假设成立法，如果已经排好序了，后面就不用再排了</h3><ol>\n<li>在每趟排列前，先假设，已经排好了</li>\n<li>一趟下来，如果一次交换都没有发生，flag值就是true<pre><code class=\"javascript\">var arr = [7, 6, 5, 4, 3, 2, 1];\n// 外层控制趟数, 一趟可以比出一个最大值, 7个数, 比6趟即可\nfor (var j = 0; j &lt; arr.length-1; j++) {\n// 在每趟排列前, 先假设, 已经排好了\nvar flag = true;\nfor (var i = 0; i &lt; arr.length-1-j; i++) {\n if (arr[i] &gt; arr[i + 1]) {\n   var temp = arr[i];\n   arr[i] = arr[i + 1];\n   arr[i+1] = temp;\n   // 发生了交换, 说明没有排好\n   flag = false;\n }\n}\n// 一趟下来, 如果一次交换都没有发生, flag值就是 true\nif (flag) {\n break; \n}\n}\nconsole.log(arr);\n</code></pre>\n</li>\n</ol>\n<h2 id=\"15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）\"><a href=\"#15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）\" class=\"headerlink\" title=\"15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）\"></a>15、函数（可以将一段重复的代码进行封装，一次声明，可以多次调用）</h2><p><strong>好处</strong>：可维护性高</p>\n<h3 id=\"15-1-声明函数\"><a href=\"#15-1-声明函数\" class=\"headerlink\" title=\"15.1 声明函数\"></a>15.1 声明函数</h3><p><strong>函数名的规范</strong>：一般都是动词+名词（一般函数都是要做某一件事情）</p>\n<pre><code>function 函数名(){\n  函数体;\n}\n</code></pre><blockquote>\n<p>函数光声明，是不会执行的。</p>\n</blockquote>\n<h4 id=\"15-1-1-调用函数\"><a href=\"#15-1-1-调用函数\" class=\"headerlink\" title=\"15.1.1 调用函数\"></a>15.1.1 调用函数</h4><pre><code>函数();\n</code></pre><p>函数一次声明，可以多次调用！！！</p>\n<h4 id=\"15-1-2-函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）\"><a href=\"#15-1-2-函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）\" class=\"headerlink\" title=\"15.1.2 函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）\"></a>15.1.2 函数的参数（在函数中，需要发生变化的值，可以定义成函数的参数）</h4><ul>\n<li><p>形参---形式参数（函数在声明时，函数名括号内的参数）<br>  形参默认没有值或类型！！！只在函数调用时，形参才会有具体的值或类型<br>  作用：占位置</p>\n</li>\n<li><p>实参---实际参数（函数调用时传递给函数的参数）<br>  实参有具体的值或者类型<br>  作用：在函数调用时将数据传递给形参</p>\n</li>\n</ul>\n<blockquote>\n<p>注意点：形参和实参一一对应！！！</p>\n</blockquote>\n<h4 id=\"15-1-3-函数的声明和调用进阶写法\"><a href=\"#15-1-3-函数的声明和调用进阶写法\" class=\"headerlink\" title=\"15.1.3 函数的声明和调用进阶写法\"></a>15.1.3 函数的声明和调用进阶写法</h4><pre><code class=\"javascript\">function 函数名（形参1，形参2，形参3...）{\n  函数体;\n}\n</code></pre>\n<h4 id=\"15-1-4-函数的返回值\"><a href=\"#15-1-4-函数的返回值\" class=\"headerlink\" title=\"15.1.4 函数的返回值\"></a>15.1.4 函数的返回值</h4><p>函数内部声明的变量 或者 形参，只能在函数内使用，出了函数就用不了了<br>如果希望函数的执行，有结果，需要通过<code>return</code>返回内容</p>\n<blockquote>\n<p>函数的三要素---决定了一个函数怎么去使用</p>\n<ol>\n<li><code>函数名</code>：一个函数一次声明，可以多次调用（规范：动词+名词）</li>\n<li><code>函数参数</code>：可有可无，但是如果有需要变化的值，一般需要提取成形参</li>\n<li><code>返回值</code>：可有可无，但是如果需要拿到函数的执行结果，就必须要return</li>\n</ol>\n</blockquote>\n<h4 id=\"15-1-5-函数参数与返回值的说明\"><a href=\"#15-1-5-函数参数与返回值的说明\" class=\"headerlink\" title=\"15.1.5 函数参数与返回值的说明\"></a>15.1.5 函数参数与返回值的说明</h4><ul>\n<li><p>开发的时候，函数的参数要一一对应</p>\n<ol>\n<li>传递的参数，如果少了，没接收到值的形参，值就是undefined（数字和undefined加起来就是NaN）</li>\n<li>传递的参数，如果多了，多传的参数，会被忽略</li>\n</ol>\n</li>\n<li><p>返回值的问题<br>  1.return的值，就是函数的执行结果<br>  2.return后面的代码，不执行了！return表示函数的结束！！</p>\n</li>\n</ul>\n<h4 id=\"15-1-6-函数调试说明\"><a href=\"#15-1-6-函数调试说明\" class=\"headerlink\" title=\"15.1.6 函数调试说明\"></a>15.1.6 函数调试说明</h4><ul>\n<li>函数可以在内部调用函数</li>\n<li>F10 让代码往下一步执行，如果遇到了函数调用，会跳过函数的执行过程，直接看结果</li>\n<li>F11让代码往下一步执行，如果遇到了函数调用，会进入函数一步步执行</li>\n<li>shift + F11 跳出函数的执行（将当前函数的调用的剩余代码全部执行完，直接看结果）</li>\n</ul>\n<h4 id=\"15-1-7-声明函数的两种方式\"><a href=\"#15-1-7-声明函数的两种方式\" class=\"headerlink\" title=\"15.1.7 声明函数的两种方式\"></a>15.1.7 声明函数的两种方式</h4><ol>\n<li><p><code>函数声明式</code>（可以先调用，后声明---预解析，会提升函数的声明）</p>\n<pre><code class=\"javascript\">function fn( ) {\nconsole.log(&#39;嘿嘿&#39;);\n}\n</code></pre>\n</li>\n<li><p><code>函数表达式</code>（只可以先声明赋值，后调用）---写法相对严格</p>\n<pre><code>var fn = function( ){\nconsole.log(&#39;哈哈&#39;);\n};\n</code></pre></li>\n</ol>\n<h3 id=\"15-2-匿名函数（没有名字的函数，不能直接使用）\"><a href=\"#15-2-匿名函数（没有名字的函数，不能直接使用）\" class=\"headerlink\" title=\"15.2 匿名函数（没有名字的函数，不能直接使用）\"></a>15.2 匿名函数（没有名字的函数，不能直接使用）</h3><p>使用场景：</p>\n<ol>\n<li>函数表达式 var fn = function(){...}</li>\n<li>匿名函数自调用（自执行)<blockquote>\n<p>直接自调用会报错，可以给整个函数包一个( ),包成了一个整体，就可以调用了</p>\n<pre><code class=\"javascript\">(function ( ) {\n console.log(123);\n})( );\n</code></pre>\n</blockquote>\n</li>\n</ol>\n<p><strong>沙箱模式--匿名函数自调用的应用=&gt;可以用于解决全局变量污染问题</strong><br>由于全局变量，可以在任何地方都可以访问，所以不能乱用<br>一般都会用函数自调用包裹起来</p>\n<pre><code>（function() {...}）\n</code></pre><h2 id=\"16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）\"><a href=\"#16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）\" class=\"headerlink\" title=\"16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）\"></a>16、对象（如果需要描述现实生活对象的特征和行为，就需要js中的对象）</h2><h3 id=\"16-1-概念：无序的键值对的集合\"><a href=\"#16-1-概念：无序的键值对的集合\" class=\"headerlink\" title=\"16.1 概念：无序的键值对的集合\"></a>16.1 概念：无序的键值对的集合</h3><h3 id=\"16-2-创建对象的方式\"><a href=\"#16-2-创建对象的方式\" class=\"headerlink\" title=\"16.2 创建对象的方式\"></a>16.2 创建对象的方式</h3><ol>\n<li>字面量<br>1 ‘abc’ true undefined null [ ] { }<br><code>var obj = { }</code>创建空对象</li>\n</ol>\n<p>键值对的集合，多个键值对通过&quot;，&quot;隔开<br>特征：对象的属性<br>行为：对象的方法---对象的函数</p>\n<ol start=\"2\">\n<li>构造函数的方式（了解）<br>var obj = new Object({...});</li>\n</ol>\n<h3 id=\"16-3-取值和赋值（点语法）\"><a href=\"#16-3-取值和赋值（点语法）\" class=\"headerlink\" title=\"16.3 取值和赋值（点语法）\"></a>16.3 取值和赋值（点语法）</h3><ul>\n<li><p>取值：<br>语法：对象名.属性名  对象名.方法名( );---方法的调用，得到整个函数</p>\n<ul>\n<li>有这个属性名，返回对应值</li>\n<li>如果没有这个属性名，返回undefined</li>\n</ul>\n</li>\n<li><p>赋值：<br>语法：对象名.属性名 = &#39;新的值&#39;</p>\n<ul>\n<li>如果有这个属性名，覆盖</li>\n<li>如果没有这个属性名，新建一个属性并赋值</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"16-3-1-点语法（简洁方便，不支持变量）\"><a href=\"#16-3-1-点语法（简洁方便，不支持变量）\" class=\"headerlink\" title=\"16.3.1 点语法（简洁方便，不支持变量）\"></a>16.3.1 点语法（简洁方便，不支持变量）</h4><p>对象名.属性名</p>\n<h4 id=\"16-3-2-中括号语法（支持字符串或变量，更加的灵活）\"><a href=\"#16-3-2-中括号语法（支持字符串或变量，更加的灵活）\" class=\"headerlink\" title=\"16.3.2 中括号语法（支持字符串或变量，更加的灵活）\"></a>16.3.2 中括号语法（支持字符串或变量，更加的灵活）</h4><p>对象的取值：对象名[&#39;属性名&#39;]<br>对象的赋值：对象名[&#39;属性名&#39;] = &quot;新的值&quot;<br><strong>只要访问对象属性时，需要用到变量，只能用中括号语法</strong></p>\n<h3 id=\"16-4-对象的遍历（访问对象的所有属性）\"><a href=\"#16-4-对象的遍历（访问对象的所有属性）\" class=\"headerlink\" title=\"16.4 对象的遍历（访问对象的所有属性）\"></a>16.4 对象的遍历（访问对象的所有属性）</h3><p>固定语法 （key就是键，属性名）</p>\n<pre><code class=\"javascript\">for （var key in obj）{\n  console.log(key);\n  console.log(obj[key]);---打印属性值\n}\n</code></pre>\n<h3 id=\"16-5-批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）\"><a href=\"#16-5-批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）\" class=\"headerlink\" title=\"16.5 批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）\"></a>16.5 批量创建对象（将来网站用户，不可能只有一个，就需要批量创建对象）</h3><p>设计模式（工厂模式、单例模式、观察者模式）<br>在对象的方法中，this指代当前对象（对象名）</p>\n<h4 id=\"16-5-1-工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）\"><a href=\"#16-5-1-工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）\" class=\"headerlink\" title=\"16.5.1 工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）\"></a>16.5.1 工厂函数（可以将创建对象的代码封装在一个函数中，这个函数就叫工厂函数）</h4><p>通过工厂函数创建的对象，没有具体的类型，都是Object</p>\n<pre><code class=\"javascript\">function Student(sno,name,gender,major){\n    obj=new Object();\n    obj.sno=sno;\n    obj.name=name;\n    obj.gender=gender;\n    obj.major=major;\n    obj.say=function(){\n      console.log(&quot;hello!&quot;);\n    }\n    return obj;\n}\nvar s=new Student(&quot;123&quot;,&quot;张三&quot;,&quot;男&quot;,&quot;数学&quot;);\nfor(var i in s){\n    document.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);\n}\n</code></pre>\n<p>这里Student()函数相当于一个工厂，在其内部生产对象。这种方式简化了代码，但是无法细分对象，也会造成共有方法和属性的内存浪费。无法细分对象就是生产出的对象的constructor是Object，而不是自定义的</p>\n<pre><code>console.log(s.constructor);\n</code></pre><p><img src=\"https://img-blog.csdnimg.cn/20200831171959364.png#\" alt><br>内存浪费就是因为方法声明在了对象的内部，每一个对象都有同一个方法，造成了浪费。</p>\n<h4 id=\"16-5-2-构造函数（给新建的对象，添加属性和方法-实例化对象）\"><a href=\"#16-5-2-构造函数（给新建的对象，添加属性和方法-实例化对象）\" class=\"headerlink\" title=\"16.5.2 构造函数（给新建的对象，添加属性和方法----实例化对象）\"></a>16.5.2 构造函数（给新建的对象，添加属性和方法----实例化对象）</h4><ol>\n<li>就是一个函数</li>\n<li>首字母大写</li>\n<li>js中，内置了一些构造函数，比如：<code>Object</code>，<code>Array</code></li>\n<li>构造函数可以自定义</li>\n</ol>\n<ul>\n<li>构造函数的使用步骤<ul>\n<li>自己声明一个构造函数</li>\n<li>结合new一起使用，创建一个有类型的对象<pre><code class=\"javascript\">function Student(sno,name,gender,major){\nthis.sno=sno;\nthis.name=name;\nthis.gender=gender;\nthis.major=major;\nthis.say=function(){\n    console.log(&quot;hello!&quot;);\n}\n}\nvar s=new Student(&quot;1234&quot;,&quot;李四&quot;,&quot;男&quot;,&quot;物理&quot;);\nfor(var i in s){\ndocument.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);\n}\n</code></pre>\n这种模式解决了对象不能细分问题，此时s的constructor就是Student()构造函数了。<pre><code>console.log(s.constructor);\n</code></pre><img src=\"https://img-blog.csdnimg.cn/20200831184528158.png#\" alt><br>但是还是没有解决公有方法造成的内存浪费问题。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"16-5-3-构造函数-原型对象模式\"><a href=\"#16-5-3-构造函数-原型对象模式\" class=\"headerlink\" title=\"16.5.3 构造函数+原型对象模式\"></a>16.5.3 构造函数+原型对象模式</h4><pre><code class=\"javascript\">function Student(sno,name,gender,major){\n    this.sno=sno;\n    this.name=name;\n    this.gender=gender;\n    this.major=major;\n}\nStudent.prototype.say=function(){\n    console.log(&quot;hello!&quot;);\n}\nvar s=new Student(&quot;12345&quot;,&quot;王五&quot;,&quot;男&quot;,&quot;化学&quot;);\nfor(var i in s){\n    document.write(i+&quot; : &quot;+s[i]+&quot;&lt;br&gt;&quot;);\n}\n</code></pre>\n<p>这种模式和构造函模式类似，不同点是该模式把公有的属性和方法声明到构造函数的原型对象中，解决了内存浪费。</p>\n<h4 id=\"16-5-4-new的作用（创建对象）\"><a href=\"#16-5-4-new的作用（创建对象）\" class=\"headerlink\" title=\"16.5.4 new的作用（创建对象）\"></a>16.5.4 new的作用（创建对象）</h4><ul>\n<li>会新建一个对象，指定对象的类型</li>\n<li>让构造函数的this，指向新创建的对象----this.name = &#39;张三&#39;;</li>\n<li>执行构造函数（给新建的对象，添加属性和方法）</li>\n<li>将新创建的对象返回</li>\n</ul>\n<h3 id=\"16-6-内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）\"><a href=\"#16-6-内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）\" class=\"headerlink\" title=\"16.6 内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）\"></a>16.6 内置对象（js语法中，内置的一些对象，提供了很多的属性和方法，可以直接用）</h3><h4 id=\"16-6-1-Math对象（提供了一系列和数学相关的属性和方法）\"><a href=\"#16-6-1-Math对象（提供了一系列和数学相关的属性和方法）\" class=\"headerlink\" title=\"16.6.1 Math对象（提供了一系列和数学相关的属性和方法）\"></a>16.6.1 Math对象（提供了一系列和数学相关的属性和方法）</h4><ol>\n<li>PI Math.PI</li>\n<li>求最大最小值 max min<br>var max = Math.max(3,5,6,110);<br>console.log(max);</li>\n<li>取整 ceil floor round<br>（1）ceil向上取整，取大的那个数---天花板函数<br>（2）floor向下取整，取小的那个数---地板函数<br>（3）round四舍五入，离哪个近取哪个</li>\n<li>随机数random <code>[0,1)</code>可以取到0，取不到1<br>公式：求一个整数范围0~N，parseInt(Math.random()*(N+1))</li>\n<li>绝对值abs</li>\n<li>求次方pow</li>\n<li>求开方sqrt</li>\n</ol>\n<h4 id=\"16-6-2-Date日期对象\"><a href=\"#16-6-2-Date日期对象\" class=\"headerlink\" title=\"16.6.2 Date日期对象\"></a>16.6.2 Date日期对象</h4><p>js中提供的Date构造函数，可以创建日期对象</p>\n<ol>\n<li><p>如何创建日期对象</p>\n<pre><code class=\"javascript\">var now = new Date(); // 构造函数不传参，创建的是当前时间\nvar date = new Date(&#39;2019-4-22 16:00:00&#39;); // 构造函数传日期字符串，指定具体的日期\n</code></pre>\n</li>\n<li><p>日期格式化 （不用）---一般日期格式都是自定义的</p>\n<pre><code class=\"javascript\">var now = new Date();---当前时间\nconsole.log(now.toString()); // 让日期以标准化的日期字符串格式化输出,&#39;Thu Apr 08 2021 11:13:41 GMT+0800 (GMT+08:00)&#39;\nconsole.log(now.toLocaleString()); // 本地化日期字符串格式输出,&#39;2021-4-8 11:13:41&#39;\nconsole.log(now.toLocaleDateString()); //只显示日期,&#39;2021-4-8&#39;\nconsole.log(now.toLocaleTimeString()); //只显示时间,&#39;11:13:41&#39;\n</code></pre>\n</li>\n<li><p>日期格式的自定义，xx年xx月xx日--获取日期里面的各个组成部分<br>可以封装一个函数，专门给小于10的数，前面加上0</p>\n<pre><code class=\"javascript\">function addZero（n）{\nif(n&lt;10) {\n return &#39;0&#39; + n;\n}\nelse {\n return n;\n}\n}\nvar now = new Date(); // 当前时间\nvar year = now.getFullYear(); // 年\nvar month = now.getMonth()+1; // 获取月，getMonth从0开始，范围0-11\nmonth = addZero(month);\n// 获取日getDate\n// 获取一周中的第几天，getDay,范围0-6，周日0，周一1\nvar hours = now.getHours(); // 时，getHours\nvar minutes = now.getMinutes(); // 分，getMinutes\nvar seconds = now.getSeconds(); // 秒，getSeconds\n// now.getMilliseconds毫秒\n</code></pre>\n</li>\n<li><p>时间戳（就是数字格式的日期，便于运算，一般用于求时间差）---距离1970年1月1日 0时0分0秒，所过去的毫秒数</p>\n<pre><code class=\"javascript\">var now = new Date();\nconsole.log(+now);\n</code></pre>\n</li>\n</ol>\n<p><strong>应用</strong></p>\n<ul>\n<li>统计一段代码的执行时间---性能优化<pre><code class=\"javascript\">var begin = new Date();\nvar end = new Date();\nconsole.log(end - begin);\n</code></pre>\n</li>\n<li>用于秒杀倒计时</li>\n</ul>\n<h2 id=\"17、数组对象Array\"><a href=\"#17、数组对象Array\" class=\"headerlink\" title=\"17、数组对象Array\"></a>17、数组对象Array</h2><ol>\n<li><p><code>.join(分隔符)</code>：将数组中的值拼接成一个字符串，返回这个字符串<br>默认分隔符&quot; , &quot;</p>\n</li>\n<li><p>数组的增删操作<code>push</code> <code>pop</code> <code>unshift</code>  <code>shift</code> <strong><em>会更改原数组</em></strong><br>.push在数组的最后面，添加一个或多个项，返回数组的长度<br>.pop在数组的最后面，删除一个项，返回删除的项<br>.unshift在数组的最前面，添加一个或多个项，返回数组的长度<br>.shift在数组的最前面，删除一项，返回删除的项</p>\n</li>\n<li><p>翻转<code>reverse</code> <strong><em>会更改原数组</em></strong></p>\n</li>\n<li><p>排序<code>sort</code>（默认按照字符串的方式进行排序，先比较第一个字符）<strong><em>会更改原数组</em></strong><br> <strong>如果要制定排序规则，是需要传参的（参数：一个函数）</strong> </p>\n<pre><code class=\"javascript\">arr.sort(function(a,b) {\n return a-b;---从小往大\n return b-a;---从大往小\n})\n</code></pre>\n<blockquote>\n<p>a表示前一项，b表示后一项<br>函数的返回值&gt;0,a和b交换位置<br>函数的返回值=0，不换位置<br>函数的返回值&lt;0,不换位置</p>\n</blockquote>\n</li>\n<li><p>合并 <code>arr.concat(arr2,arr3....)</code>，返回合并后的新数组</p>\n</li>\n<li><p>截取<code>arr.slice</code>（从数组中，截取一部分出来，返回一个新数组）</p>\n<ul>\n<li>arr.slice();从开始一直截取到最后（将整个数组截取，复制一份）</li>\n<li>arr.slice(begin)从begin（下标）开始一直截取到最后    </li>\n<li>arr.slice(begin,end)从begin（下标）开始一直截取到end结束（<strong>包括begin,不包括end</strong>）</li>\n</ul>\n</li>\n<li><p><code>splice</code>方法，可以在数组的任意位置添加、删除、替换任意项---会更改原数组</p>\n<pre><code> splice（从哪开始删，删几个，添加的项1，添加的项2...）\n splice(begin,deleteCounts,item1,item2...)\n</code></pre></li>\n<li><p><code>indexOf</code>查找值在数组中第一次出现的下标（可以用来查重）<br> <code>lastIndexOf</code>查找值在数组中最后一次出现的下标<br>如果值在数组中不存在，返回 <code>-1</code></p>\n</li>\n<li><p>清空一个数组</p>\n<pre><code class=\"javascript\">arr = [ ];\narr.length = 0;\narr.splice(0,arr.length)\n</code></pre>\n</li>\n</ol>\n<h2 id=\"18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）\"><a href=\"#18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）\" class=\"headerlink\" title=\"18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）\"></a>18、基本包装类型（解释了简单数据类型，为什么可以直接使用属性和方法）</h2><p><strong>js内部，对于除了undefined和null的简单数据类型，都提供了一个对应的复杂数据类型</strong></p>\n<p>简答数据类型：没有属性和方法，只有值<br>复杂数据类型：可以有多个属性和方法</p>\n<ul>\n<li>在js中，如果简单数据类型，在访问复杂数据类型的属性或方法时</li>\n<li>为了方便，自动将简单数据类型，包装成复杂数据类型，然后获取对应的值</li>\n<li>会将值变回简单数据类型    </li>\n</ul>\n<h3 id=\"18-1-Number\"><a href=\"#18-1-Number\" class=\"headerlink\" title=\"18.1 Number\"></a>18.1 Number</h3><pre><code>通过new Number()创建的对象，``toString``   ``toFixed``两个方法\nnum.toFixed(3) 保留3位小数\n</code></pre><h3 id=\"18-2-Boolean\"><a href=\"#18-2-Boolean\" class=\"headerlink\" title=\"18.2 Boolean\"></a>18.2 Boolean</h3><pre><code>    通过new Boolean()创建的对象，toString\n</code></pre><h3 id=\"18-3-String\"><a href=\"#18-3-String\" class=\"headerlink\" title=\"18.3 String\"></a>18.3 String</h3><ol>\n<li>字符串可以和数组一样，进行遍历，字符串不是数组，不能混用方法</li>\n<li><code>indexOf</code>和<code>lastIndexOf</code> 查找值在字符串中第一次/最后一次出现的下标</li>\n<li><code>trim</code>去除字符串<code>首尾</code>的空格</li>\n<li>转大小写<br><code>toUpperCase</code>转大写<br><code>toLowerCase</code>转小写</li>\n<li>拼接<code>.concat</code>将字符串进行拼接，返回新的字符串）<br>一般用<code>+</code></li>\n<li><p>截取</p>\n<ul>\n<li>slice(begin,end) <blockquote>\n<p>从begin开始截取，截取到end结束，包括begin，不包括end<br>begin（必需）：规定从何处开始选取。如果是负数，那么它规定从字符串尾部开始算起的位置。也就是说，-1 指最后一个字符，-2 指倒数第二个字符，以此类推。<br>end（可选）：规定从何处结束选取，即结束处的字符下标。如果没有指定该参数，那么截取的字符串包含从 start 到结束的所有字符。如果这个参数是负数，那么它规定的是从数组尾部开始算起的字符。</p>\n<pre><code class=\"javascript\"> var str = &quot;0123456789&quot;;\n console.log(&quot;原始字符串：&quot;, str);\n console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.slice(3));  //3456789\n console.log(&quot;从倒数第3个字符起一直到结束：&quot;, str.slice(-3));  //789\n console.log(&quot;从开始一直到索引为5的前一个字符：&quot;, str.slice(0,5));  //01234\n console.log(&quot;从开始一直到倒数第3个字符的前一个字符：&quot;, str.slice(0,-3));  //0123456\n console.log(&quot;从索引为3的字符起到索引为5的前一个字符：&quot;, str.slice(3,5));  //34\n console.log(&quot;从索引为3的字符起到倒数第3个字符的前一个字符：&quot;, str.slice(3,-3));  //3456\n</code></pre>\n</blockquote>\n</li>\n<li>substring(begin,end) 从begin开始截取，截取到end结束，包括begin，不包括end<pre><code class=\"javascript\"> var str = &quot;0123456789&quot;;\n console.log(&quot;原始字符串：&quot;, str);\n console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.substring(3));  //3456789\n console.log(&quot;从索引为20的字符起一直到结束：&quot;, str.substring(20));  //\n console.log(&quot;从索引为3的字符起到索引为5的前一个字符结束：&quot;, str.substring(3,5));  //34\n console.log(&quot;start比end大会自动交换，结果同上：&quot;, str.substring(5,3));  //34\n console.log(&quot;从索引为3的字符起到索引为20的前一个字符结束：&quot;, str.substring(3,20));  //3456789\n console.log(&quot;substring将负数转化为0:&quot;, str.substring(-3)); //\n</code></pre>\n</li>\n<li>substr(begin,length) 从begin开始截取，截取length个<pre><code class=\"javascript\"> var str = &quot;0123456789&quot;;\n console.log(&quot;原始字符串：&quot;, str);\n console.log(&quot;从索引为3的字符起一直到结束：&quot;, str.substr(3));  //3456789\n console.log(&quot;从索引为20的字符起一直到结束：&quot;, str.substr(20));  //\n console.log(&quot;从索引为3的字符起截取长度为5的字符串：&quot;, str.substr(3,5));  //34567\n console.log(&quot;从索引为3的字符起截取长度为20的字符串：&quot;, str.substr(3,20));  //3456789\n</code></pre>\n</li>\n<li><p>三者比较<br><code>`</code>javascript<br>var str = &#39;中华人民共和国万岁&#39;<br>// 一，start为负数，end不传<br>str.slice(-3) // &#39;国万岁&#39;<br>str.substring(-3) // &#39;中华人民共和国万岁&#39;<br>str.substr(-3) // &#39;国万岁&#39;<br>// 说明： 1，slice与substr第一个参数为负数时，将从字符串反方向开始计数，末位记为-1,等同于str.slice(6)，str.substr(6)<br>//       2，substring将负数转化为0，既str.substring(0)</p>\n<p>// 二，start为负数，end为负数时<br>str.slice(-3,-1) // &#39;国万&#39;<br>str.substring(-3,-1) // &#39;&#39;<br>str.substr(-3,-1) // &#39;&#39;<br>// 说明：<br>//    1，slice正常截取字符串，相比substring灵活很多<br>//    2，substring将所有参数转化为0，既str.substring(0,0)<br>//    3，substr end参数不能为负数</p>\n<p>// 三，start与end均大于零，且start &gt; end<br>str.slice(5,3) // &#39;&#39;<br>str.substring(5,3) // &#39;民共&#39;<br>str.substr(5,3) // &#39;和国万&#39;<br>// 说明：<br>//   1，substr正常截取字符串，代表从第五位开始，截取字符串长度为3<br>//   2，当start&gt;end时，substring在提取子串之前会先交换这两个参数，既转换为substring(3,5)；而slice不能进行此转换，所以截取的为空字符串</p>\n<p>// 四，start与end均大于零，且start &lt; end<br>str.slice(3,5) //&#39;民共&#39;<br>str.substring(3,5) // &#39;民共&#39;<br>str.substr(3,5) // &#39;民共和国万&#39;<br>// 说明：三种方法均正常截取字符串，只是substr第二个参数含义不同，代表截取的字符串长度而不是终止位置。</p>\n</li>\n</ul>\n<p><code>`</code></p>\n</li>\n<li><p>通过.split(分隔符):可以将字符串拆分成数组，会返回一个拆分得到的数组<br> 通过join:可以将数组的值，拼成字符串，会返回一个拼接成的字符串</p>\n</li>\n<li><p>replace替换，会返回替换的结果</p>\n<pre><code class=\"javascript\">str.replace(&#39;aa&#39;,&#39;bb&#39;); // 将字符串中的第一个aa替换成bb\n</code></pre>\n</li>\n</ol>\n<p>想要全部替换，需要用到正则<code>str.replace(/aa/g,&#39;bb&#39;)</code>;</p>\n<h2 id=\"19、值类型和引用类型\"><a href=\"#19、值类型和引用类型\" class=\"headerlink\" title=\"19、值类型和引用类型\"></a>19、值类型和引用类型</h2><p>从内存的存储角度，分成了<code>值类型</code>和<code>引用类型</code>（内存是可以释放，可以重复利用的）</p>\n<p><strong>值类型（简单数据类型）</strong>：存储在变量中，存的是值本身<br><strong>引用类型（复杂数据类型）</strong>：存储在变量中，存的是<code>内存地址</code>----会单独在内存中开辟一块空间存储</p>\n<h3 id=\"19-1-值类型和引用类型的赋值类型\"><a href=\"#19-1-值类型和引用类型的赋值类型\" class=\"headerlink\" title=\"19.1 值类型和引用类型的赋值类型\"></a>19.1 值类型和引用类型的赋值类型</h3><ul>\n<li>值类型：存储在变量中 ，存的是<code>值本身</code>，所以在赋值给其他变量时，赋值的是<code>值本身</code></li>\n<li>引用类型：存储在变量中，存的是<code>内存地址</code>，所以在赋值给其他变量时，赋值的是<code>内存地址</code></li>\n</ul>\n<h3 id=\"19-2-值类型和引用类型的值传递（让值作为函数的参数进行传递）\"><a href=\"#19-2-值类型和引用类型的值传递（让值作为函数的参数进行传递）\" class=\"headerlink\" title=\"19.2 值类型和引用类型的值传递（让值作为函数的参数进行传递）\"></a>19.2 值类型和引用类型的值传递（让值作为函数的参数进行传递）</h3><ul>\n<li>值类型：存储在变量中，存的是值本身，所以在值传递时，传的也是值本身</li>\n<li>引用类型：存储在变量中，存的是内存地址，所以在值传递时，传的也是内存地址</li>\n</ul>\n<h2 id=\"20、typeof-关键字\"><a href=\"#20、typeof-关键字\" class=\"headerlink\" title=\"20、typeof 关键字\"></a>20、typeof 关键字</h2><ol>\n<li>typeof获取简单数据类型，可以直接返回对应的类型<br><strong><em>特例</em></strong>：typeof null  返回object</li>\n<li>typeof获取复杂数据类型，一般返回object<br><strong><em>特例</em></strong>：typeof 函数  返回function    函数是js的一等公民</li>\n</ol>\n<h2 id=\"21、逻辑中断（短路运算）-amp-amp\"><a href=\"#21、逻辑中断（短路运算）-amp-amp\" class=\"headerlink\" title=\"21、逻辑中断（短路运算）&amp;&amp; ||\"></a>21、逻辑中断（短路运算）&amp;&amp; ||</h2><p>&amp;&amp;找假值，只要遇到了假值，就中断短路（后面的不看了）<br>||找真值，只要看到了真值，就中断短路（后面的不看了）</p>\n<pre><code class=\"javascript\">function demo(fn){\n  fn&amp;&amp;fn(); //fn存在，才去调用\n}    \ndemo(function(){\n  console.log(111);\n});\ndemo();\n</code></pre>\n<p><strong>逻辑<code>或</code>，一般可以用于设置默认值,也可以解决兼容性</strong></p>\n<pre><code class=\"javascript\">function getSum(a,b){\n  a=a || 0;\n  b=b || 0;\n  var sum = a+b;\n  return sum;\n}\n</code></pre>\n<h2 id=\"22、如何拷贝一个对象\"><a href=\"#22、如何拷贝一个对象\" class=\"headerlink\" title=\"22、如何拷贝一个对象\"></a>22、如何拷贝一个对象</h2><p>封装一个方法，可以拷贝一个对象，返回（浅拷贝，只拷贝了 一层）</p>\n<pre><code class=\"javascript\">function copy(obj){\n  var newObj = {};\n  for (var k in obj){\n    newObj[k] = obj[k];\n  }\n}\n</code></pre>\n<ul>\n<li>浅拷贝，只拷贝了一层，如果全是简单类型的属性，没有问题<br>  但是如果有复杂类型的属性（对象），此时拷贝的只是地址，需要处理的</li>\n<li>深拷贝<pre><code>  newObj[k] = typeof obj[k] === &#39;object&#39; ? copy(obj[k]) : obj[k];\n</code></pre></li>\n</ul>\n<pre><code class=\"javascript\">// 1.遍历+递归\nfunction deepClone(obj){\n  let newObj =  {}\n  for(let key in obj){\n      if(obj.hasOwnProperty(key)){\n          if(typeof(obj[key]) === &#39;object&#39; &amp;&amp; obj[key] !== null){\n            newObj[key] = (Array.isArray(obj[key])  ? [] : {})\n            newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : deepClone(obj[key]));  \n          }else{\n              newObj[key] = obj[key];\n          }\n      }\n  }\n  return newObj;\n}\n\n// 2.Object.assign + 递归\nfunction deepClone(obj){\n  let newObj = {}\n  for(let key in obj){\n    if(obj.hasOwnProperty(key)){\n      newObj[key] = (typeof obj[key] === &#39;object&#39; ? Object.assign(obj[key]) : obj[key])\n    }\n  }\n  return newObj\n}\n\n// 3.对象扩展+递归\nfunction deepClone(obj){\n  var newObj ={}\n  for(let key in obj){\n    if(obj.hasOwnProperty(key)){\n      if(typeof obj[key] === &#39;object&#39;){\n        newObj[key] = (Array.isArray(obj[key]) ? [] : {})\n        newObj[key] = (Array.isArray(newObj[key]) ? [...obj[key]] : {...obj[key]}) \n      } \n      else{\n        newObj[key] = obj[key]\n      }\n    }\n  }\n  return newObj\n}\n\n// 4.JSON复制（对NaN和undefined无法正确复制，会丢失）\nfunction deepClone(obj) {\n  var newObj = JSON.parse(JSON.stringify(obj))\n  return newObj\n}\n</code></pre>\n<h2 id=\"23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！\"><a href=\"#23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！\" class=\"headerlink\" title=\"23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！\"></a>23、面向过程：注重点是过程和步骤，亲力亲为，事无巨细的！！</h2><h2 id=\"24、面向对象：关注的是找一个对象，去做某件事\"><a href=\"#24、面向对象：关注的是找一个对象，去做某件事\" class=\"headerlink\" title=\"24、面向对象：关注的是找一个对象，去做某件事\"></a>24、面向对象：关注的是找一个对象，去做某件事</h2><p><strong><em>面向对象不是面向过程的替代，是面向过程的封装</em></strong></p>\n<h3 id=\"24-1-特性：\"><a href=\"#24-1-特性：\" class=\"headerlink\" title=\"24.1 特性：\"></a>24.1 特性：</h3><ol>\n<li>封装性</li>\n<li>继承性</li>\n<li>多态性（js中没有）</li>\n</ol>\n<h2 id=\"25、原型\"><a href=\"#25、原型\" class=\"headerlink\" title=\"25、原型\"></a>25、原型</h2><p>JavaScript是一门基于原型的语言，在软件设计模式中，有一种模式叫做原型模式，JavaScript正是利用这种模式而被创建出来</p>\n<h3 id=\"25-1-原型模式\"><a href=\"#25-1-原型模式\" class=\"headerlink\" title=\"25.1 原型模式\"></a>25.1 原型模式</h3><p>原型模式是用于创建重复的对象，同时又能保证性能，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。<br>原型模式的<code>目的</code>是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，也就是说利用已有的一个原型对象，可以快速地生成和原型对象一样的新对象实例</p>\n<h3 id=\"25-2-原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板\"><a href=\"#25-2-原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板\" class=\"headerlink\" title=\"25.2 原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板\"></a>25.2 原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板</h3><ol>\n<li>原型是定义了一些公用的属性和方法，利用原型创建出来的新对象实例会共享原型的所有属性和方法<br>实例代码：<br><code>`</code>javascript<br>// 创建原型<br>var Person = function(name){<br> this.name = name;<br>};</li>\n</ol>\n<p>// 原型的方法<br>Person.prototype.sayHello = function(){<br>    console.log(this.name+&quot;,hello&quot;);<br>};</p>\n<p>// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法<br>var person1 = new Person(&quot;zhangsan&quot;);<br>var person2 = new Person(&quot;lisi&quot;);</p>\n<p>// zhangsan,hello<br>person1.sayHello();<br>// lisi,hello<br>person2.sayHello();</p>\n<pre><code>\n2. 严格模式下，原型的属性和方法还是会被原型实例所共享的\n实例代码：\n```javascript\n// 开启严格模式，原型的属性和方法还是会被原型实例所共享的\n&quot;use strict&quot;;\n\n// 创建原型\nvar Person = function(name){\n    this.name = name;\n};\n\n// 原型的方法\nPerson.prototype.sayHello = function(){\n    console.log(this.name+&quot;,hello&quot;);\n};\n\n// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法\nvar person1 = new Person(&quot;zhangsan&quot;);\nvar person2 = new Person(&quot;lisi&quot;);\n\n// zhangsan,hello\nperson1.sayHello();\n// lisi,hello\nperson2.sayHello();\n</code></pre><ol start=\"3\">\n<li>通过原型创建的新对象实例是相互独立的，为新对象实例添加的方法只有该实例拥有这个方法，其它实例是没有这个方法的<br>实例代码：<br><code>`</code>javascript<br>// 创建原型<br>var Person = function(name){<br>this.name = name;<br>};</li>\n</ol>\n<p>// 原型的方法<br>Person.prototype.sayHello = function(){<br>  console.log(this.name+&quot;,hello&quot;);<br>};</p>\n<p>// 实例化创建新的原型对象，新的原型对象会共享原型的属性和方法<br>var person1 = new Person(&quot;zhangsan&quot;);<br>var person2 = new Person(&quot;lisi&quot;);</p>\n<p>// zhangsan,hello<br>person1.sayHello();<br>// lisi,hello<br>person2.sayHello();</p>\n<p>// 为新对象实例添加方法<br>// 通过原型创建的新对象实例是相互独立的<br>person1.getName = function(){<br>    console.log(this.name);<br>}</p>\n<p>// zhangsan<br>person1.getName();<br>// Uncaught TypeError: person2.getName is not a function<br>person2.getName();</p>\n<pre><code>\n4. 原型的总结：\n\n* 所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象\n* 所有函数都有一个prototype(原型)属性，属性值是一个普通的对象\n* 所有引用类型的__proto__属性指向它构造函数的prototype\n\n5. 函数的原型prototype：函数才有prototype，prototype是一个对象，指向了当前构造函数的引用地址\n6. 函数的原型对象__proto__：所有对象都有__proto__属性， 当用构造函数实例化（new）一个对象时，会将新对象的__proto__属性指向 构造函数的prototype\n\n7. 原型对象和函数的原型的关系\n![原型对象和函数的原型的关系](https://img-blog.csdnimg.cn/20190623221321362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)\n\n&gt; 说明：\n&gt; * 所有函数的__proto__都是指向Function的prototype\n&gt; * 构造函数new出来的对象__proto__指向构造函数的prototype\n&gt; * 非构造函数实例化出的对象或者对象的prototype的__proto__指向Object的prototype\n&gt;   Object的prototype指向null\n\n8. 所有的原型对象都会自动获得一个``constructor``（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）\n9. 实例的构造函数属性（constructor）指向构造函数 ：person1.constructor == Person\n10. 原型对象（Person.prototype）是 构造函数（Person）的一个实例\n11. 原型的分类：\n* ``隐式原型（_proto_）``：上面说的这个原型是JavaScript中的内置属性[[prototype]]，此属性继承自object对象，在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_，隐式原型的作用是用来构成原型链，实现基于原型的继承\n* ``显示原型``（prototype）``：每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享\n12. 原型的使用方式：\n通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型\n在赋值原型prototype的时候使用function立即执行的表达式来赋值，可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果\n\n#### 25.2.1 原型链\n原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构\n\n#### 25.2.2 原型设计的问题\n当查找一个对象的属性时，JavaScript 会根据原型链向上遍历对象的原型，直到找到给定名称的属性为止，直到到达原型链的顶部仍然没有找到指定的属性，就会返回 undefined\n也可以理解为原型链继承时查找属性的过程是先查找自身属性，当自身属性不存在时，会在原型链中逐级查找\n\n#### 25.2.3 hasOwnProperty 函数：\n可以用来检查对象自身是否含有某个属性，返回值是布尔值，当属性不存在时不会向上查找对象原型链，*hasOwnProperty是 JavaScript 中``唯一一个``处理属性但是不查找原型链的函数*\n\n#### 25.2.4 getOwnPropertyNames 函数\n可以获取对象所有的自身属性，返回值是由对象自身属性名称组成的数组，同样不会向上查找对象原型链\n\n#### 25.2.5 原型链的小结：\n一直往上层查找，直到到null还没有找到，则返回undefined\nObject.prototype.__proto__ === null\n所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象\n\n6）JavaScript的原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法\n\n#### 25.2.6 常见面试题\n\n* 谈谈你对原型的理解？\n在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法\n\n* 什么是原型链？原型链解决的是什么问题？\n 1. 原型链解决的主要是继承问题\n 2. 每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法\n 3. 构造函数 Parent、Parent.prototype 和 实例 p 的关系如下:(p.__proto__ === Parent.prototype)\n![](https://img-blog.csdnimg.cn/20190623221912165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNDA4MA==,size_16,color_FFFFFF,t_70)\n\n* prototype 和 proto 区别是什么？\n 1. prototype是构造函数的属性\n 2. __proto__是每个实例都有的属性，可以访问 [[prototype]] 属性\n 3. 实例的__proto__与其构造函数的prototype指向的是同一个对象\n\n### 25.3 补充（原先的）\n#### 25.3.1 属性搜索原则：自己有就访问自己的，自己没有，去原型链中就近查找\n1. 如果自己有这个属性，就访问自己的\n2. 如果自己没有这个属性，会到原型中找，如果找到，不找了，直接返回\n3. 如果原型中也没有，会到原型的原型中找...\n4. 一直找到Object.prototype，如果老祖宗也没有，返回undefined\n\n#### 25.3.2 设置属性：\n如果有这个属性，直接修改赋值\n如果自己没有这个属性，给自己添加一个新属性（不会改到原型）\n\n#### 25.3.3 Object.prototype的成员\n1. ``hasOwnProperty``\n    语法：``对象.hasOwnProperty(&#39;属性名&#39;)`` ---判断属性是否是自己的，而不是原型的（不是继承来的）\n    for in 遍历，不仅自己的属性可以遍历，原型上的属性也会遍历到（对于constructor等浏览器内置的属性，被浏览器进行来了处理，不会被for in便利出来）\n    遍历时，只打印自身的（用hasOwnProperty进行判断）\n    in操作符：判断属性是否可以被对象所访问（只要能够访问到这个属性，就返回true）---这个不是成员\n    语法：&#39;属性名&#39; in 对象\n\n2. ``A.isPrototypeOf(B)``:判断A是不是B的原型\n\n3. ``对象.propertyIsEnumerable(&#39;属性名&#39;)`` 判断属性是否可以遍历（可枚举）\n4. toSting()\n5. valueof()\n\n6. instanceof运算符\n    语法：A instanceof B（判断A是否是B的实例，B构造函数）\n    进阶原理：判断B.prototype在不在A的原型链上\n    使用typeof无法区分具体的对象类型！！！\n\n```javascript\nconsole.log(p.constructor.name)---可以用来打印类型\nObject.prototype.toString.call([]) ---可以用来获取复杂数据是什么类型 ---[object Array]\n</code></pre><h2 id=\"26、js数据类型\"><a href=\"#26、js数据类型\" class=\"headerlink\" title=\"26、js数据类型\"></a>26、js数据类型</h2><p>堆和栈（只是将Java中概念，拿过来类比了）<br>js中没有特别明确的堆和栈的概念，而且js的实现，也不需要堆和栈的概念<br>java中堆内存和栈内存<br>1.所有的<code>简单数据</code>类型，存在<code>栈</code>中<br>2.所有的<code>复杂数据</code>类型，存在<code>堆</code>中---真实存在变量中的，也是地址</p>\n<h2 id=\"27、this的规则：\"><a href=\"#27、this的规则：\" class=\"headerlink\" title=\"27、this的规则：\"></a>27、this的规则：</h2><p>xx.fn();---fn函数调用时里面的this，指向调用者（谁调用的，this就指向谁）</p>\n<ol>\n<li>如果是直接调用的方法，this指向window<pre><code> （1）function fn(){console.log(this)}\n          fn();\n （2）setInterval(function(){console.log(this)},2000)---定时器中的this指向window\n</code></pre></li>\n<li>如果对象中的方法，被调用了，this指向调用者，谁调用的，指向谁</li>\n<li>特例，构造函数中执行的this，this指向新创建的对象</li>\n</ol>\n<p>全局的var a = 123;  等价于 window.a = 123;</p>\n<h2 id=\"28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️\"><a href=\"#28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️\" class=\"headerlink\" title=\"28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️\"></a>28、继承（拿来主义，自己没有的属性和方法，别人有，拿过来用，就实现了继承）⭐️⭐️⭐️</h2><h3 id=\"28-1-原型链继承\"><a href=\"#28-1-原型链继承\" class=\"headerlink\" title=\"28.1 原型链继承\"></a>28.1 原型链继承</h3><pre><code class=\"javascript\">function Person() {\n  this.name = &#39;Hello World&#39;;\n}\nPerson.prototype.getName = function() {\n  console.log(this.name)\n}\nfunction Child() {\n\n}\nChild.prototype = new Person()\nvar child1 = new Child()\nchild1.getName() // Hello World\n</code></pre>\n<p><strong><em>重点：</em></strong><br>让新实例的原型等于父类的实例。</p>\n<p><strong><em>优点：</em></strong><br>实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的 属性！）</p>\n<p><strong><em>缺点：</em></strong></p>\n<ol>\n<li>新实例无法向父类构造函数传参。</li>\n<li>继承单一。</li>\n<li>所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性 也会被修改！）</li>\n</ol>\n<h3 id=\"28-2-构造函数继承\"><a href=\"#28-2-构造函数继承\" class=\"headerlink\" title=\"28.2 构造函数继承\"></a>28.2 构造函数继承</h3><pre><code class=\"javascript\">function Person(){\n  this.name = &#39;xiaoming&#39;;\n  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];\n}\n\nPerson.prototype.getName = function(){\n  console.log(this.name);\n}\n\nfunction Child(age){\n  Person.call(this);\n  this.age = age\n}\n\nvar child1 = new Child(23);\nvar child2 = new Child(12);\nchild1.colors.push(&#39;yellow&#39;);\nconsole.log(child1.name); // xiaoming\nconsole.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]\nconsole.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]\n</code></pre>\n<p><strong><em>重点：</em></strong><br>用.call()和.apply()将父类构造函数引入子类函数（在子类 函数中做了父类函数的自执行（复制））</p>\n<p><strong><em>优点：</em></strong></p>\n<ol>\n<li>只继承了父类构造函数的属性，没有继承父类原型的属性。</li>\n<li>解决了原型链继承缺点1、2、3。</li>\n<li>可以继承多个构造函数属性（call多个）。</li>\n<li>在子实例中可向父实例传参。</li>\n</ol>\n<p><strong><em>缺点：</em></strong></p>\n<ol>\n<li>只能继承父类构造函数的属性。</li>\n<li>无法实现构造函数的复用。（每次用每次都要重新调用）</li>\n<li>每个新实例都有父类构造函数的副本，臃肿。</li>\n</ol>\n<h3 id=\"28-3-组合继承（组合原型链继承和借用构造函数继承）（常用）\"><a href=\"#28-3-组合继承（组合原型链继承和借用构造函数继承）（常用）\" class=\"headerlink\" title=\"28.3 组合继承（组合原型链继承和借用构造函数继承）（常用）\"></a>28.3 组合继承（组合原型链继承和借用构造函数继承）（常用）</h3><pre><code class=\"javascript\">function Parent(name){\n    this.name = name;\n    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];\n}\n\nParent.prototype.getName = function(){\n    console.log(this.name);\n}\n\nfunction Child(name,age){\n    Parent.call(this,name);// 第二次调用 Parent()\n    this.age = age;\n}\n\nChild.prototype = new Parent(); // 第一次调用 Parent()\n\nvar child1 = new Child(&#39;xiaopao&#39;,18);\nvar child2 = new Child(&#39;lulu&#39;,19);\n</code></pre>\n<p><strong><em>重点：</em></strong><br>结合了两种模式的优点，传参和复用</p>\n<p><strong><em>优点：</em></strong></p>\n<ol>\n<li>可以继承父类原型上的属性，可以传参，可复用。<br>2、每个新实例引入的构造函数属性是私有的。</li>\n</ol>\n<p><strong><em>缺点：</em></strong><br>调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p>\n<h3 id=\"28-4-原型式继承\"><a href=\"#28-4-原型式继承\" class=\"headerlink\" title=\"28.4 原型式继承\"></a>28.4 原型式继承</h3><pre><code class=\"javascript\">function CreateObj(o){\n    function F(){}\n    F.prototype = o;\n    console.log(o.__proto__ === Object.prototype);\n    console.log(F.prototype.constructor === Object); // true\n    return new F();\n}\n\nvar person = {\n    name: &#39;xiaopao&#39;,\n    friend: [&#39;daisy&#39;,&#39;kelly&#39;]\n}\n\nvar person1 = CreateObj(person);\n\n// var person2 = CreateObj(person);\n\nperson1.name = &#39;person1&#39;;\n// console.log(person2.name); // xiaopao\nperson1.friend.push(&#39;taylor&#39;);\n// console.log(person2.friend); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]\n// console.log(person); // {name: &quot;xiaopao&quot;, friend: Array(3)}\nperson1.friend = [&#39;lulu&#39;];\n// console.log(person1.friend); // [&quot;lulu&quot;]\n// console.log(person.friend); //  [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]\n// 注意： 这里修改了person1.name的值，person2.name的值并未改变，并不是因为person1和person2有独立的name值，而是person1.name=&#39;person1&#39;是给person1添加了name值，并非修改了原型上的name值\n// 因为我们找对象上的属性时，总是先找实例上对象，没有找到的话再去原型对象上的属性。实例对象和原型对象上如果有同名属性，总是先取实例对象上的值\n</code></pre>\n<p><strong><em>重点：</em></strong><br>用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</p>\n<p><strong><em>优点：</em></strong><br>类似于复制一个对象，用函数来包装。</p>\n<p><strong><em>缺点：</em></strong></p>\n<ol>\n<li>所有实例都会继承原型上的属性。</li>\n<li>无法实现复用。（新实例属性都是后面添加的）</li>\n</ol>\n<h3 id=\"28-5-寄生式继承\"><a href=\"#28-5-寄生式继承\" class=\"headerlink\" title=\"28.5 寄生式继承\"></a>28.5 寄生式继承</h3><pre><code class=\"javascript\">var ob = {\n    name: &#39;xiaopao&#39;,\n    friends: [&#39;lulu&#39;,&#39;huahua&#39;]\n}\n\nfunction CreateObj(o){\n    function F(){};  // 创建一个构造函数F\n    F.prototype = o;\n    return new F();\n}\n\n// 上面CreateObj函数 在ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的 , 看下面代码\nvar ob1 = CreateObj(ob);\nvar ob2 = Object.create(ob);\nconsole.log(ob1.name); // xiaopao\nconsole.log(ob2.name); // xiaopao\n\nfunction CreateChild(o){\n    var newob = CreateObj(o); // 创建对象 或者用 var newob = Object.create(ob)\n    newob.sayName = function(){ // 增强对象\n        console.log(this.name);\n    }\n    return newob; // 指定对象\n}\n\nvar p1 = CreateChild(ob);\np1.sayName(); // xiaopao \n</code></pre>\n<p><strong><em>重点：</em></strong><br>就是给原型式继承外面套了个壳子。</p>\n<p><strong><em>优点：</em></strong><br>没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</p>\n<p><strong><em>缺点：</em></strong><br>没用到原型，无法复用。</p>\n<h3 id=\"28-6-寄生组合式继承（常用）\"><a href=\"#28-6-寄生组合式继承（常用）\" class=\"headerlink\" title=\"28.6 寄生组合式继承（常用）\"></a>28.6 寄生组合式继承（常用）</h3><pre><code class=\"javascript\">function Parent(name){\n    this.name = name;\n    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];\n}\n\nParent.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nfunction Child(name,age){\n    Parent.call(this,name); \n    this.age = age;\n}\n\nfunction CreateObj(o){\n    function F(){};\n    F.prototype = o;\n    return new F();\n}\n\n// Child.prototype = new Parent(); // 这里换成下面\nfunction prototype(child,parent){\n    var prototype = CreateObj(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\nprototype(Child,Parent);\n\nvar child1 = new Child(&#39;xiaopao&#39;, 18);\nconsole.log(child1); \n</code></pre>\n<p><strong><em>重点：</em></strong><br>修复了组合继承的问题</p>\n<h3 id=\"28-7-class继承\"><a href=\"#28-7-class继承\" class=\"headerlink\" title=\"28.7 class继承\"></a>28.7 class继承</h3><pre><code class=\"javascript\">class Parent5 {\n  constructor() {\n    this.name = [&#39;super5&#39;]\n  }\n  reName() {\n    this.name.push(&#39;new 5&#39;)\n  }\n}\nclass Child5 extends Parent5 {\n  constructor() {\n    super()\n  }\n}\nvar child51 = new Child5()\nvar child52 = new Child5()\n</code></pre>\n<h2 id=\"29、定义函数的三种方式\"><a href=\"#29、定义函数的三种方式\" class=\"headerlink\" title=\"29、定义函数的三种方式\"></a>29、定义函数的三种方式</h2><h3 id=\"29-1-函数声明式\"><a href=\"#29-1-函数声明式\" class=\"headerlink\" title=\"29.1 函数声明式\"></a>29.1 函数声明式</h3><pre><code>function fn(){}\nfn();\n</code></pre><h3 id=\"29-2-函数表达式\"><a href=\"#29-2-函数表达式\" class=\"headerlink\" title=\"29.2 函数表达式\"></a>29.2 函数表达式</h3><pre><code>var fn = function(){};\nfn();\n</code></pre><h3 id=\"29-3-构造函数的方式\"><a href=\"#29-3-构造函数的方式\" class=\"headerlink\" title=\"29.3 构造函数的方式\"></a>29.3 构造函数的方式</h3><pre><code>new Function(...)\n</code></pre><p>作用：可以直接执行字符串<br>参数：都是字符串类型，最后一个参数是函数体，前面其他所有参数是定义的形参<br>         只有一个参数，就会当成函数体</p>\n<pre><code class=\"javascript\">var fn = new Function(&#39;a&#39; , &#39;b&#39; , &#39;console.log(a+b)&#39;);\nfn(1,2);\n</code></pre>\n<h2 id=\"30、try和catch\"><a href=\"#30、try和catch\" class=\"headerlink\" title=\"30、try和catch\"></a>30、try和catch</h2><ul>\n<li>try和catch必须一起使用</li>\n<li>try表示尝试执行某段代码，就算发生了错误，js也会继续执行</li>\n<li>catch，只要try中代码发生了错误，就会执行catch中的代码</li>\n<li>finally:不管try中的代码执行是否成功，都会执行finally的代码<pre><code class=\"javascript\">try {  ----尝试执行某段代码\n   var fn = new Function(value);\n   fn();\n}\ncatch（e）{ ---- 抓取，可以抓取到try执行中的错误，可以进行处理，可以不处理\n   console.log(e)\n}\nfinally{\n}    \n</code></pre>\n</li>\n</ul>\n<h2 id=\"31、eval-str-可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）\"><a href=\"#31、eval-str-可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）\" class=\"headerlink\" title=\"31、eval(str)可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）\"></a>31、eval(str)可以执行字符串，非常强大，但是不用（风险性太大，会造成全局变量的污染）</h2><pre><code class=\"javascript\">var a = 100;\nvar str = &#39;var a = 1; var b = 2; console.log(a + b)&#39;;\neval(str); \n</code></pre>\n<h2 id=\"32、四种调用模式\"><a href=\"#32、四种调用模式\" class=\"headerlink\" title=\"32、四种调用模式\"></a>32、四种调用模式</h2><ul>\n<li>函数：指的是普通的，不属于任何对象的函数</li>\n<li>方法：作为对象的属性存在的函数（对象中的函数）</li>\n<li>函数内的this指向谁，只跟怎么调用有关系，跟函数定义在什么地方，没有任何关系</li>\n</ul>\n<h3 id=\"32-1-函数调用模式\"><a href=\"#32-1-函数调用模式\" class=\"headerlink\" title=\"32.1 函数调用模式\"></a>32.1 函数调用模式</h3><pre><code class=\"javascript\">fn( );   // this指向window\n</code></pre>\n<h3 id=\"32-2-方法调用模式\"><a href=\"#32-2-方法调用模式\" class=\"headerlink\" title=\"32.2 方法调用模式\"></a>32.2 方法调用模式</h3><pre><code class=\"javascript\">obj.fn();  // this指向obj，谁调用指向谁\n</code></pre>\n<blockquote>\n<p>可以把数组当成一个对象，访问0属性，就是方法，方法调用模式，指向arr</p>\n</blockquote>\n<h3 id=\"32-3-构造函数调用模式\"><a href=\"#32-3-构造函数调用模式\" class=\"headerlink\" title=\"32.3 构造函数调用模式\"></a>32.3 构造函数调用模式</h3><pre><code class=\"javascript\">var p = new Person();  // this指向实例p---new改变了this的指向，让this指向了新的实例\n</code></pre>\n<h3 id=\"32-4-上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）\"><a href=\"#32-4-上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）\" class=\"headerlink\" title=\"32.4 上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）\"></a>32.4 上下文调用模式：（this在这边是可以自定义的，想要this指向谁，函数执行时this就指向谁）</h3><ol>\n<li><p>call</p>\n<ul>\n<li>任何函数（都可以看成一个特殊的对象，也可以设置属性和方法）都有一个call方法</li>\n<li>call方法也可以用于调用函数,还可以指定函数执行的this的指向---fn.call(this指向);</li>\n<li>如果不传参，默认this指向window，如果传递第一个参数，那么就会指定this的指向</li>\n</ul>\n<p><strong><em>使用call来调用函数和普通调用函数的方式，唯一的区别，就是多了一个参数，call的第一个参数用于指定this指向</em></strong></p>\n</li>\n</ol>\n<p><code>数组</code>：有着数组的方法，可以遍历<br><code>伪数组</code>，本质上是对象，不是数组，数组的方法不能直接调用，但是伪数组是可以遍历的<br>常见的伪数组：<code>arguments</code> <code>document.querySelector()</code>  <code>jQuery</code></p>\n<blockquote>\n<p>小结：学习call方法，fn.call(this指向,x,y,z);<br>          call方法调用函数和普通函数调用的唯一区别，在于多了一个参数，第一个参数，用于指定this<br>          call方法，可以用于函数借调（借用别人的函数，借来调用）<br>          别人.方法.call(自己)；将this改成自己，借用别人的方法</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>apply</p>\n<ul>\n<li>apply的功能和call的功能是一样的，只是调用的方法不同了</li>\n<li>每个函数，都有一个apply方法，可以用于调用函数，且可以指定this指向</li>\n<li><strong><em>apply的语法：fn.apply(this指向，[x,y,z]);</em></strong></li>\n<li>参数1：用于指定this的指向</li>\n<li><p>参数2：接收一个数组，里面存放着所有传递的参数</p>\n<blockquote>\n<p>如果参数比较少，一般使用call，比较简单<br>如果参数比较多，一般使用apply，可以将所有需要传递的参数，放在一个数组中，一次性传递</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>bind（复制一个新函数，并且将新函数的this固定死指向传入的this值）</p>\n<pre><code class=\"javascript\">     var newFn = fn.bind(this指向)\n</code></pre>\n</li>\n<li><p>arguments</p>\n</li>\n</ol>\n<ul>\n<li>任何一个函数，都有一个对象，arguments，是一个伪数组，用于收集所有传递的参数（实参）</li>\n<li><p>一般用于参数不确定的情况</p>\n<p>new会和最近的 函数名() 结合，是一个整体，new fn()</p>\n</li>\n</ul>\n<blockquote>\n<p>补充：（1）定时器中的this ，指向window<br>      (2）事件处理函数中，浏览器让this指向了事件源</p>\n</blockquote>\n<h2 id=\"33、函数也是对象\"><a href=\"#33、函数也是对象\" class=\"headerlink\" title=\"33、函数也是对象\"></a>33、函数也是对象</h2><p>函数也是一种特殊的对象，可以添加属性和方法</p>\n<h2 id=\"34、js的规则：\"><a href=\"#34、js的规则：\" class=\"headerlink\" title=\"34、js的规则：\"></a>34、js的规则：</h2><ol>\n<li>任何<code>函数</code>，都是由<code>Function</code>创建出来的，包括他自己，包括Object函数</li>\n<li>任何的<code>原型对象</code>，都是直接由<code>Object</code>创建出来的</li>\n</ol>\n<p>js中的作用域：词法作用域，静态作用域，函数的作用域在函数声明时，就已经确定好了，跟调用没有关系<br>作用域链：每个函数都有自己的作用域，如果是定义在函数内的函数，里面的函数又会有自己的作用域（一层套一层，形成了作用域链）<br>变量的查询规则：先看自己作用域有没有这个变量，如果没有，往外一层一层的就近查找，如果一直找到全局都没有找到，就会报错</p>\n<h2 id=\"35、递归函数：在一个函数内部，自己调用自己\"><a href=\"#35、递归函数：在一个函数内部，自己调用自己\" class=\"headerlink\" title=\"35、递归函数：在一个函数内部，自己调用自己\"></a>35、递归函数：在一个函数内部，自己调用自己</h2><p>函数在调用时，其实是占用内存，函数在调用时，会开辟一块内存，进行执行</p>\n<p><strong>特点：</strong></p>\n<ol>\n<li>自己调用自己</li>\n<li>必须要有结束条件，要有出口</li>\n</ol>\n<p><em>递归：是一种算法，一种思想 ，化归思想，复杂的问题简单化</em></p>\n<h3 id=\"35-1-斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和\"><a href=\"#35-1-斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和\" class=\"headerlink\" title=\"35.1 斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和\"></a>35.1 斐波那契数列（兔子数列）：从第三个数开始，后面的数等于前两个数的和</h3><pre><code class=\"javascript\">// 直接这么写会有性能问题\nfunction getFib(n) {\n  if (n === 1 || n === 2) {\n    return 1;\n  }\n  return getFib(n-1) + getFib(n-2);\n}\n</code></pre>\n<p><strong><em>为什么会有性能问题？</em></strong><br>一个函数内部，调用了两次自己，真正执行时进行了大量的重复运算</p>\n<p><strong><em>如何优化：将已经算过的第n个斐波那契数列存起来</em></strong><br>运算过程中：</p>\n<ol>\n<li>先判断这个数，有没有算过，如果算过了，直接用</li>\n<li><p>如果没有算过，接着自己算，算完，存起来</p>\n<pre><code class=\"javascript\">// 找规律: getFib(n) = getFib(n-1) + getFib(n-2);\nvar arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数\nfunction getFib(n) {\nif (n === 1 || n === 2) {\nreturn 1;\n}\n\nif (arr[n]) {\nreturn arr[n];\n}\nelse {\narr[n] = getFib(n-1) + getFib(n-2);\nreturn arr[n];\n}\n}\n</code></pre>\n</li>\n</ol>\n<p><strong><em>利用闭包解决斐波那契数列</em></strong></p>\n<pre><code class=\"javascript\">// 省去了外部的函数名, 利用函数自调用\n\nvar result = (function() {\n  var arr = [];  // 专门用于存储已经算好的数,  arr[n] = 第n个斐波纳契数\n  function getFib(n) {\n    if (n === 1 || n === 2) {\n      return 1;\n    }\n\n    if (arr[n]) {\n      return arr[n];\n    }\n    else {\n      arr[n] = getFib(n - 1) + getFib(n - 2);\n      return arr[n];\n    }\n  }\n  return getFib;\n})();\n</code></pre>\n<h2 id=\"36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包\"><a href=\"#36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包\" class=\"headerlink\" title=\"36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包\"></a>36、闭包：一个函数的内部，有另一个函数，内部函数引用了外部函数的局部变量，这个模型，称之为闭包</h2><ul>\n<li>作用：保护变量（变量私有化）</li>\n<li>闭包的内存，不会直接释放（会占用内存）</li>\n<li>函数执行调用时，必然会开辟一快内存空间，一般来说，执行完就会释放</li>\n</ul>\n<p><strong><em>闭包的基本模型：</em></strong></p>\n<ol>\n<li>outer里面包inner</li>\n<li>匿名函数自调用<pre><code class=\"javascript\">var result = (function(){\nvar count = 0;\nreturn function(){\n count++;\n console.log(count);\n}\n})();\n</code></pre>\n</li>\n</ol>\n<h2 id=\"37、js垃圾回收机制（会将一些不用的内存空间，释放掉）\"><a href=\"#37、js垃圾回收机制（会将一些不用的内存空间，释放掉）\" class=\"headerlink\" title=\"37、js垃圾回收机制（会将一些不用的内存空间，释放掉）\"></a>37、js垃圾回收机制（会将一些不用的内存空间，释放掉）</h2><p><strong>内存泄漏：</strong>如果一块内存空间，一直得不到释放，就认为这块内存泄漏了<br><strong>机制：</strong></p>\n<ol>\n<li>引用计数：如果一块空间的引用次数，最终变成0，就会被释放掉<pre><code>bug：如果两个对象，互相引用，形成了循环引用，使用引用计数，就会得不到释放（内存泄漏）\n</code></pre></li>\n<li>标记清除：如果一块内存空间，可以访问到，就不释放；如果访问不到了，就会释放掉<pre><code>闭包用完了，只需要将指向函数内部的引用干掉，此时内存就会释放了\n</code></pre></li>\n</ol>\n<h2 id=\"38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）\"><a href=\"#38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）\" class=\"headerlink\" title=\"38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）\"></a>38、正则表达式：用于匹配规律规则的表达式（经常用于表单校验）</h2><h3 id=\"38-1-创建正则表达式：\"><a href=\"#38-1-创建正则表达式：\" class=\"headerlink\" title=\"38.1 创建正则表达式：\"></a>38.1 创建正则表达式：</h3><ol>\n<li>通过构造函数 <pre><code class=\"javascript\">var reg = new RegExp(//);\n</code></pre>\n\\d 表示数字，0-9，/\\d/可以匹配所有的数字<br>通过 <code>test</code> 方法，判断字符串，是否符合正则规则</li>\n<li>字面量<pre><code class=\"javascript\">var reg = /\\d/;\n</code></pre>\n</li>\n</ol>\n<h3 id=\"38-2-正则-元字符\"><a href=\"#38-2-正则-元字符\" class=\"headerlink\" title=\"38.2 正则-元字符\"></a>38.2 正则-元字符</h3><h4 id=\"38-2-1-普通字符：a-b-c\"><a href=\"#38-2-1-普通字符：a-b-c\" class=\"headerlink\" title=\"38.2.1 普通字符：a b c\"></a>38.2.1 普通字符：a b c</h4><h4 id=\"38-2-2-元字符：有特殊含义的\"><a href=\"#38-2-2-元字符：有特殊含义的\" class=\"headerlink\" title=\"38.2.2 元字符：有特殊含义的\"></a>38.2.2 元字符：有特殊含义的</h4><ol>\n<li><code>\\d</code> 数字，0-9</li>\n<li><code>\\D</code> 非数字</li>\n<li><code>\\w</code> 匹配单词字符（字母数字下划线），0-9  a-z  A-Z  _</li>\n<li><code>\\W</code> 非\\w（只要不是\\w中的字符，都匹配）</li>\n<li><code>\\s</code> 匹配不可见字符（换行<code>\\n</code> <code>空格</code> ）</li>\n<li><code>\\S</code> 匹配可见字符</li>\n<li><code>.</code> 匹配任意字符（除了<code>\\n</code>）----a.b可以匹配acb  aab a1b......<br>有时，就需要匹配点，需要转义 .--&gt;表示普通的点</li>\n</ol>\n<h3 id=\"38-3-正则表达式的优先级\"><a href=\"#38-3-正则表达式的优先级\" class=\"headerlink\" title=\"38.3 正则表达式的优先级\"></a>38.3 正则表达式的优先级</h3><p><code>|</code> 表示或，优先级最低<br><code>()</code> 优先级最高，一般用于提升优先级</p>\n<h3 id=\"38-4-正则表达式的字符\"><a href=\"#38-4-正则表达式的字符\" class=\"headerlink\" title=\"38.4 正则表达式的字符\"></a>38.4 正则表达式的字符</h3><p><code>[ ]</code>这个位置，可以出现的字符---[abc]，这个位置，可以出现a或者b或者c<br><code>[a-z]</code>，这个位置，可以出现a-z的所有小写字符<br><code>[a-zA-Z0-9_]</code>，这个位置，可以出现所有的字母、数字、下划线<br>[ ]内的 ^ 表示非</p>\n<h3 id=\"38-5-正则的边界（严格匹配）\"><a href=\"#38-5-正则的边界（严格匹配）\" class=\"headerlink\" title=\"38.5 正则的边界（严格匹配）\"></a>38.5 正则的边界（严格匹配）</h3><p><code>^</code>必须以...开头<br><code>$</code> 必须以...结尾<br>console.log(/^$/);---严格匹配，严格到字符数都是确定的</p>\n<h3 id=\"38-6-正则的量词\"><a href=\"#38-6-正则的量词\" class=\"headerlink\" title=\"38.6 正则的量词\"></a>38.6 正则的量词</h3><p><code>*</code> 出现0次或多次<br><code>+</code> 出现1次或多次<br><code>?</code> 出现0次或1次<br><code>{m,n}</code> 表示可以出现m次到n次<br><code>{m,}</code> 表示至少出现m次<br><code>{m}</code> 出现m次<br>汉字也是字符的一种，也有范围[\\u4e00-u9fa5]---一 yu</p>\n<h3 id=\"38-7-正则的replace（不严格的替换）\"><a href=\"#38-7-正则的replace（不严格的替换）\" class=\"headerlink\" title=\"38.7 正则的replace（不严格的替换）\"></a>38.7 正则的replace（不严格的替换）</h3><p>正则也比较懒，不加参数，只替换一次（加上g，表示 全局替换）</p>\n<pre><code class=\"javascript\">str.replace(/aa/g,&#39;xx&#39;)\n</code></pre>\n<h2 id=\"39、js校正计算\"><a href=\"#39、js校正计算\" class=\"headerlink\" title=\"39、js校正计算\"></a>39、js校正计算</h2><p>/<strong>\n </strong> 加法函数，用来得到精确的加法结果<br> <strong> 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。\n </strong> 调用：accAdd(arg1,arg2)<br> <strong> 返回值：arg1加上arg2的精确结果\n </strong>/</p>\n<pre><code class=\"javascript\">function accAdd(arg1, arg2) {\n    var r1, r2, m, c;\n    try {\n        r1 = arg1.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = arg2.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n        r2 = 0;\n    }\n    c = Math.abs(r1 - r2);\n    m = Math.pow(10, Math.max(r1, r2));\n    if (c &gt; 0) {\n        var cm = Math.pow(10, c);\n        if (r1 &gt; r2) {\n            arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));\n            arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;)) * cm;\n        } else {\n            arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;)) * cm;\n            arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));\n        }\n    } else {\n        arg1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));\n        arg2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));\n    }\n    return (arg1 + arg2) / m;\n}\n\n//给Number类型增加一个add方法，调用起来更加方便。\nNumber.prototype.add = function (arg) {\n    return accAdd(arg, this);\n};\n</code></pre>\n<p>/<strong>\n </strong> 减法函数，用来得到精确的减法结果<br> <strong> 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。\n </strong> 调用：accSub(arg1,arg2)<br> <strong> 返回值：arg1加上arg2的精确结果\n </strong>/</p>\n<pre><code class=\"javascript\">function accSub(arg1, arg2) {\n    var r1, r2, m, n;\n    try {\n        r1 = arg1.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = arg2.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n        r2 = 0;\n    }\n    m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度\n    n = (r1 &gt;= r2) ? r1 : r2;\n    return ((arg2 * m - arg1 * m) / m).toFixed(n);\n}\n\n// 给Number类型增加一个mul方法，调用起来更加方便。\nNumber.prototype.sub = function (arg) {\n    return accSub(arg, this);\n};\n</code></pre>\n<p>/<strong>\n </strong> 乘法函数，用来得到精确的乘法结果<br> <strong> 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。\n </strong> 调用：accMul(arg1,arg2)<br> <strong> 返回值：arg1乘以 arg2的精确结果\n </strong>/</p>\n<pre><code class=\"javascript\">function accMul(arg1, arg2) {\n    var m = 0, s1 = arg1.toString(), s2 = arg2.toString();\n    try {\n        m += s1.split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n    }\n    try {\n        m += s2.split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n    }\n    return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) / Math.pow(10, m);\n}\n\n// 给Number类型增加一个mul方法，调用起来更加方便。\nNumber.prototype.mul = function (arg) {\n    return accMul(arg, this);\n};\n</code></pre>\n<p>/<strong> \n </strong> 除法函数，用来得到精确的除法结果<br> <strong> 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。\n </strong> 调用：accDiv(arg1,arg2)<br> <strong> 返回值：arg1除以arg2的精确结果\n </strong>/</p>\n<pre><code class=\"javascript\">function accDiv(arg1, arg2) {\n    var t1 = 0, t2 = 0, r1, r2;\n    try {\n        t1 = arg1.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n    }\n    try {\n        t2 = arg2.toString().split(&quot;.&quot;)[1].length;\n    }\n    catch (e) {\n    }\n    with (Math) {\n        r1 = Number(arg1.toString().replace(&quot;.&quot;, &quot;&quot;));\n        r2 = Number(arg2.toString().replace(&quot;.&quot;, &quot;&quot;));\n        return (r1 / r2) * pow(10, t2 - t1);\n    }\n}\n\n//给Number类型增加一个div方法，调用起来更加方便。\nNumber.prototype.div = function (arg) {\n    return accDiv(this, arg);\n};\n</code></pre>\n"},{"title":"新鲜玩意","author":"DarkStrand","avatar":"https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg","authorLink":"DarkStrand.cn","authorAbout":"一个神奇的小伙","authorDesc":"一个神奇的小伙","date":"2021-08-13T00:36:56.751Z","comments":1,"keywords":"新奇","description":"各种新奇玩意","photos":["https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg"],"_content":"\n## 页面浮动多边形跟随鼠标移动\n\n![页面浮动多边形跟随鼠标移动](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e635cd6c5a0d4086ad1c2edefeb44a4e~tplv-k3u1fbpfcp-zoom-1.image)\n<!-- ![页面浮动多边形跟随鼠标移动][img1] -->\n\n```javascript\n//鼠标绘制多边形\n!(function() {\n  //封装方法，压缩之后减少文件大小\n  function get_attribute(node, attr, default_value) {\n    return node.getAttribute(attr) || default_value\n  }\n  //封装方法，压缩之后减少文件大小\n  function get_by_tagname(name) {\n    return document.getElementsByTagName(name)\n  }\n  //获取配置参数\n  function get_config_option() {\n    var scripts = get_by_tagname(\"script\"),\n      script_len = scripts.length,\n      script = scripts[script_len - 1] //当前加载的script\n    return {\n      l: script_len, //长度，用于生成id用\n      z: get_attribute(script, \"zIndex\", -1), //z-index\n      o: get_attribute(script, \"opacity\", 0.5), //opacity\n      c: get_attribute(script, \"color\", \"0,0,0\"), //color\n      n: get_attribute(script, \"count\", 99), //count\n    }\n  }\n  //设置canvas的高宽\n  function set_canvas_size() {\n    ;(canvas_width = the_canvas.width =\n      window.innerWidth ||\n      document.documentElement.clientWidth ||\n      document.body.clientWidth),\n      (canvas_height = the_canvas.height =\n        window.innerHeight ||\n        document.documentElement.clientHeight ||\n        document.body.clientHeight)\n  }\n\n  //绘制过程\n  function draw_canvas() {\n    context.clearRect(0, 0, canvas_width, canvas_height)\n    //随机的线条和当前位置联合数组\n    var e, i, d, x_dist, y_dist, dist //临时节点\n    //遍历处理每一个点\n    random_points.forEach(function(r, idx) {\n      ;(r.x += r.xa),\n        (r.y += r.ya), //移动\n        (r.xa *= r.x > canvas_width || r.x < 0 ? -1 : 1),\n        (r.ya *= r.y > canvas_height || r.y < 0 ? -1 : 1), //碰到边界，反向反弹\n        context.fillRect(r.x - 0.5, r.y - 0.5, 1, 1) //绘制一个宽高为1的点\n      //从下一个点开始\n      for (i = idx + 1; i < all_array.length; i++) {\n        e = all_array[i]\n        // 当前点存在\n        if (null !== e.x && null !== e.y) {\n          x_dist = r.x - e.x //x轴距离 l\n          y_dist = r.y - e.y //y轴距离 n\n          dist = x_dist * x_dist + y_dist * y_dist //总距离, m\n\n          dist < e.max &&\n            (e === current_point &&\n              dist >= e.max / 2 &&\n              ((r.x -= 0.03 * x_dist), (r.y -= 0.03 * y_dist)), //靠近的时候加速\n            (d = (e.max - dist) / e.max),\n            context.beginPath(),\n            (context.lineWidth = d / 2),\n            (context.strokeStyle = \"rgba(\" + config.c + \",\" + (d + 0.2) + \")\"),\n            context.moveTo(r.x, r.y),\n            context.lineTo(e.x, e.y),\n            context.stroke())\n        }\n      }\n    }),\n      frame_func(draw_canvas)\n  }\n  //创建画布，并添加到body中\n  var the_canvas = document.createElement(\"canvas\"), //画布\n    config = get_config_option(), //配置\n    canvas_id = \"c_n\" + config.l, //canvas id\n    context = the_canvas.getContext(\"2d\"),\n    canvas_width,\n    canvas_height,\n    frame_func =\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(func) {\n        window.setTimeout(func, 1000 / 45)\n      },\n    random = Math.random,\n    current_point = {\n      x: null, //当前鼠标x\n      y: null, //当前鼠标y\n      max: 20000, // 圈半径的平方\n    },\n    all_array\n  the_canvas.id = canvas_id\n  the_canvas.style.cssText =\n    \"position:fixed;top:0;left:0;z-index:\" + config.z + \";opacity:\" + config.o\n  get_by_tagname(\"body\")[0].appendChild(the_canvas)\n\n  //初始化画布大小\n  set_canvas_size()\n  window.onresize = set_canvas_size\n  //当时鼠标位置存储，离开的时候，释放当前位置信息\n  ;(window.onmousemove = function(e) {\n    e = e || window.event\n    current_point.x = e.clientX\n    current_point.y = e.clientY\n  }),\n    (window.onmouseout = function() {\n      current_point.x = null\n      current_point.y = null\n    })\n  //随机生成config.n条线位置信息\n  for (var random_points = [], i = 0; config.n > i; i++) {\n    var x = random() * canvas_width, //随机位置\n      y = random() * canvas_height,\n      xa = 2 * random() - 1, //随机运动方向\n      ya = 2 * random() - 1\n    // 随机点\n    random_points.push({\n      x: x,\n      y: y,\n      xa: xa,\n      ya: ya,\n      max: 6000, //沾附距离\n    })\n  }\n  all_array = random_points.concat([current_point])\n  //0.1秒后绘制\n  setTimeout(function() {\n    draw_canvas()\n  }, 100)\n})()\n```\n\n## 每日一言功能\n\n![每日一言功能](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b7a8b1a5b3e4577b1b67efee35b54ba~tplv-k3u1fbpfcp-zoom-1.image)\n\n```html\n<body>\n  <strong><p id=\"hitokoto\">每日一言获取中...</p></strong>\n  <script>\n    //每日一言\n    $(function() {\n      var xhr = new XMLHttpRequest()\n      xhr.open(\"get\", \"https://v1.hitokoto.cn\")\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var data = JSON.parse(xhr.responseText)\n          var hitokoto = document.getElementById(\"hitokoto\")\n          hitokoto.innerText = data.hitokoto\n        }\n      }\n      xhr.send()\n    })\n  </script>\n</body>\n```\n\n## 鼠标点击出现爱心特效\n\n![鼠标点击出现不同颜色爱心](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da17b3c0f8374b11bf92938a7cb32031~tplv-k3u1fbpfcp-zoom-1.image)\n\n```javascript\n//鼠标点击爱心\n!(function(e, t, a) {\n  function r() {\n    for (var e = 0; e < s.length; e++)\n      s[e].alpha <= 0\n        ? (t.body.removeChild(s[e].el), s.splice(e, 1))\n        : (s[e].y--,\n          (s[e].scale += 0.004),\n          (s[e].alpha -= 0.013),\n          (s[e].el.style.cssText =\n            \"left:\" +\n            s[e].x +\n            \"px;top:\" +\n            s[e].y +\n            \"px;opacity:\" +\n            s[e].alpha +\n            \";transform:scale(\" +\n            s[e].scale +\n            \",\" +\n            s[e].scale +\n            \") rotate(45deg);background:\" +\n            s[e].color +\n            \";z-index:99999\"))\n    requestAnimationFrame(r)\n  }\n  function n() {\n    var t = \"function\" == typeof e.onclick && e.onclick\n    e.onclick = function(e) {\n      t && t(), o(e)\n    }\n  }\n  function o(e) {\n    var a = t.createElement(\"div\")\n    ;(a.className = \"heart\"),\n      s.push({\n        el: a,\n        x: e.clientX - 5,\n        y: e.clientY - 5,\n        scale: 1,\n        alpha: 1,\n        color: c(),\n      }),\n      t.body.appendChild(a)\n  }\n  function i(e) {\n    var a = t.createElement(\"style\")\n    a.type = \"text/css\"\n    try {\n      a.appendChild(t.createTextNode(e))\n    } catch (t) {\n      a.styleSheet.cssText = e\n    }\n    t.getElementsByTagName(\"head\")[0].appendChild(a)\n  }\n  function c() {\n    return (\n      \"rgb(\" +\n      ~~(255 * Math.random()) +\n      \",\" +\n      ~~(255 * Math.random()) +\n      \",\" +\n      ~~(255 * Math.random()) +\n      \")\"\n    )\n  }\n  var s = []\n  ;(e.requestAnimationFrame =\n    e.requestAnimationFrame ||\n    e.webkitRequestAnimationFrame ||\n    e.mozRequestAnimationFrame ||\n    e.oRequestAnimationFrame ||\n    e.msRequestAnimationFrame ||\n    function(e) {\n      setTimeout(e, 1e3 / 60)\n    }),\n    i(\n      \".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"\n    ),\n    n(),\n    r()\n})(window, document)\n```\n\n![鼠标点击出现‘富强明主’字体](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5015800b668b4f329c0c414283c79d5a~tplv-k3u1fbpfcp-zoom-1.image)\n\n```javascript\n\n<script>\n    //定义获取词语下标\nvar a_idx = 0;\njQuery(document).ready(function($) {\n        //点击body时触发事件\n    $(\"body\").click(function(e) {\n    //需要显示的词语\n    var a = new Array(\"富强\",\"民主\", \"文明\", \"和谐\",\"自由\", \"平等\", \"公正\",\"法治\", \"爱国\", \"敬业\",\"诚信\", \"友善\");\n    //设置词语给span标签\n    var $i = $(\"<span/>\").text(a[a_idx]);\n    //下标等于原来下标+1  余 词语总数\n    a_idx = (a_idx + 1)% a.length;\n    //获取鼠标指针的位置，分别相对于文档的左和右边缘。\n    //获取x和y的指针坐标\n    var x = e.pageX, y = e.pageY;\n    //在鼠标的指针的位置给$i定义的span标签添加css样式\n    $i.css({\"z-index\" : 999999,\n        \"top\" : y - 20,\n        \"left\" : x,\n        \"position\" : \"absolute\",\n        \"font-weight\" : \"bold\",\n        \"color\" : \"#ff6651\"\n        });\n    //在body添加这个标签\n    $(\"body\").append($i);\n        //animate() 方法执行 CSS 属性集的自定义动画。\n        //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。\n        //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp\n        $i.animate({\n        //将原来的位置向上移动180\n            \"top\" : y - 180,\n                \"opacity\" : 0\n         //1500动画的速度\n        }, 1500, function() {\n        //时间到了自动删除\n            $i.remove();\n        });\n    });\n});\n\n</script>\n\n```\n\n## macOS Dock 效果\n\n![macOS中Dock效果](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdcbc5783ecd4331b40b1326ebc0143f~tplv-k3u1fbpfcp-watermark.image)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      html {\n        font-size: 15px;\n      }\n\n      body {\n        margin: 0;\n        padding: 0;\n        display: flex;\n        width: 100%;\n        min-height: 100vh;\n        overflow: hidden;\n        align-items: flex-end;\n        background-image: linear-gradient(\n          109.6deg,\n          rgba(25, 170, 209, 1) 11.3%,\n          rgba(21, 65, 249, 1) 69.9%\n        );\n      }\n\n      .glass {\n        width: 100%;\n        height: 8rem;\n        background: rgba(255, 255, 255, 0.25);\n        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n        backdrop-filter: blur(4px);\n        -webkit-backdrop-filter: blur(4px);\n        border: 1px solid rgba(255, 255, 255, 0.18);\n        display: flex;\n        justify-content: center;\n      }\n\n      .dock {\n        --scale: 1;\n\n        list-style: none;\n        margin: 0;\n        padding: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .dock li {\n        font-size: calc(6rem * var(--scale));\n        padding: 0 0.5rem;\n        cursor: default;\n\n        position: relative;\n        top: calc((6rem * var(--scale) - 6rem) / 2 * -1);\n\n        transition: 15ms all ease-out;\n      }\n\n      .dock li.loading {\n        animation: 1s loading ease-in infinite;\n      }\n\n      @keyframes loading {\n        0%,\n        100% {\n          transform: translateY(0px);\n        }\n        60% {\n          transform: translateY(-40px);\n        }\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"glass\">\n      <ul class=\"dock\">\n        <li>😃</li>\n        <li>😊</li>\n        <li>😜</li>\n        <li>😍</li>\n        <li>🤩</li>\n        <li>🥳</li>\n        <li>🥶</li>\n      </ul>\n    </div>\n\n    <script>\n      document.querySelectorAll(\".dock li\").forEach((li) => {\n        li.addEventListener(\"click\", (e) => {\n          e.currentTarget.classList.add(\"loading\")\n        })\n\n        li.addEventListener(\"mousemove\", (e) => {\n          let item = e.target\n          let itemRect = item.getBoundingClientRect()\n          let offset = Math.abs(e.clientX - itemRect.left) / itemRect.width\n\n          let prev = item.previousElementSibling || null\n          let next = item.nextElementSibling || null\n\n          let scale = 0.6\n\n          resetScale()\n\n          if (prev) {\n            prev.style.setProperty(\"--scale\", 1 + scale * Math.abs(offset - 1))\n          }\n\n          item.style.setProperty(\"--scale\", 1 + scale)\n\n          if (next) {\n            next.style.setProperty(\"--scale\", 1 + scale * offset)\n          }\n        })\n      })\n\n      document.querySelector(\".dock\").addEventListener(\"mouseleave\", (e) => {\n        resetScale()\n      })\n\n      function resetScale() {\n        document.querySelectorAll(\".dock li\").forEach((li) => {\n          li.style.setProperty(\"--scale\", 1)\n        })\n      }\n    </script>\n  </body>\n</html>\n```\n\n## canvas 实现水印\n\n```javascript\nvar watermark = {}\n\nfunction setWatermark(args) {\n  //声明一个怪异一点的变量，确保id的唯一性\n  var id = \"111.222.333.456\"\n  var xIndex = 15 //绘制文本的 x 坐标位置\n  var yIndex = 65 //绘制文本的 y 坐标位置\n  var xInterval = 25 //有多个参数时的行间间隔\n  if (document.getElementById(id) !== null) {\n    document.body.removeChild(document.getElementById(id))\n  }\n  //利用canvas绘制水印信息\n  var can = document.createElement(\"canvas\")\n  can.width = 250\n  can.height = 150\n  var cans = can.getContext(\"2d\")\n  cans.rotate((-20 * Math.PI) / 180)\n  cans.font = \"17px Vedana\"\n  // ziti yanse\n  cans.fillStyle = \"rgba(200, 200, 200, 0.30)\"\n  cans.textAlign = \"left\"\n  cans.textBaseline = \"Middle\"\n  for (let i = 0; i < args.length; i++) {\n    cans.fillText(args[i], xIndex, yIndex) //绘制水印文案\n    yIndex += xInterval //设置每行间隔\n  }\n  //创建div用于显示\n  var div = document.createElement(\"div\")\n  div.id = id\n  div.style.pointerEvents = \"none\"\n  div.style.top = \"70px\"\n  div.style.left = \"90px\"\n  div.style.position = \"fixed\"\n  div.style.zIndex = \"100000\"\n  div.style.width = document.documentElement.clientWidth - 50 + \"px\"\n  div.style.height = document.documentElement.clientHeight - 50 + \"px\"\n  //div承载水印显示\n  div.style.background =\n    \"url(\" + can.toDataURL(\"image/png\") + \") left top repeat\"\n  document.body.appendChild(div)\n  return id\n}\n\nwatermark.set = function() {\n  let args = Array.prototype.slice.apply(arguments)\n  let id = setWatermark(args)\n  // 检测如果水印被去掉了，自动给加上\n  setInterval(function() {\n    if (document.getElementById(id) === null) {\n      id = setWatermark(args)\n    }\n  }, 500)\n  //在窗口大小改变之后,自动触发加水印事件\n  window.onresize = function() {\n    setWatermark(args)\n  }\n}\nwindow.watermark = watermark\n\nwatermark.set(\"绝密档案\", \"严禁外泄\")\n```\n\n\n## canvas实现验证码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>Document</title>\n</head>\n\n<body>\n  <canvas id=\"canvas\" width=\"120\" height=\"40\"></canvas>\n  <a href=\"#\" id=\"changeImg\">看不清，换一张</a>\n  <input type=\"text\" id=\"text\">\n  <script>\n    // 随机数\n    function randomNum(min, max) {\n      return Math.floor(Math.random() * (max - min) + min);\n    }\n    /**生成一个随机色**/\n    function randomColor(min, max) {\n      var r = randomNum(min, max);\n      var g = randomNum(min, max);\n      var b = randomNum(min, max);\n      return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    }\n    drawPic();\n    document.getElementById(\"changeImg\").onclick = function (e) {\n      e.preventDefault();\n      drawPic();\n    }\n\n    var Vcode = ''\n\n    /**绘制验证码图片**/\n    function drawPic() {\n      var canvas = document.getElementById(\"canvas\");\n      var width = canvas.width;\n      var height = canvas.height;\n      var ctx = canvas.getContext('2d');\n      ctx.textBaseline = 'bottom';\n\n      /**绘制背景色**/\n      ctx.fillStyle = randomColor(180, 240); //颜色若太深可能导致看不清\n      ctx.fillRect(0, 0, width, height);\n      /**绘制文字**/\n      var str = 'ABCEFGHJKLMNPQRSTWXY123456789';\n      vCode = ''\n      for (var i = 0; i < 4; i++) {\n        var txt = str[randomNum(0, str.length)];    // 每次随机生成的数\n        vCode += txt\n        ctx.fillStyle = randomColor(50, 160);  //随机生成字体颜色\n        ctx.font = randomNum(15, 40) + 'px SimHei'; //随机生成字体大小\n        var x = 10 + i * 25;\n        var y = randomNum(25, 45);\n        var deg = randomNum(-45, 45);\n        //修改坐标原点和旋转角度\n        ctx.translate(x, y);\n        ctx.rotate(deg * Math.PI / 180);\n        ctx.fillText(txt, 0, 0);\n        //恢复坐标原点和旋转角度\n        ctx.rotate(-deg * Math.PI / 180);\n        ctx.translate(-x, -y);\n      }\n      /* *绘制干扰线* */\n      for (var i = 0; i < 4; i++) {\n        ctx.strokeStyle = randomColor(40, 180);\n        ctx.beginPath();\n        ctx.moveTo(randomNum(0, width), randomNum(0, height));\n        ctx.lineTo(randomNum(0, width), randomNum(0, height));\n        ctx.stroke();\n      }\n      /**绘制干扰点**/\n      for (var i = 0; i < 20; i++) {\n        ctx.fillStyle = randomColor(0, 255);\n        ctx.beginPath();\n        ctx.arc(randomNum(0, width), randomNum(0, height), 1, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n      console.log(\"随机生成的验证码是:::\", vCode);\n    }\n    let text = document.getElementById('text')\n    text.onblur = function(e) {\n      console.log(text.value,'value')\n      if(text.value == vCode) {\n\n      } else {\n        alert('请输入正确的验证码')\n      }\n    }\n  </script>\n</body>\n\n</html>\n```\n\n\n## 纯css实现霓虹灯效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .light {\n      position: relative;\n      padding: 25px 30px;\n      color: #03e9f4;\n      font-size: 24px;\n      text-transform: uppercase;\n      transition: 0.5s;\n      letter-spacing: 4px;\n      cursor: pointer;\n      overflow: hidden;\n      width: 200px;\n      height: 100px;\n    }\n    .light:hover {\n      background-color: #03e9f4;\n      color: #050801;\n      box-shadow: 0 0 5px #03e9f4,\n                  0 0 25px #03e9f4,\n                  0 0 50px #03e9f4,\n                  0 0 200px #03e9f4;\n    }\n    .light div {\n      position: absolute;\n    }\n    .light div:nth-child(1){\n      width: 100%;\n      height: 2px;\n      top: 0;\n      left: -100%;\n      background: linear-gradient(to right,transparent,#03e9f4);\n      animation: animate1 2s linear infinite;\n    }\n    .light div:nth-child(2){\n      width: 2px;\n      height: 100%;\n      top: -100%;\n      right: 0;\n      background: linear-gradient(to bottom,transparent,#03e9f4);\n      animation: animate2 2s linear infinite;\n      animation-delay: 0.5s;\n    }\n    .light div:nth-child(3){\n      width: 100%;\n      height: 2px;\n      bottom: 0;\n      right: -100%;\n      background: linear-gradient(to left,transparent,#03e9f4);\n      animation: animate3 2s linear infinite;\n      animation-delay: 1s;\n    }\n    .light div:nth-child(4){\n      width: 2px;\n      height: 100%;\n      bottom: -100%;\n      left: 0;\n      background: linear-gradient(to top,transparent,#03e9f4);\n      animation: animate4 2s linear infinite;\n      animation-delay: 1.5s;\n    }\n    @keyframes animate1 {\n      0% {\n        left: -100%;\n      }\n      50%,100% {\n        left: 100%;\n      }\n    }\n    @keyframes animate2 {\n      0% {\n        top: -100%;\n      }\n      50%,100% {\n        top: 100%;\n      }\n    }\n    @keyframes animate3 {\n      0% {\n        right: -100%;\n      }\n      50%,100% {\n        right: 100%;\n      }\n    }\n    @keyframes animate4 {\n      0% {\n        bottom: -100%;\n      }\n      50%,100% {\n        bottom: 100%;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"light\">\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n    Neon Button\n  </div>\n</body>\n</html>\n```\n\n\n## canvas实现刮刮乐\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <img src=\"./男1.jpg\" width=\"400\" id=\"img\" alt=\"\" />\n    <input type=\"text\" name=\"\" id=\"txt\" />\n    <!-- <canvas></canvas> -->\n    <script>\n      const oImg = document.getElementById(\"img\")\n      const txt = document.getElementById(\"txt\")\n      //oImg.readyState 图片加载状态\n      if (oImg.readyState === \"complete\") {\n        draw() //true表示已经加载完成 执行draw()方法\n      } else {\n        //图片加载完成执行draw方法\n        oImg.onload = draw\n      }\n\n      function draw() {\n        //等图片加载完成后再添加canvas画布在上面\n        let can = document.createElement(\"canvas\") //创建一个canvas画布\n        can.width = oImg.width //等于图片的宽高\n        can.height = oImg.height\n        can.style.position = \"absolute\" //canvas画布设置浮动会漂浮在图片上\n        can.style.left = oImg.offsetLeft + \"px\" //保存与画布位置一致\n        can.style.top = oImg.offsetTop + \"px\"\n        //找到图片的父级：parentNode  在oImg子元素前面添加canvas标签：insertBefore\n        oImg.parentNode.insertBefore(can, oImg) //在img前面去插入canvas标签\n        let ctx = can.getContext(\"2d\")\n        ctx.fillStyle = \"#bbb\" //刮刮乐的颜色\n        ctx.fillRect(0, 0, oImg.width, oImg.height) //填充宽度\n\n        //合成:处理合成图片的透明样式；\n        //拖拽的时候，canvas图层显示透明；destination-out：新图形与原图形重叠部分透明\n        ctx.globalCompositeOperation = \"destination-out\"\n        ctx.strokeStyle = \"#eee\" //触笔的颜色 随便  因为它终究变成透明\n        ctx.lineWidth = 30 //拖动时开始画线的线宽\n        ctx.lineCap = \"round\" //这两步是把画笔变成圆形\n\n        //按下，移动，抬起事件\n        can.onmousedown = function (e) {\n          e = e || window.event //兼容低版本IE浏览器\n          //e.pageX距离文档右边缘； offsetLeft：canvas画布距离文档的右边距离\n          let x = e.pageX - can.offsetLeft //得到的x是在canvas上的坐标值\n          let y = e.pageY - can.offsetTop\n          ctx.beginPath()\n          // ctx.moveTo(  x,y )//从哪里开始来画\n          ctx.arc(x, y, 15, 0, 6.3, false) //点第一下是画一个圆\n          ctx.fill()\n          //按下后拖拽\n          can.onmousemove = function (e) {\n            //拖动时一直执行下面\n            e = e || window.event //兼容低版本IE浏览器\n            ctx.beginPath() //拖动时开始画线\n            ctx.moveTo(x, y) //起始点\n            ctx.lineTo(e.pageX - can.offsetLeft, e.pageY - can.offsetTop) //移动的过程\n\n            //每次移动的时候，样式所在的坐标；\n            x = e.pageX - can.offsetLeft //第二次渲染刮图片效果的起始点应该在上一次的终止点\n            y = e.pageY - can.offsetTop\n            ctx.stroke() //弹出图形并恢复画布\n          }\n          document.onmouseup = function () {\n            //抬起后将事件注销\n            can.onmousemove = null\n            this.onmouseup = null\n            check() //完成后通过像素计算刮过的的百分比\n          }\n        }\n        function check() {\n          //获取画布的像素列表\n          let data = ctx.getImageData(0, 0, can.width, can.height).data\n          let n = 0 //计算透明像素的个数\n          for (let i = 0; i < data.length; i += 4) {\n            //感觉这一步比较消耗性能\n            //RGBA\n            if (\n              data[i] == 0 &&\n              data[i + 1] == 0 &&\n              data[i + 2] == 0 &&\n              data[i + 3] == 0\n            ) {\n              n++\n            }\n          }\n          let f = (n * 100) / (can.width * can.height) //算出所刮的面积的占比；\n          txt.value = `刮开面积:${f.toFixed(2)}%`\n          //刮开面积的比例\n          if (f > 30) {\n            //如果所刮的面积大于30%   则将canvas画布整体清除fillRect\n            ctx.beginPath()\n            ctx.fillRect(0, 0, can.width, can.height)\n            txt.value = \"刮开面积大于30%，全部显示\"\n          }\n        }\n      }\n    </script>\n  </body>\n</html>\n```\n\n## swiper轮播图组件\n> 拖拽、回弹物料效果是参照开源项目swiper.js做的\n```javascript\n/**\n * 轮播组件\n * @param {object} params 配置传参\n * @param {string} params.el 组件节点 class|id|<label>\n * @param {number} params.moveTime 过渡时间（毫秒）默认 300\n * @param {number} params.interval 自动播放间隔（毫秒）默认 3000\n * @param {boolean} params.loop 是否需要回路\n * @param {boolean} params.vertical 是否垂直滚动\n * @param {boolean} params.autoPaly 是否需要自动播放\n * @param {boolean} params.pagination 是否需要底部圆点\n * @param {(index: number) => void} params.slideCallback 滑动/切换结束回调\n * @author https://github.com/Hansen-hjs\n * @description \n * 移动端`swiper`组件，如果需要兼容`pc`自行修改对应的`touch`到`mouse`事件即可。现成效果预览：https://huangjingsheng.gitee.io/hjs/cv/demo/face/\n */\nfunction swiper(params) {\n    /**\n     * css class 命名列表\n     * @dec [\"滑动列表\",\"滑动item\",\"圆点容器\",\"底部圆点\",\"圆点高亮\"]\n     */\n    const classNames = [\".swiper_list\", \".swiper_item\", \".swiper_pagination\", \".swiper_dot\", \".swiper_dot_active\"];\n    /** 滑动结束函数 */\n    const slideEnd = params.slideCallback || function() {};\n    /**\n     * 组件节点\n     * @type {HTMLElement}\n     */\n    let node = null;\n    /**\n     * item列表容器\n     * @type {HTMLElement}\n     */\n    let nodeItem = null;\n    /**\n     * item节点列表\n     * @type {Array<HTMLElement>}\n     */\n    let nodeItems = [];\n    /**\n     * 圆点容器\n     * @type {HTMLElement}\n     */\n    let nodePagination = null;\n    /**\n     * 圆点节点列表\n     * @type {Array<HTMLElement>}\n     */\n    let nodePaginationItems = [];\n    /** 是否需要底部圆点 */\n    let pagination = false;\n    /** 是否需要回路 */\n    let isLoop = false;\n    /** 方向 `X => true` | `Y => false` */\n    let direction = false;\n    /** 是否需要自动播放 */\n    let autoPaly = false;\n    /** 自动播放间隔（毫秒）默认 3000 */\n    let interval = 3000;\n    /** 过渡时间（毫秒）默认 300 */\n    let moveTime = 300;\n\n    /** 设置动画 */\n    function startAnimation() {\n        nodeItem.style.transition = `${moveTime / 1000}s all`; \n    }\n\n    /** 关闭动画 */\n    function stopAnimation() {\n        nodeItem.style.transition = \"0s all\";\n    }\n\n    /**\n     * 属性样式滑动\n     * @param {number} n 移动的距离\n     */\n    function slideStyle(n) {\n        let x = 0, y = 0;\n        if (direction) {\n            y = n;\n        } else {\n            x = n;\n        }\n        nodeItem.style.transform = `translate3d(${x}px, ${y}px, 0px)`;\n    }\n\n    /**\n     * 事件开始\n     * @param {number} width 滚动容器的宽度\n     * @param {number} height 滚动容器的高度\n     */\n    function main(width, height) {\n        /**\n         * 动画帧\n         * @type {requestAnimationFrame}\n         */\n        const animation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n        /** 触摸开始时间 */\n        let startTime = 0;\n        /** 触摸结束时间 */\n        let endTime = 0;\n        /** 开始的距离 */\n        let startDistance = 0;\n        /** 结束的距离 */\n        let endDistance = 0;\n        /** 结束距离状态 */\n        let endState = 0;\n        /** 移动的距离 */\n        let moveDistance = 0;\n        /** 圆点位置 && 当前 item 索引 */\n        let index = 0;\n        /** 动画帧计数 */\n        let count = 0;\n        /** loop 帧计数 */\n        let loopCount = 0;\n        /** 移动范围 */\n        let range = direction ? height : width;\n\n        /** 获取拖动距离 */\n        function getDragDistance() {\n            /** 拖动距离 */\n            let dragDistance = 0;\n            // 默认这个公式\n            dragDistance = moveDistance + (endDistance - startDistance);\n            // 判断最大正负值\n            if ((endDistance - startDistance) >= range) {\n                dragDistance = moveDistance + range;\n            } else if ((endDistance - startDistance) <= -range) {\n                dragDistance = moveDistance - range;\n            }\n            // 没有 loop 的时候惯性拖拽\n            if (!isLoop) {\n                if ((endDistance - startDistance) > 0 && index === 0) {\n                    // console.log(\"到达最初\");\n                    dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6));\n                } else if ((endDistance - startDistance) < 0 && index === nodeItems.length - 1) {\n                    // console.log(\"到达最后\");\n                    dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6));\n                }\n            }\n            return dragDistance;\n        }\n\n        /**\n         * 判断触摸处理函数 \n         * @param {number} slideDistance 滑动的距离\n         */\n        function judgeTouch(slideDistance) {\n            //\t这里我设置了200毫秒的有效拖拽间隔\n            if ((endTime - startTime) < 200) return true;\n            // 这里判断方向（正值和负值）\n            if (slideDistance < 0) {\n                if ((endDistance - startDistance) < (slideDistance / 2)) return true;\n                return false;\n            } else {\n                if ((endDistance - startDistance) > (slideDistance / 2)) return true;\n                return false;\n            }\n        }\n\n        /** 返回原来位置 */\n        function backLocation() {\n            startAnimation();\n            slideStyle(moveDistance);\n        }\n\n        /**\n         * 滑动\n         * @param {number} slideDistance 滑动的距离\n         */\n        function slideMove(slideDistance) {\n            startAnimation();\n            slideStyle(slideDistance);\n            loopCount = 0;\n            // 判断 loop 时回到第一张或最后一张\n            if (isLoop && index < 0) {\n                // 我这里是想让滑块过渡完之后再重置位置所以加的延迟 (之前用setTimeout，快速滑动有问题，然后换成 requestAnimationFrame解决了这类问题)\n                function loopMoveMin() {\n                    loopCount += 1;\n                    if (loopCount < moveTime / 1000 * 60) return animation(loopMoveMin);\n                    stopAnimation();\n                    slideStyle(range * -(nodeItems.length - 3));\n                    // 重置一下位置\n                    moveDistance = range * -(nodeItems.length - 3);\n                }\n                loopMoveMin();\n                index = nodeItems.length - 3;\n            } else if (isLoop && index > nodeItems.length - 3) {\n                function loopMoveMax() {\n                    loopCount += 1;\n                    if (loopCount < moveTime / 1000 * 60) return animation(loopMoveMax);\n                    stopAnimation();\n                    slideStyle(0);\n                    moveDistance = 0;\n                }\n                loopMoveMax();\n                index = 0;\n            }\n            // console.log(`第${ index+1 }张`);\t// 这里可以做滑动结束回调\n            if (pagination) {\n                nodePagination.querySelector(classNames[4]).className = classNames[3].slice(1);\n                nodePaginationItems[index].classList.add(classNames[4].slice(1));\n            }\n        }\n\n        /** 判断移动 */\n        function judgeMove() {\n            // 判断是否需要执行过渡\n            if (endDistance < startDistance) {\n                // 往上滑动 or 向左滑动\n                if (judgeTouch(-range)) {\n                    // 判断有loop的时候不需要执行下面的事件\n                    if (!isLoop && moveDistance === (-(nodeItems.length - 1) * range)) return backLocation();\n                    index += 1;\n                    slideMove(moveDistance - range);\n                    moveDistance -= range;\n                    slideEnd(index);\n                } else {\n                    backLocation();\n                }\n            } else {\n                // 往下滑动 or 向右滑动\n                if (judgeTouch(range)) {\n                    if (!isLoop && moveDistance === 0) return backLocation();\n                    index -= 1;\n                    slideMove(moveDistance + range);\n                    moveDistance += range;\n                    slideEnd(index)\n                } else {\n                    backLocation();\n                }\n            }\n        }\n\n        /** 自动播放移动 */\n        function autoMove() {\n            // 这里判断 loop 的自动播放\n            if (isLoop) {\n                index += 1;\n                slideMove(moveDistance - range);\n                moveDistance -= range;\n            } else {\n                if (index >= nodeItems.length - 1) {\n                    index = 0;\n                    slideMove(0);\n                    moveDistance = 0;\n                } else {\n                    index += 1;\n                    slideMove(moveDistance - range);\n                    moveDistance -= range;\n                }\n            }\n            slideEnd(index);\n        }\n\n        /** 开始自动播放 */\n        function startAuto() {\n            count += 1;\n            if (count < interval / 1000 * 60) return animation(startAuto);\n            count = 0;\n            autoMove();\n            startAuto();\n        }\n\n        // 判断是否需要开启自动播放\n        if (autoPaly && nodeItems.length > 1) startAuto();\n\n        // 开始触摸\n        nodeItem.addEventListener(\"touchstart\", ev => {\n            startTime = Date.now();\n            count = 0;\n            loopCount = moveTime / 1000 * 60;\n            stopAnimation();\n            startDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX;\n        });\n\n        // 触摸移动\n        nodeItem.addEventListener(\"touchmove\", ev => {\n            ev.preventDefault();\n            count = 0;\n            endDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX;\n            slideStyle(getDragDistance());\n        });\n\n        // 触摸离开\n        nodeItem.addEventListener(\"touchend\", () => {\n            endTime = Date.now();\n            // 判断是否点击\n            if (endState !== endDistance) {\n                judgeMove();\n            } else {\n                backLocation();\n            }\n            // 更新位置 \n            endState = endDistance;\n            // 重新打开自动播\n            count = 0;\n        });\n    }\n\n    /**\n     * 输出回路：如果要回路的话前后增加元素\n     * @param {number} width 滚动容器的宽度\n     * @param {number} height 滚动容器的高度\n     */\n    function outputLoop(width, height) {\n        const first = nodeItems[0].cloneNode(true), last = nodeItems[nodeItems.length - 1].cloneNode(true);\n        nodeItem.insertBefore(last, nodeItems[0]);\n        nodeItem.appendChild(first);\n        nodeItems.unshift(last);\n        nodeItems.push(first);\n        if (direction) {\n            nodeItem.style.top = `${-height}px`;\n        } else {\n            nodeItem.style.left = `${-width}px`;\n        }\n    }\n\n    /**\n     * 输出动态布局\n     * @param {number} width 滚动容器的宽度\n     * @param {number} height 滚动容器的高度\n     */\n    function outputLayout(width, height) {\n        if (direction) {\n            for (let i = 0; i < nodeItems.length; i++) {\n                nodeItems[i].style.height = `${height}px`;\n            }\n        } else {\n            nodeItem.style.width = `${width * nodeItems.length}px`;\n            for (let i = 0; i < nodeItems.length; i++) {\n                nodeItems[i].style.width = `${width}px`;\n            }\n        }\n    }\n\n    /** 输出底部圆点 */\n    function outputPagination() {\n        let paginations = \"\";\n        nodePagination = node.querySelector(classNames[2]);\n        // 如果没有找到对应节点则创建一个\n        if (!nodePagination) {\n            nodePagination = document.createElement(\"div\");\n            nodePagination.className = classNames[2].slice(1);\n            node.appendChild(nodePagination);\n        }\n        for (let i = 0; i < nodeItems.length; i++) {\n            paginations += `<div class=\"${classNames[3].slice(1)}\"></div>`;\n        }\n        nodePagination.innerHTML = paginations;\n        nodePaginationItems = [...nodePagination.querySelectorAll(classNames[3])];\n        nodePagination.querySelector(classNames[3]).classList.add(classNames[4].slice(1));\n    }\n\n    /** 初始化动态布局 */\n    function initLayout() {\n        node = document.querySelector(params.el);\n        if (!node) return console.warn(\"没有可执行的节点！\");\n        nodeItem = node.querySelector(classNames[0]);\n        if (!nodeItem) return console.warn(`缺少\"${classNames[0]}\"节点！`);\n        nodeItems = [...node.querySelectorAll(classNames[1])];\n        if (nodeItems.length == 0) return console.warn(\"滑动节点个数必须大于0！\");\n        const moveWidth = node.offsetWidth, moveHeight = node.offsetHeight;\n        if (pagination) outputPagination();\n        if (isLoop) outputLoop(moveWidth, moveHeight);\n        outputLayout(moveWidth, moveHeight);\n        main(moveWidth, moveHeight);\n    }\n\n    /** 初始化参数 */\n    function initParams() {\n        if (typeof params !== \"object\") return console.warn(\"传参有误\");\n        pagination = params.pagination || false;\n        direction = params.vertical || false;\n        autoPaly = params.autoPaly || false;\n        isLoop = params.loop || false;\n        moveTime = params.moveTime || 300;\n        interval = params.interval || 3000;\n        initLayout();\n    }\n    initParams();\n}\n\n```\n\n## 图片懒加载\n>非传统实现方式，性能最优\n```javascript\n/**\n * 懒加载\n * @description 可加载`<img>`、`<video>`、`<audio>`等一些引用资源路径的标签\n * @param {object} params 传参对象\n * @param {string?} params.lazyAttr 自定义加载的属性（可选）\n * @param {\"src\"|\"background\"} params.loadType 加载的类型（默认为`src`）\n * @param {string?} params.errorPath 加载失败时显示的资源路径，仅在`loadType`设置为`src`中可用（可选）\n */\nfunction lazyLoad(params) {\n    const attr = params.lazyAttr || \"lazy\";\n    const type = params.loadType || \"src\";\n\n    /** 更新整个文档的懒加载节点 */\n    function update() {\n        const els = document.querySelectorAll(`[${attr}]`);\n        for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n            observer.observe(el);\n        }\n    }\n\n    /**\n     * 加载图片\n     * @param {HTMLImageElement} el 图片节点\n     */\n    function loadImage(el) {\n        const cache = el.src; // 缓存当前`src`加载失败时候用\n        el.src = el.getAttribute(attr);\n        el.onerror = function () {\n            el.src = params.errorPath || cache;\n        }\n    }\n\n    /**\n     * 加载单个节点\n     * @param {HTMLElement} el \n     */\n    function loadElement(el) {\n        switch (type) {\n            case \"src\":\n                loadImage(el);\n                break;\n            case \"background\":\n                el.style.backgroundImage = `url(${el.getAttribute(attr)})`;\n                break;\n        }\n        el.removeAttribute(attr);\n        observer.unobserve(el);\n    }\n\n    /** \n     * 监听器 \n     * [MDN说明](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)\n    */\n    const observer = new IntersectionObserver(function(entries) {\n        for (let i = 0; i < entries.length; i++) {\n            const item = entries[i];\n            if (item.isIntersecting) {\n                loadElement(item.target);\n            }\n        }\n    })\n\n    update();\n\n    return {\n        observer,\n        update\n    }\n}\n\n```\n\n在vue中使用指令去使用\n```javascript\nimport Vue from \"vue\";\n\n/** 添加一个加载`src`的指令 */\nconst lazySrc = lazyLoad({\n    lazyAttr: \"vlazy\",\n    errorPath: \"./img/error.jpg\"\n})\n\nVue.directive(\"v-lazy\", {\n    inserted(el, binding) {\n        el.setAttribute(\"vlazy\", binding.value); // 跟上面的对应\n        lazySrc.observer.observe(el);\n    }\n})\n\n/** 添加一个加载`background`的指令 */\nconst lazyBg = lazyLoad({\n    lazyAttr: \"vlazybg\",\n    loadType: \"background\"\n})\n\nVue.directive(\"v-lazybg\", {\n    inserted(el, binding) {\n        el.setAttribute(\"vlazybg\", binding.value); // 跟上面的对应\n        lazyBg.observer.observe(el);\n    }\n})\n\n\n```\n\n## 上传图片\n```html\n<!-- 先准备好一个input标签，然后设置type=\"file\"，最后挂载一个onchange事件 -->\n<input class=\"upload-input\" type=\"file\" name=\"picture\" onchange=\"upLoadImage(this)\">\n```\n\n```javascript\n/**\n * input上传图片\n * @param {HTMLInputElement} el \n */\nfunction upLoadImage(el) {\n    /** 上传文件 */\n    const file = el.files[0];\n    /** 上传类型数组 */\n    const types = [\"image/jpg\", \"image/png\", \"image/jpeg\", \"image/gif\"];\n    // 判断文件类型\n    if (types.indexOf(file.type) < 0) {\n        file.value = null; // 这里一定要清空当前错误的内容\n        return alert(\"文件格式只支持：jpg 和 png\");\n    }\n    // 判断大小\n    if (file.size > 2 * 1024 * 1024) {\n        file.value = null;\n        return alert(\"上传的文件不能大于2M\");\n    }\n    \n    const formData = new FormData();    // 这个是传给后台的数据\n    formData.append(\"img\", file);       // 这里`img`是跟后台约定好的`key`字段\n    console.log(formData, file);\n    // 最后POST给后台，这里我用上面的方法\n    ajax({\n        url: \"http://xxx.com/uploadImg\",\n        method: \"POST\",\n        data: {},\n        formData: formData,\n        overtime: 5000,\n        success(res) {\n            console.log(\"上传成功\", res);\n        },\n        fail(err) {\n            console.log(\"上传失败\", err);\n        },\n        timeout() {\n            console.warn(\"XMLHttpRequest 请求超时 !!!\");\n        }\n    });\n}\n\n```\n\n[base64转换和静态预览](https://github.com/Hansen-hjs/my-note/blob/master/JavaScript/upload-img.html)\n## 下拉刷新组件\n> 拖拽效果参考上面swiper的实现方式，下拉中的效果是可以自己定义的\n```javascript\n// 这里我做的不是用 window 的滚动事件，而是用最外层的绑定触摸下拉事件去实现\n// 好处是我用在Vue这类单页应用的时候，组件销毁时不用去解绑 window 的 scroll 事件\n// 但是滑动到底部事件就必须要用 window 的 scroll 事件，这点需要注意\n\n/**\n * 下拉刷新组件\n * @param {object} option 配置\n * @param {HTMLElement} option.el 下拉元素（必选）\n * @param {number} option.distance 下拉距离[px]（可选）\n * @param {number} option.deviation 顶部往下偏移量[px]（可选）\n * @param {string} option.loadIcon 下拉中的 icon html（可选）\n */\nfunction dropDownRefresh(option) {\n    const doc = document;\n    /** 整体节点 */\n    const page = option.el;\n    /** 下拉距离 */\n    const distance = option.distance || 88;\n    /** 顶部往下偏移量 */\n    const deviation = option.deviation || 0;\n    /** 顶层节点 */\n    const topNode = doc.createElement(\"div\");\n    /** 下拉时遮罩 */\n    const maskNode = doc.createElement(\"div\");\n\n    topNode.innerHTML = `<div refresh-icon style=\"transition: .2s all;\"><svg style=\"transform: rotate(90deg); display: block;\" t=\"1570593064555\" viewBox=\"0 0 1575 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"26089\" width=\"48\" height=\"48\"><path d=\"M1013.76 0v339.968H484.115692V679.778462h529.644308v339.968l529.644308-485.612308v-48.600616L1013.76 0zM243.396923 679.857231h144.462769V339.968H243.396923V679.778462z m-240.797538 0h144.462769V339.968H2.599385V679.778462z\" fill=\"#000000\" fill-opacity=\".203\" p-id=\"26090\"></path></svg></div><div refresh-loading style=\"display: none; animation: refresh-loading 1s linear infinite;\">${option.loadIcon || '<p style=\"font-size: 15px; color: #666;\">loading...</p>'}</div>`;\n    topNode.style.cssText = `width: 100%; height: ${distance}px; position: fixed; top: ${-distance + deviation}px; left: 0; z-index: 10; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; box-sizing: border-box; margin: 0; padding: 0;`;\n    maskNode.style.cssText = \"position: fixed; top: 0; left: 0; width: 100%; height: 100vh; box-sizing: border-box; margin: 0; padding: 0; background-color: rgba(0,0,0,0); z-index: 999;\";\n    page.parentNode.insertBefore(topNode, page);\n\n    /**\n     * 设置动画时间\n     * @param {number} n 秒数 \n     */\n    function setAnimation(n) {\n        page.style.transition = topNode.style.transition = n + \"s all\";\n    }\n\n    /**\n     * 设置滑动距离\n     * @param {number} n 滑动的距离（像素）\n     */\n    function setSlide(n) {\n        page.style.transform = topNode.style.transform = `translate3d(0px, ${n}px, 0px)`;\n    }\n    \n    /** 下拉提示 icon */\n    const icon = topNode.querySelector(\"[refresh-icon]\");\n    /** 下拉 loading 动画 */\n    const loading = topNode.querySelector(\"[refresh-loading]\");\n\n    return {\n        /**\n         * 监听开始刷新\n         * @param {Function} callback 下拉结束回调\n         * @param {(n: number) => void} rangeCallback 下拉状态回调\n         */\n        onRefresh(callback, rangeCallback = null) {\n            /** 顶部距离 */\n            let scrollTop = 0;\n            /** 开始距离 */\n            let startDistance = 0;\n            /** 结束距离 */\n            let endDistance = 0;\n            /** 最后移动的距离 */\n            let range = 0;\n\n            // 触摸开始\n            page.addEventListener(\"touchstart\", function (e) {\n                startDistance = e.touches[0].pageY;\n                scrollTop = 1;\n                setAnimation(0);\n            });\n\n            // 触摸移动\n            page.addEventListener(\"touchmove\", function (e) {\n                scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop;\n                // 没到达顶部就停止\n                if (scrollTop != 0) return;\n                endDistance = e.touches[0].pageY;\n                range = Math.floor(endDistance - startDistance);\n                // 判断如果是下滑才执行\n                if (range > 0) {\n                    // 阻止浏览自带的下拉效果\n                    e.preventDefault();\n                    // 物理回弹公式计算距离\n                    range = range - (range * 0.5);\n                    // 下拉时icon旋转\n                    if (range > distance) {\n                        icon.style.transform = \"rotate(180deg)\";\n                    } else {\n                        icon.style.transform = \"rotate(0deg)\";\n                    }\n                    setSlide(range);\n                    // 回调距离函数 如果有需要\n                    if (typeof rangeCallback === \"function\") rangeCallback(range);\n                }\n            });\n\n            // 触摸结束\n            page.addEventListener(\"touchend\", function () {\n                setAnimation(0.3);\n                // console.log(`移动的距离：${range}, 最大距离：${distance}`);\n                if (range > distance && range > 1 && scrollTop === 0) {\n                    setSlide(distance);\n                    doc.body.appendChild(maskNode);\n                    // 阻止往上滑动\n                    maskNode.ontouchmove = e => e.preventDefault();\n                    // 回调成功下拉到最大距离并松开函数\n                    if (typeof callback === \"function\") callback();\n                    icon.style.display = \"none\";\n                    loading.style.display = \"block\";\n                } else {\n                    setSlide(0);\n                }\n            });\n\n        },\n        /** 结束下拉 */\n        end() {\n            maskNode.parentNode.removeChild(maskNode);\n            setAnimation(0.3);\n            setSlide(0);\n            icon.style.display = \"block\";\n            loading.style.display = \"none\";\n        }\n    }\n}\n\n```\n\n## 监听滚动到底部\n```javascript\n/**\n * 监听滚动到底部\n * @param {object} options 传参对象\n * @param {number} options.distance 距离底部多少像素触发（px）\n * @param {boolean} options.once 是否为一次性（防止重复用）\n * @param {() => void} options.callback 到达底部回调函数\n */\nfunction onScrollToBottom(options) {\n    const { distance = 0, once = false, callback = null } = options;\n    const doc = document;\n    /** 滚动事件 */\n    function onScroll() {\n        /** 滚动的高度 */\n        let scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop;\n        /** 滚动条高度 */\n        let scrollHeight = doc.documentElement.scrollTop === 0 ? doc.body.scrollHeight : doc.documentElement.scrollHeight;\n        if (scrollHeight - scrollTop - distance <= window.innerHeight) {\n            if (typeof callback === \"function\") callback();\n            if (once) window.removeEventListener(\"scroll\", onScroll);\n        }\n    }\n    window.addEventListener(\"scroll\", onScroll);\n    // 必要时先执行一次\n    // onScroll(); \n}\n\n```\n\n## 音频播放组件\n```javascript\n/**\n * `AudioContext`音频组件 \n * [资料参考](https://www.cnblogs.com/Wayou/p/html5_audio_api_visualizer.html)\n * @description 解决在移动端网页上标签播放音频延迟的方案 貌似`H5`游戏引擎也是使用这个实现\n */\nfunction audioComponent() {\n    /**\n     * 音频上下文\n     * @type {AudioContext}\n     */\n    const context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext)();\n    /** \n     * @type {AnalyserNode} \n     */\n    const analyser = context.createAnalyser();;\n    /**\n     * @type {AudioBufferSourceNode}\n     */\n    let bufferNode = null;\n    /**\n     * @type {AudioBuffer}\n     */\n    let buffer = null;\n    /** 是否加载完成 */\n    let loaded = false;\n\n    analyser.fftSize = 256;\n\n    return {\n        /**\n         * 加载路径音频文件\n         * @param {string} url 音频路径\n         * @param {(res: AnalyserNode) => void} callback 加载完成回调\n         */\n        loadPath(url, callback) {\n            const XHR = new XMLHttpRequest(); \n            XHR.open(\"GET\", url, true); \n            XHR.responseType = \"arraybuffer\"; \n            // 先加载音频文件\n            XHR.onload = () => {\n                context.decodeAudioData(XHR.response, audioBuffer => {\n                    // 最后缓存音频资源\n                    buffer = audioBuffer;\n                    loaded = true;\n                    typeof callback === \"function\" && callback(analyser);\n                });\n            }\n            XHR.send(null);\n        },\n\n        /** \n         * 加载 input 音频文件\n         * @param {File} file 音频文件\n         * @param {(res: AnalyserNode) => void} callback 加载完成回调\n         */\n        loadFile(file, callback) {\n            const FR = new FileReader();\n            // 先加载音频文件\n            FR.onload = e => {\n                const res = e.target.result;\n                // 然后解码\n                context.decodeAudioData(res, audioBuffer => {\n                    // 最后缓存音频资源\n                    buffer = audioBuffer;\n                    loaded = true;\n                    typeof callback === \"function\" && callback(analyser);\n                });\n            }\n            FR.readAsArrayBuffer(file);\n        },\n\n        /** 播放音频 */\n        play() {\n            if (!loaded) return console.warn(\"音频未加载完成 !!!\");\n            // 这里有个问题，就是创建的音频对象不能缓存下来然后多次执行 start , 所以每次都要创建然后 start()\n            bufferNode = context.createBufferSource();\n            bufferNode.connect(analyser);\n            analyser.connect(context.destination);\n            bufferNode.buffer = buffer;\n            bufferNode.start(0);\n        },\n\n        /** 停止播放 */\n        stop() {\n            if (!bufferNode) return console.warn(\"音频未播放 !!!\");\n            bufferNode.stop();\n        }\n    }\n}\n\n```\n\n## 全局监听图片错误并替换到默认图片\n```javascript\nwindow.addEventListener(\"error\", e => {\n    /** 默认`base64`图片 */\n    const defaultImg = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJoAAACACAYAAADzsnDqAAANXElEQVR4Xu2dDYxcVRXHz3mz0FgjICBSgkZAQD5CwQ+Qz4BBBUEkUJpK0FAUYmms2O47d7oSmYbYnXfeLIXl01ojBAnSokRQQIWAIvEjkfBhUZGPEkMFDajgbjdu5x1zYVpmd2d25r1335uZzrkJIenec869//ubO/Pux3kIWlSBHBTAHGJoCFUAFDSFIBcFFLRcZNYgCpoykIsCClouMmsQBU0ZyEUBBS0XmTWIgqYM5KKAgpaLzBpEQVMGclFAQctFZg2ioCkDuSigoOUiswbJHLTR0dE5W7ZsWQAAB6rcnVMAETcj4vO+7z/QiVZkCtrIyMhB1Wr12wBwcic6pzFnKiAiq4wxpby1yRS0IAhuR8RFeXdK47VUYCERbWhZy2GFzEBbs2bNvMnJyc0O26qu3CnwJBHNd+eutafMQBseHj65UCg81LoJWqMTChBRZmPfqD+ZBVPQOoFP+zEVtPa10popFFDQUoinpu0r0E+gPVytVle1L43WjKNAoVC4YrZlpb4CjYhOiSOe1m1fAWa2D2JN1y8VtPa11JqzKKCgvS3OwzqjZfdZUdAUtOzoqvOsoCloCppLBdpYsNWvTpeCT/OlM5rOaBni9bZrBU1BU9BcKqBfnS7VjO9LZzSd0eJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQVPQ4lOTwEJBU9ASYBPfREFT0OJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQesgaMy8NxG9HH/Yes9CQesQaOVy+f2e560koiW9h038FitoHQKNmb8LABeJSNEYE8Qfut6yUNA6ABozfwoAfmZDi8gEIl5IRHf0FjrxWqugdQC0MAwfFZHj6obqT4i42Pf938Ubvt6praDlDFoQBMsQ8ZrpiCDifWNjYwtKpdJ47+DTfksVtBxBC8NwLxH5MwC8u8kQ3UhEl7Y/fL1TU0HLF7TrRaQVSIaIuHcQaq+lClpOoJXL5ZM8z/tlG8MyHkXR4mKxuL6Nuj1TRUHLCTRmfhAAPtEmGU9v3br13KGhIfs1u0MUBS0H0Jj5EgCwSZrjlHuJ6Iw4Bt1cV0HLGLTR0dFdtmzZ8gwivjcuCCJygzFmaVy7bqyvoGUMWhiGIyKyPMXg+0RUSWHfFabMfJ6IHIaIhwKA/e+w+oZp2qoUwxQEwdGImHYRdgwAziGin6doSteZhmF4eBRFi2rp+A9Q0FIMETP/FAA+k8LFNtONY2Njx61atep1B766zgUzn0tEP8yzYZ3Myu00yQszfxEAbnEo3k+I6LMO/fW1qx0CtFKptPPcuXOfBYD3uRxNRLzO9/2vuvTZr752CNCY+VsAMJTRIF5MROsy8h3b7erVq/fwPG8fz/PmAcA+iDhPRP4LAPZA58sDAwN/nzNnzstLly61/9Y1pedBC8PwCBF5IitF7SB6nnes7/t/zCrGbH5rs7X9Cj8TAOz/92izHRtF5E7P8+7rhlMqPQ8aM98FAGe3KX7Sak8R0RFJjZPYMfNpAHABAJwOALsn8VFnsxEAHkDEdZ36wPQ0aOVyeaHneXkdYLyHiM5KOeAtzZn5wwDwNQCwDzeui126ucYem/J9/x+unc/mr6dBY2b7AHBAXoKJyJXGmG9mES8Ign0R0QK2DAB2ziJGnc8XLHBENOOcXlZxexY0ZrYD3ok3r5xBRPe6HJBKpXJSFEVrAeBgl37b8PXAwMDAkuXLl9sPbKalJ0FbvXr1QQMDA3/JVJkmzhHx9UKhsN/y5ctfcxE/DMOFIpLX13+jJr8aRdEXisXifS7608xHT4IWBMEdiLgwS2Fa+HbyYlVmvgoAvt7BftSHXkZE12bVlp4DLQiCsxDxx1kJ0q5fRLzF9/0L260/vR4z311brkjqwrkdIn7e9/0fOHcMAD0HGjM/DQCHZCFGXJ8issQYc1NcuyAIRhAxzQmTuCHbrl8oFI5csWKF83XJngKNmQkAuu3y71FE9Hi7I8nMdhb8Xrv1O1DvbwBwtOvUET0DWi2lwYsdEL5VyP8Q0W6tKtm/l8vl+Z7n2eNHe7VTv0Udg4j3FwqFvyLibpOTk/sDQAgAxzrw7XzNsGdAY+ZbayvlDnR07uIhImp5P4GZ7ekSFwuxixrdtC+VSnPnzp17m6OdkstcrrP1BGj1KQ2cI+LIISIO+77fdGO/tqWUegkBEa/2fb/pkyozHwkA9qWwbc2ys3T/BUT8uKsdhJ4ALQiCxxFxviMmMnMjIp8zxtinyRmFmS1kdv8yVfE875DBwcFZb2sxs/0NmPiJuK6Bq4noG6kaXDPuetDCMLxMRNa46GzWPkTkVGOMveY3pTg8lPkcEX2wVT+Y+csA8J1W9dr4+1htVkt9cqWrQbMpDQBgs4gU2hCl01VeJ6Jdm8xmvwWAYxw0cBMR7dfKj+Mn22uJyO6/pipdDdq2nGapepif8c1EtHh6OHspRESectUMEdnFGPPGbP7CMFwrIhe7iCkizxpjDkzrq2tBi5HSIK0GTuyb/T5jZnsi42onQd7K79bw67nefxiGj4uIs9+01Wr1lJUrVz6cpg9dCxoz/x4APpamcznaVolooMnXpn0CPNlVW0RkyBgz3Mzf6OjonImJiQlX8Wp+RohoMI3PrgQtCIJLEfH6NB3L01ZEfmGMsVklp5Ra2qxXHLflLiI6p5nPSqVyQhRFj7iMKSLPGGNSHWHqOtBsSoOJiQl70eIdLsXK0peI3GaMsceupxRmtuf873Ec+yUi2reZzzAMl4vIiOOY9iu75W/D2WJ2HWjMfCMAfMW1UFn6E5GrjDErGoCWJNlMy6Yi4v6+79tTsjNKEAS3126jt/QTp0KhUDh4xYoVz8Sxqa/bVaCFYXiMiNilgJ4qzTJ9h2F4hYiUXHdGRM4zxtzZyG9Wp1vSPhB0G2iPiMgJrgcma38icpExZsaJDGa2qbPsrOa0NNvuqlQqe0ZR9E+nwd52dj4R3Z7Ud9eA5nA1O6kWie2iKDqzWCzavB9TShiGd4tIFmkVHiSiUxt8Vdu8IzPakbhjdYYiMmiMSfzbrytAq12Stde/Gq6suxAqYx8NL6wws30QsA8Erssb4+Pju5dKpa31jpn5cgC40nUw62+HAC0IAnvXMPU2RxYCt+lzMRHd3GCGsfuNdt/ReRGRY4wxdq1xewmCYAMiLnAe7C3QLjDG2CNIiUrHZ7SRkZGjqtXqY4la3yVGIkLGGHvocEphZju72Fkmi3IpEdkn9O2Fme1TYertokaNbWdHYrZOdhy0MAwfFJGWhwazGClXPhEx9H3fHjOfUjJeeF5HRNv3M8Mw3E9EnnfVp+l+PM87bHBw0N7XSFQ6Clrt7LzLnGaJRHBg1HBDPQiCcxAxq4R3jxHRR7a1vVKpnB1Fkc1DkkkZGBjYI81d1k6DZvOqvicTZfJ12jCjd6VSOTSKIptgJZNSv7YVBEEJEa/IJBDAq0S0ZxrfnQbN2WZzGhHS2orIK8aYvRv5YWZ7aHBKouK08ers38yaOTIyclC1WrW33e0x7ixKwxk7TqBOghannV1fN4qiE4vF4q+nNzTjmcaG2wQANtV9lnvDC9LmvFXQ3CFcISJ/ujtmPhEAfuUuTO6eXhsfH59XKpX+lyaygpZGvam2Tc/zM7O9TJLqmI27Zsb2dBsRzTiZEteLghZXsVnqR1F0WrFYfPNNx/UlCAJ72bfsMFSerj7t4p0LCprbIbuJiJZMd7l+/frCpk2bHnV0QWWbe3u0+nIReRIR7SWeczNIF9GwP0kkU9CSqNbERkTGd9ppp/mNEtsFQbAAETc4CreRiA6f7mt4ePgDhUKh4Tm1uHHtkzQiHk9Ez8W1bVRfQXOhYp2P2dKPMrPdKzw/bUhEPM73/d808sPMNqWXi1y7Tt+JpaClHfWZ9i+Oj48fWSqV/j39T66SvMz2HidHyyk7VJIX90PcPR6bZk90cbnXpofwff/JJjOafZPyeSmk2OHSVqXQortNEfGJycnJTw4NDTU87eogEd8GIpqRWjUMw3eKyGYA2CWpQr2YiG//QqHg5IdkUtE6bDfrtk3a1KIissoYs/0+QrlcPh0RRxGxZW6OZrr0ZGpR2xlmtlsyx3d4wDsWXkSWGmNuaNaAIAjWIeKXUjTwXwDwvIjsmgYwG7/ZBZsUbZtimtnDgI1SS2z8fQB4l6sG95ifLQBwAhE1PdjJzPbV2td1sl+IeInv+y6yDzXtRqag1WD7aO1T+6FOitnJ2PaExWzxXTwgJOzfSyKyzBjzo4T2bZtlDlrbLenzivZWu51ZMro11UjdtTbtRLOnV9fDoaC5VjSlvxyAW+t53trBwcE/pGxqLHMFLZZc+VWu5e1Y5PI1ip7n3Zo3YNsUU9DyYydRpDQvhq3trd6/Q78YNpGqatRSAX3VdUuJtEI/K6Bfnf08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0MpaP08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0P9H/gjHdvP/Qy/AAAAAElFTkSuQmCC';\n    /**\n     * @type {HTMLImageElement}\n     */\n    const node = e.target;\n    if (node.nodeName && node.nodeName.toLocaleLowerCase() === \"img\") {     \n        node.style.objectFit = \"cover\";\n        node.src = defaultImg;\n    }\n}, true);\n\n```\n\n## 复制功能\n翻 ``Clipboard.js`` 这个插件库源码的时候找到核心代码 ``setSelectionRange(start: number, end: number)``，百度上搜到的复制功能全部都少了这个操作，所以搜到的复制文本代码在 ios 和 IE 等一些浏览器上复制不了。\n```javascript\n/**\n * 复制文本\n * @param {string} text 复制的内容\n * @param {() => void} success 成功回调\n * @param {(tip: string) => void} fail 出错回调\n */\nfunction copyText(text, success = null, fail = null) {\n    text = text.replace(/(^\\s*)|(\\s*$)/g, \"\");\n    if (!text) {\n        typeof fail === \"function\" && fail(\"复制的内容不能为空！\");\n        return;\n    }\n    const id = \"the-clipboard\";\n    /**\n     * 粘贴板节点\n     * @type {HTMLTextAreaElement}\n     */\n    let clipboard = document.getElementById(id);\n    if (!clipboard) {\n        clipboard = document.createElement(\"textarea\");\n        clipboard.id = id;\n        clipboard.readOnly = true\n        clipboard.style.cssText = \"font-size: 15px; position: fixed; top: -1000%; left: -1000%;\";\n        document.body.appendChild(clipboard);\n    }\n    clipboard.value = text;\n    clipboard.select();\n    clipboard.setSelectionRange(0, text.length);\n    const state = document.execCommand(\"copy\");\n    if (state) {\n        typeof success === \"function\" && success();\n    } else {\n        typeof fail === \"function\" && fail(\"复制失败\");\n    }\n}\n\n```\n\n## 检测类型\n```javascript\n/**\n * 检测类型\n * @param {any} target 检测的目标\n * @returns {\"string\"|\"number\"|\"array\"|\"object\"|\"function\"|\"null\"|\"undefined\"} 只枚举一些常用的类型\n */\nfunction checkType(target) {\n    /** @type {string} */\n    const value = Object.prototype.toString.call(target);\n    const result = value.match(/\\[object (\\S*)\\]/)[1];\n    return result.toLocaleLowerCase();\n}\n\n```\n\n## 格式化日期（代码极少版）\n```javascript\n/**\n * 获取指定日期时间戳\n * @param {number} time 毫秒数\n */\nfunction getDateFormat(time = Date.now()) {\n    const date = new Date(time);\n    return `${date.toLocaleDateString()} ${date.toTimeString().slice(0, 8)}`;\n}\n\n```\n\n## js小数精度计算\n```javascript\n/**\n * 数字运算（主要用于小数点精度问题）\n * @param {number} a 前面的值\n * @param {\"+\"|\"-\"|\"*\"|\"/\"} type 计算方式\n * @param {number} b 后面的值\n * @example \n * ```js\n * // 可链式调用\n * const res = computeNumber(1.3, \"-\", 1.2).next(\"+\", 1.5).next(\"*\", 2.3).next(\"/\", 0.2).result;\n * console.log(res);\n * ```\n */\nfunction computeNumber(a, type, b) {\n    /**\n     * 获取数字小数点的长度\n     * @param {number} n 数字\n     */\n    function getDecimalLength(n) {\n        const decimal = n.toString().split(\".\")[1];\n        return decimal ? decimal.length : 0;\n    }\n    /**\n     * 修正小数点\n     * @description 防止出现 `33.33333*100000 = 3333332.9999999995` && `33.33*10 = 333.29999999999995` 这类情况做的处理\n     * @param {number} n\n     */\n    const amend = (n, precision = 15) => parseFloat(Number(n).toPrecision(precision));\n    const power = Math.pow(10, Math.max(getDecimalLength(a), getDecimalLength(b)));\n    let result = 0;\n\n    a = amend(a * power);\n    b = amend(b * power);\n\n    switch (type) {\n        case \"+\":\n            result = (a + b) / power;\n            break;\n        case \"-\":\n            result = (a - b) / power;\n            break;\n        case \"*\":\n            result = (a * b) / (power * power);\n            break;\n        case \"/\":\n            result = a / b;\n            break;\n    }\n\n    result = amend(result);\n\n    return {\n        /** 计算结果 */\n        result,\n        /**\n         * 继续计算\n         * @param {\"+\"|\"-\"|\"*\"|\"/\"} nextType 继续计算方式\n         * @param {number} nextValue 继续计算的值\n         */\n        next(nextType, nextValue) {\n            return computeNumber(result, nextType, nextValue);\n        }\n    };\n}\n\n```\n\n## 一行css适配rem\n750是设计稿的宽度：之后的单位直接1:1使用设计稿的大小，单位是rem\n```javascript\nhtml{ font-size: calc(100vw / 750); }\n```\n\n## 好用的格式化日期方法\n```javascript\n/**\n * 格式化日期\n * @param {string | number | Date} value 指定日期\n * @param {string} format 格式化的规则\n * @example\n * ```js\n * formatDate();\n * formatDate(1603264465956);\n * formatDate(1603264465956, \"h:m:s\");\n * formatDate(1603264465956, \"Y年M月D日\");\n * ```\n */\nfunction formatDate(value = Date.now(), format = \"Y-M-D h:m:s\") {\n    const formatNumber = n => `0${n}`.slice(-2);\n    const date = new Date(value);\n    const formatList = [\"Y\", \"M\", \"D\", \"h\", \"m\", \"s\"];\n    const resultList = [];\n    resultList.push(date.getFullYear().toString());\n    resultList.push(formatNumber(date.getMonth() + 1));\n    resultList.push(formatNumber(date.getDate()));\n    resultList.push(formatNumber(date.getHours()));\n    resultList.push(formatNumber(date.getMinutes()));\n    resultList.push(formatNumber(date.getSeconds()));\n    for (let i = 0; i < resultList.length; i++) {\n        format = format.replace(formatList[i], resultList[i]);\n    }\n    return format;\n}\n\n```\n\n## 网页定位\n这里使用百度定位，无论代码封装、调用方式还是位置准确性都比微信sdk那个好用太多了，包括在任何网页端；\n[文档说明](http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey)\n[获取百度地图key](http://lbsyun.baidu.com/apiconsole/key#/home)\n```javascript\n/**\n * 插入脚本\n * @param {string} link 脚本路径\n * @param {Function} callback 脚本加载完成回调\n */\nfunction insertScript(link, callback) {\n    const label = document.createElement(\"script\");\n    label.src = link;\n    label.onload = function () {\n        if (label.parentNode) label.parentNode.removeChild(label);\n        if (typeof callback === \"function\") callback();\n    }\n    document.body.appendChild(label);\n}\n\n/**\n * 获取定位信息 \n * @returns {Promise<{ city: string, districtName: string, province: string, longitude: number, latitude: number }>}\n*/\nfunction getLocationInfo() {\n    /**\n     * 使用百度定位\n     * @param {(value: any) => void} callback\n     */\n    function useBaiduLocation(callback) {\n        const geolocation = new BMap.Geolocation({\n            maximumAge: 10\n        })\n        geolocation.getCurrentPosition(function(res) {\n            console.log(\"%c 使用百度定位 >>\", \"background-color: #4e6ef2; padding: 2px 6px; color: #fff; border-radius: 2px\", res);\n            callback({\n                city: res.address.city,\n                districtName: res.address.district,\n                province: res.address.province,\n                longitude: Number(res.longitude),\n                latitude: Number(res.latitude)\n            })\n        })\n    }\n\n    return new Promise(function (resolve, reject) {\n        if (!window._baiduLocation) {\n            window._baiduLocation = function () {\n                useBaiduLocation(resolve);\n            }\n            // ak=你自己的key\n            insertScript(\"https://api.map.baidu.com/api?v=2.0&ak=66vCKv7PtNlOprFEe9kneTHEHl8DY1mR&callback=_baiduLocation\");\n        } else {\n            useBaiduLocation(resolve);\n        }\n    })\n}\n\n```\n\n## 输入保留数字``<input type=\"text\">``\n使用场景：用户在输入框输入内容时，实时过滤保持数字值显示；\n\ntips：在Firefox中设置 ``<input type=\"number\">`` 会有样式 bug\n```javascript\n/**\n * 输入只能是数字\n * @param {string | number} value 输入的值\n * @param {boolean} decimal 是否要保留小数\n * @param {boolean} negative 是否可以为负数\n */\nfunction inputOnlyNumber(value, decimal, negative) {\n    let result = value.toString().trim();\n    if (result.length === 0) return \"\";\n    const minus = (negative && result[0] == \"-\") ? \"-\" : \"\";\n    if (decimal) {\n        result = result.replace(/[^0-9.]+/ig, \"\");\n        let array = result.split(\".\");\n        if (array.length > 1) {\n            result = array[0] + \".\" + array[1];\n        }\n    } else {\n        result = result.replace(/[^0-9]+/ig, \"\");\n    }\n    return minus + result;\n}\n\n```\n\n## Intl.NumberFormat（格式化数字）\n* 现在JS提供了一个更加可用和规范化的API——Intl.NumberFormat。对于常用的货币格式化都有良好的支持。\n>推荐使用\n```javascript\nnew Intl.NumberFormat().format(123456.789);\n// 显示结果为：123,456.789\n```\n\n```javascript\nnew Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(12345.678);\n// 结果显示为：\"￥12,346\"\n```\n\n* 正则表达式 （古早的做法）\n```javascript\nconst number = 1234567;\nnumber.toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1,');\n// 结果为：1,234,567\n```\n\n* Date API\n```javascript\nconst number = 123456.789;\nnumber.toLocaleString();// 结果为：123,456.789\n```\n\n## 加密\n### base64加密\n```javascript\nvar str = 'hello';\nvar str64 = window.btoa(str);\nconsole.log('经base64编码后：'+ str64); // 经base64编码后：aGVsbG8=\nconsole.log('经base64解码后：' + window.atob(str64)); // 经base64解码后：hello\n\n```\n\n### 编码和解码字符串\n使用JS函数的``escape()``和``unescape()``，分别是编码和解码字符串\n```javascript\nvar escape1 = escape('我的名字是：Neo'); // 编码\nvar unescape1 = unescape(escape1); // 解码\nconsole.log(escape1) // %u6211%u7684%u540D%u5B57%u662F%uFF1ANeo\nconsole.log(unescape1) // \"我的名字是：Neo\"\n```\n\n## lucky-canvas【大转盘/九宫格】抽奖\n[lucky-canvas【大转盘/九宫格】抽奖](https://100px.net/)\n\n## FineBI大屏\n[FineBI大屏](https://help.fanruan.com/finebi/)\n\n## 大屏数据展示模板\n[大屏数据展示模板](https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi)\n\n## js拖动滑块验证功能\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>滑块解锁封装js方法</title>\n    <!--注：这里首次用到了iconfont的语法，即矢量图标-->\n    <link rel=\"stylesheet\" href=\"font/iconfont.css\" />\n    <style>\n      * {\n        padding: 0;\n        margin: 0;\n      }\n      #box {\n        position: relative;\n        width: 300px;\n        height: 40px;\n        margin: 0 auto;\n        margin-top: 10px;\n        background-color: #e8e8e8;\n        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);\n      }\n      .bgColor {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 40px;\n        height: 40px;\n        background-color: lightblue;\n      }\n      .txt {\n        position: absolute;\n        width: 100%;\n        height: 40px;\n        line-height: 40px;\n        font-size: 14px;\n        color: #000;\n        text-align: center;\n      }\n      .slider {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 50px;\n        height: 38px;\n        border: 1px solid #ccc;\n        background: #fff;\n        text-align: center;\n        cursor: move;\n      }\n      .slider > i {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n      }\n      .slider.active > i {\n        color: green;\n      }\n    </style>\n  </head>\n  <body>\n    <div id=\"box\" onselectstart=\"return false;\">\n      <div class=\"bgColor\"></div>\n      <div class=\"txt\">滑动解锁</div>\n      <!--给i标签添加上相应字体图标的类名即可-->\n      <div class=\"slider\"><i class=\"iconfont icon-double-right\"></i></div>\n    </div>\n    <script>\n      //一、定义了一个获取元素的方法\n      function getEle(selector) {\n        return document.querySelector(selector)\n      }\n      //二、获取到需要用到的DOM元素\n      var box = getEle(\"#box\"), //容器\n        bgColor = getEle(\".bgColor\"), //背景色\n        txt = getEle(\".txt\"), //文本\n        slider = getEle(\".slider\"), //滑块\n        icon = getEle(\".slider>i\"),\n        successMoveDistance = box.offsetWidth - slider.offsetWidth, //解锁需要滑动的距离\n        downX, //用于存放鼠标按下时的位置\n        isSuccess = false //是否解锁成功的标志，默认不成功\n\n      //三、给滑块添加鼠标按下事件\n      slider.onmousedown = mousedownHandler\n\n      //3.1鼠标按下事件的方法实现\n      function mousedownHandler(e) {\n        bgColor.style.transition = \"\"\n        slider.style.transition = \"\"\n        var e = e || window.event || e.which\n        downX = e.clientX\n        //在鼠标按下时，分别给鼠标添加移动和松开事件\n        document.onmousemove = mousemoveHandler\n        document.onmouseup = mouseupHandler\n      }\n\n      //四、定义一个获取鼠标当前需要移动多少距离的方法\n      function getOffsetX(offset, min, max) {\n        if (offset < min) {\n          offset = min\n        } else if (offset > max) {\n          offset = max\n        }\n        return offset\n      }\n\n      //3.1.1鼠标移动事件的方法实现\n      function mousemoveHandler(e) {\n        var e = e || window.event || e.which\n        var moveX = e.clientX\n        var offsetX = getOffsetX(moveX - downX, 0, successMoveDistance)\n        bgColor.style.width = offsetX + \"px\"\n        slider.style.left = offsetX + \"px\"\n\n        if (offsetX == successMoveDistance) {\n          success()\n        }\n        //如果不设置滑块滑动时会出现问题（目前还不知道为什么）\n        e.preventDefault()\n      }\n\n      //3.1.2鼠标松开事件的方法实现\n      function mouseupHandler(e) {\n        if (!isSuccess) {\n          bgColor.style.width = 0 + \"px\"\n          slider.style.left = 0 + \"px\"\n          bgColor.style.transition = \"width 0.8s linear\"\n          slider.style.transition = \"left 0.8s linear\"\n        }\n        document.onmousemove = null\n        document.onmouseup = null\n      }\n\n      //五、定义一个滑块解锁成功的方法\n      function success() {\n        isSuccess = true\n        txt.innerHTML = \"解锁成功\"\n        bgColor.style.backgroundColor = \"lightgreen\"\n        slider.className = \"slider active\"\n        icon.className = \"iconfont icon-xuanzhong\"\n        //滑动成功时，移除鼠标按下事件和鼠标移动事件\n        slider.onmousedown = null\n        document.onmousemove = null\n      }\n    </script>\n  </body>\n</html>\n\n```\n\n## canvas实现贪吃蛇\n[原文](https://juejin.cn/post/6959789039566192654#heading-14)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>贪吃蛇</title>\n  <style>\n    body {\n      background-color: #eee;\n    }\n    .container {\n      text-align: center;\n    }\n    .top {\n      margin: 20px auto;\n      width: 640px;\n    }\n    #score {\n      float: left;\n    }\n    .main {\n      position: absolute;\n      left: 50%;\n      transform: translateX(-50%);\n      width: 642px;\n      height: 402px;\n    }\n    #snake {\n      border: 1px solid #000;\n      width: 640px;\n      height: 400px;\n      display: inline-block;\n      z-index: 99;\n      background-color: rgba(0, 0, 0, .1);\n    }\n    #mask {\n      background-color: rgba(0, 0, 0, .5);\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      z-index: 100;\n      display: block;\n      color: #fff;\n      line-height: 400px;\n      text-align: center;\n      font-size: 30px;\n      cursor: pointer;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"top\">\n      <span id=\"score\">Score: 0</span>\n      <button id=\"restart\">重新开始</button>\n      <button id=\"stop\">暂停</button>\n      <button id=\"continue\">继续</button>\n    </div>\n    <div class=\"main\">\n      <canvas id=\"snake\" width=\"640\" height=\"400\"></canvas>\n      <div id=\"mask\">开始</div>\n    </div>\n  </div>\n\n<script>\n  let greedySnake = null\n  let score = document.querySelector('#score')\n  let restart = document.querySelector('#restart')\n  let stop = document.querySelector('#stop')\n  let conti = document.querySelector('#continue')\n  let mask = document.querySelector('#mask')\n\n  restart.onclick = () => {\n    if (!greedySnake.isStart) return\n    greedySnake.start()\n  }\n  stop.onclick = () => {\n    if (greedySnake.isStop || !greedySnake.isStart) return\n    greedySnake.stop()\n  }\n  conti.onclick = () => {\n    if (!greedySnake.isStop || !greedySnake.isStart) return\n    greedySnake.continue()\n  }\n  mask.onclick = () => {\n    if (!greedySnake.isStart) {\n      greedySnake.start()\n    } else {\n      greedySnake.continue()\n    }\n  }\n\n  // 大小为64 * 40\n  class GreedySnake {\n    constructor() {\n      this.canvas = document.querySelector('#snake')\n      this.ctx = this.canvas.getContext('2d')\n      this.maxX = 64          // 最大行\n      this.maxY = 40          // 最大列\n      this.itemWidth = 10     // 每个点的大小\n      this.direction = 'right'// up down right left 方向\n      this.speed = 150        // ms 速度\n      this.isStop = false     // 是否暂停\n      this.isOver = false     // 是否结束\n      this.isStart = false    // 是否开始\n      this.score = 0          // 分数\n      this.timer = null       // 移动定时器\n      this.j = 1\n      this.canChange = true\n      \n      this.grid = new Array()\n\n      for (let i = 0; i < this.maxX; i++) {\n        for (let j = 0; j < this.maxY; j++) {\n          this.grid.push([i, j])\n        } \n      }\n\n      this.drawGridLine()\n      this.getDirection()\n    }\n\n    // 开始\n    start() {\n      if (this.timer) {\n        clearTimeout(this.timer)\n      }\n      if (!this.isStart) {\n        this.isStart = true\n      }\n      this.score = 0\n      this.speed = 150\n      this.isStop = false\n      this.isOver = false\n      this.direction = 'right'\n      this.createSnake()\n      this.createFood()\n      this.draw()\n      this.move()\n      mask.style.display = 'none'\n    }\n\n    // 创建蛇主体\n    createSnake() {\n      this.snake = [\n        [4, 25],\n        [3, 25],\n        [2, 25],\n        [1, 25],\n        [0, 25]\n      ]\n    }\n\n    // 移动\n    move() {\n      if (this.isStop) return\n\n      let [x, y] = this.snake[0]\n      switch(this.direction) {\n        case 'left':\n          x--\n          break\n        case 'right':\n          x++\n          break\n        case 'up':\n          y--\n          break\n        case 'down':\n          y++\n          break\n      }\n      \n      // 如果下一步不是食物的位置\n      if (x !== this.food[0] || y !== this.food[1]) {\n        this.snake.pop()\n      } else {\n        this.createFood()\n      }\n\n      if (this.over([x, y])) {\n        this.isOver = true\n        mask.style.display = 'block'\n        mask.innerHTML = '结束'\n        return\n      }\n      if (this.completed()) {\n        mask.style.display = 'block'\n        mask.innerHTML = '恭喜您，游戏通关'\n        return\n      }\n\n      this.snake.unshift([x, y])\n      \n      this.draw()\n      this.canChange = true\n      this.timer = setTimeout(() => this.move(), this.speed)\n    }\n    \n    // 暂停游戏\n    stop() {\n      if (this.isOver) return\n      this.isStop = true\n      mask.style.display = 'block'\n      mask.innerHTML = '暂停'\n    }\n\n    // 继续游戏\n    continue() {\n      if (this.isOver) return\n      this.isStop = false\n      this.move()\n      mask.style.display = 'none'\n    }\n\n    getDirection() {\n      // 上38 下40 左37 右39 不能往相反的方向走\n      document.onkeydown = (e) => {\n        // 在贪吃蛇移动的间隔内不能连续改变两次方向\n        if (!this.canChange) return\n        switch(e.keyCode) {\n          case 37:\n            if (this.direction !== 'right') {\n              this.direction = 'left'\n              this.canChange = false\n            }\n            break\n          case 38:\n            if (this.direction !== 'down') {\n              this.direction = 'up'\n              this.canChange = false\n            }\n            break\n          case 39:\n            if (this.direction !== 'left') {\n              this.direction = 'right'\n              this.canChange = false\n            }\n            break\n          case 40:\n            if (this.direction !== 'up') {\n              this.direction = 'down'\n              this.canChange = false\n            }\n            break\n          case 32:\n            // 空格暂停与继续\n            if (!this.isStop) {\n              this.stop()\n            } else {\n              this.continue()\n            }\n            break\n        }\n      }\n    }\n    createPos() {\n      let [x, y] = this.grid[(Math.random() * this.grid.length) | 0]\n\n      for (let i = 0; i < this.snake.length; i++) {\n        if (this.snake[i][0] == x && this.snake[i][1] == y) {\n          return this.createPos()\n        }\n      }\n\n      return [x, y]\n    }\n    // 生成食物\n    createFood() {\n      this.food = this.createPos()\n\n      // 更新分数\n      score.innerHTML = 'Score: '+ this.score++\n      \n      if (this.speed > 50) {\n        this.speed--\n      }\n    }\n\n    // 结束\n    over([x, y]) {\n      if (x < 0 || x >= this.maxX || y < 0 || y >= this.maxY) {\n        return true\n      }\n      \n      if (this.snake.some(v => v[0] === x && v[1] === y)) {\n        return true\n      }\n    }\n\n    // 完成\n    completed() {\n      if (this.snake.length == this.maxX * this.maxY) {\n        return true\n      }\n    }\n\n    // 网格线\n    drawGridLine() {\n      for (let i = 1; i < this.maxY; i++) {\n        this.ctx.moveTo(0, i * this.itemWidth)\n        this.ctx.lineTo(this.canvas.width, i * this.itemWidth)\n      }\n      \n      for (let i = 1; i < this.maxX; i++) {\n        this.ctx.moveTo(i * this.itemWidth, 0)\n        this.ctx.lineTo(i * this.itemWidth, this.canvas.height)\n      }\n      this.ctx.lineWidth = 1\n      this.ctx.strokeStyle = '#ddd'\n      this.ctx.stroke()\n    }\n\n    // 绘制\n    draw() {\n      // 清空画布\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      this.drawGridLine()\n\n      this.ctx.fillStyle=\"#000\"\n      this.ctx.fillRect(\n        this.food[0] * this.itemWidth + this.j,\n        this.food[1] * this.itemWidth + this.j,\n        this.itemWidth - this.j * 2,\n        this.itemWidth -  + this.j * 2\n      )\n      this.j ^= 1\n\n      this.ctx.fillStyle=\"green\"\n      this.ctx.fillRect(\n        this.snake[0][0] * this.itemWidth + 0.5,\n        this.snake[0][1] * this.itemWidth + 0.5,\n        this.itemWidth - 1,\n        this.itemWidth - 1\n      )\n      this.ctx.fillStyle=\"red\"\n      for (let i = 1; i < this.snake.length; i++) {\n        this.ctx.fillRect(\n          this.snake[i][0] * this.itemWidth + 0.5,\n          this.snake[i][1] * this.itemWidth + 0.5,\n          this.itemWidth - 1,\n          this.itemWidth - 1\n        )\n      }\n    }\n  }\n  greedySnake = new GreedySnake()\n</script>\n</body>\n</html>\n\n```\n\n## canvas实现带笔锋手写笔记\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n    <title>canvas 手写毛笔字效果</title>\n    <style type=\"text/css\">\n      #canvasId {\n        background-color: #ffffcc;\n      }\n    </style>\n  </head>\n\n  <body style=\"touch-action: none\">\n    <canvas id=\"canvasId\" width=\"800\" height=\"720\"></canvas><br />\n    <script>\n      Array.prototype.clone = function () {\n        return [].concat(this)\n        //或者 return this.concat();\n      }\n      class Point {\n        constructor(x, y, time) {\n          this.x = x\n          this.y = y\n          this.isControl = false\n          this.time = Date.now()\n          this.lineWidth = 0\n          this.isAdd = false\n        }\n      }\n\n      class Line {\n        constructor() {\n          this.points = new Array()\n          this.changeWidthCount = 0\n          this.lineWidth = 10\n        }\n      }\n      class HandwritingSelf {\n        constructor(canvas) {\n          this.canvas = canvas\n          this.ctx = canvas.getContext(\"2d\")\n          // this.points = new Array();\n          this.line = new Line()\n          this.pointLines = new Array() //Line数组\n          this.k = 0.5\n          this.begin = null\n          this.middle = null\n          this.end = null\n          this.preTime = null\n          this.lineWidth = 8\n          this.isDown = false\n        }\n        down(x, y) {\n          this.isDown = true\n          this.line = new Line()\n          this.line.lineWidth = this.lineWidth\n          let currentPoint = new Point(x, y, Date.now())\n          this.addPoint(currentPoint)\n\n          this.preTime = Date.now()\n        }\n        move(x, y) {\n          // console.log(\"move:\",x,y)\n          if (this.isDown) {\n            let currentPoint = new Point(x, y, Date.now())\n            this.addPoint(currentPoint)\n            this.draw()\n          }\n        }\n        up(x, y) {\n          // if (e.touches.length > 0) {\n          let currentPoint = new Point(x, y, Date.now())\n          this.addPoint(currentPoint)\n          // }\n          this.draw(true)\n\n          this.pointLines.push(this.line)\n\n          this.begin = null\n          this.middle = null\n          this.end = null\n          this.isDown = false\n        }\n        draw(isUp = false) {\n          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n          this.ctx.strokeStyle = \"rgba(255,20,87,1)\"\n\n          //绘制不包含this.line的线条\n          this.pointLines.forEach((line, index) => {\n            let points = line.points\n            this.ctx.beginPath()\n            this.ctx.ellipse(\n              points[0].x - 1.5,\n              points[0].y,\n              6,\n              3,\n              Math.PI / 4,\n              0,\n              Math.PI * 2\n            )\n            this.ctx.fill()\n            this.ctx.beginPath()\n            this.ctx.moveTo(points[0].x, points[0].y)\n            let lastW = line.lineWidth\n            this.ctx.lineWidth = line.lineWidth\n            this.ctx.lineJoin = \"round\"\n            this.ctx.lineCap = \"round\"\n            let minLineW = line.lineWidth / 4\n            let isChangeW = false\n\n            let changeWidthCount = line.changeWidthCount\n            for (let i = 1; i <= points.length; i++) {\n              if (i == points.length) {\n                this.ctx.stroke()\n                break\n              }\n              if (i > points.length - changeWidthCount) {\n                if (!isChangeW) {\n                  this.ctx.stroke() //将之前的线条不变的path绘制完\n                  isChangeW = true\n                  if (i > 1 && points[i - 1].isControl) continue\n                }\n                let w =\n                  ((lastW - minLineW) / changeWidthCount) *\n                    (points.length - i) +\n                  minLineW\n                points[i - 1].lineWidth = w\n                this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍\n                // this.ctx.strokeStyle = \"rgba(\"+Math.random()*255+\",\"+Math.random()*255+\",\"+Math.random()*255+\",1)\";\n                this.ctx.lineWidth = w\n                this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点\n                this.ctx.lineTo(points[i].x, points[i].y)\n                this.ctx.stroke() //将之前的线条不变的path绘制完\n              } else {\n                if (points[i].isControl && points[i + 1]) {\n                  this.ctx.quadraticCurveTo(\n                    points[i].x,\n                    points[i].y,\n                    points[i + 1].x,\n                    points[i + 1].y\n                  )\n                } else if (i >= 1 && points[i - 1].isControl) {\n                  //上一个是控制点 当前点已经被绘制\n                } else this.ctx.lineTo(points[i].x, points[i].y)\n              }\n            }\n          })\n\n          //绘制this.line线条\n          let points\n          if (isUp) points = this.line.points\n          else points = this.line.points.clone()\n          //当前绘制的线条最后几个补点 贝塞尔方式增加点\n          let count = 0\n          let insertCount = 0\n          let i = points.length - 1\n          let endPoint = points[i]\n          let controlPoint\n          let startPoint\n          while (i >= 0) {\n            if (points[i].isControl == true) {\n              controlPoint = points[i]\n              count++\n            } else {\n              startPoint = points[i]\n            }\n            if (startPoint && controlPoint && endPoint) {\n              //使用贝塞尔计算补点\n              let dis =\n                this.z_distance(startPoint, controlPoint) +\n                this.z_distance(controlPoint, endPoint)\n              let insertPoints = this.BezierCalculate(\n                [startPoint, controlPoint, endPoint],\n                Math.floor(dis / 6) + 1\n              )\n              insertCount += insertPoints.length\n              var index = i //插入位置\n              // 把insertPoints 变成一个适合splice的数组（包含splice前2个参数的数组）\n              insertPoints.unshift(index, 1)\n              Array.prototype.splice.apply(points, insertPoints)\n\n              //补完点后\n              endPoint = startPoint\n              startPoint = null\n            }\n            if (count >= 6) break\n            i--\n          }\n          //确定最后线宽变化的点数\n          let changeWidthCount = count + insertCount\n          if (isUp) this.line.changeWidthCount = changeWidthCount\n\n          //制造椭圆头\n          this.ctx.fillStyle = \"rgba(255,20,87,1)\"\n          this.ctx.beginPath()\n          this.ctx.ellipse(\n            points[0].x - 1.5,\n            points[0].y,\n            6,\n            3,\n            Math.PI / 4,\n            0,\n            Math.PI * 2\n          )\n          this.ctx.fill()\n\n          this.ctx.beginPath()\n          this.ctx.moveTo(points[0].x, points[0].y)\n          let lastW = this.line.lineWidth\n          this.ctx.lineWidth = this.line.lineWidth\n          this.ctx.lineJoin = \"round\"\n          this.ctx.lineCap = \"round\"\n          let minLineW = this.line.lineWidth / 4\n          let isChangeW = false\n          for (let i = 1; i <= points.length; i++) {\n            if (i == points.length) {\n              this.ctx.stroke()\n              break\n            }\n            //最后的一些点线宽变细\n            if (i > points.length - changeWidthCount) {\n              if (!isChangeW) {\n                this.ctx.stroke() //将之前的线条不变的path绘制完\n                isChangeW = true\n                if (i > 1 && points[i - 1].isControl) continue\n              }\n\n              //计算线宽\n              let w =\n                ((lastW - minLineW) / changeWidthCount) * (points.length - i) +\n                minLineW\n              points[i - 1].lineWidth = w\n              this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍\n              // this.ctx.strokeStyle = \"rgba(\" + Math.random() * 255 + \",\" + Math.random() * 255 + \",\" + Math.random() * 255 + \",0.5)\";\n              this.ctx.lineWidth = w\n              this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点\n              this.ctx.lineTo(points[i].x, points[i].y)\n              this.ctx.stroke() //将之前的线条不变的path绘制完\n            } else {\n              if (points[i].isControl && points[i + 1]) {\n                this.ctx.quadraticCurveTo(\n                  points[i].x,\n                  points[i].y,\n                  points[i + 1].x,\n                  points[i + 1].y\n                )\n              } else if (i >= 1 && points[i - 1].isControl) {\n                //上一个是控制点 当前点已经被绘制\n              } else this.ctx.lineTo(points[i].x, points[i].y)\n            }\n          }\n        }\n\n        addPoint(p) {\n          if (this.line.points.length >= 1) {\n            let last_point = this.line.points[this.line.points.length - 1]\n            let distance = this.z_distance(p, last_point)\n            if (distance < 10) {\n              return\n            }\n          }\n\n          if (this.line.points.length == 0) {\n            this.begin = p\n            p.isControl = true\n            this.pushPoint(p)\n          } else {\n            this.middle = p\n            let controlPs = this.computeControlPoints(\n              this.k,\n              this.begin,\n              this.middle,\n              null\n            )\n            this.pushPoint(controlPs.first)\n            this.pushPoint(p)\n            p.isControl = true\n\n            this.begin = this.middle\n          }\n        }\n\n        addOtherPoint(p1, p2, w1, w2) {\n          let otherPoints = new Array()\n          let dis = this.z_distance(p1, p2)\n          if (dis >= 25) {\n            otherPoints.push(p1)\n            let insertPCount = Math.floor(dis / 20)\n            for (let j = 0; j < insertPCount; j++) {\n              let insertP = new Point(\n                p1.x + ((j + 1) / (insertPCount + 1)) * (p2.x - p1.x),\n                p1.y + ((j + 1) / (insertPCount + 1)) * (p2.y - p1.y)\n              )\n              insertP.isAdd = true\n              otherPoints.push(insertP)\n            }\n            otherPoints.push(p2)\n          }\n          let count = otherPoints.length\n          if (count > 0) {\n            console.log(\"addOtherPoint\")\n            debugger\n            let diffW = (w2 - w1) / (count - 1)\n            for (let i = 1; i < count; i++) {\n              let w = w1 + diffW * i\n              this.ctx.beginPath()\n              this.ctx.lineWidth = w\n              this.ctx.moveTo(otherPoints[i - 1].x, otherPoints[i - 1].y)\n              this.ctx.lineTo(otherPoints[i].x, otherPoints[i].y)\n              this.ctx.stroke()\n            }\n          }\n          return otherPoints\n        }\n        pushPoint(p) {\n          //排除重复点\n          if (\n            this.line.points.length >= 1 &&\n            this.line.points[this.line.points.length - 1].x == p.x &&\n            this.line.points[this.line.points.length - 1].y == p.y\n          )\n            return\n          this.line.points.push(p)\n        }\n        computeControlPoints(k, begin, middle, end) {\n          if (k > 0.5 || k <= 0) return\n\n          let diff1 = new Point(middle.x - begin.x, middle.y - begin.y)\n          let diff2 = null\n          if (end) diff2 = new Point(end.x - middle.x, end.y - middle.y)\n\n          // let l1 = (diff1.x ** 2 + diff1.y ** 2) ** (1 / 2)\n          // let l2 = (diff2.x ** 2 + diff2.y ** 2) ** (1 / 2)\n\n          let first = new Point(middle.x - k * diff1.x, middle.y - k * diff1.y)\n          let second = null\n          if (diff2)\n            second = new Point(middle.x + k * diff2.x, middle.y + k * diff2.y)\n          return { first: first, second: second }\n        }\n        // W_current =\n        // 　　W_previous + min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) >= 0\n        // 　　W_previous - min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) < 0\n        // 　　W_current 　　　　  当前线段的宽度\n        // 　　W_previous　　　　与当前线条相邻的前一条线段的宽度\n        // 　　distance 　　\t　　    当前线条的长度\n        // 　　w_k 　　　　　　　\t设定的一个固定阈值,表示:单位距离内, 笔迹的线条宽度可以变化的最大量.\n        // 　　distance * w_k 　　  即为当前线段的长度内, 笔宽可以相对于前一条线段笔宽的基础上, 最多能够变宽或者可以变窄多少.\n        z_linewidth(b, e, bwidth, step) {\n          if (e.time == b.time) return bwidth\n\n          let max_speed = 2.0\n          let d = this.z_distance(b, e)\n          let s = d / (e.time - b.time) //计算速度\n          console.log(\"s\", e.time - b.time, s)\n          s = s > max_speed ? max_speed : s\n\n          // let w = (max_speed - s) / max_speed;\n          let w = 0.5 / s\n\n          let max_dif = d * step\n          console.log(w, bwidth, max_dif)\n          if (w < 0.05) w = 0.05\n          if (Math.abs(w - bwidth) > max_dif) {\n            if (w > bwidth) w = bwidth + max_dif\n            else w = bwidth - max_dif\n          }\n          // printf(\"d:%.4f, time_diff:%lld, speed:%.4f, width:%.4f\\n\", d, e.t-b.t, s, w);\n          return w\n        }\n        z_distance(b, e) {\n          return Math.sqrt(Math.pow(e.x - b.x, 2) + Math.pow(e.y - b.y, 2))\n        }\n        BezierCalculate(poss, precision) {\n          //维度，坐标轴数（二维坐标，三维坐标...）\n          let dimersion = 2\n\n          //贝塞尔曲线控制点数（阶数）\n          let number = poss.length\n\n          //控制点数不小于 2 ，至少为二维坐标系\n          if (number < 2 || dimersion < 2) return null\n\n          let result = new Array()\n\n          //计算杨辉三角\n          let mi = new Array()\n          mi[0] = mi[1] = 1\n          for (let i = 3; i <= number; i++) {\n            let t = new Array()\n            for (let j = 0; j < i - 1; j++) {\n              t[j] = mi[j]\n            }\n\n            mi[0] = mi[i - 1] = 1\n            for (let j = 0; j < i - 2; j++) {\n              mi[j + 1] = t[j] + t[j + 1]\n            }\n          }\n\n          //计算坐标点\n          for (let i = 0; i < precision; i++) {\n            let t = i / precision\n            let p = new Point(0, 0)\n            p.isAdd = true\n            result.push(p)\n            for (let j = 0; j < dimersion; j++) {\n              let temp = 0.0\n              for (let k = 0; k < number; k++) {\n                temp +=\n                  Math.pow(1 - t, number - k - 1) *\n                  (j == 0 ? poss[k].x : poss[k].y) *\n                  Math.pow(t, k) *\n                  mi[k]\n              }\n              j == 0 ? (p.x = temp) : (p.y = temp)\n            }\n          }\n\n          return result\n        }\n      }\n\n      //以下代码为鼠标移动事件部分\n      let handwriting = new HandwritingSelf(document.getElementById(\"canvasId\"))\n      // document.ontouchstart = document.onmousedown\n      document.onpointerdown = function (e) {\n        if (e.type == \"touchstart\")\n          handwriting.down(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.down(e.x, e.y)\n      }\n      // document.ontouchmove = document.onmousemove\n      document.onpointermove = function (e) {\n        if (e.type == \"touchmove\")\n          handwriting.move(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.move(e.x, e.y)\n      }\n      // document.ontouchend = document.onmouseup\n      document.onpointerup = function (e) {\n        if (e.type == \"touchend\")\n          handwriting.up(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.up(e.x, e.y)\n      }\n    </script>\n  </body>\n</html>\n\n```\n\n## 代码雨\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Code</title>\n    <style>\n      body {\n        margin: 0;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n\n  <body>\n    <canvas id=\"myCanvas\"></canvas>\n    <script>\n      const width = (document.getElementById(\"myCanvas\").width = 1920) //screen.availWidth;\n      const height = (document.getElementById(\"myCanvas\").height = 1080) //screen.availHeight;\n      const ctx = document.getElementById(\"myCanvas\").getContext(\"2d\")\n      const arr = Array(Math.ceil(width / 10)).fill(0)\n      const str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".split(\"\")\n\n      function rain() {\n        ctx.fillStyle = \"rgba(0,0,0,0.05)\"\n        ctx.fillRect(0, 0, width, height)\n        ctx.fillStyle = \"#0f0\"\n        arr.forEach(function (value, index) {\n          ctx.fillText(\n            str[Math.floor(Math.random() * str.length)],\n            index * 10,\n            value + 10\n          )\n          arr[index] =\n            value >= height || value > 8888 * Math.random() ? 0 : value + 10\n        })\n      }\n\n      setInterval(rain, 30)\n    </script>\n  </body>\n</html>\n\n```\n\n## qq企鹅\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      html,\n      body,\n      div,\n      strong {\n        margin: 0;\n        padding: 0;\n      }\n      body {\n        overflow: hidden;\n      }\n      .wrap {\n        width: 600px;\n        margin: 50px auto 0;\n        position: relative;\n      }\n      /* ……………………………………………………………………企鹅头部…………………………………………………………………… */\n\n      /* 上半部分黑色头部 */\n      .headtop {\n        width: 240px;\n        height: 110px;\n        background: #000;\n        margin: 0 auto;\n        border-top-left-radius: 120px 110px;\n        border-top-right-radius: 120px 110px;\n        position: relative;\n        z-index: 999;\n      }\n      /* 下半部分黑色头部 */\n      .headbottom {\n        width: 240px;\n        height: 90px;\n        background: #000;\n        border-bottom-left-radius: 120px 90px;\n        border-bottom-right-radius: 120px 90px;\n        position: absolute;\n        top: 110px;\n        z-index: 1;\n      }\n\n      h1 {\n        position: absolute;\n      }\n      /* 左眼部分 */\n      .lefteye {\n        width: 46px;\n        height: 70px;\n        background: #fff;\n        border-radius: 50% 50%;\n        position: absolute;\n\n        top: 30px;\n        left: 64px;\n        z-index: 2;\n      }\n      .lefteye_in {\n        width: 20px;\n        height: 30px;\n        background: #000;\n        border-radius: 50% 50%;\n        margin-left: 23px;\n        margin-top: 20px;\n      }\n      .eyeshow {\n        display: block;\n        width: 8px;\n        height: 10px;\n        border-radius: 50% 50%;\n        background: #fff;\n        position: absolute;\n        top: 26px;\n        left: 32px;\n      }\n\n      /*右眼部分 */\n      .righteye {\n        width: 46px;\n        height: 70px;\n        background: #fff;\n        border-radius: 50% 50%;\n        position: absolute;\n        top: 30px;\n        left: 130px;\n        z-index: 2;\n      }\n      .righteye_in {\n        width: 19px;\n        height: 23px;\n        background: #000;\n        border-top-left-radius: 17px 30px;\n        border-top-right-radius: 17px 30px;\n        border-bottom-left-radius: 5px;\n        border-bottom-right-radius: 5px;\n        border: 1px solid #000;\n        margin-left: 7px;\n        margin-top: 16px;\n      }\n      .eyebai {\n        display: block;\n        width: 12px;\n        height: 19px;\n        border-top-left-radius: 5px 14px;\n        border-top-right-radius: 8px 14px;\n        background: #fff;\n        margin-top: 10px;\n        margin-left: 4px;\n      }\n      /*右眼部分 */\n\n      /*嘴巴*/\n      .mouth {\n        width: 158px;\n        height: 56px;\n        background: #ffa600;\n        border-radius: 50%;\n        position: absolute;\n        top: 106px;\n        left: 42px;\n        z-index: 2;\n      }\n      .mouth_bar {\n        width: 126px;\n        height: 30px;\n        background: #000;\n        position: absolute;\n        top: 142px;\n        left: 55px;\n        z-index: 2;\n        border-bottom-left-radius: 76px 96px;\n        border-bottom-right-radius: 76px 96px;\n      }\n      .mouth_bar1 {\n        width: 126px;\n        height: 20px;\n        background: #ffa600;\n        position: absolute;\n        z-index: 3;\n        border-bottom-left-radius: 104px 32px;\n        border-bottom-right-radius: 104px 32px;\n      }\n      /*嘴巴*/\n      /* ……………………………………………………………………end  企鹅头部…………………………………………………………………… */\n\n      /* ……………………………………………………………………star 企鹅身体…………………………………………………………………… */\n\n      /* 企鹅身体黑色部分 */\n      .body {\n        width: 276px;\n        height: 260px;\n        background: #000;\n        position: absolute;\n        top: 142px;\n        left: 167px;\n        border-top-left-radius: 160px 140px;\n        border-bottom-left-radius: 160px 140px;\n        border-top-right-radius: 160px 140px;\n        border-bottom-right-radius: 160px 140px;\n        z-index: 2;\n      }\n      /* 企鹅身体黑色部分 */\n\n      /* 红色围脖 */\n      .body_1 {\n        width: 264px;\n        height: 137px;\n        background: #ff0000;\n        border: 5px solid #000;\n        border-top-left-radius: 195px 100px;\n        border-bottom-left-radius: 237px 146px;\n        border-top-right-radius: 195px 100px;\n        border-bottom-right-radius: 269px 146px;\n        position: absolute;\n        bottom: 159px;\n        left: 0px;\n      }\n\n      .body_2 {\n        width: 249px;\n        height: 139px;\n        position: absolute;\n        background: #000;\n        top: -33px;\n        left: 7px;\n        border-radius: 50%;\n        border: 1px #000 solid;\n      }\n\n      .body_3 {\n        width: 241px;\n        height: 145px;\n        position: absolute;\n        background: red;\n        top: 0px;\n        left: 5px;\n        border-radius: 50%;\n      }\n      /* 红色围脖 */\n\n      /* 白色企鹅肚子 */\n      .tummy {\n        width: 240px;\n        height: 240px;\n        background: #fff;\n        position: absolute;\n        top: 11px;\n        left: 17px;\n        border-radius: 50%;\n      }\n      /* 白色企鹅肚子 */\n\n      /* 企鹅口袋 */\n      .pocket {\n        width: 58px;\n        height: 78px;\n        position: absolute;\n        top: 72px;\n        left: 19px;\n        border: 3px solid #000;\n        background: red;\n        border-top-left-radius: 20px 52px;\n        border-bottom-left-radius: 40px 40px;\n        border-top-right-radius: 0px 0px;\n        border-bottom-right-radius: 21px 21px;\n      }\n\n      .pocket .pocket_line1 {\n        width: 11px;\n        height: 43px;\n        border-bottom-left-radius: 29px 57px;\n        border-top-left-radius: 0px 0px;\n        border: 9px solid #000;\n        border-top: none;\n        border-right: none;\n        position: absolute;\n        top: 0px;\n        left: 30px;\n        -webkit-transform: rotateZ(10deg);\n        -moz-transform: rotateZ(10deg);\n        -ms-transform: rotateZ(10deg);\n        -o-transform: rotateZ(10deg);\n        transform: rotateZ(10deg);\n      }\n\n      .pocket .pocket_line2 {\n        width: 2px;\n        height: 45px;\n        border-bottom-left-radius: 11px 24px;\n        border-top-left-radius: 10px 15px;\n        border: 9px solid red;\n        border-top: none;\n        border-right: none;\n        position: absolute;\n        top: 0px;\n        left: 2px;\n      }\n\n      /* 企鹅左右手 */\n      .lefthand,\n      .righthand {\n        width: 49px;\n        height: 160px;\n        background: #000;\n        position: absolute;\n      }\n\n      .lefthand {\n        top: 20px;\n        left: -29px;\n        border-top-left-radius: 89px 166px;\n        border-top-right-radius: 6px 63px;\n        border-bottom-left-radius: 85px 194px;\n        border-bottom-right-radius: 40px 128px;\n        -webkit-transform: rotateZ(20deg);\n        -moz-transform: rotateZ(20deg);\n        -ms-transform: rotateZ(20deg);\n        -o-transform: rotateZ(20deg);\n        transform: rotateZ(20deg);\n        -webkit-animation: left_rotate 0.5s infinite;\n        -moz-animation: left_rotate 0.5s infinite;\n        -ms-animation: left_rotate 0.5s infinite;\n        -o-animation: left_rotate 0.5s infinite;\n        animation: left_rotate 0.5s infinite;\n        -webkit-animation-direction: alternate;\n        -moz-animation-direction: alternate;\n        -ms-animation-direction: alternate;\n        -o-animation-direction: alternate;\n        animation-direction: alternate;\n      }\n      .righthand {\n        top: 20px;\n        left: 258px;\n        border-top-right-radius: 89px 166px;\n        border-bottom-right-radius: 85px 194px;\n        border-top-left-radius: 6px 63px;\n        border-bottom-left-radius: 40px 128px;\n        -webkit-transform: rotateZ(-20deg);\n        -moz-transform: rotateZ(-20deg);\n        -ms-transform: rotateZ(-20deg);\n        -o-transform: rotateZ(-20deg);\n        transform: rotateZ(-20deg);\n        -webkit-animation: right_rotate 0.5s infinite;\n        -moz-animation: right_rotate 0.5s infinite;\n        -ms-animation: right_rotate 0.5s infinite;\n        -o-animation: right_rotate 0.5s infinite;\n        animation: right_rotate 0.5s infinite;\n        -webkit-animation-direction: alternate;\n        -moz-animation-direction: alternate;\n        -ms-animation-direction: alternate;\n        -o-animation-direction: alternate;\n        animation-direction: alternate;\n      }\n      /* 企鹅左右手 */\n      /* ……………………………………………………………………end 企鹅身体…………………………………………………………………… */\n\n      /* ……………………………………………………………………star 企鹅脚部…………………………………………………………………… */\n      .footer .left_footer,\n      .footer .right_footer {\n        width: 134px;\n        height: 74px;\n        position: absolute;\n        background: #ffa600;\n        border: 3px solid #000;\n        border-radius: 50%;\n        z-index: 1;\n      }\n\n      .footer .left_footer {\n        top: 347px;\n        left: 163px;\n      }\n\n      .footer .right_footer {\n        top: 347px;\n        left: 320px;\n      }\n      /* ……………………………………………………………………end 企鹅脚部…………………………………………………………………… */\n\n      @keyframes left_rotate {\n        from {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(60deg);\n        }\n\n        to {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(30deg);\n        }\n      }\n\n      @keyframes right_rotate {\n        from {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-60deg);\n        }\n\n        to {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-30deg);\n        }\n      }\n\n      @-webkit-keyframes left_rotate {\n        from {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(60deg);\n        }\n\n        to {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(30deg);\n        }\n      }\n\n      @-webkit-keyframes right_rotate {\n        from {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-60deg);\n        }\n\n        to {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-30deg);\n        }\n      }\n      @-moz-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-moz-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n      @-ms-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-ms-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n      @-o-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-o-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"wrap\">\n      <!-- 企鹅头部 -->\n      <div class=\"headtop\">\n        <div class=\"headbottom\"></div>\n        <!-- 眼睛部分 -->\n        <h1 class=\"lefteye\">\n          <p class=\"lefteye_in\">\n            <strong class=\"eyeshow\"></strong>\n          </p>\n        </h1>\n        <h1 class=\"righteye\">\n          <p class=\"righteye_in\">\n            <strong class=\"eyebai\"></strong>\n          </p>\n        </h1>\n        <!-- 嘴巴部分 -->\n        <h1 class=\"mouth\"></h1>\n        <p class=\"mouth_bar\">\n          <strong class=\"mouth_bar1\"></strong>\n        </p>\n      </div>\n\n      <!-- 企鹅头部 -->\n\n      <!-- 企鹅身体 -->\n      <div class=\"body\">\n        <div class=\"tummy\">\n          <div class=\"pocket\">\n            <div class=\"pocket_line1\">\n              <div class=\"pocket_line2\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"hand\">\n          <div class=\"lefthand\"></div>\n          <div class=\"righthand\"></div>\n        </div>\n        <div class=\"body_1\">\n          <div class=\"body_2\">\n            <div class=\"body_3\"></div>\n          </div>\n        </div>\n      </div>\n      <!-- 企鹅身体 -->\n\n      <!-- 企鹅脚丫 -->\n      <div class=\"footer\">\n        <div class=\"left_footer\"></div>\n        <div class=\"right_footer\"></div>\n      </div>\n      <!-- 企鹅脚丫 -->\n    </div>\n  </body>\n</html>\n\n```","source":"_posts/amazing.md","raw":"---\ntitle: 新鲜玩意\nauthor: DarkStrand\navatar: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/avatar.jpg\nauthorLink: DarkStrand.cn\nauthorAbout: 一个神奇的小伙\nauthorDesc: 一个神奇的小伙\ncategories: 技术\ndate: 2021-08-13 08：38：25\ncomments: true\ntags: \n - web\nkeywords: 新奇\ndescription: 各种新奇玩意\nphotos: https://cdn.jsdelivr.net/gh/Darkstranded/CDN/images/4.jpg\n---\n\n## 页面浮动多边形跟随鼠标移动\n\n![页面浮动多边形跟随鼠标移动](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e635cd6c5a0d4086ad1c2edefeb44a4e~tplv-k3u1fbpfcp-zoom-1.image)\n<!-- ![页面浮动多边形跟随鼠标移动][img1] -->\n\n```javascript\n//鼠标绘制多边形\n!(function() {\n  //封装方法，压缩之后减少文件大小\n  function get_attribute(node, attr, default_value) {\n    return node.getAttribute(attr) || default_value\n  }\n  //封装方法，压缩之后减少文件大小\n  function get_by_tagname(name) {\n    return document.getElementsByTagName(name)\n  }\n  //获取配置参数\n  function get_config_option() {\n    var scripts = get_by_tagname(\"script\"),\n      script_len = scripts.length,\n      script = scripts[script_len - 1] //当前加载的script\n    return {\n      l: script_len, //长度，用于生成id用\n      z: get_attribute(script, \"zIndex\", -1), //z-index\n      o: get_attribute(script, \"opacity\", 0.5), //opacity\n      c: get_attribute(script, \"color\", \"0,0,0\"), //color\n      n: get_attribute(script, \"count\", 99), //count\n    }\n  }\n  //设置canvas的高宽\n  function set_canvas_size() {\n    ;(canvas_width = the_canvas.width =\n      window.innerWidth ||\n      document.documentElement.clientWidth ||\n      document.body.clientWidth),\n      (canvas_height = the_canvas.height =\n        window.innerHeight ||\n        document.documentElement.clientHeight ||\n        document.body.clientHeight)\n  }\n\n  //绘制过程\n  function draw_canvas() {\n    context.clearRect(0, 0, canvas_width, canvas_height)\n    //随机的线条和当前位置联合数组\n    var e, i, d, x_dist, y_dist, dist //临时节点\n    //遍历处理每一个点\n    random_points.forEach(function(r, idx) {\n      ;(r.x += r.xa),\n        (r.y += r.ya), //移动\n        (r.xa *= r.x > canvas_width || r.x < 0 ? -1 : 1),\n        (r.ya *= r.y > canvas_height || r.y < 0 ? -1 : 1), //碰到边界，反向反弹\n        context.fillRect(r.x - 0.5, r.y - 0.5, 1, 1) //绘制一个宽高为1的点\n      //从下一个点开始\n      for (i = idx + 1; i < all_array.length; i++) {\n        e = all_array[i]\n        // 当前点存在\n        if (null !== e.x && null !== e.y) {\n          x_dist = r.x - e.x //x轴距离 l\n          y_dist = r.y - e.y //y轴距离 n\n          dist = x_dist * x_dist + y_dist * y_dist //总距离, m\n\n          dist < e.max &&\n            (e === current_point &&\n              dist >= e.max / 2 &&\n              ((r.x -= 0.03 * x_dist), (r.y -= 0.03 * y_dist)), //靠近的时候加速\n            (d = (e.max - dist) / e.max),\n            context.beginPath(),\n            (context.lineWidth = d / 2),\n            (context.strokeStyle = \"rgba(\" + config.c + \",\" + (d + 0.2) + \")\"),\n            context.moveTo(r.x, r.y),\n            context.lineTo(e.x, e.y),\n            context.stroke())\n        }\n      }\n    }),\n      frame_func(draw_canvas)\n  }\n  //创建画布，并添加到body中\n  var the_canvas = document.createElement(\"canvas\"), //画布\n    config = get_config_option(), //配置\n    canvas_id = \"c_n\" + config.l, //canvas id\n    context = the_canvas.getContext(\"2d\"),\n    canvas_width,\n    canvas_height,\n    frame_func =\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(func) {\n        window.setTimeout(func, 1000 / 45)\n      },\n    random = Math.random,\n    current_point = {\n      x: null, //当前鼠标x\n      y: null, //当前鼠标y\n      max: 20000, // 圈半径的平方\n    },\n    all_array\n  the_canvas.id = canvas_id\n  the_canvas.style.cssText =\n    \"position:fixed;top:0;left:0;z-index:\" + config.z + \";opacity:\" + config.o\n  get_by_tagname(\"body\")[0].appendChild(the_canvas)\n\n  //初始化画布大小\n  set_canvas_size()\n  window.onresize = set_canvas_size\n  //当时鼠标位置存储，离开的时候，释放当前位置信息\n  ;(window.onmousemove = function(e) {\n    e = e || window.event\n    current_point.x = e.clientX\n    current_point.y = e.clientY\n  }),\n    (window.onmouseout = function() {\n      current_point.x = null\n      current_point.y = null\n    })\n  //随机生成config.n条线位置信息\n  for (var random_points = [], i = 0; config.n > i; i++) {\n    var x = random() * canvas_width, //随机位置\n      y = random() * canvas_height,\n      xa = 2 * random() - 1, //随机运动方向\n      ya = 2 * random() - 1\n    // 随机点\n    random_points.push({\n      x: x,\n      y: y,\n      xa: xa,\n      ya: ya,\n      max: 6000, //沾附距离\n    })\n  }\n  all_array = random_points.concat([current_point])\n  //0.1秒后绘制\n  setTimeout(function() {\n    draw_canvas()\n  }, 100)\n})()\n```\n\n## 每日一言功能\n\n![每日一言功能](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b7a8b1a5b3e4577b1b67efee35b54ba~tplv-k3u1fbpfcp-zoom-1.image)\n\n```html\n<body>\n  <strong><p id=\"hitokoto\">每日一言获取中...</p></strong>\n  <script>\n    //每日一言\n    $(function() {\n      var xhr = new XMLHttpRequest()\n      xhr.open(\"get\", \"https://v1.hitokoto.cn\")\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var data = JSON.parse(xhr.responseText)\n          var hitokoto = document.getElementById(\"hitokoto\")\n          hitokoto.innerText = data.hitokoto\n        }\n      }\n      xhr.send()\n    })\n  </script>\n</body>\n```\n\n## 鼠标点击出现爱心特效\n\n![鼠标点击出现不同颜色爱心](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da17b3c0f8374b11bf92938a7cb32031~tplv-k3u1fbpfcp-zoom-1.image)\n\n```javascript\n//鼠标点击爱心\n!(function(e, t, a) {\n  function r() {\n    for (var e = 0; e < s.length; e++)\n      s[e].alpha <= 0\n        ? (t.body.removeChild(s[e].el), s.splice(e, 1))\n        : (s[e].y--,\n          (s[e].scale += 0.004),\n          (s[e].alpha -= 0.013),\n          (s[e].el.style.cssText =\n            \"left:\" +\n            s[e].x +\n            \"px;top:\" +\n            s[e].y +\n            \"px;opacity:\" +\n            s[e].alpha +\n            \";transform:scale(\" +\n            s[e].scale +\n            \",\" +\n            s[e].scale +\n            \") rotate(45deg);background:\" +\n            s[e].color +\n            \";z-index:99999\"))\n    requestAnimationFrame(r)\n  }\n  function n() {\n    var t = \"function\" == typeof e.onclick && e.onclick\n    e.onclick = function(e) {\n      t && t(), o(e)\n    }\n  }\n  function o(e) {\n    var a = t.createElement(\"div\")\n    ;(a.className = \"heart\"),\n      s.push({\n        el: a,\n        x: e.clientX - 5,\n        y: e.clientY - 5,\n        scale: 1,\n        alpha: 1,\n        color: c(),\n      }),\n      t.body.appendChild(a)\n  }\n  function i(e) {\n    var a = t.createElement(\"style\")\n    a.type = \"text/css\"\n    try {\n      a.appendChild(t.createTextNode(e))\n    } catch (t) {\n      a.styleSheet.cssText = e\n    }\n    t.getElementsByTagName(\"head\")[0].appendChild(a)\n  }\n  function c() {\n    return (\n      \"rgb(\" +\n      ~~(255 * Math.random()) +\n      \",\" +\n      ~~(255 * Math.random()) +\n      \",\" +\n      ~~(255 * Math.random()) +\n      \")\"\n    )\n  }\n  var s = []\n  ;(e.requestAnimationFrame =\n    e.requestAnimationFrame ||\n    e.webkitRequestAnimationFrame ||\n    e.mozRequestAnimationFrame ||\n    e.oRequestAnimationFrame ||\n    e.msRequestAnimationFrame ||\n    function(e) {\n      setTimeout(e, 1e3 / 60)\n    }),\n    i(\n      \".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"\n    ),\n    n(),\n    r()\n})(window, document)\n```\n\n![鼠标点击出现‘富强明主’字体](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5015800b668b4f329c0c414283c79d5a~tplv-k3u1fbpfcp-zoom-1.image)\n\n```javascript\n\n<script>\n    //定义获取词语下标\nvar a_idx = 0;\njQuery(document).ready(function($) {\n        //点击body时触发事件\n    $(\"body\").click(function(e) {\n    //需要显示的词语\n    var a = new Array(\"富强\",\"民主\", \"文明\", \"和谐\",\"自由\", \"平等\", \"公正\",\"法治\", \"爱国\", \"敬业\",\"诚信\", \"友善\");\n    //设置词语给span标签\n    var $i = $(\"<span/>\").text(a[a_idx]);\n    //下标等于原来下标+1  余 词语总数\n    a_idx = (a_idx + 1)% a.length;\n    //获取鼠标指针的位置，分别相对于文档的左和右边缘。\n    //获取x和y的指针坐标\n    var x = e.pageX, y = e.pageY;\n    //在鼠标的指针的位置给$i定义的span标签添加css样式\n    $i.css({\"z-index\" : 999999,\n        \"top\" : y - 20,\n        \"left\" : x,\n        \"position\" : \"absolute\",\n        \"font-weight\" : \"bold\",\n        \"color\" : \"#ff6651\"\n        });\n    //在body添加这个标签\n    $(\"body\").append($i);\n        //animate() 方法执行 CSS 属性集的自定义动画。\n        //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。\n        //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp\n        $i.animate({\n        //将原来的位置向上移动180\n            \"top\" : y - 180,\n                \"opacity\" : 0\n         //1500动画的速度\n        }, 1500, function() {\n        //时间到了自动删除\n            $i.remove();\n        });\n    });\n});\n\n</script>\n\n```\n\n## macOS Dock 效果\n\n![macOS中Dock效果](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdcbc5783ecd4331b40b1326ebc0143f~tplv-k3u1fbpfcp-watermark.image)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      html {\n        font-size: 15px;\n      }\n\n      body {\n        margin: 0;\n        padding: 0;\n        display: flex;\n        width: 100%;\n        min-height: 100vh;\n        overflow: hidden;\n        align-items: flex-end;\n        background-image: linear-gradient(\n          109.6deg,\n          rgba(25, 170, 209, 1) 11.3%,\n          rgba(21, 65, 249, 1) 69.9%\n        );\n      }\n\n      .glass {\n        width: 100%;\n        height: 8rem;\n        background: rgba(255, 255, 255, 0.25);\n        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n        backdrop-filter: blur(4px);\n        -webkit-backdrop-filter: blur(4px);\n        border: 1px solid rgba(255, 255, 255, 0.18);\n        display: flex;\n        justify-content: center;\n      }\n\n      .dock {\n        --scale: 1;\n\n        list-style: none;\n        margin: 0;\n        padding: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .dock li {\n        font-size: calc(6rem * var(--scale));\n        padding: 0 0.5rem;\n        cursor: default;\n\n        position: relative;\n        top: calc((6rem * var(--scale) - 6rem) / 2 * -1);\n\n        transition: 15ms all ease-out;\n      }\n\n      .dock li.loading {\n        animation: 1s loading ease-in infinite;\n      }\n\n      @keyframes loading {\n        0%,\n        100% {\n          transform: translateY(0px);\n        }\n        60% {\n          transform: translateY(-40px);\n        }\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"glass\">\n      <ul class=\"dock\">\n        <li>😃</li>\n        <li>😊</li>\n        <li>😜</li>\n        <li>😍</li>\n        <li>🤩</li>\n        <li>🥳</li>\n        <li>🥶</li>\n      </ul>\n    </div>\n\n    <script>\n      document.querySelectorAll(\".dock li\").forEach((li) => {\n        li.addEventListener(\"click\", (e) => {\n          e.currentTarget.classList.add(\"loading\")\n        })\n\n        li.addEventListener(\"mousemove\", (e) => {\n          let item = e.target\n          let itemRect = item.getBoundingClientRect()\n          let offset = Math.abs(e.clientX - itemRect.left) / itemRect.width\n\n          let prev = item.previousElementSibling || null\n          let next = item.nextElementSibling || null\n\n          let scale = 0.6\n\n          resetScale()\n\n          if (prev) {\n            prev.style.setProperty(\"--scale\", 1 + scale * Math.abs(offset - 1))\n          }\n\n          item.style.setProperty(\"--scale\", 1 + scale)\n\n          if (next) {\n            next.style.setProperty(\"--scale\", 1 + scale * offset)\n          }\n        })\n      })\n\n      document.querySelector(\".dock\").addEventListener(\"mouseleave\", (e) => {\n        resetScale()\n      })\n\n      function resetScale() {\n        document.querySelectorAll(\".dock li\").forEach((li) => {\n          li.style.setProperty(\"--scale\", 1)\n        })\n      }\n    </script>\n  </body>\n</html>\n```\n\n## canvas 实现水印\n\n```javascript\nvar watermark = {}\n\nfunction setWatermark(args) {\n  //声明一个怪异一点的变量，确保id的唯一性\n  var id = \"111.222.333.456\"\n  var xIndex = 15 //绘制文本的 x 坐标位置\n  var yIndex = 65 //绘制文本的 y 坐标位置\n  var xInterval = 25 //有多个参数时的行间间隔\n  if (document.getElementById(id) !== null) {\n    document.body.removeChild(document.getElementById(id))\n  }\n  //利用canvas绘制水印信息\n  var can = document.createElement(\"canvas\")\n  can.width = 250\n  can.height = 150\n  var cans = can.getContext(\"2d\")\n  cans.rotate((-20 * Math.PI) / 180)\n  cans.font = \"17px Vedana\"\n  // ziti yanse\n  cans.fillStyle = \"rgba(200, 200, 200, 0.30)\"\n  cans.textAlign = \"left\"\n  cans.textBaseline = \"Middle\"\n  for (let i = 0; i < args.length; i++) {\n    cans.fillText(args[i], xIndex, yIndex) //绘制水印文案\n    yIndex += xInterval //设置每行间隔\n  }\n  //创建div用于显示\n  var div = document.createElement(\"div\")\n  div.id = id\n  div.style.pointerEvents = \"none\"\n  div.style.top = \"70px\"\n  div.style.left = \"90px\"\n  div.style.position = \"fixed\"\n  div.style.zIndex = \"100000\"\n  div.style.width = document.documentElement.clientWidth - 50 + \"px\"\n  div.style.height = document.documentElement.clientHeight - 50 + \"px\"\n  //div承载水印显示\n  div.style.background =\n    \"url(\" + can.toDataURL(\"image/png\") + \") left top repeat\"\n  document.body.appendChild(div)\n  return id\n}\n\nwatermark.set = function() {\n  let args = Array.prototype.slice.apply(arguments)\n  let id = setWatermark(args)\n  // 检测如果水印被去掉了，自动给加上\n  setInterval(function() {\n    if (document.getElementById(id) === null) {\n      id = setWatermark(args)\n    }\n  }, 500)\n  //在窗口大小改变之后,自动触发加水印事件\n  window.onresize = function() {\n    setWatermark(args)\n  }\n}\nwindow.watermark = watermark\n\nwatermark.set(\"绝密档案\", \"严禁外泄\")\n```\n\n\n## canvas实现验证码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>Document</title>\n</head>\n\n<body>\n  <canvas id=\"canvas\" width=\"120\" height=\"40\"></canvas>\n  <a href=\"#\" id=\"changeImg\">看不清，换一张</a>\n  <input type=\"text\" id=\"text\">\n  <script>\n    // 随机数\n    function randomNum(min, max) {\n      return Math.floor(Math.random() * (max - min) + min);\n    }\n    /**生成一个随机色**/\n    function randomColor(min, max) {\n      var r = randomNum(min, max);\n      var g = randomNum(min, max);\n      var b = randomNum(min, max);\n      return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    }\n    drawPic();\n    document.getElementById(\"changeImg\").onclick = function (e) {\n      e.preventDefault();\n      drawPic();\n    }\n\n    var Vcode = ''\n\n    /**绘制验证码图片**/\n    function drawPic() {\n      var canvas = document.getElementById(\"canvas\");\n      var width = canvas.width;\n      var height = canvas.height;\n      var ctx = canvas.getContext('2d');\n      ctx.textBaseline = 'bottom';\n\n      /**绘制背景色**/\n      ctx.fillStyle = randomColor(180, 240); //颜色若太深可能导致看不清\n      ctx.fillRect(0, 0, width, height);\n      /**绘制文字**/\n      var str = 'ABCEFGHJKLMNPQRSTWXY123456789';\n      vCode = ''\n      for (var i = 0; i < 4; i++) {\n        var txt = str[randomNum(0, str.length)];    // 每次随机生成的数\n        vCode += txt\n        ctx.fillStyle = randomColor(50, 160);  //随机生成字体颜色\n        ctx.font = randomNum(15, 40) + 'px SimHei'; //随机生成字体大小\n        var x = 10 + i * 25;\n        var y = randomNum(25, 45);\n        var deg = randomNum(-45, 45);\n        //修改坐标原点和旋转角度\n        ctx.translate(x, y);\n        ctx.rotate(deg * Math.PI / 180);\n        ctx.fillText(txt, 0, 0);\n        //恢复坐标原点和旋转角度\n        ctx.rotate(-deg * Math.PI / 180);\n        ctx.translate(-x, -y);\n      }\n      /* *绘制干扰线* */\n      for (var i = 0; i < 4; i++) {\n        ctx.strokeStyle = randomColor(40, 180);\n        ctx.beginPath();\n        ctx.moveTo(randomNum(0, width), randomNum(0, height));\n        ctx.lineTo(randomNum(0, width), randomNum(0, height));\n        ctx.stroke();\n      }\n      /**绘制干扰点**/\n      for (var i = 0; i < 20; i++) {\n        ctx.fillStyle = randomColor(0, 255);\n        ctx.beginPath();\n        ctx.arc(randomNum(0, width), randomNum(0, height), 1, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n      console.log(\"随机生成的验证码是:::\", vCode);\n    }\n    let text = document.getElementById('text')\n    text.onblur = function(e) {\n      console.log(text.value,'value')\n      if(text.value == vCode) {\n\n      } else {\n        alert('请输入正确的验证码')\n      }\n    }\n  </script>\n</body>\n\n</html>\n```\n\n\n## 纯css实现霓虹灯效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .light {\n      position: relative;\n      padding: 25px 30px;\n      color: #03e9f4;\n      font-size: 24px;\n      text-transform: uppercase;\n      transition: 0.5s;\n      letter-spacing: 4px;\n      cursor: pointer;\n      overflow: hidden;\n      width: 200px;\n      height: 100px;\n    }\n    .light:hover {\n      background-color: #03e9f4;\n      color: #050801;\n      box-shadow: 0 0 5px #03e9f4,\n                  0 0 25px #03e9f4,\n                  0 0 50px #03e9f4,\n                  0 0 200px #03e9f4;\n    }\n    .light div {\n      position: absolute;\n    }\n    .light div:nth-child(1){\n      width: 100%;\n      height: 2px;\n      top: 0;\n      left: -100%;\n      background: linear-gradient(to right,transparent,#03e9f4);\n      animation: animate1 2s linear infinite;\n    }\n    .light div:nth-child(2){\n      width: 2px;\n      height: 100%;\n      top: -100%;\n      right: 0;\n      background: linear-gradient(to bottom,transparent,#03e9f4);\n      animation: animate2 2s linear infinite;\n      animation-delay: 0.5s;\n    }\n    .light div:nth-child(3){\n      width: 100%;\n      height: 2px;\n      bottom: 0;\n      right: -100%;\n      background: linear-gradient(to left,transparent,#03e9f4);\n      animation: animate3 2s linear infinite;\n      animation-delay: 1s;\n    }\n    .light div:nth-child(4){\n      width: 2px;\n      height: 100%;\n      bottom: -100%;\n      left: 0;\n      background: linear-gradient(to top,transparent,#03e9f4);\n      animation: animate4 2s linear infinite;\n      animation-delay: 1.5s;\n    }\n    @keyframes animate1 {\n      0% {\n        left: -100%;\n      }\n      50%,100% {\n        left: 100%;\n      }\n    }\n    @keyframes animate2 {\n      0% {\n        top: -100%;\n      }\n      50%,100% {\n        top: 100%;\n      }\n    }\n    @keyframes animate3 {\n      0% {\n        right: -100%;\n      }\n      50%,100% {\n        right: 100%;\n      }\n    }\n    @keyframes animate4 {\n      0% {\n        bottom: -100%;\n      }\n      50%,100% {\n        bottom: 100%;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"light\">\n    <div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n    Neon Button\n  </div>\n</body>\n</html>\n```\n\n\n## canvas实现刮刮乐\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <img src=\"./男1.jpg\" width=\"400\" id=\"img\" alt=\"\" />\n    <input type=\"text\" name=\"\" id=\"txt\" />\n    <!-- <canvas></canvas> -->\n    <script>\n      const oImg = document.getElementById(\"img\")\n      const txt = document.getElementById(\"txt\")\n      //oImg.readyState 图片加载状态\n      if (oImg.readyState === \"complete\") {\n        draw() //true表示已经加载完成 执行draw()方法\n      } else {\n        //图片加载完成执行draw方法\n        oImg.onload = draw\n      }\n\n      function draw() {\n        //等图片加载完成后再添加canvas画布在上面\n        let can = document.createElement(\"canvas\") //创建一个canvas画布\n        can.width = oImg.width //等于图片的宽高\n        can.height = oImg.height\n        can.style.position = \"absolute\" //canvas画布设置浮动会漂浮在图片上\n        can.style.left = oImg.offsetLeft + \"px\" //保存与画布位置一致\n        can.style.top = oImg.offsetTop + \"px\"\n        //找到图片的父级：parentNode  在oImg子元素前面添加canvas标签：insertBefore\n        oImg.parentNode.insertBefore(can, oImg) //在img前面去插入canvas标签\n        let ctx = can.getContext(\"2d\")\n        ctx.fillStyle = \"#bbb\" //刮刮乐的颜色\n        ctx.fillRect(0, 0, oImg.width, oImg.height) //填充宽度\n\n        //合成:处理合成图片的透明样式；\n        //拖拽的时候，canvas图层显示透明；destination-out：新图形与原图形重叠部分透明\n        ctx.globalCompositeOperation = \"destination-out\"\n        ctx.strokeStyle = \"#eee\" //触笔的颜色 随便  因为它终究变成透明\n        ctx.lineWidth = 30 //拖动时开始画线的线宽\n        ctx.lineCap = \"round\" //这两步是把画笔变成圆形\n\n        //按下，移动，抬起事件\n        can.onmousedown = function (e) {\n          e = e || window.event //兼容低版本IE浏览器\n          //e.pageX距离文档右边缘； offsetLeft：canvas画布距离文档的右边距离\n          let x = e.pageX - can.offsetLeft //得到的x是在canvas上的坐标值\n          let y = e.pageY - can.offsetTop\n          ctx.beginPath()\n          // ctx.moveTo(  x,y )//从哪里开始来画\n          ctx.arc(x, y, 15, 0, 6.3, false) //点第一下是画一个圆\n          ctx.fill()\n          //按下后拖拽\n          can.onmousemove = function (e) {\n            //拖动时一直执行下面\n            e = e || window.event //兼容低版本IE浏览器\n            ctx.beginPath() //拖动时开始画线\n            ctx.moveTo(x, y) //起始点\n            ctx.lineTo(e.pageX - can.offsetLeft, e.pageY - can.offsetTop) //移动的过程\n\n            //每次移动的时候，样式所在的坐标；\n            x = e.pageX - can.offsetLeft //第二次渲染刮图片效果的起始点应该在上一次的终止点\n            y = e.pageY - can.offsetTop\n            ctx.stroke() //弹出图形并恢复画布\n          }\n          document.onmouseup = function () {\n            //抬起后将事件注销\n            can.onmousemove = null\n            this.onmouseup = null\n            check() //完成后通过像素计算刮过的的百分比\n          }\n        }\n        function check() {\n          //获取画布的像素列表\n          let data = ctx.getImageData(0, 0, can.width, can.height).data\n          let n = 0 //计算透明像素的个数\n          for (let i = 0; i < data.length; i += 4) {\n            //感觉这一步比较消耗性能\n            //RGBA\n            if (\n              data[i] == 0 &&\n              data[i + 1] == 0 &&\n              data[i + 2] == 0 &&\n              data[i + 3] == 0\n            ) {\n              n++\n            }\n          }\n          let f = (n * 100) / (can.width * can.height) //算出所刮的面积的占比；\n          txt.value = `刮开面积:${f.toFixed(2)}%`\n          //刮开面积的比例\n          if (f > 30) {\n            //如果所刮的面积大于30%   则将canvas画布整体清除fillRect\n            ctx.beginPath()\n            ctx.fillRect(0, 0, can.width, can.height)\n            txt.value = \"刮开面积大于30%，全部显示\"\n          }\n        }\n      }\n    </script>\n  </body>\n</html>\n```\n\n## swiper轮播图组件\n> 拖拽、回弹物料效果是参照开源项目swiper.js做的\n```javascript\n/**\n * 轮播组件\n * @param {object} params 配置传参\n * @param {string} params.el 组件节点 class|id|<label>\n * @param {number} params.moveTime 过渡时间（毫秒）默认 300\n * @param {number} params.interval 自动播放间隔（毫秒）默认 3000\n * @param {boolean} params.loop 是否需要回路\n * @param {boolean} params.vertical 是否垂直滚动\n * @param {boolean} params.autoPaly 是否需要自动播放\n * @param {boolean} params.pagination 是否需要底部圆点\n * @param {(index: number) => void} params.slideCallback 滑动/切换结束回调\n * @author https://github.com/Hansen-hjs\n * @description \n * 移动端`swiper`组件，如果需要兼容`pc`自行修改对应的`touch`到`mouse`事件即可。现成效果预览：https://huangjingsheng.gitee.io/hjs/cv/demo/face/\n */\nfunction swiper(params) {\n    /**\n     * css class 命名列表\n     * @dec [\"滑动列表\",\"滑动item\",\"圆点容器\",\"底部圆点\",\"圆点高亮\"]\n     */\n    const classNames = [\".swiper_list\", \".swiper_item\", \".swiper_pagination\", \".swiper_dot\", \".swiper_dot_active\"];\n    /** 滑动结束函数 */\n    const slideEnd = params.slideCallback || function() {};\n    /**\n     * 组件节点\n     * @type {HTMLElement}\n     */\n    let node = null;\n    /**\n     * item列表容器\n     * @type {HTMLElement}\n     */\n    let nodeItem = null;\n    /**\n     * item节点列表\n     * @type {Array<HTMLElement>}\n     */\n    let nodeItems = [];\n    /**\n     * 圆点容器\n     * @type {HTMLElement}\n     */\n    let nodePagination = null;\n    /**\n     * 圆点节点列表\n     * @type {Array<HTMLElement>}\n     */\n    let nodePaginationItems = [];\n    /** 是否需要底部圆点 */\n    let pagination = false;\n    /** 是否需要回路 */\n    let isLoop = false;\n    /** 方向 `X => true` | `Y => false` */\n    let direction = false;\n    /** 是否需要自动播放 */\n    let autoPaly = false;\n    /** 自动播放间隔（毫秒）默认 3000 */\n    let interval = 3000;\n    /** 过渡时间（毫秒）默认 300 */\n    let moveTime = 300;\n\n    /** 设置动画 */\n    function startAnimation() {\n        nodeItem.style.transition = `${moveTime / 1000}s all`; \n    }\n\n    /** 关闭动画 */\n    function stopAnimation() {\n        nodeItem.style.transition = \"0s all\";\n    }\n\n    /**\n     * 属性样式滑动\n     * @param {number} n 移动的距离\n     */\n    function slideStyle(n) {\n        let x = 0, y = 0;\n        if (direction) {\n            y = n;\n        } else {\n            x = n;\n        }\n        nodeItem.style.transform = `translate3d(${x}px, ${y}px, 0px)`;\n    }\n\n    /**\n     * 事件开始\n     * @param {number} width 滚动容器的宽度\n     * @param {number} height 滚动容器的高度\n     */\n    function main(width, height) {\n        /**\n         * 动画帧\n         * @type {requestAnimationFrame}\n         */\n        const animation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n        /** 触摸开始时间 */\n        let startTime = 0;\n        /** 触摸结束时间 */\n        let endTime = 0;\n        /** 开始的距离 */\n        let startDistance = 0;\n        /** 结束的距离 */\n        let endDistance = 0;\n        /** 结束距离状态 */\n        let endState = 0;\n        /** 移动的距离 */\n        let moveDistance = 0;\n        /** 圆点位置 && 当前 item 索引 */\n        let index = 0;\n        /** 动画帧计数 */\n        let count = 0;\n        /** loop 帧计数 */\n        let loopCount = 0;\n        /** 移动范围 */\n        let range = direction ? height : width;\n\n        /** 获取拖动距离 */\n        function getDragDistance() {\n            /** 拖动距离 */\n            let dragDistance = 0;\n            // 默认这个公式\n            dragDistance = moveDistance + (endDistance - startDistance);\n            // 判断最大正负值\n            if ((endDistance - startDistance) >= range) {\n                dragDistance = moveDistance + range;\n            } else if ((endDistance - startDistance) <= -range) {\n                dragDistance = moveDistance - range;\n            }\n            // 没有 loop 的时候惯性拖拽\n            if (!isLoop) {\n                if ((endDistance - startDistance) > 0 && index === 0) {\n                    // console.log(\"到达最初\");\n                    dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6));\n                } else if ((endDistance - startDistance) < 0 && index === nodeItems.length - 1) {\n                    // console.log(\"到达最后\");\n                    dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6));\n                }\n            }\n            return dragDistance;\n        }\n\n        /**\n         * 判断触摸处理函数 \n         * @param {number} slideDistance 滑动的距离\n         */\n        function judgeTouch(slideDistance) {\n            //\t这里我设置了200毫秒的有效拖拽间隔\n            if ((endTime - startTime) < 200) return true;\n            // 这里判断方向（正值和负值）\n            if (slideDistance < 0) {\n                if ((endDistance - startDistance) < (slideDistance / 2)) return true;\n                return false;\n            } else {\n                if ((endDistance - startDistance) > (slideDistance / 2)) return true;\n                return false;\n            }\n        }\n\n        /** 返回原来位置 */\n        function backLocation() {\n            startAnimation();\n            slideStyle(moveDistance);\n        }\n\n        /**\n         * 滑动\n         * @param {number} slideDistance 滑动的距离\n         */\n        function slideMove(slideDistance) {\n            startAnimation();\n            slideStyle(slideDistance);\n            loopCount = 0;\n            // 判断 loop 时回到第一张或最后一张\n            if (isLoop && index < 0) {\n                // 我这里是想让滑块过渡完之后再重置位置所以加的延迟 (之前用setTimeout，快速滑动有问题，然后换成 requestAnimationFrame解决了这类问题)\n                function loopMoveMin() {\n                    loopCount += 1;\n                    if (loopCount < moveTime / 1000 * 60) return animation(loopMoveMin);\n                    stopAnimation();\n                    slideStyle(range * -(nodeItems.length - 3));\n                    // 重置一下位置\n                    moveDistance = range * -(nodeItems.length - 3);\n                }\n                loopMoveMin();\n                index = nodeItems.length - 3;\n            } else if (isLoop && index > nodeItems.length - 3) {\n                function loopMoveMax() {\n                    loopCount += 1;\n                    if (loopCount < moveTime / 1000 * 60) return animation(loopMoveMax);\n                    stopAnimation();\n                    slideStyle(0);\n                    moveDistance = 0;\n                }\n                loopMoveMax();\n                index = 0;\n            }\n            // console.log(`第${ index+1 }张`);\t// 这里可以做滑动结束回调\n            if (pagination) {\n                nodePagination.querySelector(classNames[4]).className = classNames[3].slice(1);\n                nodePaginationItems[index].classList.add(classNames[4].slice(1));\n            }\n        }\n\n        /** 判断移动 */\n        function judgeMove() {\n            // 判断是否需要执行过渡\n            if (endDistance < startDistance) {\n                // 往上滑动 or 向左滑动\n                if (judgeTouch(-range)) {\n                    // 判断有loop的时候不需要执行下面的事件\n                    if (!isLoop && moveDistance === (-(nodeItems.length - 1) * range)) return backLocation();\n                    index += 1;\n                    slideMove(moveDistance - range);\n                    moveDistance -= range;\n                    slideEnd(index);\n                } else {\n                    backLocation();\n                }\n            } else {\n                // 往下滑动 or 向右滑动\n                if (judgeTouch(range)) {\n                    if (!isLoop && moveDistance === 0) return backLocation();\n                    index -= 1;\n                    slideMove(moveDistance + range);\n                    moveDistance += range;\n                    slideEnd(index)\n                } else {\n                    backLocation();\n                }\n            }\n        }\n\n        /** 自动播放移动 */\n        function autoMove() {\n            // 这里判断 loop 的自动播放\n            if (isLoop) {\n                index += 1;\n                slideMove(moveDistance - range);\n                moveDistance -= range;\n            } else {\n                if (index >= nodeItems.length - 1) {\n                    index = 0;\n                    slideMove(0);\n                    moveDistance = 0;\n                } else {\n                    index += 1;\n                    slideMove(moveDistance - range);\n                    moveDistance -= range;\n                }\n            }\n            slideEnd(index);\n        }\n\n        /** 开始自动播放 */\n        function startAuto() {\n            count += 1;\n            if (count < interval / 1000 * 60) return animation(startAuto);\n            count = 0;\n            autoMove();\n            startAuto();\n        }\n\n        // 判断是否需要开启自动播放\n        if (autoPaly && nodeItems.length > 1) startAuto();\n\n        // 开始触摸\n        nodeItem.addEventListener(\"touchstart\", ev => {\n            startTime = Date.now();\n            count = 0;\n            loopCount = moveTime / 1000 * 60;\n            stopAnimation();\n            startDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX;\n        });\n\n        // 触摸移动\n        nodeItem.addEventListener(\"touchmove\", ev => {\n            ev.preventDefault();\n            count = 0;\n            endDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX;\n            slideStyle(getDragDistance());\n        });\n\n        // 触摸离开\n        nodeItem.addEventListener(\"touchend\", () => {\n            endTime = Date.now();\n            // 判断是否点击\n            if (endState !== endDistance) {\n                judgeMove();\n            } else {\n                backLocation();\n            }\n            // 更新位置 \n            endState = endDistance;\n            // 重新打开自动播\n            count = 0;\n        });\n    }\n\n    /**\n     * 输出回路：如果要回路的话前后增加元素\n     * @param {number} width 滚动容器的宽度\n     * @param {number} height 滚动容器的高度\n     */\n    function outputLoop(width, height) {\n        const first = nodeItems[0].cloneNode(true), last = nodeItems[nodeItems.length - 1].cloneNode(true);\n        nodeItem.insertBefore(last, nodeItems[0]);\n        nodeItem.appendChild(first);\n        nodeItems.unshift(last);\n        nodeItems.push(first);\n        if (direction) {\n            nodeItem.style.top = `${-height}px`;\n        } else {\n            nodeItem.style.left = `${-width}px`;\n        }\n    }\n\n    /**\n     * 输出动态布局\n     * @param {number} width 滚动容器的宽度\n     * @param {number} height 滚动容器的高度\n     */\n    function outputLayout(width, height) {\n        if (direction) {\n            for (let i = 0; i < nodeItems.length; i++) {\n                nodeItems[i].style.height = `${height}px`;\n            }\n        } else {\n            nodeItem.style.width = `${width * nodeItems.length}px`;\n            for (let i = 0; i < nodeItems.length; i++) {\n                nodeItems[i].style.width = `${width}px`;\n            }\n        }\n    }\n\n    /** 输出底部圆点 */\n    function outputPagination() {\n        let paginations = \"\";\n        nodePagination = node.querySelector(classNames[2]);\n        // 如果没有找到对应节点则创建一个\n        if (!nodePagination) {\n            nodePagination = document.createElement(\"div\");\n            nodePagination.className = classNames[2].slice(1);\n            node.appendChild(nodePagination);\n        }\n        for (let i = 0; i < nodeItems.length; i++) {\n            paginations += `<div class=\"${classNames[3].slice(1)}\"></div>`;\n        }\n        nodePagination.innerHTML = paginations;\n        nodePaginationItems = [...nodePagination.querySelectorAll(classNames[3])];\n        nodePagination.querySelector(classNames[3]).classList.add(classNames[4].slice(1));\n    }\n\n    /** 初始化动态布局 */\n    function initLayout() {\n        node = document.querySelector(params.el);\n        if (!node) return console.warn(\"没有可执行的节点！\");\n        nodeItem = node.querySelector(classNames[0]);\n        if (!nodeItem) return console.warn(`缺少\"${classNames[0]}\"节点！`);\n        nodeItems = [...node.querySelectorAll(classNames[1])];\n        if (nodeItems.length == 0) return console.warn(\"滑动节点个数必须大于0！\");\n        const moveWidth = node.offsetWidth, moveHeight = node.offsetHeight;\n        if (pagination) outputPagination();\n        if (isLoop) outputLoop(moveWidth, moveHeight);\n        outputLayout(moveWidth, moveHeight);\n        main(moveWidth, moveHeight);\n    }\n\n    /** 初始化参数 */\n    function initParams() {\n        if (typeof params !== \"object\") return console.warn(\"传参有误\");\n        pagination = params.pagination || false;\n        direction = params.vertical || false;\n        autoPaly = params.autoPaly || false;\n        isLoop = params.loop || false;\n        moveTime = params.moveTime || 300;\n        interval = params.interval || 3000;\n        initLayout();\n    }\n    initParams();\n}\n\n```\n\n## 图片懒加载\n>非传统实现方式，性能最优\n```javascript\n/**\n * 懒加载\n * @description 可加载`<img>`、`<video>`、`<audio>`等一些引用资源路径的标签\n * @param {object} params 传参对象\n * @param {string?} params.lazyAttr 自定义加载的属性（可选）\n * @param {\"src\"|\"background\"} params.loadType 加载的类型（默认为`src`）\n * @param {string?} params.errorPath 加载失败时显示的资源路径，仅在`loadType`设置为`src`中可用（可选）\n */\nfunction lazyLoad(params) {\n    const attr = params.lazyAttr || \"lazy\";\n    const type = params.loadType || \"src\";\n\n    /** 更新整个文档的懒加载节点 */\n    function update() {\n        const els = document.querySelectorAll(`[${attr}]`);\n        for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n            observer.observe(el);\n        }\n    }\n\n    /**\n     * 加载图片\n     * @param {HTMLImageElement} el 图片节点\n     */\n    function loadImage(el) {\n        const cache = el.src; // 缓存当前`src`加载失败时候用\n        el.src = el.getAttribute(attr);\n        el.onerror = function () {\n            el.src = params.errorPath || cache;\n        }\n    }\n\n    /**\n     * 加载单个节点\n     * @param {HTMLElement} el \n     */\n    function loadElement(el) {\n        switch (type) {\n            case \"src\":\n                loadImage(el);\n                break;\n            case \"background\":\n                el.style.backgroundImage = `url(${el.getAttribute(attr)})`;\n                break;\n        }\n        el.removeAttribute(attr);\n        observer.unobserve(el);\n    }\n\n    /** \n     * 监听器 \n     * [MDN说明](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)\n    */\n    const observer = new IntersectionObserver(function(entries) {\n        for (let i = 0; i < entries.length; i++) {\n            const item = entries[i];\n            if (item.isIntersecting) {\n                loadElement(item.target);\n            }\n        }\n    })\n\n    update();\n\n    return {\n        observer,\n        update\n    }\n}\n\n```\n\n在vue中使用指令去使用\n```javascript\nimport Vue from \"vue\";\n\n/** 添加一个加载`src`的指令 */\nconst lazySrc = lazyLoad({\n    lazyAttr: \"vlazy\",\n    errorPath: \"./img/error.jpg\"\n})\n\nVue.directive(\"v-lazy\", {\n    inserted(el, binding) {\n        el.setAttribute(\"vlazy\", binding.value); // 跟上面的对应\n        lazySrc.observer.observe(el);\n    }\n})\n\n/** 添加一个加载`background`的指令 */\nconst lazyBg = lazyLoad({\n    lazyAttr: \"vlazybg\",\n    loadType: \"background\"\n})\n\nVue.directive(\"v-lazybg\", {\n    inserted(el, binding) {\n        el.setAttribute(\"vlazybg\", binding.value); // 跟上面的对应\n        lazyBg.observer.observe(el);\n    }\n})\n\n\n```\n\n## 上传图片\n```html\n<!-- 先准备好一个input标签，然后设置type=\"file\"，最后挂载一个onchange事件 -->\n<input class=\"upload-input\" type=\"file\" name=\"picture\" onchange=\"upLoadImage(this)\">\n```\n\n```javascript\n/**\n * input上传图片\n * @param {HTMLInputElement} el \n */\nfunction upLoadImage(el) {\n    /** 上传文件 */\n    const file = el.files[0];\n    /** 上传类型数组 */\n    const types = [\"image/jpg\", \"image/png\", \"image/jpeg\", \"image/gif\"];\n    // 判断文件类型\n    if (types.indexOf(file.type) < 0) {\n        file.value = null; // 这里一定要清空当前错误的内容\n        return alert(\"文件格式只支持：jpg 和 png\");\n    }\n    // 判断大小\n    if (file.size > 2 * 1024 * 1024) {\n        file.value = null;\n        return alert(\"上传的文件不能大于2M\");\n    }\n    \n    const formData = new FormData();    // 这个是传给后台的数据\n    formData.append(\"img\", file);       // 这里`img`是跟后台约定好的`key`字段\n    console.log(formData, file);\n    // 最后POST给后台，这里我用上面的方法\n    ajax({\n        url: \"http://xxx.com/uploadImg\",\n        method: \"POST\",\n        data: {},\n        formData: formData,\n        overtime: 5000,\n        success(res) {\n            console.log(\"上传成功\", res);\n        },\n        fail(err) {\n            console.log(\"上传失败\", err);\n        },\n        timeout() {\n            console.warn(\"XMLHttpRequest 请求超时 !!!\");\n        }\n    });\n}\n\n```\n\n[base64转换和静态预览](https://github.com/Hansen-hjs/my-note/blob/master/JavaScript/upload-img.html)\n## 下拉刷新组件\n> 拖拽效果参考上面swiper的实现方式，下拉中的效果是可以自己定义的\n```javascript\n// 这里我做的不是用 window 的滚动事件，而是用最外层的绑定触摸下拉事件去实现\n// 好处是我用在Vue这类单页应用的时候，组件销毁时不用去解绑 window 的 scroll 事件\n// 但是滑动到底部事件就必须要用 window 的 scroll 事件，这点需要注意\n\n/**\n * 下拉刷新组件\n * @param {object} option 配置\n * @param {HTMLElement} option.el 下拉元素（必选）\n * @param {number} option.distance 下拉距离[px]（可选）\n * @param {number} option.deviation 顶部往下偏移量[px]（可选）\n * @param {string} option.loadIcon 下拉中的 icon html（可选）\n */\nfunction dropDownRefresh(option) {\n    const doc = document;\n    /** 整体节点 */\n    const page = option.el;\n    /** 下拉距离 */\n    const distance = option.distance || 88;\n    /** 顶部往下偏移量 */\n    const deviation = option.deviation || 0;\n    /** 顶层节点 */\n    const topNode = doc.createElement(\"div\");\n    /** 下拉时遮罩 */\n    const maskNode = doc.createElement(\"div\");\n\n    topNode.innerHTML = `<div refresh-icon style=\"transition: .2s all;\"><svg style=\"transform: rotate(90deg); display: block;\" t=\"1570593064555\" viewBox=\"0 0 1575 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"26089\" width=\"48\" height=\"48\"><path d=\"M1013.76 0v339.968H484.115692V679.778462h529.644308v339.968l529.644308-485.612308v-48.600616L1013.76 0zM243.396923 679.857231h144.462769V339.968H243.396923V679.778462z m-240.797538 0h144.462769V339.968H2.599385V679.778462z\" fill=\"#000000\" fill-opacity=\".203\" p-id=\"26090\"></path></svg></div><div refresh-loading style=\"display: none; animation: refresh-loading 1s linear infinite;\">${option.loadIcon || '<p style=\"font-size: 15px; color: #666;\">loading...</p>'}</div>`;\n    topNode.style.cssText = `width: 100%; height: ${distance}px; position: fixed; top: ${-distance + deviation}px; left: 0; z-index: 10; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; box-sizing: border-box; margin: 0; padding: 0;`;\n    maskNode.style.cssText = \"position: fixed; top: 0; left: 0; width: 100%; height: 100vh; box-sizing: border-box; margin: 0; padding: 0; background-color: rgba(0,0,0,0); z-index: 999;\";\n    page.parentNode.insertBefore(topNode, page);\n\n    /**\n     * 设置动画时间\n     * @param {number} n 秒数 \n     */\n    function setAnimation(n) {\n        page.style.transition = topNode.style.transition = n + \"s all\";\n    }\n\n    /**\n     * 设置滑动距离\n     * @param {number} n 滑动的距离（像素）\n     */\n    function setSlide(n) {\n        page.style.transform = topNode.style.transform = `translate3d(0px, ${n}px, 0px)`;\n    }\n    \n    /** 下拉提示 icon */\n    const icon = topNode.querySelector(\"[refresh-icon]\");\n    /** 下拉 loading 动画 */\n    const loading = topNode.querySelector(\"[refresh-loading]\");\n\n    return {\n        /**\n         * 监听开始刷新\n         * @param {Function} callback 下拉结束回调\n         * @param {(n: number) => void} rangeCallback 下拉状态回调\n         */\n        onRefresh(callback, rangeCallback = null) {\n            /** 顶部距离 */\n            let scrollTop = 0;\n            /** 开始距离 */\n            let startDistance = 0;\n            /** 结束距离 */\n            let endDistance = 0;\n            /** 最后移动的距离 */\n            let range = 0;\n\n            // 触摸开始\n            page.addEventListener(\"touchstart\", function (e) {\n                startDistance = e.touches[0].pageY;\n                scrollTop = 1;\n                setAnimation(0);\n            });\n\n            // 触摸移动\n            page.addEventListener(\"touchmove\", function (e) {\n                scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop;\n                // 没到达顶部就停止\n                if (scrollTop != 0) return;\n                endDistance = e.touches[0].pageY;\n                range = Math.floor(endDistance - startDistance);\n                // 判断如果是下滑才执行\n                if (range > 0) {\n                    // 阻止浏览自带的下拉效果\n                    e.preventDefault();\n                    // 物理回弹公式计算距离\n                    range = range - (range * 0.5);\n                    // 下拉时icon旋转\n                    if (range > distance) {\n                        icon.style.transform = \"rotate(180deg)\";\n                    } else {\n                        icon.style.transform = \"rotate(0deg)\";\n                    }\n                    setSlide(range);\n                    // 回调距离函数 如果有需要\n                    if (typeof rangeCallback === \"function\") rangeCallback(range);\n                }\n            });\n\n            // 触摸结束\n            page.addEventListener(\"touchend\", function () {\n                setAnimation(0.3);\n                // console.log(`移动的距离：${range}, 最大距离：${distance}`);\n                if (range > distance && range > 1 && scrollTop === 0) {\n                    setSlide(distance);\n                    doc.body.appendChild(maskNode);\n                    // 阻止往上滑动\n                    maskNode.ontouchmove = e => e.preventDefault();\n                    // 回调成功下拉到最大距离并松开函数\n                    if (typeof callback === \"function\") callback();\n                    icon.style.display = \"none\";\n                    loading.style.display = \"block\";\n                } else {\n                    setSlide(0);\n                }\n            });\n\n        },\n        /** 结束下拉 */\n        end() {\n            maskNode.parentNode.removeChild(maskNode);\n            setAnimation(0.3);\n            setSlide(0);\n            icon.style.display = \"block\";\n            loading.style.display = \"none\";\n        }\n    }\n}\n\n```\n\n## 监听滚动到底部\n```javascript\n/**\n * 监听滚动到底部\n * @param {object} options 传参对象\n * @param {number} options.distance 距离底部多少像素触发（px）\n * @param {boolean} options.once 是否为一次性（防止重复用）\n * @param {() => void} options.callback 到达底部回调函数\n */\nfunction onScrollToBottom(options) {\n    const { distance = 0, once = false, callback = null } = options;\n    const doc = document;\n    /** 滚动事件 */\n    function onScroll() {\n        /** 滚动的高度 */\n        let scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop;\n        /** 滚动条高度 */\n        let scrollHeight = doc.documentElement.scrollTop === 0 ? doc.body.scrollHeight : doc.documentElement.scrollHeight;\n        if (scrollHeight - scrollTop - distance <= window.innerHeight) {\n            if (typeof callback === \"function\") callback();\n            if (once) window.removeEventListener(\"scroll\", onScroll);\n        }\n    }\n    window.addEventListener(\"scroll\", onScroll);\n    // 必要时先执行一次\n    // onScroll(); \n}\n\n```\n\n## 音频播放组件\n```javascript\n/**\n * `AudioContext`音频组件 \n * [资料参考](https://www.cnblogs.com/Wayou/p/html5_audio_api_visualizer.html)\n * @description 解决在移动端网页上标签播放音频延迟的方案 貌似`H5`游戏引擎也是使用这个实现\n */\nfunction audioComponent() {\n    /**\n     * 音频上下文\n     * @type {AudioContext}\n     */\n    const context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext)();\n    /** \n     * @type {AnalyserNode} \n     */\n    const analyser = context.createAnalyser();;\n    /**\n     * @type {AudioBufferSourceNode}\n     */\n    let bufferNode = null;\n    /**\n     * @type {AudioBuffer}\n     */\n    let buffer = null;\n    /** 是否加载完成 */\n    let loaded = false;\n\n    analyser.fftSize = 256;\n\n    return {\n        /**\n         * 加载路径音频文件\n         * @param {string} url 音频路径\n         * @param {(res: AnalyserNode) => void} callback 加载完成回调\n         */\n        loadPath(url, callback) {\n            const XHR = new XMLHttpRequest(); \n            XHR.open(\"GET\", url, true); \n            XHR.responseType = \"arraybuffer\"; \n            // 先加载音频文件\n            XHR.onload = () => {\n                context.decodeAudioData(XHR.response, audioBuffer => {\n                    // 最后缓存音频资源\n                    buffer = audioBuffer;\n                    loaded = true;\n                    typeof callback === \"function\" && callback(analyser);\n                });\n            }\n            XHR.send(null);\n        },\n\n        /** \n         * 加载 input 音频文件\n         * @param {File} file 音频文件\n         * @param {(res: AnalyserNode) => void} callback 加载完成回调\n         */\n        loadFile(file, callback) {\n            const FR = new FileReader();\n            // 先加载音频文件\n            FR.onload = e => {\n                const res = e.target.result;\n                // 然后解码\n                context.decodeAudioData(res, audioBuffer => {\n                    // 最后缓存音频资源\n                    buffer = audioBuffer;\n                    loaded = true;\n                    typeof callback === \"function\" && callback(analyser);\n                });\n            }\n            FR.readAsArrayBuffer(file);\n        },\n\n        /** 播放音频 */\n        play() {\n            if (!loaded) return console.warn(\"音频未加载完成 !!!\");\n            // 这里有个问题，就是创建的音频对象不能缓存下来然后多次执行 start , 所以每次都要创建然后 start()\n            bufferNode = context.createBufferSource();\n            bufferNode.connect(analyser);\n            analyser.connect(context.destination);\n            bufferNode.buffer = buffer;\n            bufferNode.start(0);\n        },\n\n        /** 停止播放 */\n        stop() {\n            if (!bufferNode) return console.warn(\"音频未播放 !!!\");\n            bufferNode.stop();\n        }\n    }\n}\n\n```\n\n## 全局监听图片错误并替换到默认图片\n```javascript\nwindow.addEventListener(\"error\", e => {\n    /** 默认`base64`图片 */\n    const defaultImg = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJoAAACACAYAAADzsnDqAAANXElEQVR4Xu2dDYxcVRXHz3mz0FgjICBSgkZAQD5CwQ+Qz4BBBUEkUJpK0FAUYmms2O47d7oSmYbYnXfeLIXl01ojBAnSokRQQIWAIvEjkfBhUZGPEkMFDajgbjdu5x1zYVpmd2d25r1335uZzrkJIenec869//ubO/Pux3kIWlSBHBTAHGJoCFUAFDSFIBcFFLRcZNYgCpoykIsCClouMmsQBU0ZyEUBBS0XmTWIgqYM5KKAgpaLzBpEQVMGclFAQctFZg2ioCkDuSigoOUiswbJHLTR0dE5W7ZsWQAAB6rcnVMAETcj4vO+7z/QiVZkCtrIyMhB1Wr12wBwcic6pzFnKiAiq4wxpby1yRS0IAhuR8RFeXdK47VUYCERbWhZy2GFzEBbs2bNvMnJyc0O26qu3CnwJBHNd+eutafMQBseHj65UCg81LoJWqMTChBRZmPfqD+ZBVPQOoFP+zEVtPa10popFFDQUoinpu0r0E+gPVytVle1L43WjKNAoVC4YrZlpb4CjYhOiSOe1m1fAWa2D2JN1y8VtPa11JqzKKCgvS3OwzqjZfdZUdAUtOzoqvOsoCloCppLBdpYsNWvTpeCT/OlM5rOaBni9bZrBU1BU9BcKqBfnS7VjO9LZzSd0eJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQVPQ4lOTwEJBU9ASYBPfREFT0OJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQesgaMy8NxG9HH/Yes9CQesQaOVy+f2e560koiW9h038FitoHQKNmb8LABeJSNEYE8Qfut6yUNA6ABozfwoAfmZDi8gEIl5IRHf0FjrxWqugdQC0MAwfFZHj6obqT4i42Pf938Ubvt6praDlDFoQBMsQ8ZrpiCDifWNjYwtKpdJ47+DTfksVtBxBC8NwLxH5MwC8u8kQ3UhEl7Y/fL1TU0HLF7TrRaQVSIaIuHcQaq+lClpOoJXL5ZM8z/tlG8MyHkXR4mKxuL6Nuj1TRUHLCTRmfhAAPtEmGU9v3br13KGhIfs1u0MUBS0H0Jj5EgCwSZrjlHuJ6Iw4Bt1cV0HLGLTR0dFdtmzZ8gwivjcuCCJygzFmaVy7bqyvoGUMWhiGIyKyPMXg+0RUSWHfFabMfJ6IHIaIhwKA/e+w+oZp2qoUwxQEwdGImHYRdgwAziGin6doSteZhmF4eBRFi2rp+A9Q0FIMETP/FAA+k8LFNtONY2Njx61atep1B766zgUzn0tEP8yzYZ3Myu00yQszfxEAbnEo3k+I6LMO/fW1qx0CtFKptPPcuXOfBYD3uRxNRLzO9/2vuvTZr752CNCY+VsAMJTRIF5MROsy8h3b7erVq/fwPG8fz/PmAcA+iDhPRP4LAPZA58sDAwN/nzNnzstLly61/9Y1pedBC8PwCBF5IitF7SB6nnes7/t/zCrGbH5rs7X9Cj8TAOz/92izHRtF5E7P8+7rhlMqPQ8aM98FAGe3KX7Sak8R0RFJjZPYMfNpAHABAJwOALsn8VFnsxEAHkDEdZ36wPQ0aOVyeaHneXkdYLyHiM5KOeAtzZn5wwDwNQCwDzeui126ucYem/J9/x+unc/mr6dBY2b7AHBAXoKJyJXGmG9mES8Ign0R0QK2DAB2ziJGnc8XLHBENOOcXlZxexY0ZrYD3ok3r5xBRPe6HJBKpXJSFEVrAeBgl37b8PXAwMDAkuXLl9sPbKalJ0FbvXr1QQMDA3/JVJkmzhHx9UKhsN/y5ctfcxE/DMOFIpLX13+jJr8aRdEXisXifS7608xHT4IWBMEdiLgwS2Fa+HbyYlVmvgoAvt7BftSHXkZE12bVlp4DLQiCsxDxx1kJ0q5fRLzF9/0L260/vR4z311brkjqwrkdIn7e9/0fOHcMAD0HGjM/DQCHZCFGXJ8issQYc1NcuyAIRhAxzQmTuCHbrl8oFI5csWKF83XJngKNmQkAuu3y71FE9Hi7I8nMdhb8Xrv1O1DvbwBwtOvUET0DWi2lwYsdEL5VyP8Q0W6tKtm/l8vl+Z7n2eNHe7VTv0Udg4j3FwqFvyLibpOTk/sDQAgAxzrw7XzNsGdAY+ZbayvlDnR07uIhImp5P4GZ7ekSFwuxixrdtC+VSnPnzp17m6OdkstcrrP1BGj1KQ2cI+LIISIO+77fdGO/tqWUegkBEa/2fb/pkyozHwkA9qWwbc2ys3T/BUT8uKsdhJ4ALQiCxxFxviMmMnMjIp8zxtinyRmFmS1kdv8yVfE875DBwcFZb2sxs/0NmPiJuK6Bq4noG6kaXDPuetDCMLxMRNa46GzWPkTkVGOMveY3pTg8lPkcEX2wVT+Y+csA8J1W9dr4+1htVkt9cqWrQbMpDQBgs4gU2hCl01VeJ6Jdm8xmvwWAYxw0cBMR7dfKj+Mn22uJyO6/pipdDdq2nGapepif8c1EtHh6OHspRESectUMEdnFGPPGbP7CMFwrIhe7iCkizxpjDkzrq2tBi5HSIK0GTuyb/T5jZnsi42onQd7K79bw67nefxiGj4uIs9+01Wr1lJUrVz6cpg9dCxoz/x4APpamcznaVolooMnXpn0CPNlVW0RkyBgz3Mzf6OjonImJiQlX8Wp+RohoMI3PrgQtCIJLEfH6NB3L01ZEfmGMsVklp5Ra2qxXHLflLiI6p5nPSqVyQhRFj7iMKSLPGGNSHWHqOtBsSoOJiQl70eIdLsXK0peI3GaMsceupxRmtuf873Ec+yUi2reZzzAMl4vIiOOY9iu75W/D2WJ2HWjMfCMAfMW1UFn6E5GrjDErGoCWJNlMy6Yi4v6+79tTsjNKEAS3126jt/QTp0KhUDh4xYoVz8Sxqa/bVaCFYXiMiNilgJ4qzTJ9h2F4hYiUXHdGRM4zxtzZyG9Wp1vSPhB0G2iPiMgJrgcma38icpExZsaJDGa2qbPsrOa0NNvuqlQqe0ZR9E+nwd52dj4R3Z7Ud9eA5nA1O6kWie2iKDqzWCzavB9TShiGd4tIFmkVHiSiUxt8Vdu8IzPakbhjdYYiMmiMSfzbrytAq12Stde/Gq6suxAqYx8NL6wws30QsA8Erssb4+Pju5dKpa31jpn5cgC40nUw62+HAC0IAnvXMPU2RxYCt+lzMRHd3GCGsfuNdt/ReRGRY4wxdq1xewmCYAMiLnAe7C3QLjDG2CNIiUrHZ7SRkZGjqtXqY4la3yVGIkLGGHvocEphZju72Fkmi3IpEdkn9O2Fme1TYertokaNbWdHYrZOdhy0MAwfFJGWhwazGClXPhEx9H3fHjOfUjJeeF5HRNv3M8Mw3E9EnnfVp+l+PM87bHBw0N7XSFQ6Clrt7LzLnGaJRHBg1HBDPQiCcxAxq4R3jxHRR7a1vVKpnB1Fkc1DkkkZGBjYI81d1k6DZvOqvicTZfJ12jCjd6VSOTSKIptgJZNSv7YVBEEJEa/IJBDAq0S0ZxrfnQbN2WZzGhHS2orIK8aYvRv5YWZ7aHBKouK08ers38yaOTIyclC1WrW33e0x7ixKwxk7TqBOghannV1fN4qiE4vF4q+nNzTjmcaG2wQANtV9lnvDC9LmvFXQ3CFcISJ/ujtmPhEAfuUuTO6eXhsfH59XKpX+lyaygpZGvam2Tc/zM7O9TJLqmI27Zsb2dBsRzTiZEteLghZXsVnqR1F0WrFYfPNNx/UlCAJ72bfsMFSerj7t4p0LCprbIbuJiJZMd7l+/frCpk2bHnV0QWWbe3u0+nIReRIR7SWeczNIF9GwP0kkU9CSqNbERkTGd9ppp/mNEtsFQbAAETc4CreRiA6f7mt4ePgDhUKh4Tm1uHHtkzQiHk9Ez8W1bVRfQXOhYp2P2dKPMrPdKzw/bUhEPM73/d808sPMNqWXi1y7Tt+JpaClHfWZ9i+Oj48fWSqV/j39T66SvMz2HidHyyk7VJIX90PcPR6bZk90cbnXpofwff/JJjOafZPyeSmk2OHSVqXQortNEfGJycnJTw4NDTU87eogEd8GIpqRWjUMw3eKyGYA2CWpQr2YiG//QqHg5IdkUtE6bDfrtk3a1KIissoYs/0+QrlcPh0RRxGxZW6OZrr0ZGpR2xlmtlsyx3d4wDsWXkSWGmNuaNaAIAjWIeKXUjTwXwDwvIjsmgYwG7/ZBZsUbZtimtnDgI1SS2z8fQB4l6sG95ifLQBwAhE1PdjJzPbV2td1sl+IeInv+y6yDzXtRqag1WD7aO1T+6FOitnJ2PaExWzxXTwgJOzfSyKyzBjzo4T2bZtlDlrbLenzivZWu51ZMro11UjdtTbtRLOnV9fDoaC5VjSlvxyAW+t53trBwcE/pGxqLHMFLZZc+VWu5e1Y5PI1ip7n3Zo3YNsUU9DyYydRpDQvhq3trd6/Q78YNpGqatRSAX3VdUuJtEI/K6Bfnf08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0MpaP08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0P9H/gjHdvP/Qy/AAAAAElFTkSuQmCC';\n    /**\n     * @type {HTMLImageElement}\n     */\n    const node = e.target;\n    if (node.nodeName && node.nodeName.toLocaleLowerCase() === \"img\") {     \n        node.style.objectFit = \"cover\";\n        node.src = defaultImg;\n    }\n}, true);\n\n```\n\n## 复制功能\n翻 ``Clipboard.js`` 这个插件库源码的时候找到核心代码 ``setSelectionRange(start: number, end: number)``，百度上搜到的复制功能全部都少了这个操作，所以搜到的复制文本代码在 ios 和 IE 等一些浏览器上复制不了。\n```javascript\n/**\n * 复制文本\n * @param {string} text 复制的内容\n * @param {() => void} success 成功回调\n * @param {(tip: string) => void} fail 出错回调\n */\nfunction copyText(text, success = null, fail = null) {\n    text = text.replace(/(^\\s*)|(\\s*$)/g, \"\");\n    if (!text) {\n        typeof fail === \"function\" && fail(\"复制的内容不能为空！\");\n        return;\n    }\n    const id = \"the-clipboard\";\n    /**\n     * 粘贴板节点\n     * @type {HTMLTextAreaElement}\n     */\n    let clipboard = document.getElementById(id);\n    if (!clipboard) {\n        clipboard = document.createElement(\"textarea\");\n        clipboard.id = id;\n        clipboard.readOnly = true\n        clipboard.style.cssText = \"font-size: 15px; position: fixed; top: -1000%; left: -1000%;\";\n        document.body.appendChild(clipboard);\n    }\n    clipboard.value = text;\n    clipboard.select();\n    clipboard.setSelectionRange(0, text.length);\n    const state = document.execCommand(\"copy\");\n    if (state) {\n        typeof success === \"function\" && success();\n    } else {\n        typeof fail === \"function\" && fail(\"复制失败\");\n    }\n}\n\n```\n\n## 检测类型\n```javascript\n/**\n * 检测类型\n * @param {any} target 检测的目标\n * @returns {\"string\"|\"number\"|\"array\"|\"object\"|\"function\"|\"null\"|\"undefined\"} 只枚举一些常用的类型\n */\nfunction checkType(target) {\n    /** @type {string} */\n    const value = Object.prototype.toString.call(target);\n    const result = value.match(/\\[object (\\S*)\\]/)[1];\n    return result.toLocaleLowerCase();\n}\n\n```\n\n## 格式化日期（代码极少版）\n```javascript\n/**\n * 获取指定日期时间戳\n * @param {number} time 毫秒数\n */\nfunction getDateFormat(time = Date.now()) {\n    const date = new Date(time);\n    return `${date.toLocaleDateString()} ${date.toTimeString().slice(0, 8)}`;\n}\n\n```\n\n## js小数精度计算\n```javascript\n/**\n * 数字运算（主要用于小数点精度问题）\n * @param {number} a 前面的值\n * @param {\"+\"|\"-\"|\"*\"|\"/\"} type 计算方式\n * @param {number} b 后面的值\n * @example \n * ```js\n * // 可链式调用\n * const res = computeNumber(1.3, \"-\", 1.2).next(\"+\", 1.5).next(\"*\", 2.3).next(\"/\", 0.2).result;\n * console.log(res);\n * ```\n */\nfunction computeNumber(a, type, b) {\n    /**\n     * 获取数字小数点的长度\n     * @param {number} n 数字\n     */\n    function getDecimalLength(n) {\n        const decimal = n.toString().split(\".\")[1];\n        return decimal ? decimal.length : 0;\n    }\n    /**\n     * 修正小数点\n     * @description 防止出现 `33.33333*100000 = 3333332.9999999995` && `33.33*10 = 333.29999999999995` 这类情况做的处理\n     * @param {number} n\n     */\n    const amend = (n, precision = 15) => parseFloat(Number(n).toPrecision(precision));\n    const power = Math.pow(10, Math.max(getDecimalLength(a), getDecimalLength(b)));\n    let result = 0;\n\n    a = amend(a * power);\n    b = amend(b * power);\n\n    switch (type) {\n        case \"+\":\n            result = (a + b) / power;\n            break;\n        case \"-\":\n            result = (a - b) / power;\n            break;\n        case \"*\":\n            result = (a * b) / (power * power);\n            break;\n        case \"/\":\n            result = a / b;\n            break;\n    }\n\n    result = amend(result);\n\n    return {\n        /** 计算结果 */\n        result,\n        /**\n         * 继续计算\n         * @param {\"+\"|\"-\"|\"*\"|\"/\"} nextType 继续计算方式\n         * @param {number} nextValue 继续计算的值\n         */\n        next(nextType, nextValue) {\n            return computeNumber(result, nextType, nextValue);\n        }\n    };\n}\n\n```\n\n## 一行css适配rem\n750是设计稿的宽度：之后的单位直接1:1使用设计稿的大小，单位是rem\n```javascript\nhtml{ font-size: calc(100vw / 750); }\n```\n\n## 好用的格式化日期方法\n```javascript\n/**\n * 格式化日期\n * @param {string | number | Date} value 指定日期\n * @param {string} format 格式化的规则\n * @example\n * ```js\n * formatDate();\n * formatDate(1603264465956);\n * formatDate(1603264465956, \"h:m:s\");\n * formatDate(1603264465956, \"Y年M月D日\");\n * ```\n */\nfunction formatDate(value = Date.now(), format = \"Y-M-D h:m:s\") {\n    const formatNumber = n => `0${n}`.slice(-2);\n    const date = new Date(value);\n    const formatList = [\"Y\", \"M\", \"D\", \"h\", \"m\", \"s\"];\n    const resultList = [];\n    resultList.push(date.getFullYear().toString());\n    resultList.push(formatNumber(date.getMonth() + 1));\n    resultList.push(formatNumber(date.getDate()));\n    resultList.push(formatNumber(date.getHours()));\n    resultList.push(formatNumber(date.getMinutes()));\n    resultList.push(formatNumber(date.getSeconds()));\n    for (let i = 0; i < resultList.length; i++) {\n        format = format.replace(formatList[i], resultList[i]);\n    }\n    return format;\n}\n\n```\n\n## 网页定位\n这里使用百度定位，无论代码封装、调用方式还是位置准确性都比微信sdk那个好用太多了，包括在任何网页端；\n[文档说明](http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey)\n[获取百度地图key](http://lbsyun.baidu.com/apiconsole/key#/home)\n```javascript\n/**\n * 插入脚本\n * @param {string} link 脚本路径\n * @param {Function} callback 脚本加载完成回调\n */\nfunction insertScript(link, callback) {\n    const label = document.createElement(\"script\");\n    label.src = link;\n    label.onload = function () {\n        if (label.parentNode) label.parentNode.removeChild(label);\n        if (typeof callback === \"function\") callback();\n    }\n    document.body.appendChild(label);\n}\n\n/**\n * 获取定位信息 \n * @returns {Promise<{ city: string, districtName: string, province: string, longitude: number, latitude: number }>}\n*/\nfunction getLocationInfo() {\n    /**\n     * 使用百度定位\n     * @param {(value: any) => void} callback\n     */\n    function useBaiduLocation(callback) {\n        const geolocation = new BMap.Geolocation({\n            maximumAge: 10\n        })\n        geolocation.getCurrentPosition(function(res) {\n            console.log(\"%c 使用百度定位 >>\", \"background-color: #4e6ef2; padding: 2px 6px; color: #fff; border-radius: 2px\", res);\n            callback({\n                city: res.address.city,\n                districtName: res.address.district,\n                province: res.address.province,\n                longitude: Number(res.longitude),\n                latitude: Number(res.latitude)\n            })\n        })\n    }\n\n    return new Promise(function (resolve, reject) {\n        if (!window._baiduLocation) {\n            window._baiduLocation = function () {\n                useBaiduLocation(resolve);\n            }\n            // ak=你自己的key\n            insertScript(\"https://api.map.baidu.com/api?v=2.0&ak=66vCKv7PtNlOprFEe9kneTHEHl8DY1mR&callback=_baiduLocation\");\n        } else {\n            useBaiduLocation(resolve);\n        }\n    })\n}\n\n```\n\n## 输入保留数字``<input type=\"text\">``\n使用场景：用户在输入框输入内容时，实时过滤保持数字值显示；\n\ntips：在Firefox中设置 ``<input type=\"number\">`` 会有样式 bug\n```javascript\n/**\n * 输入只能是数字\n * @param {string | number} value 输入的值\n * @param {boolean} decimal 是否要保留小数\n * @param {boolean} negative 是否可以为负数\n */\nfunction inputOnlyNumber(value, decimal, negative) {\n    let result = value.toString().trim();\n    if (result.length === 0) return \"\";\n    const minus = (negative && result[0] == \"-\") ? \"-\" : \"\";\n    if (decimal) {\n        result = result.replace(/[^0-9.]+/ig, \"\");\n        let array = result.split(\".\");\n        if (array.length > 1) {\n            result = array[0] + \".\" + array[1];\n        }\n    } else {\n        result = result.replace(/[^0-9]+/ig, \"\");\n    }\n    return minus + result;\n}\n\n```\n\n## Intl.NumberFormat（格式化数字）\n* 现在JS提供了一个更加可用和规范化的API——Intl.NumberFormat。对于常用的货币格式化都有良好的支持。\n>推荐使用\n```javascript\nnew Intl.NumberFormat().format(123456.789);\n// 显示结果为：123,456.789\n```\n\n```javascript\nnew Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(12345.678);\n// 结果显示为：\"￥12,346\"\n```\n\n* 正则表达式 （古早的做法）\n```javascript\nconst number = 1234567;\nnumber.toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1,');\n// 结果为：1,234,567\n```\n\n* Date API\n```javascript\nconst number = 123456.789;\nnumber.toLocaleString();// 结果为：123,456.789\n```\n\n## 加密\n### base64加密\n```javascript\nvar str = 'hello';\nvar str64 = window.btoa(str);\nconsole.log('经base64编码后：'+ str64); // 经base64编码后：aGVsbG8=\nconsole.log('经base64解码后：' + window.atob(str64)); // 经base64解码后：hello\n\n```\n\n### 编码和解码字符串\n使用JS函数的``escape()``和``unescape()``，分别是编码和解码字符串\n```javascript\nvar escape1 = escape('我的名字是：Neo'); // 编码\nvar unescape1 = unescape(escape1); // 解码\nconsole.log(escape1) // %u6211%u7684%u540D%u5B57%u662F%uFF1ANeo\nconsole.log(unescape1) // \"我的名字是：Neo\"\n```\n\n## lucky-canvas【大转盘/九宫格】抽奖\n[lucky-canvas【大转盘/九宫格】抽奖](https://100px.net/)\n\n## FineBI大屏\n[FineBI大屏](https://help.fanruan.com/finebi/)\n\n## 大屏数据展示模板\n[大屏数据展示模板](https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi)\n\n## js拖动滑块验证功能\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>滑块解锁封装js方法</title>\n    <!--注：这里首次用到了iconfont的语法，即矢量图标-->\n    <link rel=\"stylesheet\" href=\"font/iconfont.css\" />\n    <style>\n      * {\n        padding: 0;\n        margin: 0;\n      }\n      #box {\n        position: relative;\n        width: 300px;\n        height: 40px;\n        margin: 0 auto;\n        margin-top: 10px;\n        background-color: #e8e8e8;\n        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);\n      }\n      .bgColor {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 40px;\n        height: 40px;\n        background-color: lightblue;\n      }\n      .txt {\n        position: absolute;\n        width: 100%;\n        height: 40px;\n        line-height: 40px;\n        font-size: 14px;\n        color: #000;\n        text-align: center;\n      }\n      .slider {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 50px;\n        height: 38px;\n        border: 1px solid #ccc;\n        background: #fff;\n        text-align: center;\n        cursor: move;\n      }\n      .slider > i {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n      }\n      .slider.active > i {\n        color: green;\n      }\n    </style>\n  </head>\n  <body>\n    <div id=\"box\" onselectstart=\"return false;\">\n      <div class=\"bgColor\"></div>\n      <div class=\"txt\">滑动解锁</div>\n      <!--给i标签添加上相应字体图标的类名即可-->\n      <div class=\"slider\"><i class=\"iconfont icon-double-right\"></i></div>\n    </div>\n    <script>\n      //一、定义了一个获取元素的方法\n      function getEle(selector) {\n        return document.querySelector(selector)\n      }\n      //二、获取到需要用到的DOM元素\n      var box = getEle(\"#box\"), //容器\n        bgColor = getEle(\".bgColor\"), //背景色\n        txt = getEle(\".txt\"), //文本\n        slider = getEle(\".slider\"), //滑块\n        icon = getEle(\".slider>i\"),\n        successMoveDistance = box.offsetWidth - slider.offsetWidth, //解锁需要滑动的距离\n        downX, //用于存放鼠标按下时的位置\n        isSuccess = false //是否解锁成功的标志，默认不成功\n\n      //三、给滑块添加鼠标按下事件\n      slider.onmousedown = mousedownHandler\n\n      //3.1鼠标按下事件的方法实现\n      function mousedownHandler(e) {\n        bgColor.style.transition = \"\"\n        slider.style.transition = \"\"\n        var e = e || window.event || e.which\n        downX = e.clientX\n        //在鼠标按下时，分别给鼠标添加移动和松开事件\n        document.onmousemove = mousemoveHandler\n        document.onmouseup = mouseupHandler\n      }\n\n      //四、定义一个获取鼠标当前需要移动多少距离的方法\n      function getOffsetX(offset, min, max) {\n        if (offset < min) {\n          offset = min\n        } else if (offset > max) {\n          offset = max\n        }\n        return offset\n      }\n\n      //3.1.1鼠标移动事件的方法实现\n      function mousemoveHandler(e) {\n        var e = e || window.event || e.which\n        var moveX = e.clientX\n        var offsetX = getOffsetX(moveX - downX, 0, successMoveDistance)\n        bgColor.style.width = offsetX + \"px\"\n        slider.style.left = offsetX + \"px\"\n\n        if (offsetX == successMoveDistance) {\n          success()\n        }\n        //如果不设置滑块滑动时会出现问题（目前还不知道为什么）\n        e.preventDefault()\n      }\n\n      //3.1.2鼠标松开事件的方法实现\n      function mouseupHandler(e) {\n        if (!isSuccess) {\n          bgColor.style.width = 0 + \"px\"\n          slider.style.left = 0 + \"px\"\n          bgColor.style.transition = \"width 0.8s linear\"\n          slider.style.transition = \"left 0.8s linear\"\n        }\n        document.onmousemove = null\n        document.onmouseup = null\n      }\n\n      //五、定义一个滑块解锁成功的方法\n      function success() {\n        isSuccess = true\n        txt.innerHTML = \"解锁成功\"\n        bgColor.style.backgroundColor = \"lightgreen\"\n        slider.className = \"slider active\"\n        icon.className = \"iconfont icon-xuanzhong\"\n        //滑动成功时，移除鼠标按下事件和鼠标移动事件\n        slider.onmousedown = null\n        document.onmousemove = null\n      }\n    </script>\n  </body>\n</html>\n\n```\n\n## canvas实现贪吃蛇\n[原文](https://juejin.cn/post/6959789039566192654#heading-14)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>贪吃蛇</title>\n  <style>\n    body {\n      background-color: #eee;\n    }\n    .container {\n      text-align: center;\n    }\n    .top {\n      margin: 20px auto;\n      width: 640px;\n    }\n    #score {\n      float: left;\n    }\n    .main {\n      position: absolute;\n      left: 50%;\n      transform: translateX(-50%);\n      width: 642px;\n      height: 402px;\n    }\n    #snake {\n      border: 1px solid #000;\n      width: 640px;\n      height: 400px;\n      display: inline-block;\n      z-index: 99;\n      background-color: rgba(0, 0, 0, .1);\n    }\n    #mask {\n      background-color: rgba(0, 0, 0, .5);\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      z-index: 100;\n      display: block;\n      color: #fff;\n      line-height: 400px;\n      text-align: center;\n      font-size: 30px;\n      cursor: pointer;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"top\">\n      <span id=\"score\">Score: 0</span>\n      <button id=\"restart\">重新开始</button>\n      <button id=\"stop\">暂停</button>\n      <button id=\"continue\">继续</button>\n    </div>\n    <div class=\"main\">\n      <canvas id=\"snake\" width=\"640\" height=\"400\"></canvas>\n      <div id=\"mask\">开始</div>\n    </div>\n  </div>\n\n<script>\n  let greedySnake = null\n  let score = document.querySelector('#score')\n  let restart = document.querySelector('#restart')\n  let stop = document.querySelector('#stop')\n  let conti = document.querySelector('#continue')\n  let mask = document.querySelector('#mask')\n\n  restart.onclick = () => {\n    if (!greedySnake.isStart) return\n    greedySnake.start()\n  }\n  stop.onclick = () => {\n    if (greedySnake.isStop || !greedySnake.isStart) return\n    greedySnake.stop()\n  }\n  conti.onclick = () => {\n    if (!greedySnake.isStop || !greedySnake.isStart) return\n    greedySnake.continue()\n  }\n  mask.onclick = () => {\n    if (!greedySnake.isStart) {\n      greedySnake.start()\n    } else {\n      greedySnake.continue()\n    }\n  }\n\n  // 大小为64 * 40\n  class GreedySnake {\n    constructor() {\n      this.canvas = document.querySelector('#snake')\n      this.ctx = this.canvas.getContext('2d')\n      this.maxX = 64          // 最大行\n      this.maxY = 40          // 最大列\n      this.itemWidth = 10     // 每个点的大小\n      this.direction = 'right'// up down right left 方向\n      this.speed = 150        // ms 速度\n      this.isStop = false     // 是否暂停\n      this.isOver = false     // 是否结束\n      this.isStart = false    // 是否开始\n      this.score = 0          // 分数\n      this.timer = null       // 移动定时器\n      this.j = 1\n      this.canChange = true\n      \n      this.grid = new Array()\n\n      for (let i = 0; i < this.maxX; i++) {\n        for (let j = 0; j < this.maxY; j++) {\n          this.grid.push([i, j])\n        } \n      }\n\n      this.drawGridLine()\n      this.getDirection()\n    }\n\n    // 开始\n    start() {\n      if (this.timer) {\n        clearTimeout(this.timer)\n      }\n      if (!this.isStart) {\n        this.isStart = true\n      }\n      this.score = 0\n      this.speed = 150\n      this.isStop = false\n      this.isOver = false\n      this.direction = 'right'\n      this.createSnake()\n      this.createFood()\n      this.draw()\n      this.move()\n      mask.style.display = 'none'\n    }\n\n    // 创建蛇主体\n    createSnake() {\n      this.snake = [\n        [4, 25],\n        [3, 25],\n        [2, 25],\n        [1, 25],\n        [0, 25]\n      ]\n    }\n\n    // 移动\n    move() {\n      if (this.isStop) return\n\n      let [x, y] = this.snake[0]\n      switch(this.direction) {\n        case 'left':\n          x--\n          break\n        case 'right':\n          x++\n          break\n        case 'up':\n          y--\n          break\n        case 'down':\n          y++\n          break\n      }\n      \n      // 如果下一步不是食物的位置\n      if (x !== this.food[0] || y !== this.food[1]) {\n        this.snake.pop()\n      } else {\n        this.createFood()\n      }\n\n      if (this.over([x, y])) {\n        this.isOver = true\n        mask.style.display = 'block'\n        mask.innerHTML = '结束'\n        return\n      }\n      if (this.completed()) {\n        mask.style.display = 'block'\n        mask.innerHTML = '恭喜您，游戏通关'\n        return\n      }\n\n      this.snake.unshift([x, y])\n      \n      this.draw()\n      this.canChange = true\n      this.timer = setTimeout(() => this.move(), this.speed)\n    }\n    \n    // 暂停游戏\n    stop() {\n      if (this.isOver) return\n      this.isStop = true\n      mask.style.display = 'block'\n      mask.innerHTML = '暂停'\n    }\n\n    // 继续游戏\n    continue() {\n      if (this.isOver) return\n      this.isStop = false\n      this.move()\n      mask.style.display = 'none'\n    }\n\n    getDirection() {\n      // 上38 下40 左37 右39 不能往相反的方向走\n      document.onkeydown = (e) => {\n        // 在贪吃蛇移动的间隔内不能连续改变两次方向\n        if (!this.canChange) return\n        switch(e.keyCode) {\n          case 37:\n            if (this.direction !== 'right') {\n              this.direction = 'left'\n              this.canChange = false\n            }\n            break\n          case 38:\n            if (this.direction !== 'down') {\n              this.direction = 'up'\n              this.canChange = false\n            }\n            break\n          case 39:\n            if (this.direction !== 'left') {\n              this.direction = 'right'\n              this.canChange = false\n            }\n            break\n          case 40:\n            if (this.direction !== 'up') {\n              this.direction = 'down'\n              this.canChange = false\n            }\n            break\n          case 32:\n            // 空格暂停与继续\n            if (!this.isStop) {\n              this.stop()\n            } else {\n              this.continue()\n            }\n            break\n        }\n      }\n    }\n    createPos() {\n      let [x, y] = this.grid[(Math.random() * this.grid.length) | 0]\n\n      for (let i = 0; i < this.snake.length; i++) {\n        if (this.snake[i][0] == x && this.snake[i][1] == y) {\n          return this.createPos()\n        }\n      }\n\n      return [x, y]\n    }\n    // 生成食物\n    createFood() {\n      this.food = this.createPos()\n\n      // 更新分数\n      score.innerHTML = 'Score: '+ this.score++\n      \n      if (this.speed > 50) {\n        this.speed--\n      }\n    }\n\n    // 结束\n    over([x, y]) {\n      if (x < 0 || x >= this.maxX || y < 0 || y >= this.maxY) {\n        return true\n      }\n      \n      if (this.snake.some(v => v[0] === x && v[1] === y)) {\n        return true\n      }\n    }\n\n    // 完成\n    completed() {\n      if (this.snake.length == this.maxX * this.maxY) {\n        return true\n      }\n    }\n\n    // 网格线\n    drawGridLine() {\n      for (let i = 1; i < this.maxY; i++) {\n        this.ctx.moveTo(0, i * this.itemWidth)\n        this.ctx.lineTo(this.canvas.width, i * this.itemWidth)\n      }\n      \n      for (let i = 1; i < this.maxX; i++) {\n        this.ctx.moveTo(i * this.itemWidth, 0)\n        this.ctx.lineTo(i * this.itemWidth, this.canvas.height)\n      }\n      this.ctx.lineWidth = 1\n      this.ctx.strokeStyle = '#ddd'\n      this.ctx.stroke()\n    }\n\n    // 绘制\n    draw() {\n      // 清空画布\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      this.drawGridLine()\n\n      this.ctx.fillStyle=\"#000\"\n      this.ctx.fillRect(\n        this.food[0] * this.itemWidth + this.j,\n        this.food[1] * this.itemWidth + this.j,\n        this.itemWidth - this.j * 2,\n        this.itemWidth -  + this.j * 2\n      )\n      this.j ^= 1\n\n      this.ctx.fillStyle=\"green\"\n      this.ctx.fillRect(\n        this.snake[0][0] * this.itemWidth + 0.5,\n        this.snake[0][1] * this.itemWidth + 0.5,\n        this.itemWidth - 1,\n        this.itemWidth - 1\n      )\n      this.ctx.fillStyle=\"red\"\n      for (let i = 1; i < this.snake.length; i++) {\n        this.ctx.fillRect(\n          this.snake[i][0] * this.itemWidth + 0.5,\n          this.snake[i][1] * this.itemWidth + 0.5,\n          this.itemWidth - 1,\n          this.itemWidth - 1\n        )\n      }\n    }\n  }\n  greedySnake = new GreedySnake()\n</script>\n</body>\n</html>\n\n```\n\n## canvas实现带笔锋手写笔记\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n    <title>canvas 手写毛笔字效果</title>\n    <style type=\"text/css\">\n      #canvasId {\n        background-color: #ffffcc;\n      }\n    </style>\n  </head>\n\n  <body style=\"touch-action: none\">\n    <canvas id=\"canvasId\" width=\"800\" height=\"720\"></canvas><br />\n    <script>\n      Array.prototype.clone = function () {\n        return [].concat(this)\n        //或者 return this.concat();\n      }\n      class Point {\n        constructor(x, y, time) {\n          this.x = x\n          this.y = y\n          this.isControl = false\n          this.time = Date.now()\n          this.lineWidth = 0\n          this.isAdd = false\n        }\n      }\n\n      class Line {\n        constructor() {\n          this.points = new Array()\n          this.changeWidthCount = 0\n          this.lineWidth = 10\n        }\n      }\n      class HandwritingSelf {\n        constructor(canvas) {\n          this.canvas = canvas\n          this.ctx = canvas.getContext(\"2d\")\n          // this.points = new Array();\n          this.line = new Line()\n          this.pointLines = new Array() //Line数组\n          this.k = 0.5\n          this.begin = null\n          this.middle = null\n          this.end = null\n          this.preTime = null\n          this.lineWidth = 8\n          this.isDown = false\n        }\n        down(x, y) {\n          this.isDown = true\n          this.line = new Line()\n          this.line.lineWidth = this.lineWidth\n          let currentPoint = new Point(x, y, Date.now())\n          this.addPoint(currentPoint)\n\n          this.preTime = Date.now()\n        }\n        move(x, y) {\n          // console.log(\"move:\",x,y)\n          if (this.isDown) {\n            let currentPoint = new Point(x, y, Date.now())\n            this.addPoint(currentPoint)\n            this.draw()\n          }\n        }\n        up(x, y) {\n          // if (e.touches.length > 0) {\n          let currentPoint = new Point(x, y, Date.now())\n          this.addPoint(currentPoint)\n          // }\n          this.draw(true)\n\n          this.pointLines.push(this.line)\n\n          this.begin = null\n          this.middle = null\n          this.end = null\n          this.isDown = false\n        }\n        draw(isUp = false) {\n          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n          this.ctx.strokeStyle = \"rgba(255,20,87,1)\"\n\n          //绘制不包含this.line的线条\n          this.pointLines.forEach((line, index) => {\n            let points = line.points\n            this.ctx.beginPath()\n            this.ctx.ellipse(\n              points[0].x - 1.5,\n              points[0].y,\n              6,\n              3,\n              Math.PI / 4,\n              0,\n              Math.PI * 2\n            )\n            this.ctx.fill()\n            this.ctx.beginPath()\n            this.ctx.moveTo(points[0].x, points[0].y)\n            let lastW = line.lineWidth\n            this.ctx.lineWidth = line.lineWidth\n            this.ctx.lineJoin = \"round\"\n            this.ctx.lineCap = \"round\"\n            let minLineW = line.lineWidth / 4\n            let isChangeW = false\n\n            let changeWidthCount = line.changeWidthCount\n            for (let i = 1; i <= points.length; i++) {\n              if (i == points.length) {\n                this.ctx.stroke()\n                break\n              }\n              if (i > points.length - changeWidthCount) {\n                if (!isChangeW) {\n                  this.ctx.stroke() //将之前的线条不变的path绘制完\n                  isChangeW = true\n                  if (i > 1 && points[i - 1].isControl) continue\n                }\n                let w =\n                  ((lastW - minLineW) / changeWidthCount) *\n                    (points.length - i) +\n                  minLineW\n                points[i - 1].lineWidth = w\n                this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍\n                // this.ctx.strokeStyle = \"rgba(\"+Math.random()*255+\",\"+Math.random()*255+\",\"+Math.random()*255+\",1)\";\n                this.ctx.lineWidth = w\n                this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点\n                this.ctx.lineTo(points[i].x, points[i].y)\n                this.ctx.stroke() //将之前的线条不变的path绘制完\n              } else {\n                if (points[i].isControl && points[i + 1]) {\n                  this.ctx.quadraticCurveTo(\n                    points[i].x,\n                    points[i].y,\n                    points[i + 1].x,\n                    points[i + 1].y\n                  )\n                } else if (i >= 1 && points[i - 1].isControl) {\n                  //上一个是控制点 当前点已经被绘制\n                } else this.ctx.lineTo(points[i].x, points[i].y)\n              }\n            }\n          })\n\n          //绘制this.line线条\n          let points\n          if (isUp) points = this.line.points\n          else points = this.line.points.clone()\n          //当前绘制的线条最后几个补点 贝塞尔方式增加点\n          let count = 0\n          let insertCount = 0\n          let i = points.length - 1\n          let endPoint = points[i]\n          let controlPoint\n          let startPoint\n          while (i >= 0) {\n            if (points[i].isControl == true) {\n              controlPoint = points[i]\n              count++\n            } else {\n              startPoint = points[i]\n            }\n            if (startPoint && controlPoint && endPoint) {\n              //使用贝塞尔计算补点\n              let dis =\n                this.z_distance(startPoint, controlPoint) +\n                this.z_distance(controlPoint, endPoint)\n              let insertPoints = this.BezierCalculate(\n                [startPoint, controlPoint, endPoint],\n                Math.floor(dis / 6) + 1\n              )\n              insertCount += insertPoints.length\n              var index = i //插入位置\n              // 把insertPoints 变成一个适合splice的数组（包含splice前2个参数的数组）\n              insertPoints.unshift(index, 1)\n              Array.prototype.splice.apply(points, insertPoints)\n\n              //补完点后\n              endPoint = startPoint\n              startPoint = null\n            }\n            if (count >= 6) break\n            i--\n          }\n          //确定最后线宽变化的点数\n          let changeWidthCount = count + insertCount\n          if (isUp) this.line.changeWidthCount = changeWidthCount\n\n          //制造椭圆头\n          this.ctx.fillStyle = \"rgba(255,20,87,1)\"\n          this.ctx.beginPath()\n          this.ctx.ellipse(\n            points[0].x - 1.5,\n            points[0].y,\n            6,\n            3,\n            Math.PI / 4,\n            0,\n            Math.PI * 2\n          )\n          this.ctx.fill()\n\n          this.ctx.beginPath()\n          this.ctx.moveTo(points[0].x, points[0].y)\n          let lastW = this.line.lineWidth\n          this.ctx.lineWidth = this.line.lineWidth\n          this.ctx.lineJoin = \"round\"\n          this.ctx.lineCap = \"round\"\n          let minLineW = this.line.lineWidth / 4\n          let isChangeW = false\n          for (let i = 1; i <= points.length; i++) {\n            if (i == points.length) {\n              this.ctx.stroke()\n              break\n            }\n            //最后的一些点线宽变细\n            if (i > points.length - changeWidthCount) {\n              if (!isChangeW) {\n                this.ctx.stroke() //将之前的线条不变的path绘制完\n                isChangeW = true\n                if (i > 1 && points[i - 1].isControl) continue\n              }\n\n              //计算线宽\n              let w =\n                ((lastW - minLineW) / changeWidthCount) * (points.length - i) +\n                minLineW\n              points[i - 1].lineWidth = w\n              this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍\n              // this.ctx.strokeStyle = \"rgba(\" + Math.random() * 255 + \",\" + Math.random() * 255 + \",\" + Math.random() * 255 + \",0.5)\";\n              this.ctx.lineWidth = w\n              this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点\n              this.ctx.lineTo(points[i].x, points[i].y)\n              this.ctx.stroke() //将之前的线条不变的path绘制完\n            } else {\n              if (points[i].isControl && points[i + 1]) {\n                this.ctx.quadraticCurveTo(\n                  points[i].x,\n                  points[i].y,\n                  points[i + 1].x,\n                  points[i + 1].y\n                )\n              } else if (i >= 1 && points[i - 1].isControl) {\n                //上一个是控制点 当前点已经被绘制\n              } else this.ctx.lineTo(points[i].x, points[i].y)\n            }\n          }\n        }\n\n        addPoint(p) {\n          if (this.line.points.length >= 1) {\n            let last_point = this.line.points[this.line.points.length - 1]\n            let distance = this.z_distance(p, last_point)\n            if (distance < 10) {\n              return\n            }\n          }\n\n          if (this.line.points.length == 0) {\n            this.begin = p\n            p.isControl = true\n            this.pushPoint(p)\n          } else {\n            this.middle = p\n            let controlPs = this.computeControlPoints(\n              this.k,\n              this.begin,\n              this.middle,\n              null\n            )\n            this.pushPoint(controlPs.first)\n            this.pushPoint(p)\n            p.isControl = true\n\n            this.begin = this.middle\n          }\n        }\n\n        addOtherPoint(p1, p2, w1, w2) {\n          let otherPoints = new Array()\n          let dis = this.z_distance(p1, p2)\n          if (dis >= 25) {\n            otherPoints.push(p1)\n            let insertPCount = Math.floor(dis / 20)\n            for (let j = 0; j < insertPCount; j++) {\n              let insertP = new Point(\n                p1.x + ((j + 1) / (insertPCount + 1)) * (p2.x - p1.x),\n                p1.y + ((j + 1) / (insertPCount + 1)) * (p2.y - p1.y)\n              )\n              insertP.isAdd = true\n              otherPoints.push(insertP)\n            }\n            otherPoints.push(p2)\n          }\n          let count = otherPoints.length\n          if (count > 0) {\n            console.log(\"addOtherPoint\")\n            debugger\n            let diffW = (w2 - w1) / (count - 1)\n            for (let i = 1; i < count; i++) {\n              let w = w1 + diffW * i\n              this.ctx.beginPath()\n              this.ctx.lineWidth = w\n              this.ctx.moveTo(otherPoints[i - 1].x, otherPoints[i - 1].y)\n              this.ctx.lineTo(otherPoints[i].x, otherPoints[i].y)\n              this.ctx.stroke()\n            }\n          }\n          return otherPoints\n        }\n        pushPoint(p) {\n          //排除重复点\n          if (\n            this.line.points.length >= 1 &&\n            this.line.points[this.line.points.length - 1].x == p.x &&\n            this.line.points[this.line.points.length - 1].y == p.y\n          )\n            return\n          this.line.points.push(p)\n        }\n        computeControlPoints(k, begin, middle, end) {\n          if (k > 0.5 || k <= 0) return\n\n          let diff1 = new Point(middle.x - begin.x, middle.y - begin.y)\n          let diff2 = null\n          if (end) diff2 = new Point(end.x - middle.x, end.y - middle.y)\n\n          // let l1 = (diff1.x ** 2 + diff1.y ** 2) ** (1 / 2)\n          // let l2 = (diff2.x ** 2 + diff2.y ** 2) ** (1 / 2)\n\n          let first = new Point(middle.x - k * diff1.x, middle.y - k * diff1.y)\n          let second = null\n          if (diff2)\n            second = new Point(middle.x + k * diff2.x, middle.y + k * diff2.y)\n          return { first: first, second: second }\n        }\n        // W_current =\n        // 　　W_previous + min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) >= 0\n        // 　　W_previous - min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) < 0\n        // 　　W_current 　　　　  当前线段的宽度\n        // 　　W_previous　　　　与当前线条相邻的前一条线段的宽度\n        // 　　distance 　　\t　　    当前线条的长度\n        // 　　w_k 　　　　　　　\t设定的一个固定阈值,表示:单位距离内, 笔迹的线条宽度可以变化的最大量.\n        // 　　distance * w_k 　　  即为当前线段的长度内, 笔宽可以相对于前一条线段笔宽的基础上, 最多能够变宽或者可以变窄多少.\n        z_linewidth(b, e, bwidth, step) {\n          if (e.time == b.time) return bwidth\n\n          let max_speed = 2.0\n          let d = this.z_distance(b, e)\n          let s = d / (e.time - b.time) //计算速度\n          console.log(\"s\", e.time - b.time, s)\n          s = s > max_speed ? max_speed : s\n\n          // let w = (max_speed - s) / max_speed;\n          let w = 0.5 / s\n\n          let max_dif = d * step\n          console.log(w, bwidth, max_dif)\n          if (w < 0.05) w = 0.05\n          if (Math.abs(w - bwidth) > max_dif) {\n            if (w > bwidth) w = bwidth + max_dif\n            else w = bwidth - max_dif\n          }\n          // printf(\"d:%.4f, time_diff:%lld, speed:%.4f, width:%.4f\\n\", d, e.t-b.t, s, w);\n          return w\n        }\n        z_distance(b, e) {\n          return Math.sqrt(Math.pow(e.x - b.x, 2) + Math.pow(e.y - b.y, 2))\n        }\n        BezierCalculate(poss, precision) {\n          //维度，坐标轴数（二维坐标，三维坐标...）\n          let dimersion = 2\n\n          //贝塞尔曲线控制点数（阶数）\n          let number = poss.length\n\n          //控制点数不小于 2 ，至少为二维坐标系\n          if (number < 2 || dimersion < 2) return null\n\n          let result = new Array()\n\n          //计算杨辉三角\n          let mi = new Array()\n          mi[0] = mi[1] = 1\n          for (let i = 3; i <= number; i++) {\n            let t = new Array()\n            for (let j = 0; j < i - 1; j++) {\n              t[j] = mi[j]\n            }\n\n            mi[0] = mi[i - 1] = 1\n            for (let j = 0; j < i - 2; j++) {\n              mi[j + 1] = t[j] + t[j + 1]\n            }\n          }\n\n          //计算坐标点\n          for (let i = 0; i < precision; i++) {\n            let t = i / precision\n            let p = new Point(0, 0)\n            p.isAdd = true\n            result.push(p)\n            for (let j = 0; j < dimersion; j++) {\n              let temp = 0.0\n              for (let k = 0; k < number; k++) {\n                temp +=\n                  Math.pow(1 - t, number - k - 1) *\n                  (j == 0 ? poss[k].x : poss[k].y) *\n                  Math.pow(t, k) *\n                  mi[k]\n              }\n              j == 0 ? (p.x = temp) : (p.y = temp)\n            }\n          }\n\n          return result\n        }\n      }\n\n      //以下代码为鼠标移动事件部分\n      let handwriting = new HandwritingSelf(document.getElementById(\"canvasId\"))\n      // document.ontouchstart = document.onmousedown\n      document.onpointerdown = function (e) {\n        if (e.type == \"touchstart\")\n          handwriting.down(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.down(e.x, e.y)\n      }\n      // document.ontouchmove = document.onmousemove\n      document.onpointermove = function (e) {\n        if (e.type == \"touchmove\")\n          handwriting.move(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.move(e.x, e.y)\n      }\n      // document.ontouchend = document.onmouseup\n      document.onpointerup = function (e) {\n        if (e.type == \"touchend\")\n          handwriting.up(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.up(e.x, e.y)\n      }\n    </script>\n  </body>\n</html>\n\n```\n\n## 代码雨\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Code</title>\n    <style>\n      body {\n        margin: 0;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n\n  <body>\n    <canvas id=\"myCanvas\"></canvas>\n    <script>\n      const width = (document.getElementById(\"myCanvas\").width = 1920) //screen.availWidth;\n      const height = (document.getElementById(\"myCanvas\").height = 1080) //screen.availHeight;\n      const ctx = document.getElementById(\"myCanvas\").getContext(\"2d\")\n      const arr = Array(Math.ceil(width / 10)).fill(0)\n      const str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".split(\"\")\n\n      function rain() {\n        ctx.fillStyle = \"rgba(0,0,0,0.05)\"\n        ctx.fillRect(0, 0, width, height)\n        ctx.fillStyle = \"#0f0\"\n        arr.forEach(function (value, index) {\n          ctx.fillText(\n            str[Math.floor(Math.random() * str.length)],\n            index * 10,\n            value + 10\n          )\n          arr[index] =\n            value >= height || value > 8888 * Math.random() ? 0 : value + 10\n        })\n      }\n\n      setInterval(rain, 30)\n    </script>\n  </body>\n</html>\n\n```\n\n## qq企鹅\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      html,\n      body,\n      div,\n      strong {\n        margin: 0;\n        padding: 0;\n      }\n      body {\n        overflow: hidden;\n      }\n      .wrap {\n        width: 600px;\n        margin: 50px auto 0;\n        position: relative;\n      }\n      /* ……………………………………………………………………企鹅头部…………………………………………………………………… */\n\n      /* 上半部分黑色头部 */\n      .headtop {\n        width: 240px;\n        height: 110px;\n        background: #000;\n        margin: 0 auto;\n        border-top-left-radius: 120px 110px;\n        border-top-right-radius: 120px 110px;\n        position: relative;\n        z-index: 999;\n      }\n      /* 下半部分黑色头部 */\n      .headbottom {\n        width: 240px;\n        height: 90px;\n        background: #000;\n        border-bottom-left-radius: 120px 90px;\n        border-bottom-right-radius: 120px 90px;\n        position: absolute;\n        top: 110px;\n        z-index: 1;\n      }\n\n      h1 {\n        position: absolute;\n      }\n      /* 左眼部分 */\n      .lefteye {\n        width: 46px;\n        height: 70px;\n        background: #fff;\n        border-radius: 50% 50%;\n        position: absolute;\n\n        top: 30px;\n        left: 64px;\n        z-index: 2;\n      }\n      .lefteye_in {\n        width: 20px;\n        height: 30px;\n        background: #000;\n        border-radius: 50% 50%;\n        margin-left: 23px;\n        margin-top: 20px;\n      }\n      .eyeshow {\n        display: block;\n        width: 8px;\n        height: 10px;\n        border-radius: 50% 50%;\n        background: #fff;\n        position: absolute;\n        top: 26px;\n        left: 32px;\n      }\n\n      /*右眼部分 */\n      .righteye {\n        width: 46px;\n        height: 70px;\n        background: #fff;\n        border-radius: 50% 50%;\n        position: absolute;\n        top: 30px;\n        left: 130px;\n        z-index: 2;\n      }\n      .righteye_in {\n        width: 19px;\n        height: 23px;\n        background: #000;\n        border-top-left-radius: 17px 30px;\n        border-top-right-radius: 17px 30px;\n        border-bottom-left-radius: 5px;\n        border-bottom-right-radius: 5px;\n        border: 1px solid #000;\n        margin-left: 7px;\n        margin-top: 16px;\n      }\n      .eyebai {\n        display: block;\n        width: 12px;\n        height: 19px;\n        border-top-left-radius: 5px 14px;\n        border-top-right-radius: 8px 14px;\n        background: #fff;\n        margin-top: 10px;\n        margin-left: 4px;\n      }\n      /*右眼部分 */\n\n      /*嘴巴*/\n      .mouth {\n        width: 158px;\n        height: 56px;\n        background: #ffa600;\n        border-radius: 50%;\n        position: absolute;\n        top: 106px;\n        left: 42px;\n        z-index: 2;\n      }\n      .mouth_bar {\n        width: 126px;\n        height: 30px;\n        background: #000;\n        position: absolute;\n        top: 142px;\n        left: 55px;\n        z-index: 2;\n        border-bottom-left-radius: 76px 96px;\n        border-bottom-right-radius: 76px 96px;\n      }\n      .mouth_bar1 {\n        width: 126px;\n        height: 20px;\n        background: #ffa600;\n        position: absolute;\n        z-index: 3;\n        border-bottom-left-radius: 104px 32px;\n        border-bottom-right-radius: 104px 32px;\n      }\n      /*嘴巴*/\n      /* ……………………………………………………………………end  企鹅头部…………………………………………………………………… */\n\n      /* ……………………………………………………………………star 企鹅身体…………………………………………………………………… */\n\n      /* 企鹅身体黑色部分 */\n      .body {\n        width: 276px;\n        height: 260px;\n        background: #000;\n        position: absolute;\n        top: 142px;\n        left: 167px;\n        border-top-left-radius: 160px 140px;\n        border-bottom-left-radius: 160px 140px;\n        border-top-right-radius: 160px 140px;\n        border-bottom-right-radius: 160px 140px;\n        z-index: 2;\n      }\n      /* 企鹅身体黑色部分 */\n\n      /* 红色围脖 */\n      .body_1 {\n        width: 264px;\n        height: 137px;\n        background: #ff0000;\n        border: 5px solid #000;\n        border-top-left-radius: 195px 100px;\n        border-bottom-left-radius: 237px 146px;\n        border-top-right-radius: 195px 100px;\n        border-bottom-right-radius: 269px 146px;\n        position: absolute;\n        bottom: 159px;\n        left: 0px;\n      }\n\n      .body_2 {\n        width: 249px;\n        height: 139px;\n        position: absolute;\n        background: #000;\n        top: -33px;\n        left: 7px;\n        border-radius: 50%;\n        border: 1px #000 solid;\n      }\n\n      .body_3 {\n        width: 241px;\n        height: 145px;\n        position: absolute;\n        background: red;\n        top: 0px;\n        left: 5px;\n        border-radius: 50%;\n      }\n      /* 红色围脖 */\n\n      /* 白色企鹅肚子 */\n      .tummy {\n        width: 240px;\n        height: 240px;\n        background: #fff;\n        position: absolute;\n        top: 11px;\n        left: 17px;\n        border-radius: 50%;\n      }\n      /* 白色企鹅肚子 */\n\n      /* 企鹅口袋 */\n      .pocket {\n        width: 58px;\n        height: 78px;\n        position: absolute;\n        top: 72px;\n        left: 19px;\n        border: 3px solid #000;\n        background: red;\n        border-top-left-radius: 20px 52px;\n        border-bottom-left-radius: 40px 40px;\n        border-top-right-radius: 0px 0px;\n        border-bottom-right-radius: 21px 21px;\n      }\n\n      .pocket .pocket_line1 {\n        width: 11px;\n        height: 43px;\n        border-bottom-left-radius: 29px 57px;\n        border-top-left-radius: 0px 0px;\n        border: 9px solid #000;\n        border-top: none;\n        border-right: none;\n        position: absolute;\n        top: 0px;\n        left: 30px;\n        -webkit-transform: rotateZ(10deg);\n        -moz-transform: rotateZ(10deg);\n        -ms-transform: rotateZ(10deg);\n        -o-transform: rotateZ(10deg);\n        transform: rotateZ(10deg);\n      }\n\n      .pocket .pocket_line2 {\n        width: 2px;\n        height: 45px;\n        border-bottom-left-radius: 11px 24px;\n        border-top-left-radius: 10px 15px;\n        border: 9px solid red;\n        border-top: none;\n        border-right: none;\n        position: absolute;\n        top: 0px;\n        left: 2px;\n      }\n\n      /* 企鹅左右手 */\n      .lefthand,\n      .righthand {\n        width: 49px;\n        height: 160px;\n        background: #000;\n        position: absolute;\n      }\n\n      .lefthand {\n        top: 20px;\n        left: -29px;\n        border-top-left-radius: 89px 166px;\n        border-top-right-radius: 6px 63px;\n        border-bottom-left-radius: 85px 194px;\n        border-bottom-right-radius: 40px 128px;\n        -webkit-transform: rotateZ(20deg);\n        -moz-transform: rotateZ(20deg);\n        -ms-transform: rotateZ(20deg);\n        -o-transform: rotateZ(20deg);\n        transform: rotateZ(20deg);\n        -webkit-animation: left_rotate 0.5s infinite;\n        -moz-animation: left_rotate 0.5s infinite;\n        -ms-animation: left_rotate 0.5s infinite;\n        -o-animation: left_rotate 0.5s infinite;\n        animation: left_rotate 0.5s infinite;\n        -webkit-animation-direction: alternate;\n        -moz-animation-direction: alternate;\n        -ms-animation-direction: alternate;\n        -o-animation-direction: alternate;\n        animation-direction: alternate;\n      }\n      .righthand {\n        top: 20px;\n        left: 258px;\n        border-top-right-radius: 89px 166px;\n        border-bottom-right-radius: 85px 194px;\n        border-top-left-radius: 6px 63px;\n        border-bottom-left-radius: 40px 128px;\n        -webkit-transform: rotateZ(-20deg);\n        -moz-transform: rotateZ(-20deg);\n        -ms-transform: rotateZ(-20deg);\n        -o-transform: rotateZ(-20deg);\n        transform: rotateZ(-20deg);\n        -webkit-animation: right_rotate 0.5s infinite;\n        -moz-animation: right_rotate 0.5s infinite;\n        -ms-animation: right_rotate 0.5s infinite;\n        -o-animation: right_rotate 0.5s infinite;\n        animation: right_rotate 0.5s infinite;\n        -webkit-animation-direction: alternate;\n        -moz-animation-direction: alternate;\n        -ms-animation-direction: alternate;\n        -o-animation-direction: alternate;\n        animation-direction: alternate;\n      }\n      /* 企鹅左右手 */\n      /* ……………………………………………………………………end 企鹅身体…………………………………………………………………… */\n\n      /* ……………………………………………………………………star 企鹅脚部…………………………………………………………………… */\n      .footer .left_footer,\n      .footer .right_footer {\n        width: 134px;\n        height: 74px;\n        position: absolute;\n        background: #ffa600;\n        border: 3px solid #000;\n        border-radius: 50%;\n        z-index: 1;\n      }\n\n      .footer .left_footer {\n        top: 347px;\n        left: 163px;\n      }\n\n      .footer .right_footer {\n        top: 347px;\n        left: 320px;\n      }\n      /* ……………………………………………………………………end 企鹅脚部…………………………………………………………………… */\n\n      @keyframes left_rotate {\n        from {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(60deg);\n        }\n\n        to {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(30deg);\n        }\n      }\n\n      @keyframes right_rotate {\n        from {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-60deg);\n        }\n\n        to {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-30deg);\n        }\n      }\n\n      @-webkit-keyframes left_rotate {\n        from {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(60deg);\n        }\n\n        to {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(30deg);\n        }\n      }\n\n      @-webkit-keyframes right_rotate {\n        from {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-60deg);\n        }\n\n        to {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-30deg);\n        }\n      }\n      @-moz-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-moz-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n      @-ms-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-ms-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n      @-o-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-o-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"wrap\">\n      <!-- 企鹅头部 -->\n      <div class=\"headtop\">\n        <div class=\"headbottom\"></div>\n        <!-- 眼睛部分 -->\n        <h1 class=\"lefteye\">\n          <p class=\"lefteye_in\">\n            <strong class=\"eyeshow\"></strong>\n          </p>\n        </h1>\n        <h1 class=\"righteye\">\n          <p class=\"righteye_in\">\n            <strong class=\"eyebai\"></strong>\n          </p>\n        </h1>\n        <!-- 嘴巴部分 -->\n        <h1 class=\"mouth\"></h1>\n        <p class=\"mouth_bar\">\n          <strong class=\"mouth_bar1\"></strong>\n        </p>\n      </div>\n\n      <!-- 企鹅头部 -->\n\n      <!-- 企鹅身体 -->\n      <div class=\"body\">\n        <div class=\"tummy\">\n          <div class=\"pocket\">\n            <div class=\"pocket_line1\">\n              <div class=\"pocket_line2\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"hand\">\n          <div class=\"lefthand\"></div>\n          <div class=\"righthand\"></div>\n        </div>\n        <div class=\"body_1\">\n          <div class=\"body_2\">\n            <div class=\"body_3\"></div>\n          </div>\n        </div>\n      </div>\n      <!-- 企鹅身体 -->\n\n      <!-- 企鹅脚丫 -->\n      <div class=\"footer\">\n        <div class=\"left_footer\"></div>\n        <div class=\"right_footer\"></div>\n      </div>\n      <!-- 企鹅脚丫 -->\n    </div>\n  </body>\n</html>\n\n```","slug":"amazing","published":1,"updated":"2021-08-13T01:25:34.880Z","layout":"post","link":"","_id":"cku2cstrt001n4v9kex869l3q","content":"<h2 id=\"页面浮动多边形跟随鼠标移动\"><a href=\"#页面浮动多边形跟随鼠标移动\" class=\"headerlink\" title=\"页面浮动多边形跟随鼠标移动\"></a>页面浮动多边形跟随鼠标移动</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e635cd6c5a0d4086ad1c2edefeb44a4e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"页面浮动多边形跟随鼠标移动\"><br><!-- ![页面浮动多边形跟随鼠标移动][img1] --></p>\n<pre><code class=\"javascript\">//鼠标绘制多边形\n!(function() {\n  //封装方法，压缩之后减少文件大小\n  function get_attribute(node, attr, default_value) {\n    return node.getAttribute(attr) || default_value\n  }\n  //封装方法，压缩之后减少文件大小\n  function get_by_tagname(name) {\n    return document.getElementsByTagName(name)\n  }\n  //获取配置参数\n  function get_config_option() {\n    var scripts = get_by_tagname(&quot;script&quot;),\n      script_len = scripts.length,\n      script = scripts[script_len - 1] //当前加载的script\n    return {\n      l: script_len, //长度，用于生成id用\n      z: get_attribute(script, &quot;zIndex&quot;, -1), //z-index\n      o: get_attribute(script, &quot;opacity&quot;, 0.5), //opacity\n      c: get_attribute(script, &quot;color&quot;, &quot;0,0,0&quot;), //color\n      n: get_attribute(script, &quot;count&quot;, 99), //count\n    }\n  }\n  //设置canvas的高宽\n  function set_canvas_size() {\n    ;(canvas_width = the_canvas.width =\n      window.innerWidth ||\n      document.documentElement.clientWidth ||\n      document.body.clientWidth),\n      (canvas_height = the_canvas.height =\n        window.innerHeight ||\n        document.documentElement.clientHeight ||\n        document.body.clientHeight)\n  }\n\n  //绘制过程\n  function draw_canvas() {\n    context.clearRect(0, 0, canvas_width, canvas_height)\n    //随机的线条和当前位置联合数组\n    var e, i, d, x_dist, y_dist, dist //临时节点\n    //遍历处理每一个点\n    random_points.forEach(function(r, idx) {\n      ;(r.x += r.xa),\n        (r.y += r.ya), //移动\n        (r.xa *= r.x &gt; canvas_width || r.x &lt; 0 ? -1 : 1),\n        (r.ya *= r.y &gt; canvas_height || r.y &lt; 0 ? -1 : 1), //碰到边界，反向反弹\n        context.fillRect(r.x - 0.5, r.y - 0.5, 1, 1) //绘制一个宽高为1的点\n      //从下一个点开始\n      for (i = idx + 1; i &lt; all_array.length; i++) {\n        e = all_array[i]\n        // 当前点存在\n        if (null !== e.x &amp;&amp; null !== e.y) {\n          x_dist = r.x - e.x //x轴距离 l\n          y_dist = r.y - e.y //y轴距离 n\n          dist = x_dist * x_dist + y_dist * y_dist //总距离, m\n\n          dist &lt; e.max &amp;&amp;\n            (e === current_point &amp;&amp;\n              dist &gt;= e.max / 2 &amp;&amp;\n              ((r.x -= 0.03 * x_dist), (r.y -= 0.03 * y_dist)), //靠近的时候加速\n            (d = (e.max - dist) / e.max),\n            context.beginPath(),\n            (context.lineWidth = d / 2),\n            (context.strokeStyle = &quot;rgba(&quot; + config.c + &quot;,&quot; + (d + 0.2) + &quot;)&quot;),\n            context.moveTo(r.x, r.y),\n            context.lineTo(e.x, e.y),\n            context.stroke())\n        }\n      }\n    }),\n      frame_func(draw_canvas)\n  }\n  //创建画布，并添加到body中\n  var the_canvas = document.createElement(&quot;canvas&quot;), //画布\n    config = get_config_option(), //配置\n    canvas_id = &quot;c_n&quot; + config.l, //canvas id\n    context = the_canvas.getContext(&quot;2d&quot;),\n    canvas_width,\n    canvas_height,\n    frame_func =\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(func) {\n        window.setTimeout(func, 1000 / 45)\n      },\n    random = Math.random,\n    current_point = {\n      x: null, //当前鼠标x\n      y: null, //当前鼠标y\n      max: 20000, // 圈半径的平方\n    },\n    all_array\n  the_canvas.id = canvas_id\n  the_canvas.style.cssText =\n    &quot;position:fixed;top:0;left:0;z-index:&quot; + config.z + &quot;;opacity:&quot; + config.o\n  get_by_tagname(&quot;body&quot;)[0].appendChild(the_canvas)\n\n  //初始化画布大小\n  set_canvas_size()\n  window.onresize = set_canvas_size\n  //当时鼠标位置存储，离开的时候，释放当前位置信息\n  ;(window.onmousemove = function(e) {\n    e = e || window.event\n    current_point.x = e.clientX\n    current_point.y = e.clientY\n  }),\n    (window.onmouseout = function() {\n      current_point.x = null\n      current_point.y = null\n    })\n  //随机生成config.n条线位置信息\n  for (var random_points = [], i = 0; config.n &gt; i; i++) {\n    var x = random() * canvas_width, //随机位置\n      y = random() * canvas_height,\n      xa = 2 * random() - 1, //随机运动方向\n      ya = 2 * random() - 1\n    // 随机点\n    random_points.push({\n      x: x,\n      y: y,\n      xa: xa,\n      ya: ya,\n      max: 6000, //沾附距离\n    })\n  }\n  all_array = random_points.concat([current_point])\n  //0.1秒后绘制\n  setTimeout(function() {\n    draw_canvas()\n  }, 100)\n})()\n</code></pre>\n<h2 id=\"每日一言功能\"><a href=\"#每日一言功能\" class=\"headerlink\" title=\"每日一言功能\"></a>每日一言功能</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b7a8b1a5b3e4577b1b67efee35b54ba~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"每日一言功能\"></p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;strong&gt;&lt;p id=&quot;hitokoto&quot;&gt;每日一言获取中...&lt;/p&gt;&lt;/strong&gt;\n  &lt;script&gt;\n    //每日一言\n    $(function() {\n      var xhr = new XMLHttpRequest()\n      xhr.open(&quot;get&quot;, &quot;https://v1.hitokoto.cn&quot;)\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var data = JSON.parse(xhr.responseText)\n          var hitokoto = document.getElementById(&quot;hitokoto&quot;)\n          hitokoto.innerText = data.hitokoto\n        }\n      }\n      xhr.send()\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h2 id=\"鼠标点击出现爱心特效\"><a href=\"#鼠标点击出现爱心特效\" class=\"headerlink\" title=\"鼠标点击出现爱心特效\"></a>鼠标点击出现爱心特效</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da17b3c0f8374b11bf92938a7cb32031~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"鼠标点击出现不同颜色爱心\"></p>\n<pre><code class=\"javascript\">//鼠标点击爱心\n!(function(e, t, a) {\n  function r() {\n    for (var e = 0; e &lt; s.length; e++)\n      s[e].alpha &lt;= 0\n        ? (t.body.removeChild(s[e].el), s.splice(e, 1))\n        : (s[e].y--,\n          (s[e].scale += 0.004),\n          (s[e].alpha -= 0.013),\n          (s[e].el.style.cssText =\n            &quot;left:&quot; +\n            s[e].x +\n            &quot;px;top:&quot; +\n            s[e].y +\n            &quot;px;opacity:&quot; +\n            s[e].alpha +\n            &quot;;transform:scale(&quot; +\n            s[e].scale +\n            &quot;,&quot; +\n            s[e].scale +\n            &quot;) rotate(45deg);background:&quot; +\n            s[e].color +\n            &quot;;z-index:99999&quot;))\n    requestAnimationFrame(r)\n  }\n  function n() {\n    var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick\n    e.onclick = function(e) {\n      t &amp;&amp; t(), o(e)\n    }\n  }\n  function o(e) {\n    var a = t.createElement(&quot;div&quot;)\n    ;(a.className = &quot;heart&quot;),\n      s.push({\n        el: a,\n        x: e.clientX - 5,\n        y: e.clientY - 5,\n        scale: 1,\n        alpha: 1,\n        color: c(),\n      }),\n      t.body.appendChild(a)\n  }\n  function i(e) {\n    var a = t.createElement(&quot;style&quot;)\n    a.type = &quot;text/css&quot;\n    try {\n      a.appendChild(t.createTextNode(e))\n    } catch (t) {\n      a.styleSheet.cssText = e\n    }\n    t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)\n  }\n  function c() {\n    return (\n      &quot;rgb(&quot; +\n      ~~(255 * Math.random()) +\n      &quot;,&quot; +\n      ~~(255 * Math.random()) +\n      &quot;,&quot; +\n      ~~(255 * Math.random()) +\n      &quot;)&quot;\n    )\n  }\n  var s = []\n  ;(e.requestAnimationFrame =\n    e.requestAnimationFrame ||\n    e.webkitRequestAnimationFrame ||\n    e.mozRequestAnimationFrame ||\n    e.oRequestAnimationFrame ||\n    e.msRequestAnimationFrame ||\n    function(e) {\n      setTimeout(e, 1e3 / 60)\n    }),\n    i(\n      &quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;\n    ),\n    n(),\n    r()\n})(window, document)\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5015800b668b4f329c0c414283c79d5a~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"鼠标点击出现‘富强明主’字体\"></p>\n<pre><code class=\"javascript\">\n&lt;script&gt;\n    //定义获取词语下标\nvar a_idx = 0;\njQuery(document).ready(function($) {\n        //点击body时触发事件\n    $(&quot;body&quot;).click(function(e) {\n    //需要显示的词语\n    var a = new Array(&quot;富强&quot;,&quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;,&quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;,&quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;,&quot;诚信&quot;, &quot;友善&quot;);\n    //设置词语给span标签\n    var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]);\n    //下标等于原来下标+1  余 词语总数\n    a_idx = (a_idx + 1)% a.length;\n    //获取鼠标指针的位置，分别相对于文档的左和右边缘。\n    //获取x和y的指针坐标\n    var x = e.pageX, y = e.pageY;\n    //在鼠标的指针的位置给$i定义的span标签添加css样式\n    $i.css({&quot;z-index&quot; : 999999,\n        &quot;top&quot; : y - 20,\n        &quot;left&quot; : x,\n        &quot;position&quot; : &quot;absolute&quot;,\n        &quot;font-weight&quot; : &quot;bold&quot;,\n        &quot;color&quot; : &quot;#ff6651&quot;\n        });\n    //在body添加这个标签\n    $(&quot;body&quot;).append($i);\n        //animate() 方法执行 CSS 属性集的自定义动画。\n        //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。\n        //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp\n        $i.animate({\n        //将原来的位置向上移动180\n            &quot;top&quot; : y - 180,\n                &quot;opacity&quot; : 0\n         //1500动画的速度\n        }, 1500, function() {\n        //时间到了自动删除\n            $i.remove();\n        });\n    });\n});\n\n&lt;/script&gt;\n\n</code></pre>\n<h2 id=\"macOS-Dock-效果\"><a href=\"#macOS-Dock-效果\" class=\"headerlink\" title=\"macOS Dock 效果\"></a>macOS Dock 效果</h2><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdcbc5783ecd4331b40b1326ebc0143f~tplv-k3u1fbpfcp-watermark.image\" alt=\"macOS中Dock效果\"></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      html {\n        font-size: 15px;\n      }\n\n      body {\n        margin: 0;\n        padding: 0;\n        display: flex;\n        width: 100%;\n        min-height: 100vh;\n        overflow: hidden;\n        align-items: flex-end;\n        background-image: linear-gradient(\n          109.6deg,\n          rgba(25, 170, 209, 1) 11.3%,\n          rgba(21, 65, 249, 1) 69.9%\n        );\n      }\n\n      .glass {\n        width: 100%;\n        height: 8rem;\n        background: rgba(255, 255, 255, 0.25);\n        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n        backdrop-filter: blur(4px);\n        -webkit-backdrop-filter: blur(4px);\n        border: 1px solid rgba(255, 255, 255, 0.18);\n        display: flex;\n        justify-content: center;\n      }\n\n      .dock {\n        --scale: 1;\n\n        list-style: none;\n        margin: 0;\n        padding: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .dock li {\n        font-size: calc(6rem * var(--scale));\n        padding: 0 0.5rem;\n        cursor: default;\n\n        position: relative;\n        top: calc((6rem * var(--scale) - 6rem) / 2 * -1);\n\n        transition: 15ms all ease-out;\n      }\n\n      .dock li.loading {\n        animation: 1s loading ease-in infinite;\n      }\n\n      @keyframes loading {\n        0%,\n        100% {\n          transform: translateY(0px);\n        }\n        60% {\n          transform: translateY(-40px);\n        }\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=&quot;glass&quot;&gt;\n      &lt;ul class=&quot;dock&quot;&gt;\n        &lt;li&gt;😃&lt;/li&gt;\n        &lt;li&gt;😊&lt;/li&gt;\n        &lt;li&gt;😜&lt;/li&gt;\n        &lt;li&gt;😍&lt;/li&gt;\n        &lt;li&gt;🤩&lt;/li&gt;\n        &lt;li&gt;🥳&lt;/li&gt;\n        &lt;li&gt;🥶&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      document.querySelectorAll(&quot;.dock li&quot;).forEach((li) =&gt; {\n        li.addEventListener(&quot;click&quot;, (e) =&gt; {\n          e.currentTarget.classList.add(&quot;loading&quot;)\n        })\n\n        li.addEventListener(&quot;mousemove&quot;, (e) =&gt; {\n          let item = e.target\n          let itemRect = item.getBoundingClientRect()\n          let offset = Math.abs(e.clientX - itemRect.left) / itemRect.width\n\n          let prev = item.previousElementSibling || null\n          let next = item.nextElementSibling || null\n\n          let scale = 0.6\n\n          resetScale()\n\n          if (prev) {\n            prev.style.setProperty(&quot;--scale&quot;, 1 + scale * Math.abs(offset - 1))\n          }\n\n          item.style.setProperty(&quot;--scale&quot;, 1 + scale)\n\n          if (next) {\n            next.style.setProperty(&quot;--scale&quot;, 1 + scale * offset)\n          }\n        })\n      })\n\n      document.querySelector(&quot;.dock&quot;).addEventListener(&quot;mouseleave&quot;, (e) =&gt; {\n        resetScale()\n      })\n\n      function resetScale() {\n        document.querySelectorAll(&quot;.dock li&quot;).forEach((li) =&gt; {\n          li.style.setProperty(&quot;--scale&quot;, 1)\n        })\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"canvas-实现水印\"><a href=\"#canvas-实现水印\" class=\"headerlink\" title=\"canvas 实现水印\"></a>canvas 实现水印</h2><pre><code class=\"javascript\">var watermark = {}\n\nfunction setWatermark(args) {\n  //声明一个怪异一点的变量，确保id的唯一性\n  var id = &quot;111.222.333.456&quot;\n  var xIndex = 15 //绘制文本的 x 坐标位置\n  var yIndex = 65 //绘制文本的 y 坐标位置\n  var xInterval = 25 //有多个参数时的行间间隔\n  if (document.getElementById(id) !== null) {\n    document.body.removeChild(document.getElementById(id))\n  }\n  //利用canvas绘制水印信息\n  var can = document.createElement(&quot;canvas&quot;)\n  can.width = 250\n  can.height = 150\n  var cans = can.getContext(&quot;2d&quot;)\n  cans.rotate((-20 * Math.PI) / 180)\n  cans.font = &quot;17px Vedana&quot;\n  // ziti yanse\n  cans.fillStyle = &quot;rgba(200, 200, 200, 0.30)&quot;\n  cans.textAlign = &quot;left&quot;\n  cans.textBaseline = &quot;Middle&quot;\n  for (let i = 0; i &lt; args.length; i++) {\n    cans.fillText(args[i], xIndex, yIndex) //绘制水印文案\n    yIndex += xInterval //设置每行间隔\n  }\n  //创建div用于显示\n  var div = document.createElement(&quot;div&quot;)\n  div.id = id\n  div.style.pointerEvents = &quot;none&quot;\n  div.style.top = &quot;70px&quot;\n  div.style.left = &quot;90px&quot;\n  div.style.position = &quot;fixed&quot;\n  div.style.zIndex = &quot;100000&quot;\n  div.style.width = document.documentElement.clientWidth - 50 + &quot;px&quot;\n  div.style.height = document.documentElement.clientHeight - 50 + &quot;px&quot;\n  //div承载水印显示\n  div.style.background =\n    &quot;url(&quot; + can.toDataURL(&quot;image/png&quot;) + &quot;) left top repeat&quot;\n  document.body.appendChild(div)\n  return id\n}\n\nwatermark.set = function() {\n  let args = Array.prototype.slice.apply(arguments)\n  let id = setWatermark(args)\n  // 检测如果水印被去掉了，自动给加上\n  setInterval(function() {\n    if (document.getElementById(id) === null) {\n      id = setWatermark(args)\n    }\n  }, 500)\n  //在窗口大小改变之后,自动触发加水印事件\n  window.onresize = function() {\n    setWatermark(args)\n  }\n}\nwindow.watermark = watermark\n\nwatermark.set(&quot;绝密档案&quot;, &quot;严禁外泄&quot;)\n</code></pre>\n<h2 id=\"canvas实现验证码\"><a href=\"#canvas实现验证码\" class=\"headerlink\" title=\"canvas实现验证码\"></a>canvas实现验证码</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot; /&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;canvas id=&quot;canvas&quot; width=&quot;120&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt;\n  &lt;a href=&quot;#&quot; id=&quot;changeImg&quot;&gt;看不清，换一张&lt;/a&gt;\n  &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;\n  &lt;script&gt;\n    // 随机数\n    function randomNum(min, max) {\n      return Math.floor(Math.random() * (max - min) + min);\n    }\n    /**生成一个随机色**/\n    function randomColor(min, max) {\n      var r = randomNum(min, max);\n      var g = randomNum(min, max);\n      var b = randomNum(min, max);\n      return &quot;rgb(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;)&quot;;\n    }\n    drawPic();\n    document.getElementById(&quot;changeImg&quot;).onclick = function (e) {\n      e.preventDefault();\n      drawPic();\n    }\n\n    var Vcode = &#39;&#39;\n\n    /**绘制验证码图片**/\n    function drawPic() {\n      var canvas = document.getElementById(&quot;canvas&quot;);\n      var width = canvas.width;\n      var height = canvas.height;\n      var ctx = canvas.getContext(&#39;2d&#39;);\n      ctx.textBaseline = &#39;bottom&#39;;\n\n      /**绘制背景色**/\n      ctx.fillStyle = randomColor(180, 240); //颜色若太深可能导致看不清\n      ctx.fillRect(0, 0, width, height);\n      /**绘制文字**/\n      var str = &#39;ABCEFGHJKLMNPQRSTWXY123456789&#39;;\n      vCode = &#39;&#39;\n      for (var i = 0; i &lt; 4; i++) {\n        var txt = str[randomNum(0, str.length)];    // 每次随机生成的数\n        vCode += txt\n        ctx.fillStyle = randomColor(50, 160);  //随机生成字体颜色\n        ctx.font = randomNum(15, 40) + &#39;px SimHei&#39;; //随机生成字体大小\n        var x = 10 + i * 25;\n        var y = randomNum(25, 45);\n        var deg = randomNum(-45, 45);\n        //修改坐标原点和旋转角度\n        ctx.translate(x, y);\n        ctx.rotate(deg * Math.PI / 180);\n        ctx.fillText(txt, 0, 0);\n        //恢复坐标原点和旋转角度\n        ctx.rotate(-deg * Math.PI / 180);\n        ctx.translate(-x, -y);\n      }\n      /* *绘制干扰线* */\n      for (var i = 0; i &lt; 4; i++) {\n        ctx.strokeStyle = randomColor(40, 180);\n        ctx.beginPath();\n        ctx.moveTo(randomNum(0, width), randomNum(0, height));\n        ctx.lineTo(randomNum(0, width), randomNum(0, height));\n        ctx.stroke();\n      }\n      /**绘制干扰点**/\n      for (var i = 0; i &lt; 20; i++) {\n        ctx.fillStyle = randomColor(0, 255);\n        ctx.beginPath();\n        ctx.arc(randomNum(0, width), randomNum(0, height), 1, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n      console.log(&quot;随机生成的验证码是:::&quot;, vCode);\n    }\n    let text = document.getElementById(&#39;text&#39;)\n    text.onblur = function(e) {\n      console.log(text.value,&#39;value&#39;)\n      if(text.value == vCode) {\n\n      } else {\n        alert(&#39;请输入正确的验证码&#39;)\n      }\n    }\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"纯css实现霓虹灯效果\"><a href=\"#纯css实现霓虹灯效果\" class=\"headerlink\" title=\"纯css实现霓虹灯效果\"></a>纯css实现霓虹灯效果</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style&gt;\n    .light {\n      position: relative;\n      padding: 25px 30px;\n      color: #03e9f4;\n      font-size: 24px;\n      text-transform: uppercase;\n      transition: 0.5s;\n      letter-spacing: 4px;\n      cursor: pointer;\n      overflow: hidden;\n      width: 200px;\n      height: 100px;\n    }\n    .light:hover {\n      background-color: #03e9f4;\n      color: #050801;\n      box-shadow: 0 0 5px #03e9f4,\n                  0 0 25px #03e9f4,\n                  0 0 50px #03e9f4,\n                  0 0 200px #03e9f4;\n    }\n    .light div {\n      position: absolute;\n    }\n    .light div:nth-child(1){\n      width: 100%;\n      height: 2px;\n      top: 0;\n      left: -100%;\n      background: linear-gradient(to right,transparent,#03e9f4);\n      animation: animate1 2s linear infinite;\n    }\n    .light div:nth-child(2){\n      width: 2px;\n      height: 100%;\n      top: -100%;\n      right: 0;\n      background: linear-gradient(to bottom,transparent,#03e9f4);\n      animation: animate2 2s linear infinite;\n      animation-delay: 0.5s;\n    }\n    .light div:nth-child(3){\n      width: 100%;\n      height: 2px;\n      bottom: 0;\n      right: -100%;\n      background: linear-gradient(to left,transparent,#03e9f4);\n      animation: animate3 2s linear infinite;\n      animation-delay: 1s;\n    }\n    .light div:nth-child(4){\n      width: 2px;\n      height: 100%;\n      bottom: -100%;\n      left: 0;\n      background: linear-gradient(to top,transparent,#03e9f4);\n      animation: animate4 2s linear infinite;\n      animation-delay: 1.5s;\n    }\n    @keyframes animate1 {\n      0% {\n        left: -100%;\n      }\n      50%,100% {\n        left: 100%;\n      }\n    }\n    @keyframes animate2 {\n      0% {\n        top: -100%;\n      }\n      50%,100% {\n        top: 100%;\n      }\n    }\n    @keyframes animate3 {\n      0% {\n        right: -100%;\n      }\n      50%,100% {\n        right: 100%;\n      }\n    }\n    @keyframes animate4 {\n      0% {\n        bottom: -100%;\n      }\n      50%,100% {\n        bottom: 100%;\n      }\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;light&quot;&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n    Neon Button\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"canvas实现刮刮乐\"><a href=\"#canvas实现刮刮乐\" class=\"headerlink\" title=\"canvas实现刮刮乐\"></a>canvas实现刮刮乐</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=&quot;./男1.jpg&quot; width=&quot;400&quot; id=&quot;img&quot; alt=&quot;&quot; /&gt;\n    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;txt&quot; /&gt;\n    &lt;!-- &lt;canvas&gt;&lt;/canvas&gt; --&gt;\n    &lt;script&gt;\n      const oImg = document.getElementById(&quot;img&quot;)\n      const txt = document.getElementById(&quot;txt&quot;)\n      //oImg.readyState 图片加载状态\n      if (oImg.readyState === &quot;complete&quot;) {\n        draw() //true表示已经加载完成 执行draw()方法\n      } else {\n        //图片加载完成执行draw方法\n        oImg.onload = draw\n      }\n\n      function draw() {\n        //等图片加载完成后再添加canvas画布在上面\n        let can = document.createElement(&quot;canvas&quot;) //创建一个canvas画布\n        can.width = oImg.width //等于图片的宽高\n        can.height = oImg.height\n        can.style.position = &quot;absolute&quot; //canvas画布设置浮动会漂浮在图片上\n        can.style.left = oImg.offsetLeft + &quot;px&quot; //保存与画布位置一致\n        can.style.top = oImg.offsetTop + &quot;px&quot;\n        //找到图片的父级：parentNode  在oImg子元素前面添加canvas标签：insertBefore\n        oImg.parentNode.insertBefore(can, oImg) //在img前面去插入canvas标签\n        let ctx = can.getContext(&quot;2d&quot;)\n        ctx.fillStyle = &quot;#bbb&quot; //刮刮乐的颜色\n        ctx.fillRect(0, 0, oImg.width, oImg.height) //填充宽度\n\n        //合成:处理合成图片的透明样式；\n        //拖拽的时候，canvas图层显示透明；destination-out：新图形与原图形重叠部分透明\n        ctx.globalCompositeOperation = &quot;destination-out&quot;\n        ctx.strokeStyle = &quot;#eee&quot; //触笔的颜色 随便  因为它终究变成透明\n        ctx.lineWidth = 30 //拖动时开始画线的线宽\n        ctx.lineCap = &quot;round&quot; //这两步是把画笔变成圆形\n\n        //按下，移动，抬起事件\n        can.onmousedown = function (e) {\n          e = e || window.event //兼容低版本IE浏览器\n          //e.pageX距离文档右边缘； offsetLeft：canvas画布距离文档的右边距离\n          let x = e.pageX - can.offsetLeft //得到的x是在canvas上的坐标值\n          let y = e.pageY - can.offsetTop\n          ctx.beginPath()\n          // ctx.moveTo(  x,y )//从哪里开始来画\n          ctx.arc(x, y, 15, 0, 6.3, false) //点第一下是画一个圆\n          ctx.fill()\n          //按下后拖拽\n          can.onmousemove = function (e) {\n            //拖动时一直执行下面\n            e = e || window.event //兼容低版本IE浏览器\n            ctx.beginPath() //拖动时开始画线\n            ctx.moveTo(x, y) //起始点\n            ctx.lineTo(e.pageX - can.offsetLeft, e.pageY - can.offsetTop) //移动的过程\n\n            //每次移动的时候，样式所在的坐标；\n            x = e.pageX - can.offsetLeft //第二次渲染刮图片效果的起始点应该在上一次的终止点\n            y = e.pageY - can.offsetTop\n            ctx.stroke() //弹出图形并恢复画布\n          }\n          document.onmouseup = function () {\n            //抬起后将事件注销\n            can.onmousemove = null\n            this.onmouseup = null\n            check() //完成后通过像素计算刮过的的百分比\n          }\n        }\n        function check() {\n          //获取画布的像素列表\n          let data = ctx.getImageData(0, 0, can.width, can.height).data\n          let n = 0 //计算透明像素的个数\n          for (let i = 0; i &lt; data.length; i += 4) {\n            //感觉这一步比较消耗性能\n            //RGBA\n            if (\n              data[i] == 0 &amp;&amp;\n              data[i + 1] == 0 &amp;&amp;\n              data[i + 2] == 0 &amp;&amp;\n              data[i + 3] == 0\n            ) {\n              n++\n            }\n          }\n          let f = (n * 100) / (can.width * can.height) //算出所刮的面积的占比；\n          txt.value = `刮开面积:${f.toFixed(2)}%`\n          //刮开面积的比例\n          if (f &gt; 30) {\n            //如果所刮的面积大于30%   则将canvas画布整体清除fillRect\n            ctx.beginPath()\n            ctx.fillRect(0, 0, can.width, can.height)\n            txt.value = &quot;刮开面积大于30%，全部显示&quot;\n          }\n        }\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"swiper轮播图组件\"><a href=\"#swiper轮播图组件\" class=\"headerlink\" title=\"swiper轮播图组件\"></a>swiper轮播图组件</h2><blockquote>\n<p>拖拽、回弹物料效果是参照开源项目swiper.js做的<br><code>`</code>javascript<br>/**</p>\n<ul>\n<li>轮播组件</li>\n<li>@param {object} params 配置传参</li>\n<li>@param {string} params.el 组件节点 class|id|<label></label></li>\n<li>@param {number} params.moveTime 过渡时间（毫秒）默认 300</li>\n<li>@param {number} params.interval 自动播放间隔（毫秒）默认 3000</li>\n<li>@param {boolean} params.loop 是否需要回路</li>\n<li>@param {boolean} params.vertical 是否垂直滚动</li>\n<li>@param {boolean} params.autoPaly 是否需要自动播放</li>\n<li>@param {boolean} params.pagination 是否需要底部圆点</li>\n<li>@param {(index: number) =&gt; void} params.slideCallback 滑动/切换结束回调</li>\n<li>@author <a href=\"https://github.com/Hansen-hjs\" target=\"_blank\" rel=\"noopener\">https://github.com/Hansen-hjs</a></li>\n<li>@description </li>\n<li>移动端<code>swiper</code>组件，如果需要兼容<code>pc</code>自行修改对应的<code>touch</code>到<code>mouse</code>事件即可。现成效果预览：<a href=\"https://huangjingsheng.gitee.io/hjs/cv/demo/face/\" target=\"_blank\" rel=\"noopener\">https://huangjingsheng.gitee.io/hjs/cv/demo/face/</a><br>*/<br>function swiper(params) {<br> /**<ul>\n<li>css class 命名列表</li>\n<li>@dec [&quot;滑动列表&quot;,&quot;滑动item&quot;,&quot;圆点容器&quot;,&quot;底部圆点&quot;,&quot;圆点高亮&quot;]<br><em>/<br>const classNames = [&quot;.swiper_list&quot;, &quot;.swiper_item&quot;, &quot;.swiper_pagination&quot;, &quot;.swiper_dot&quot;, &quot;.swiper_dot_active&quot;];<br>/** 滑动结束函数 </em>/<br>const slideEnd = params.slideCallback || function() {};<br>/**</li>\n<li>组件节点</li>\n<li>@type {HTMLElement}<br>*/<br>let node = null;<br>/**</li>\n<li>item列表容器</li>\n<li>@type {HTMLElement}<br>*/<br>let nodeItem = null;<br>/**</li>\n<li>item节点列表</li>\n<li>@type {Array<htmlelement>}<br>*/<br>let nodeItems = [];<br>/**</htmlelement></li>\n<li>圆点容器</li>\n<li>@type {HTMLElement}<br>*/<br>let nodePagination = null;<br>/**</li>\n<li>圆点节点列表</li>\n<li>@type {Array<htmlelement>}<br><em>/<br>let nodePaginationItems = [];<br>/** 是否需要底部圆点 </em>/<br>let pagination = false;<br>/<strong> 是否需要回路 */<br>let isLoop = false;<br>/</strong> 方向 <code>X =&gt; true</code> | <code>Y =&gt; false</code> <em>/<br>let direction = false;<br>/** 是否需要自动播放 </em>/<br>let autoPaly = false;<br>/<strong> 自动播放间隔（毫秒）默认 3000 */<br>let interval = 3000;<br>/</strong> 过渡时间（毫秒）默认 300 */<br>let moveTime = 300;</htmlelement></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code>/** 设置动画 */\nfunction startAnimation() {\n    nodeItem.style.transition = `${moveTime / 1000}s all`; \n}\n\n/** 关闭动画 */\nfunction stopAnimation() {\n    nodeItem.style.transition = &quot;0s all&quot;;\n}\n\n/**\n * 属性样式滑动\n * @param {number} n 移动的距离\n */\nfunction slideStyle(n) {\n    let x = 0, y = 0;\n    if (direction) {\n        y = n;\n    } else {\n        x = n;\n    }\n    nodeItem.style.transform = `translate3d(${x}px, ${y}px, 0px)`;\n}\n\n/**\n * 事件开始\n * @param {number} width 滚动容器的宽度\n * @param {number} height 滚动容器的高度\n */\nfunction main(width, height) {\n    /**\n     * 动画帧\n     * @type {requestAnimationFrame}\n     */\n    const animation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n    /** 触摸开始时间 */\n    let startTime = 0;\n    /** 触摸结束时间 */\n    let endTime = 0;\n    /** 开始的距离 */\n    let startDistance = 0;\n    /** 结束的距离 */\n    let endDistance = 0;\n    /** 结束距离状态 */\n    let endState = 0;\n    /** 移动的距离 */\n    let moveDistance = 0;\n    /** 圆点位置 &amp;&amp; 当前 item 索引 */\n    let index = 0;\n    /** 动画帧计数 */\n    let count = 0;\n    /** loop 帧计数 */\n    let loopCount = 0;\n    /** 移动范围 */\n    let range = direction ? height : width;\n\n    /** 获取拖动距离 */\n    function getDragDistance() {\n        /** 拖动距离 */\n        let dragDistance = 0;\n        // 默认这个公式\n        dragDistance = moveDistance + (endDistance - startDistance);\n        // 判断最大正负值\n        if ((endDistance - startDistance) &gt;= range) {\n            dragDistance = moveDistance + range;\n        } else if ((endDistance - startDistance) &lt;= -range) {\n            dragDistance = moveDistance - range;\n        }\n        // 没有 loop 的时候惯性拖拽\n        if (!isLoop) {\n            if ((endDistance - startDistance) &gt; 0 &amp;&amp; index === 0) {\n                // console.log(&quot;到达最初&quot;);\n                dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6));\n            } else if ((endDistance - startDistance) &lt; 0 &amp;&amp; index === nodeItems.length - 1) {\n                // console.log(&quot;到达最后&quot;);\n                dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6));\n            }\n        }\n        return dragDistance;\n    }\n\n    /**\n     * 判断触摸处理函数 \n     * @param {number} slideDistance 滑动的距离\n     */\n    function judgeTouch(slideDistance) {\n        //    这里我设置了200毫秒的有效拖拽间隔\n        if ((endTime - startTime) &lt; 200) return true;\n        // 这里判断方向（正值和负值）\n        if (slideDistance &lt; 0) {\n            if ((endDistance - startDistance) &lt; (slideDistance / 2)) return true;\n            return false;\n        } else {\n            if ((endDistance - startDistance) &gt; (slideDistance / 2)) return true;\n            return false;\n        }\n    }\n\n    /** 返回原来位置 */\n    function backLocation() {\n        startAnimation();\n        slideStyle(moveDistance);\n    }\n\n    /**\n     * 滑动\n     * @param {number} slideDistance 滑动的距离\n     */\n    function slideMove(slideDistance) {\n        startAnimation();\n        slideStyle(slideDistance);\n        loopCount = 0;\n        // 判断 loop 时回到第一张或最后一张\n        if (isLoop &amp;&amp; index &lt; 0) {\n            // 我这里是想让滑块过渡完之后再重置位置所以加的延迟 (之前用setTimeout，快速滑动有问题，然后换成 requestAnimationFrame解决了这类问题)\n            function loopMoveMin() {\n                loopCount += 1;\n                if (loopCount &lt; moveTime / 1000 * 60) return animation(loopMoveMin);\n                stopAnimation();\n                slideStyle(range * -(nodeItems.length - 3));\n                // 重置一下位置\n                moveDistance = range * -(nodeItems.length - 3);\n            }\n            loopMoveMin();\n            index = nodeItems.length - 3;\n        } else if (isLoop &amp;&amp; index &gt; nodeItems.length - 3) {\n            function loopMoveMax() {\n                loopCount += 1;\n                if (loopCount &lt; moveTime / 1000 * 60) return animation(loopMoveMax);\n                stopAnimation();\n                slideStyle(0);\n                moveDistance = 0;\n            }\n            loopMoveMax();\n            index = 0;\n        }\n        // console.log(`第${ index+1 }张`);    // 这里可以做滑动结束回调\n        if (pagination) {\n            nodePagination.querySelector(classNames[4]).className = classNames[3].slice(1);\n            nodePaginationItems[index].classList.add(classNames[4].slice(1));\n        }\n    }\n\n    /** 判断移动 */\n    function judgeMove() {\n        // 判断是否需要执行过渡\n        if (endDistance &lt; startDistance) {\n            // 往上滑动 or 向左滑动\n            if (judgeTouch(-range)) {\n                // 判断有loop的时候不需要执行下面的事件\n                if (!isLoop &amp;&amp; moveDistance === (-(nodeItems.length - 1) * range)) return backLocation();\n                index += 1;\n                slideMove(moveDistance - range);\n                moveDistance -= range;\n                slideEnd(index);\n            } else {\n                backLocation();\n            }\n        } else {\n            // 往下滑动 or 向右滑动\n            if (judgeTouch(range)) {\n                if (!isLoop &amp;&amp; moveDistance === 0) return backLocation();\n                index -= 1;\n                slideMove(moveDistance + range);\n                moveDistance += range;\n                slideEnd(index)\n            } else {\n                backLocation();\n            }\n        }\n    }\n\n    /** 自动播放移动 */\n    function autoMove() {\n        // 这里判断 loop 的自动播放\n        if (isLoop) {\n            index += 1;\n            slideMove(moveDistance - range);\n            moveDistance -= range;\n        } else {\n            if (index &gt;= nodeItems.length - 1) {\n                index = 0;\n                slideMove(0);\n                moveDistance = 0;\n            } else {\n                index += 1;\n                slideMove(moveDistance - range);\n                moveDistance -= range;\n            }\n        }\n        slideEnd(index);\n    }\n\n    /** 开始自动播放 */\n    function startAuto() {\n        count += 1;\n        if (count &lt; interval / 1000 * 60) return animation(startAuto);\n        count = 0;\n        autoMove();\n        startAuto();\n    }\n\n    // 判断是否需要开启自动播放\n    if (autoPaly &amp;&amp; nodeItems.length &gt; 1) startAuto();\n\n    // 开始触摸\n    nodeItem.addEventListener(&quot;touchstart&quot;, ev =&gt; {\n        startTime = Date.now();\n        count = 0;\n        loopCount = moveTime / 1000 * 60;\n        stopAnimation();\n        startDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX;\n    });\n\n    // 触摸移动\n    nodeItem.addEventListener(&quot;touchmove&quot;, ev =&gt; {\n        ev.preventDefault();\n        count = 0;\n        endDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX;\n        slideStyle(getDragDistance());\n    });\n\n    // 触摸离开\n    nodeItem.addEventListener(&quot;touchend&quot;, () =&gt; {\n        endTime = Date.now();\n        // 判断是否点击\n        if (endState !== endDistance) {\n            judgeMove();\n        } else {\n            backLocation();\n        }\n        // 更新位置 \n        endState = endDistance;\n        // 重新打开自动播\n        count = 0;\n    });\n}\n\n/**\n * 输出回路：如果要回路的话前后增加元素\n * @param {number} width 滚动容器的宽度\n * @param {number} height 滚动容器的高度\n */\nfunction outputLoop(width, height) {\n    const first = nodeItems[0].cloneNode(true), last = nodeItems[nodeItems.length - 1].cloneNode(true);\n    nodeItem.insertBefore(last, nodeItems[0]);\n    nodeItem.appendChild(first);\n    nodeItems.unshift(last);\n    nodeItems.push(first);\n    if (direction) {\n        nodeItem.style.top = `${-height}px`;\n    } else {\n        nodeItem.style.left = `${-width}px`;\n    }\n}\n\n/**\n * 输出动态布局\n * @param {number} width 滚动容器的宽度\n * @param {number} height 滚动容器的高度\n */\nfunction outputLayout(width, height) {\n    if (direction) {\n        for (let i = 0; i &lt; nodeItems.length; i++) {\n            nodeItems[i].style.height = `${height}px`;\n        }\n    } else {\n        nodeItem.style.width = `${width * nodeItems.length}px`;\n        for (let i = 0; i &lt; nodeItems.length; i++) {\n            nodeItems[i].style.width = `${width}px`;\n        }\n    }\n}\n\n/** 输出底部圆点 */\nfunction outputPagination() {\n    let paginations = &quot;&quot;;\n    nodePagination = node.querySelector(classNames[2]);\n    // 如果没有找到对应节点则创建一个\n    if (!nodePagination) {\n        nodePagination = document.createElement(&quot;div&quot;);\n        nodePagination.className = classNames[2].slice(1);\n        node.appendChild(nodePagination);\n    }\n    for (let i = 0; i &lt; nodeItems.length; i++) {\n        paginations += `&lt;div class=&quot;${classNames[3].slice(1)}&quot;&gt;&lt;/div&gt;`;\n    }\n    nodePagination.innerHTML = paginations;\n    nodePaginationItems = [...nodePagination.querySelectorAll(classNames[3])];\n    nodePagination.querySelector(classNames[3]).classList.add(classNames[4].slice(1));\n}\n\n/** 初始化动态布局 */\nfunction initLayout() {\n    node = document.querySelector(params.el);\n    if (!node) return console.warn(&quot;没有可执行的节点！&quot;);\n    nodeItem = node.querySelector(classNames[0]);\n    if (!nodeItem) return console.warn(`缺少&quot;${classNames[0]}&quot;节点！`);\n    nodeItems = [...node.querySelectorAll(classNames[1])];\n    if (nodeItems.length == 0) return console.warn(&quot;滑动节点个数必须大于0！&quot;);\n    const moveWidth = node.offsetWidth, moveHeight = node.offsetHeight;\n    if (pagination) outputPagination();\n    if (isLoop) outputLoop(moveWidth, moveHeight);\n    outputLayout(moveWidth, moveHeight);\n    main(moveWidth, moveHeight);\n}\n\n/** 初始化参数 */\nfunction initParams() {\n    if (typeof params !== &quot;object&quot;) return console.warn(&quot;传参有误&quot;);\n    pagination = params.pagination || false;\n    direction = params.vertical || false;\n    autoPaly = params.autoPaly || false;\n    isLoop = params.loop || false;\n    moveTime = params.moveTime || 300;\n    interval = params.interval || 3000;\n    initLayout();\n}\ninitParams();\n</code></pre><p>}</p>\n<pre><code>\n## 图片懒加载\n&gt;非传统实现方式，性能最优\n```javascript\n/**\n * 懒加载\n * @description 可加载`&lt;img&gt;`、`&lt;video&gt;`、`&lt;audio&gt;`等一些引用资源路径的标签\n * @param {object} params 传参对象\n * @param {string?} params.lazyAttr 自定义加载的属性（可选）\n * @param {&quot;src&quot;|&quot;background&quot;} params.loadType 加载的类型（默认为`src`）\n * @param {string?} params.errorPath 加载失败时显示的资源路径，仅在`loadType`设置为`src`中可用（可选）\n */\nfunction lazyLoad(params) {\n    const attr = params.lazyAttr || &quot;lazy&quot;;\n    const type = params.loadType || &quot;src&quot;;\n\n    /** 更新整个文档的懒加载节点 */\n    function update() {\n        const els = document.querySelectorAll(`[${attr}]`);\n        for (let i = 0; i &lt; els.length; i++) {\n            const el = els[i];\n            observer.observe(el);\n        }\n    }\n\n    /**\n     * 加载图片\n     * @param {HTMLImageElement} el 图片节点\n     */\n    function loadImage(el) {\n        const cache = el.src; // 缓存当前`src`加载失败时候用\n        el.src = el.getAttribute(attr);\n        el.onerror = function () {\n            el.src = params.errorPath || cache;\n        }\n    }\n\n    /**\n     * 加载单个节点\n     * @param {HTMLElement} el \n     */\n    function loadElement(el) {\n        switch (type) {\n            case &quot;src&quot;:\n                loadImage(el);\n                break;\n            case &quot;background&quot;:\n                el.style.backgroundImage = `url(${el.getAttribute(attr)})`;\n                break;\n        }\n        el.removeAttribute(attr);\n        observer.unobserve(el);\n    }\n\n    /** \n     * 监听器 \n     * [MDN说明](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)\n    */\n    const observer = new IntersectionObserver(function(entries) {\n        for (let i = 0; i &lt; entries.length; i++) {\n            const item = entries[i];\n            if (item.isIntersecting) {\n                loadElement(item.target);\n            }\n        }\n    })\n\n    update();\n\n    return {\n        observer,\n        update\n    }\n}\n\n</code></pre><p>在vue中使用指令去使用</p>\n<pre><code class=\"javascript\">import Vue from &quot;vue&quot;;\n\n/** 添加一个加载`src`的指令 */\nconst lazySrc = lazyLoad({\n    lazyAttr: &quot;vlazy&quot;,\n    errorPath: &quot;./img/error.jpg&quot;\n})\n\nVue.directive(&quot;v-lazy&quot;, {\n    inserted(el, binding) {\n        el.setAttribute(&quot;vlazy&quot;, binding.value); // 跟上面的对应\n        lazySrc.observer.observe(el);\n    }\n})\n\n/** 添加一个加载`background`的指令 */\nconst lazyBg = lazyLoad({\n    lazyAttr: &quot;vlazybg&quot;,\n    loadType: &quot;background&quot;\n})\n\nVue.directive(&quot;v-lazybg&quot;, {\n    inserted(el, binding) {\n        el.setAttribute(&quot;vlazybg&quot;, binding.value); // 跟上面的对应\n        lazyBg.observer.observe(el);\n    }\n})\n\n\n</code></pre>\n<h2 id=\"上传图片\"><a href=\"#上传图片\" class=\"headerlink\" title=\"上传图片\"></a>上传图片</h2><pre><code class=\"html\">&lt;!-- 先准备好一个input标签，然后设置type=&quot;file&quot;，最后挂载一个onchange事件 --&gt;\n&lt;input class=&quot;upload-input&quot; type=&quot;file&quot; name=&quot;picture&quot; onchange=&quot;upLoadImage(this)&quot;&gt;\n</code></pre>\n<pre><code class=\"javascript\">/**\n * input上传图片\n * @param {HTMLInputElement} el \n */\nfunction upLoadImage(el) {\n    /** 上传文件 */\n    const file = el.files[0];\n    /** 上传类型数组 */\n    const types = [&quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;, &quot;image/gif&quot;];\n    // 判断文件类型\n    if (types.indexOf(file.type) &lt; 0) {\n        file.value = null; // 这里一定要清空当前错误的内容\n        return alert(&quot;文件格式只支持：jpg 和 png&quot;);\n    }\n    // 判断大小\n    if (file.size &gt; 2 * 1024 * 1024) {\n        file.value = null;\n        return alert(&quot;上传的文件不能大于2M&quot;);\n    }\n\n    const formData = new FormData();    // 这个是传给后台的数据\n    formData.append(&quot;img&quot;, file);       // 这里`img`是跟后台约定好的`key`字段\n    console.log(formData, file);\n    // 最后POST给后台，这里我用上面的方法\n    ajax({\n        url: &quot;http://xxx.com/uploadImg&quot;,\n        method: &quot;POST&quot;,\n        data: {},\n        formData: formData,\n        overtime: 5000,\n        success(res) {\n            console.log(&quot;上传成功&quot;, res);\n        },\n        fail(err) {\n            console.log(&quot;上传失败&quot;, err);\n        },\n        timeout() {\n            console.warn(&quot;XMLHttpRequest 请求超时 !!!&quot;);\n        }\n    });\n}\n\n</code></pre>\n<p><a href=\"https://github.com/Hansen-hjs/my-note/blob/master/JavaScript/upload-img.html\" target=\"_blank\" rel=\"noopener\">base64转换和静态预览</a></p>\n<h2 id=\"下拉刷新组件\"><a href=\"#下拉刷新组件\" class=\"headerlink\" title=\"下拉刷新组件\"></a>下拉刷新组件</h2><blockquote>\n<p>拖拽效果参考上面swiper的实现方式，下拉中的效果是可以自己定义的<br><code>`</code>javascript<br>// 这里我做的不是用 window 的滚动事件，而是用最外层的绑定触摸下拉事件去实现<br>// 好处是我用在Vue这类单页应用的时候，组件销毁时不用去解绑 window 的 scroll 事件<br>// 但是滑动到底部事件就必须要用 window 的 scroll 事件，这点需要注意</p>\n</blockquote>\n<p>/**</p>\n<ul>\n<li>下拉刷新组件</li>\n<li>@param {object} option 配置</li>\n<li>@param {HTMLElement} option.el 下拉元素（必选）</li>\n<li>@param {number} option.distance 下拉距离[px]（可选）</li>\n<li>@param {number} option.deviation 顶部往下偏移量[px]（可选）</li>\n<li><p>@param {string} option.loadIcon 下拉中的 icon html（可选）<br><em>/<br>function dropDownRefresh(option) {<br> const doc = document;<br> /** 整体节点 </em>/<br> const page = option.el;<br> /<strong> 下拉距离 */<br> const distance = option.distance || 88;<br> /</strong> 顶部往下偏移量 <em>/<br> const deviation = option.deviation || 0;<br> /** 顶层节点 </em>/<br> const topNode = doc.createElement(&quot;div&quot;);<br> /*<em> 下拉时遮罩 </em>/<br> const maskNode = doc.createElement(&quot;div&quot;);</p>\n<p> topNode.innerHTML = <code>&lt;div refresh-icon style=&quot;transition: .2s all;&quot;&gt;&lt;svg style=&quot;transform: rotate(90deg); display: block;&quot; t=&quot;1570593064555&quot; viewBox=&quot;0 0 1575 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;26089&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;path d=&quot;M1013.76 0v339.968H484.115692V679.778462h529.644308v339.968l529.644308-485.612308v-48.600616L1013.76 0zM243.396923 679.857231h144.462769V339.968H243.396923V679.778462z m-240.797538 0h144.462769V339.968H2.599385V679.778462z&quot; fill=&quot;#000000&quot; fill-opacity=&quot;.203&quot; p-id=&quot;26090&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/div&gt;&lt;div refresh-loading style=&quot;display: none; animation: refresh-loading 1s linear infinite;&quot;&gt;${option.loadIcon || &#39;&lt;p style=&quot;font-size: 15px; color: #666;&quot;&gt;loading...&lt;/p&gt;&#39;}&lt;/div&gt;</code>;<br> topNode.style.cssText = <code>width: 100%; height: ${distance}px; position: fixed; top: ${-distance + deviation}px; left: 0; z-index: 10; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; box-sizing: border-box; margin: 0; padding: 0;</code>;<br> maskNode.style.cssText = &quot;position: fixed; top: 0; left: 0; width: 100%; height: 100vh; box-sizing: border-box; margin: 0; padding: 0; background-color: rgba(0,0,0,0); z-index: 999;&quot;;<br> page.parentNode.insertBefore(topNode, page);</p>\n<p> /**</p>\n<ul>\n<li>设置动画时间</li>\n<li><p>@param {number} n 秒数<br>*/<br>function setAnimation(n) {<br> page.style.transition = topNode.style.transition = n + &quot;s all&quot;;<br>}</p>\n<p>/**</p>\n</li>\n<li>设置滑动距离</li>\n<li><p>@param {number} n 滑动的距离（像素）<br>*/<br>function setSlide(n) {<br> page.style.transform = topNode.style.transform = <code>translate3d(0px, ${n}px, 0px)</code>;<br>}</p>\n<p>/<strong> 下拉提示 icon */<br>const icon = topNode.querySelector(&quot;[refresh-icon]&quot;);<br>/</strong> 下拉 loading 动画 */<br>const loading = topNode.querySelector(&quot;[refresh-loading]&quot;);</p>\n<p>return {<br> /**</p>\n<ul>\n<li>监听开始刷新</li>\n<li>@param {Function} callback 下拉结束回调</li>\n<li><p>@param {(n: number) =&gt; void} rangeCallback 下拉状态回调<br><em>/<br>onRefresh(callback, rangeCallback = null) {<br> /** 顶部距离 </em>/<br> let scrollTop = 0;<br> /<strong> 开始距离 */<br> let startDistance = 0;<br> /</strong> 结束距离 <em>/<br> let endDistance = 0;<br> /** 最后移动的距离 </em>/<br> let range = 0;</p>\n<p> // 触摸开始<br> page.addEventListener(&quot;touchstart&quot;, function (e) {</p>\n<pre><code> startDistance = e.touches[0].pageY;\n scrollTop = 1;\n setAnimation(0);\n</code></pre><p> });</p>\n<p> // 触摸移动<br> page.addEventListener(&quot;touchmove&quot;, function (e) {</p>\n<pre><code> scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop;\n // 没到达顶部就停止\n if (scrollTop != 0) return;\n endDistance = e.touches[0].pageY;\n range = Math.floor(endDistance - startDistance);\n // 判断如果是下滑才执行\n if (range &gt; 0) {\n     // 阻止浏览自带的下拉效果\n     e.preventDefault();\n     // 物理回弹公式计算距离\n     range = range - (range * 0.5);\n     // 下拉时icon旋转\n     if (range &gt; distance) {\n         icon.style.transform = &quot;rotate(180deg)&quot;;\n     } else {\n         icon.style.transform = &quot;rotate(0deg)&quot;;\n     }\n     setSlide(range);\n     // 回调距离函数 如果有需要\n     if (typeof rangeCallback === &quot;function&quot;) rangeCallback(range);\n }\n</code></pre><p> });</p>\n<p> // 触摸结束<br> page.addEventListener(&quot;touchend&quot;, function () {</p>\n<pre><code> setAnimation(0.3);\n // console.log(`移动的距离：${range}, 最大距离：${distance}`);\n if (range &gt; distance &amp;&amp; range &gt; 1 &amp;&amp; scrollTop === 0) {\n     setSlide(distance);\n     doc.body.appendChild(maskNode);\n     // 阻止往上滑动\n     maskNode.ontouchmove = e =&gt; e.preventDefault();\n     // 回调成功下拉到最大距离并松开函数\n     if (typeof callback === &quot;function&quot;) callback();\n     icon.style.display = &quot;none&quot;;\n     loading.style.display = &quot;block&quot;;\n } else {\n     setSlide(0);\n }\n</code></pre><p> });</p>\n<p>},<br>/*<em> 结束下拉 </em>/<br>end() {<br> maskNode.parentNode.removeChild(maskNode);<br> setAnimation(0.3);<br> setSlide(0);<br> icon.style.display = &quot;block&quot;;<br> loading.style.display = &quot;none&quot;;<br>}<br>}<br>}</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>\n## 监听滚动到底部\n```javascript\n/**\n * 监听滚动到底部\n * @param {object} options 传参对象\n * @param {number} options.distance 距离底部多少像素触发（px）\n * @param {boolean} options.once 是否为一次性（防止重复用）\n * @param {() =&gt; void} options.callback 到达底部回调函数\n */\nfunction onScrollToBottom(options) {\n    const { distance = 0, once = false, callback = null } = options;\n    const doc = document;\n    /** 滚动事件 */\n    function onScroll() {\n        /** 滚动的高度 */\n        let scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop;\n        /** 滚动条高度 */\n        let scrollHeight = doc.documentElement.scrollTop === 0 ? doc.body.scrollHeight : doc.documentElement.scrollHeight;\n        if (scrollHeight - scrollTop - distance &lt;= window.innerHeight) {\n            if (typeof callback === &quot;function&quot;) callback();\n            if (once) window.removeEventListener(&quot;scroll&quot;, onScroll);\n        }\n    }\n    window.addEventListener(&quot;scroll&quot;, onScroll);\n    // 必要时先执行一次\n    // onScroll(); \n}\n\n</code></pre><h2 id=\"音频播放组件\"><a href=\"#音频播放组件\" class=\"headerlink\" title=\"音频播放组件\"></a>音频播放组件</h2><pre><code class=\"javascript\">/**\n * `AudioContext`音频组件 \n * [资料参考](https://www.cnblogs.com/Wayou/p/html5_audio_api_visualizer.html)\n * @description 解决在移动端网页上标签播放音频延迟的方案 貌似`H5`游戏引擎也是使用这个实现\n */\nfunction audioComponent() {\n    /**\n     * 音频上下文\n     * @type {AudioContext}\n     */\n    const context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext)();\n    /** \n     * @type {AnalyserNode} \n     */\n    const analyser = context.createAnalyser();;\n    /**\n     * @type {AudioBufferSourceNode}\n     */\n    let bufferNode = null;\n    /**\n     * @type {AudioBuffer}\n     */\n    let buffer = null;\n    /** 是否加载完成 */\n    let loaded = false;\n\n    analyser.fftSize = 256;\n\n    return {\n        /**\n         * 加载路径音频文件\n         * @param {string} url 音频路径\n         * @param {(res: AnalyserNode) =&gt; void} callback 加载完成回调\n         */\n        loadPath(url, callback) {\n            const XHR = new XMLHttpRequest(); \n            XHR.open(&quot;GET&quot;, url, true); \n            XHR.responseType = &quot;arraybuffer&quot;; \n            // 先加载音频文件\n            XHR.onload = () =&gt; {\n                context.decodeAudioData(XHR.response, audioBuffer =&gt; {\n                    // 最后缓存音频资源\n                    buffer = audioBuffer;\n                    loaded = true;\n                    typeof callback === &quot;function&quot; &amp;&amp; callback(analyser);\n                });\n            }\n            XHR.send(null);\n        },\n\n        /** \n         * 加载 input 音频文件\n         * @param {File} file 音频文件\n         * @param {(res: AnalyserNode) =&gt; void} callback 加载完成回调\n         */\n        loadFile(file, callback) {\n            const FR = new FileReader();\n            // 先加载音频文件\n            FR.onload = e =&gt; {\n                const res = e.target.result;\n                // 然后解码\n                context.decodeAudioData(res, audioBuffer =&gt; {\n                    // 最后缓存音频资源\n                    buffer = audioBuffer;\n                    loaded = true;\n                    typeof callback === &quot;function&quot; &amp;&amp; callback(analyser);\n                });\n            }\n            FR.readAsArrayBuffer(file);\n        },\n\n        /** 播放音频 */\n        play() {\n            if (!loaded) return console.warn(&quot;音频未加载完成 !!!&quot;);\n            // 这里有个问题，就是创建的音频对象不能缓存下来然后多次执行 start , 所以每次都要创建然后 start()\n            bufferNode = context.createBufferSource();\n            bufferNode.connect(analyser);\n            analyser.connect(context.destination);\n            bufferNode.buffer = buffer;\n            bufferNode.start(0);\n        },\n\n        /** 停止播放 */\n        stop() {\n            if (!bufferNode) return console.warn(&quot;音频未播放 !!!&quot;);\n            bufferNode.stop();\n        }\n    }\n}\n\n</code></pre>\n<h2 id=\"全局监听图片错误并替换到默认图片\"><a href=\"#全局监听图片错误并替换到默认图片\" class=\"headerlink\" title=\"全局监听图片错误并替换到默认图片\"></a>全局监听图片错误并替换到默认图片</h2><pre><code class=\"javascript\">window.addEventListener(&quot;error&quot;, e =&gt; {\n    /** 默认`base64`图片 */\n    const defaultImg = &#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJoAAACACAYAAADzsnDqAAANXElEQVR4Xu2dDYxcVRXHz3mz0FgjICBSgkZAQD5CwQ+Qz4BBBUEkUJpK0FAUYmms2O47d7oSmYbYnXfeLIXl01ojBAnSokRQQIWAIvEjkfBhUZGPEkMFDajgbjdu5x1zYVpmd2d25r1335uZzrkJIenec869//ubO/Pux3kIWlSBHBTAHGJoCFUAFDSFIBcFFLRcZNYgCpoykIsCClouMmsQBU0ZyEUBBS0XmTWIgqYM5KKAgpaLzBpEQVMGclFAQctFZg2ioCkDuSigoOUiswbJHLTR0dE5W7ZsWQAAB6rcnVMAETcj4vO+7z/QiVZkCtrIyMhB1Wr12wBwcic6pzFnKiAiq4wxpby1yRS0IAhuR8RFeXdK47VUYCERbWhZy2GFzEBbs2bNvMnJyc0O26qu3CnwJBHNd+eutafMQBseHj65UCg81LoJWqMTChBRZmPfqD+ZBVPQOoFP+zEVtPa10popFFDQUoinpu0r0E+gPVytVle1L43WjKNAoVC4YrZlpb4CjYhOiSOe1m1fAWa2D2JN1y8VtPa11JqzKKCgvS3OwzqjZfdZUdAUtOzoqvOsoCloCppLBdpYsNWvTpeCT/OlM5rOaBni9bZrBU1BU9BcKqBfnS7VjO9LZzSd0eJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQVPQ4lOTwEJBU9ASYBPfREFT0OJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQesgaMy8NxG9HH/Yes9CQesQaOVy+f2e560koiW9h038FitoHQKNmb8LABeJSNEYE8Qfut6yUNA6ABozfwoAfmZDi8gEIl5IRHf0FjrxWqugdQC0MAwfFZHj6obqT4i42Pf938Ubvt6praDlDFoQBMsQ8ZrpiCDifWNjYwtKpdJ47+DTfksVtBxBC8NwLxH5MwC8u8kQ3UhEl7Y/fL1TU0HLF7TrRaQVSIaIuHcQaq+lClpOoJXL5ZM8z/tlG8MyHkXR4mKxuL6Nuj1TRUHLCTRmfhAAPtEmGU9v3br13KGhIfs1u0MUBS0H0Jj5EgCwSZrjlHuJ6Iw4Bt1cV0HLGLTR0dFdtmzZ8gwivjcuCCJygzFmaVy7bqyvoGUMWhiGIyKyPMXg+0RUSWHfFabMfJ6IHIaIhwKA/e+w+oZp2qoUwxQEwdGImHYRdgwAziGin6doSteZhmF4eBRFi2rp+A9Q0FIMETP/FAA+k8LFNtONY2Njx61atep1B766zgUzn0tEP8yzYZ3Myu00yQszfxEAbnEo3k+I6LMO/fW1qx0CtFKptPPcuXOfBYD3uRxNRLzO9/2vuvTZr752CNCY+VsAMJTRIF5MROsy8h3b7erVq/fwPG8fz/PmAcA+iDhPRP4LAPZA58sDAwN/nzNnzstLly61/9Y1pedBC8PwCBF5IitF7SB6nnes7/t/zCrGbH5rs7X9Cj8TAOz/92izHRtF5E7P8+7rhlMqPQ8aM98FAGe3KX7Sak8R0RFJjZPYMfNpAHABAJwOALsn8VFnsxEAHkDEdZ36wPQ0aOVyeaHneXkdYLyHiM5KOeAtzZn5wwDwNQCwDzeui126ucYem/J9/x+unc/mr6dBY2b7AHBAXoKJyJXGmG9mES8Ign0R0QK2DAB2ziJGnc8XLHBENOOcXlZxexY0ZrYD3ok3r5xBRPe6HJBKpXJSFEVrAeBgl37b8PXAwMDAkuXLl9sPbKalJ0FbvXr1QQMDA3/JVJkmzhHx9UKhsN/y5ctfcxE/DMOFIpLX13+jJr8aRdEXisXifS7608xHT4IWBMEdiLgwS2Fa+HbyYlVmvgoAvt7BftSHXkZE12bVlp4DLQiCsxDxx1kJ0q5fRLzF9/0L260/vR4z311brkjqwrkdIn7e9/0fOHcMAD0HGjM/DQCHZCFGXJ8issQYc1NcuyAIRhAxzQmTuCHbrl8oFI5csWKF83XJngKNmQkAuu3y71FE9Hi7I8nMdhb8Xrv1O1DvbwBwtOvUET0DWi2lwYsdEL5VyP8Q0W6tKtm/l8vl+Z7n2eNHe7VTv0Udg4j3FwqFvyLibpOTk/sDQAgAxzrw7XzNsGdAY+ZbayvlDnR07uIhImp5P4GZ7ekSFwuxixrdtC+VSnPnzp17m6OdkstcrrP1BGj1KQ2cI+LIISIO+77fdGO/tqWUegkBEa/2fb/pkyozHwkA9qWwbc2ys3T/BUT8uKsdhJ4ALQiCxxFxviMmMnMjIp8zxtinyRmFmS1kdv8yVfE875DBwcFZb2sxs/0NmPiJuK6Bq4noG6kaXDPuetDCMLxMRNa46GzWPkTkVGOMveY3pTg8lPkcEX2wVT+Y+csA8J1W9dr4+1htVkt9cqWrQbMpDQBgs4gU2hCl01VeJ6Jdm8xmvwWAYxw0cBMR7dfKj+Mn22uJyO6/pipdDdq2nGapepif8c1EtHh6OHspRESectUMEdnFGPPGbP7CMFwrIhe7iCkizxpjDkzrq2tBi5HSIK0GTuyb/T5jZnsi42onQd7K79bw67nefxiGj4uIs9+01Wr1lJUrVz6cpg9dCxoz/x4APpamcznaVolooMnXpn0CPNlVW0RkyBgz3Mzf6OjonImJiQlX8Wp+RohoMI3PrgQtCIJLEfH6NB3L01ZEfmGMsVklp5Ra2qxXHLflLiI6p5nPSqVyQhRFj7iMKSLPGGNSHWHqOtBsSoOJiQl70eIdLsXK0peI3GaMsceupxRmtuf873Ec+yUi2reZzzAMl4vIiOOY9iu75W/D2WJ2HWjMfCMAfMW1UFn6E5GrjDErGoCWJNlMy6Yi4v6+79tTsjNKEAS3126jt/QTp0KhUDh4xYoVz8Sxqa/bVaCFYXiMiNilgJ4qzTJ9h2F4hYiUXHdGRM4zxtzZyG9Wp1vSPhB0G2iPiMgJrgcma38icpExZsaJDGa2qbPsrOa0NNvuqlQqe0ZR9E+nwd52dj4R3Z7Ud9eA5nA1O6kWie2iKDqzWCzavB9TShiGd4tIFmkVHiSiUxt8Vdu8IzPakbhjdYYiMmiMSfzbrytAq12Stde/Gq6suxAqYx8NL6wws30QsA8Erssb4+Pju5dKpa31jpn5cgC40nUw62+HAC0IAnvXMPU2RxYCt+lzMRHd3GCGsfuNdt/ReRGRY4wxdq1xewmCYAMiLnAe7C3QLjDG2CNIiUrHZ7SRkZGjqtXqY4la3yVGIkLGGHvocEphZju72Fkmi3IpEdkn9O2Fme1TYertokaNbWdHYrZOdhy0MAwfFJGWhwazGClXPhEx9H3fHjOfUjJeeF5HRNv3M8Mw3E9EnnfVp+l+PM87bHBw0N7XSFQ6Clrt7LzLnGaJRHBg1HBDPQiCcxAxq4R3jxHRR7a1vVKpnB1Fkc1DkkkZGBjYI81d1k6DZvOqvicTZfJ12jCjd6VSOTSKIptgJZNSv7YVBEEJEa/IJBDAq0S0ZxrfnQbN2WZzGhHS2orIK8aYvRv5YWZ7aHBKouK08ers38yaOTIyclC1WrW33e0x7ixKwxk7TqBOghannV1fN4qiE4vF4q+nNzTjmcaG2wQANtV9lnvDC9LmvFXQ3CFcISJ/ujtmPhEAfuUuTO6eXhsfH59XKpX+lyaygpZGvam2Tc/zM7O9TJLqmI27Zsb2dBsRzTiZEteLghZXsVnqR1F0WrFYfPNNx/UlCAJ72bfsMFSerj7t4p0LCprbIbuJiJZMd7l+/frCpk2bHnV0QWWbe3u0+nIReRIR7SWeczNIF9GwP0kkU9CSqNbERkTGd9ppp/mNEtsFQbAAETc4CreRiA6f7mt4ePgDhUKh4Tm1uHHtkzQiHk9Ez8W1bVRfQXOhYp2P2dKPMrPdKzw/bUhEPM73/d808sPMNqWXi1y7Tt+JpaClHfWZ9i+Oj48fWSqV/j39T66SvMz2HidHyyk7VJIX90PcPR6bZk90cbnXpofwff/JJjOafZPyeSmk2OHSVqXQortNEfGJycnJTw4NDTU87eogEd8GIpqRWjUMw3eKyGYA2CWpQr2YiG//QqHg5IdkUtE6bDfrtk3a1KIissoYs/0+QrlcPh0RRxGxZW6OZrr0ZGpR2xlmtlsyx3d4wDsWXkSWGmNuaNaAIAjWIeKXUjTwXwDwvIjsmgYwG7/ZBZsUbZtimtnDgI1SS2z8fQB4l6sG95ifLQBwAhE1PdjJzPbV2td1sl+IeInv+y6yDzXtRqag1WD7aO1T+6FOitnJ2PaExWzxXTwgJOzfSyKyzBjzo4T2bZtlDlrbLenzivZWu51ZMro11UjdtTbtRLOnV9fDoaC5VjSlvxyAW+t53trBwcE/pGxqLHMFLZZc+VWu5e1Y5PI1ip7n3Zo3YNsUU9DyYydRpDQvhq3trd6/Q78YNpGqatRSAX3VdUuJtEI/K6Bfnf08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0MpaP08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0P9H/gjHdvP/Qy/AAAAAElFTkSuQmCC&#39;;\n    /**\n     * @type {HTMLImageElement}\n     */\n    const node = e.target;\n    if (node.nodeName &amp;&amp; node.nodeName.toLocaleLowerCase() === &quot;img&quot;) {     \n        node.style.objectFit = &quot;cover&quot;;\n        node.src = defaultImg;\n    }\n}, true);\n\n</code></pre>\n<h2 id=\"复制功能\"><a href=\"#复制功能\" class=\"headerlink\" title=\"复制功能\"></a>复制功能</h2><p>翻 <code>Clipboard.js</code> 这个插件库源码的时候找到核心代码 <code>setSelectionRange(start: number, end: number)</code>，百度上搜到的复制功能全部都少了这个操作，所以搜到的复制文本代码在 ios 和 IE 等一些浏览器上复制不了。</p>\n<pre><code class=\"javascript\">/**\n * 复制文本\n * @param {string} text 复制的内容\n * @param {() =&gt; void} success 成功回调\n * @param {(tip: string) =&gt; void} fail 出错回调\n */\nfunction copyText(text, success = null, fail = null) {\n    text = text.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;);\n    if (!text) {\n        typeof fail === &quot;function&quot; &amp;&amp; fail(&quot;复制的内容不能为空！&quot;);\n        return;\n    }\n    const id = &quot;the-clipboard&quot;;\n    /**\n     * 粘贴板节点\n     * @type {HTMLTextAreaElement}\n     */\n    let clipboard = document.getElementById(id);\n    if (!clipboard) {\n        clipboard = document.createElement(&quot;textarea&quot;);\n        clipboard.id = id;\n        clipboard.readOnly = true\n        clipboard.style.cssText = &quot;font-size: 15px; position: fixed; top: -1000%; left: -1000%;&quot;;\n        document.body.appendChild(clipboard);\n    }\n    clipboard.value = text;\n    clipboard.select();\n    clipboard.setSelectionRange(0, text.length);\n    const state = document.execCommand(&quot;copy&quot;);\n    if (state) {\n        typeof success === &quot;function&quot; &amp;&amp; success();\n    } else {\n        typeof fail === &quot;function&quot; &amp;&amp; fail(&quot;复制失败&quot;);\n    }\n}\n\n</code></pre>\n<h2 id=\"检测类型\"><a href=\"#检测类型\" class=\"headerlink\" title=\"检测类型\"></a>检测类型</h2><pre><code class=\"javascript\">/**\n * 检测类型\n * @param {any} target 检测的目标\n * @returns {&quot;string&quot;|&quot;number&quot;|&quot;array&quot;|&quot;object&quot;|&quot;function&quot;|&quot;null&quot;|&quot;undefined&quot;} 只枚举一些常用的类型\n */\nfunction checkType(target) {\n    /** @type {string} */\n    const value = Object.prototype.toString.call(target);\n    const result = value.match(/\\[object (\\S*)\\]/)[1];\n    return result.toLocaleLowerCase();\n}\n\n</code></pre>\n<h2 id=\"格式化日期（代码极少版）\"><a href=\"#格式化日期（代码极少版）\" class=\"headerlink\" title=\"格式化日期（代码极少版）\"></a>格式化日期（代码极少版）</h2><pre><code class=\"javascript\">/**\n * 获取指定日期时间戳\n * @param {number} time 毫秒数\n */\nfunction getDateFormat(time = Date.now()) {\n    const date = new Date(time);\n    return `${date.toLocaleDateString()} ${date.toTimeString().slice(0, 8)}`;\n}\n\n</code></pre>\n<h2 id=\"js小数精度计算\"><a href=\"#js小数精度计算\" class=\"headerlink\" title=\"js小数精度计算\"></a>js小数精度计算</h2><pre><code class=\"javascript\">/**\n * 数字运算（主要用于小数点精度问题）\n * @param {number} a 前面的值\n * @param {&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;} type 计算方式\n * @param {number} b 后面的值\n * @example \n * ```js\n * // 可链式调用\n * const res = computeNumber(1.3, &quot;-&quot;, 1.2).next(&quot;+&quot;, 1.5).next(&quot;*&quot;, 2.3).next(&quot;/&quot;, 0.2).result;\n * console.log(res);\n *\n</code></pre>\n<p> */<br>function computeNumber(a, type, b) {<br>    /**</p>\n<pre><code> * 获取数字小数点的长度\n * @param {number} n 数字\n */\nfunction getDecimalLength(n) {\n    const decimal = n.toString().split(&quot;.&quot;)[1];\n    return decimal ? decimal.length : 0;\n}\n/**\n * 修正小数点\n * @description 防止出现 `33.33333*100000 = 3333332.9999999995` &amp;&amp; `33.33*10 = 333.29999999999995` 这类情况做的处理\n * @param {number} n\n */\nconst amend = (n, precision = 15) =&gt; parseFloat(Number(n).toPrecision(precision));\nconst power = Math.pow(10, Math.max(getDecimalLength(a), getDecimalLength(b)));\nlet result = 0;\n\na = amend(a * power);\nb = amend(b * power);\n\nswitch (type) {\n    case &quot;+&quot;:\n        result = (a + b) / power;\n        break;\n    case &quot;-&quot;:\n        result = (a - b) / power;\n        break;\n    case &quot;*&quot;:\n        result = (a * b) / (power * power);\n        break;\n    case &quot;/&quot;:\n        result = a / b;\n        break;\n}\n\nresult = amend(result);\n\nreturn {\n    /** 计算结果 */\n    result,\n    /**\n     * 继续计算\n     * @param {&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;} nextType 继续计算方式\n     * @param {number} nextValue 继续计算的值\n     */\n    next(nextType, nextValue) {\n        return computeNumber(result, nextType, nextValue);\n    }\n};\n</code></pre><p>}</p>\n<pre><code>\n## 一行css适配rem\n750是设计稿的宽度：之后的单位直接1:1使用设计稿的大小，单位是rem\n```javascript\nhtml{ font-size: calc(100vw / 750); }\n</code></pre><h2 id=\"好用的格式化日期方法\"><a href=\"#好用的格式化日期方法\" class=\"headerlink\" title=\"好用的格式化日期方法\"></a>好用的格式化日期方法</h2><pre><code class=\"javascript\">/**\n * 格式化日期\n * @param {string | number | Date} value 指定日期\n * @param {string} format 格式化的规则\n * @example\n * ```js\n * formatDate();\n * formatDate(1603264465956);\n * formatDate(1603264465956, &quot;h:m:s&quot;);\n * formatDate(1603264465956, &quot;Y年M月D日&quot;);\n *\n</code></pre>\n<p> */<br>function formatDate(value = Date.now(), format = &quot;Y-M-D h:m:s&quot;) {<br>    const formatNumber = n =&gt; <code>0${n}</code>.slice(-2);<br>    const date = new Date(value);<br>    const formatList = [&quot;Y&quot;, &quot;M&quot;, &quot;D&quot;, &quot;h&quot;, &quot;m&quot;, &quot;s&quot;];<br>    const resultList = [];<br>    resultList.push(date.getFullYear().toString());<br>    resultList.push(formatNumber(date.getMonth() + 1));<br>    resultList.push(formatNumber(date.getDate()));<br>    resultList.push(formatNumber(date.getHours()));<br>    resultList.push(formatNumber(date.getMinutes()));<br>    resultList.push(formatNumber(date.getSeconds()));<br>    for (let i = 0; i &lt; resultList.length; i++) {<br>        format = format.replace(formatList[i], resultList[i]);<br>    }<br>    return format;<br>}</p>\n<pre><code>\n## 网页定位\n这里使用百度定位，无论代码封装、调用方式还是位置准确性都比微信sdk那个好用太多了，包括在任何网页端；\n[文档说明](http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey)\n[获取百度地图key](http://lbsyun.baidu.com/apiconsole/key#/home)\n```javascript\n/**\n * 插入脚本\n * @param {string} link 脚本路径\n * @param {Function} callback 脚本加载完成回调\n */\nfunction insertScript(link, callback) {\n    const label = document.createElement(&quot;script&quot;);\n    label.src = link;\n    label.onload = function () {\n        if (label.parentNode) label.parentNode.removeChild(label);\n        if (typeof callback === &quot;function&quot;) callback();\n    }\n    document.body.appendChild(label);\n}\n\n/**\n * 获取定位信息 \n * @returns {Promise&lt;{ city: string, districtName: string, province: string, longitude: number, latitude: number }&gt;}\n*/\nfunction getLocationInfo() {\n    /**\n     * 使用百度定位\n     * @param {(value: any) =&gt; void} callback\n     */\n    function useBaiduLocation(callback) {\n        const geolocation = new BMap.Geolocation({\n            maximumAge: 10\n        })\n        geolocation.getCurrentPosition(function(res) {\n            console.log(&quot;%c 使用百度定位 &gt;&gt;&quot;, &quot;background-color: #4e6ef2; padding: 2px 6px; color: #fff; border-radius: 2px&quot;, res);\n            callback({\n                city: res.address.city,\n                districtName: res.address.district,\n                province: res.address.province,\n                longitude: Number(res.longitude),\n                latitude: Number(res.latitude)\n            })\n        })\n    }\n\n    return new Promise(function (resolve, reject) {\n        if (!window._baiduLocation) {\n            window._baiduLocation = function () {\n                useBaiduLocation(resolve);\n            }\n            // ak=你自己的key\n            insertScript(&quot;https://api.map.baidu.com/api?v=2.0&amp;ak=66vCKv7PtNlOprFEe9kneTHEHl8DY1mR&amp;callback=_baiduLocation&quot;);\n        } else {\n            useBaiduLocation(resolve);\n        }\n    })\n}\n\n</code></pre><h2 id=\"输入保留数字-lt-input-type-quot-text-quot-gt\"><a href=\"#输入保留数字-lt-input-type-quot-text-quot-gt\" class=\"headerlink\" title=\"输入保留数字&lt;input type=&quot;text&quot;&gt;\"></a>输入保留数字<code>&lt;input type=&quot;text&quot;&gt;</code></h2><p>使用场景：用户在输入框输入内容时，实时过滤保持数字值显示；</p>\n<p>tips：在Firefox中设置 <code>&lt;input type=&quot;number&quot;&gt;</code> 会有样式 bug</p>\n<pre><code class=\"javascript\">/**\n * 输入只能是数字\n * @param {string | number} value 输入的值\n * @param {boolean} decimal 是否要保留小数\n * @param {boolean} negative 是否可以为负数\n */\nfunction inputOnlyNumber(value, decimal, negative) {\n    let result = value.toString().trim();\n    if (result.length === 0) return &quot;&quot;;\n    const minus = (negative &amp;&amp; result[0] == &quot;-&quot;) ? &quot;-&quot; : &quot;&quot;;\n    if (decimal) {\n        result = result.replace(/[^0-9.]+/ig, &quot;&quot;);\n        let array = result.split(&quot;.&quot;);\n        if (array.length &gt; 1) {\n            result = array[0] + &quot;.&quot; + array[1];\n        }\n    } else {\n        result = result.replace(/[^0-9]+/ig, &quot;&quot;);\n    }\n    return minus + result;\n}\n\n</code></pre>\n<h2 id=\"Intl-NumberFormat（格式化数字）\"><a href=\"#Intl-NumberFormat（格式化数字）\" class=\"headerlink\" title=\"Intl.NumberFormat（格式化数字）\"></a>Intl.NumberFormat（格式化数字）</h2><ul>\n<li>现在JS提供了一个更加可用和规范化的API——Intl.NumberFormat。对于常用的货币格式化都有良好的支持。<blockquote>\n<p>推荐使用</p>\n<pre><code class=\"javascript\">new Intl.NumberFormat().format(123456.789);\n// 显示结果为：123,456.789\n</code></pre>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"javascript\">new Intl.NumberFormat(&#39;ja-JP&#39;, { style: &#39;currency&#39;, currency: &#39;JPY&#39; }).format(12345.678);\n// 结果显示为：&quot;￥12,346&quot;\n</code></pre>\n<ul>\n<li><p>正则表达式 （古早的做法）</p>\n<pre><code class=\"javascript\">const number = 1234567;\nnumber.toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, &#39;$1,&#39;);\n// 结果为：1,234,567\n</code></pre>\n</li>\n<li><p>Date API</p>\n<pre><code class=\"javascript\">const number = 123456.789;\nnumber.toLocaleString();// 结果为：123,456.789\n</code></pre>\n</li>\n</ul>\n<h2 id=\"加密\"><a href=\"#加密\" class=\"headerlink\" title=\"加密\"></a>加密</h2><h3 id=\"base64加密\"><a href=\"#base64加密\" class=\"headerlink\" title=\"base64加密\"></a>base64加密</h3><pre><code class=\"javascript\">var str = &#39;hello&#39;;\nvar str64 = window.btoa(str);\nconsole.log(&#39;经base64编码后：&#39;+ str64); // 经base64编码后：aGVsbG8=\nconsole.log(&#39;经base64解码后：&#39; + window.atob(str64)); // 经base64解码后：hello\n\n</code></pre>\n<h3 id=\"编码和解码字符串\"><a href=\"#编码和解码字符串\" class=\"headerlink\" title=\"编码和解码字符串\"></a>编码和解码字符串</h3><p>使用JS函数的<code>escape()</code>和<code>unescape()</code>，分别是编码和解码字符串</p>\n<pre><code class=\"javascript\">var escape1 = escape(&#39;我的名字是：Neo&#39;); // 编码\nvar unescape1 = unescape(escape1); // 解码\nconsole.log(escape1) // %u6211%u7684%u540D%u5B57%u662F%uFF1ANeo\nconsole.log(unescape1) // &quot;我的名字是：Neo&quot;\n</code></pre>\n<h2 id=\"lucky-canvas【大转盘-九宫格】抽奖\"><a href=\"#lucky-canvas【大转盘-九宫格】抽奖\" class=\"headerlink\" title=\"lucky-canvas【大转盘/九宫格】抽奖\"></a>lucky-canvas【大转盘/九宫格】抽奖</h2><p><a href=\"https://100px.net/\" target=\"_blank\" rel=\"noopener\">lucky-canvas【大转盘/九宫格】抽奖</a></p>\n<h2 id=\"FineBI大屏\"><a href=\"#FineBI大屏\" class=\"headerlink\" title=\"FineBI大屏\"></a>FineBI大屏</h2><p><a href=\"https://help.fanruan.com/finebi/\" target=\"_blank\" rel=\"noopener\">FineBI大屏</a></p>\n<h2 id=\"大屏数据展示模板\"><a href=\"#大屏数据展示模板\" class=\"headerlink\" title=\"大屏数据展示模板\"></a>大屏数据展示模板</h2><p><a href=\"https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi\" target=\"_blank\" rel=\"noopener\">大屏数据展示模板</a></p>\n<h2 id=\"js拖动滑块验证功能\"><a href=\"#js拖动滑块验证功能\" class=\"headerlink\" title=\"js拖动滑块验证功能\"></a>js拖动滑块验证功能</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;title&gt;滑块解锁封装js方法&lt;/title&gt;\n    &lt;!--注：这里首次用到了iconfont的语法，即矢量图标--&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;font/iconfont.css&quot; /&gt;\n    &lt;style&gt;\n      * {\n        padding: 0;\n        margin: 0;\n      }\n      #box {\n        position: relative;\n        width: 300px;\n        height: 40px;\n        margin: 0 auto;\n        margin-top: 10px;\n        background-color: #e8e8e8;\n        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);\n      }\n      .bgColor {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 40px;\n        height: 40px;\n        background-color: lightblue;\n      }\n      .txt {\n        position: absolute;\n        width: 100%;\n        height: 40px;\n        line-height: 40px;\n        font-size: 14px;\n        color: #000;\n        text-align: center;\n      }\n      .slider {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 50px;\n        height: 38px;\n        border: 1px solid #ccc;\n        background: #fff;\n        text-align: center;\n        cursor: move;\n      }\n      .slider &gt; i {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n      }\n      .slider.active &gt; i {\n        color: green;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;box&quot; onselectstart=&quot;return false;&quot;&gt;\n      &lt;div class=&quot;bgColor&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;txt&quot;&gt;滑动解锁&lt;/div&gt;\n      &lt;!--给i标签添加上相应字体图标的类名即可--&gt;\n      &lt;div class=&quot;slider&quot;&gt;&lt;i class=&quot;iconfont icon-double-right&quot;&gt;&lt;/i&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n      //一、定义了一个获取元素的方法\n      function getEle(selector) {\n        return document.querySelector(selector)\n      }\n      //二、获取到需要用到的DOM元素\n      var box = getEle(&quot;#box&quot;), //容器\n        bgColor = getEle(&quot;.bgColor&quot;), //背景色\n        txt = getEle(&quot;.txt&quot;), //文本\n        slider = getEle(&quot;.slider&quot;), //滑块\n        icon = getEle(&quot;.slider&gt;i&quot;),\n        successMoveDistance = box.offsetWidth - slider.offsetWidth, //解锁需要滑动的距离\n        downX, //用于存放鼠标按下时的位置\n        isSuccess = false //是否解锁成功的标志，默认不成功\n\n      //三、给滑块添加鼠标按下事件\n      slider.onmousedown = mousedownHandler\n\n      //3.1鼠标按下事件的方法实现\n      function mousedownHandler(e) {\n        bgColor.style.transition = &quot;&quot;\n        slider.style.transition = &quot;&quot;\n        var e = e || window.event || e.which\n        downX = e.clientX\n        //在鼠标按下时，分别给鼠标添加移动和松开事件\n        document.onmousemove = mousemoveHandler\n        document.onmouseup = mouseupHandler\n      }\n\n      //四、定义一个获取鼠标当前需要移动多少距离的方法\n      function getOffsetX(offset, min, max) {\n        if (offset &lt; min) {\n          offset = min\n        } else if (offset &gt; max) {\n          offset = max\n        }\n        return offset\n      }\n\n      //3.1.1鼠标移动事件的方法实现\n      function mousemoveHandler(e) {\n        var e = e || window.event || e.which\n        var moveX = e.clientX\n        var offsetX = getOffsetX(moveX - downX, 0, successMoveDistance)\n        bgColor.style.width = offsetX + &quot;px&quot;\n        slider.style.left = offsetX + &quot;px&quot;\n\n        if (offsetX == successMoveDistance) {\n          success()\n        }\n        //如果不设置滑块滑动时会出现问题（目前还不知道为什么）\n        e.preventDefault()\n      }\n\n      //3.1.2鼠标松开事件的方法实现\n      function mouseupHandler(e) {\n        if (!isSuccess) {\n          bgColor.style.width = 0 + &quot;px&quot;\n          slider.style.left = 0 + &quot;px&quot;\n          bgColor.style.transition = &quot;width 0.8s linear&quot;\n          slider.style.transition = &quot;left 0.8s linear&quot;\n        }\n        document.onmousemove = null\n        document.onmouseup = null\n      }\n\n      //五、定义一个滑块解锁成功的方法\n      function success() {\n        isSuccess = true\n        txt.innerHTML = &quot;解锁成功&quot;\n        bgColor.style.backgroundColor = &quot;lightgreen&quot;\n        slider.className = &quot;slider active&quot;\n        icon.className = &quot;iconfont icon-xuanzhong&quot;\n        //滑动成功时，移除鼠标按下事件和鼠标移动事件\n        slider.onmousedown = null\n        document.onmousemove = null\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"canvas实现贪吃蛇\"><a href=\"#canvas实现贪吃蛇\" class=\"headerlink\" title=\"canvas实现贪吃蛇\"></a>canvas实现贪吃蛇</h2><p><a href=\"https://juejin.cn/post/6959789039566192654#heading-14\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;贪吃蛇&lt;/title&gt;\n  &lt;style&gt;\n    body {\n      background-color: #eee;\n    }\n    .container {\n      text-align: center;\n    }\n    .top {\n      margin: 20px auto;\n      width: 640px;\n    }\n    #score {\n      float: left;\n    }\n    .main {\n      position: absolute;\n      left: 50%;\n      transform: translateX(-50%);\n      width: 642px;\n      height: 402px;\n    }\n    #snake {\n      border: 1px solid #000;\n      width: 640px;\n      height: 400px;\n      display: inline-block;\n      z-index: 99;\n      background-color: rgba(0, 0, 0, .1);\n    }\n    #mask {\n      background-color: rgba(0, 0, 0, .5);\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      z-index: 100;\n      display: block;\n      color: #fff;\n      line-height: 400px;\n      text-align: center;\n      font-size: 30px;\n      cursor: pointer;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;top&quot;&gt;\n      &lt;span id=&quot;score&quot;&gt;Score: 0&lt;/span&gt;\n      &lt;button id=&quot;restart&quot;&gt;重新开始&lt;/button&gt;\n      &lt;button id=&quot;stop&quot;&gt;暂停&lt;/button&gt;\n      &lt;button id=&quot;continue&quot;&gt;继续&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;\n      &lt;canvas id=&quot;snake&quot; width=&quot;640&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;\n      &lt;div id=&quot;mask&quot;&gt;开始&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n&lt;script&gt;\n  let greedySnake = null\n  let score = document.querySelector(&#39;#score&#39;)\n  let restart = document.querySelector(&#39;#restart&#39;)\n  let stop = document.querySelector(&#39;#stop&#39;)\n  let conti = document.querySelector(&#39;#continue&#39;)\n  let mask = document.querySelector(&#39;#mask&#39;)\n\n  restart.onclick = () =&gt; {\n    if (!greedySnake.isStart) return\n    greedySnake.start()\n  }\n  stop.onclick = () =&gt; {\n    if (greedySnake.isStop || !greedySnake.isStart) return\n    greedySnake.stop()\n  }\n  conti.onclick = () =&gt; {\n    if (!greedySnake.isStop || !greedySnake.isStart) return\n    greedySnake.continue()\n  }\n  mask.onclick = () =&gt; {\n    if (!greedySnake.isStart) {\n      greedySnake.start()\n    } else {\n      greedySnake.continue()\n    }\n  }\n\n  // 大小为64 * 40\n  class GreedySnake {\n    constructor() {\n      this.canvas = document.querySelector(&#39;#snake&#39;)\n      this.ctx = this.canvas.getContext(&#39;2d&#39;)\n      this.maxX = 64          // 最大行\n      this.maxY = 40          // 最大列\n      this.itemWidth = 10     // 每个点的大小\n      this.direction = &#39;right&#39;// up down right left 方向\n      this.speed = 150        // ms 速度\n      this.isStop = false     // 是否暂停\n      this.isOver = false     // 是否结束\n      this.isStart = false    // 是否开始\n      this.score = 0          // 分数\n      this.timer = null       // 移动定时器\n      this.j = 1\n      this.canChange = true\n\n      this.grid = new Array()\n\n      for (let i = 0; i &lt; this.maxX; i++) {\n        for (let j = 0; j &lt; this.maxY; j++) {\n          this.grid.push([i, j])\n        } \n      }\n\n      this.drawGridLine()\n      this.getDirection()\n    }\n\n    // 开始\n    start() {\n      if (this.timer) {\n        clearTimeout(this.timer)\n      }\n      if (!this.isStart) {\n        this.isStart = true\n      }\n      this.score = 0\n      this.speed = 150\n      this.isStop = false\n      this.isOver = false\n      this.direction = &#39;right&#39;\n      this.createSnake()\n      this.createFood()\n      this.draw()\n      this.move()\n      mask.style.display = &#39;none&#39;\n    }\n\n    // 创建蛇主体\n    createSnake() {\n      this.snake = [\n        [4, 25],\n        [3, 25],\n        [2, 25],\n        [1, 25],\n        [0, 25]\n      ]\n    }\n\n    // 移动\n    move() {\n      if (this.isStop) return\n\n      let [x, y] = this.snake[0]\n      switch(this.direction) {\n        case &#39;left&#39;:\n          x--\n          break\n        case &#39;right&#39;:\n          x++\n          break\n        case &#39;up&#39;:\n          y--\n          break\n        case &#39;down&#39;:\n          y++\n          break\n      }\n\n      // 如果下一步不是食物的位置\n      if (x !== this.food[0] || y !== this.food[1]) {\n        this.snake.pop()\n      } else {\n        this.createFood()\n      }\n\n      if (this.over([x, y])) {\n        this.isOver = true\n        mask.style.display = &#39;block&#39;\n        mask.innerHTML = &#39;结束&#39;\n        return\n      }\n      if (this.completed()) {\n        mask.style.display = &#39;block&#39;\n        mask.innerHTML = &#39;恭喜您，游戏通关&#39;\n        return\n      }\n\n      this.snake.unshift([x, y])\n\n      this.draw()\n      this.canChange = true\n      this.timer = setTimeout(() =&gt; this.move(), this.speed)\n    }\n\n    // 暂停游戏\n    stop() {\n      if (this.isOver) return\n      this.isStop = true\n      mask.style.display = &#39;block&#39;\n      mask.innerHTML = &#39;暂停&#39;\n    }\n\n    // 继续游戏\n    continue() {\n      if (this.isOver) return\n      this.isStop = false\n      this.move()\n      mask.style.display = &#39;none&#39;\n    }\n\n    getDirection() {\n      // 上38 下40 左37 右39 不能往相反的方向走\n      document.onkeydown = (e) =&gt; {\n        // 在贪吃蛇移动的间隔内不能连续改变两次方向\n        if (!this.canChange) return\n        switch(e.keyCode) {\n          case 37:\n            if (this.direction !== &#39;right&#39;) {\n              this.direction = &#39;left&#39;\n              this.canChange = false\n            }\n            break\n          case 38:\n            if (this.direction !== &#39;down&#39;) {\n              this.direction = &#39;up&#39;\n              this.canChange = false\n            }\n            break\n          case 39:\n            if (this.direction !== &#39;left&#39;) {\n              this.direction = &#39;right&#39;\n              this.canChange = false\n            }\n            break\n          case 40:\n            if (this.direction !== &#39;up&#39;) {\n              this.direction = &#39;down&#39;\n              this.canChange = false\n            }\n            break\n          case 32:\n            // 空格暂停与继续\n            if (!this.isStop) {\n              this.stop()\n            } else {\n              this.continue()\n            }\n            break\n        }\n      }\n    }\n    createPos() {\n      let [x, y] = this.grid[(Math.random() * this.grid.length) | 0]\n\n      for (let i = 0; i &lt; this.snake.length; i++) {\n        if (this.snake[i][0] == x &amp;&amp; this.snake[i][1] == y) {\n          return this.createPos()\n        }\n      }\n\n      return [x, y]\n    }\n    // 生成食物\n    createFood() {\n      this.food = this.createPos()\n\n      // 更新分数\n      score.innerHTML = &#39;Score: &#39;+ this.score++\n\n      if (this.speed &gt; 50) {\n        this.speed--\n      }\n    }\n\n    // 结束\n    over([x, y]) {\n      if (x &lt; 0 || x &gt;= this.maxX || y &lt; 0 || y &gt;= this.maxY) {\n        return true\n      }\n\n      if (this.snake.some(v =&gt; v[0] === x &amp;&amp; v[1] === y)) {\n        return true\n      }\n    }\n\n    // 完成\n    completed() {\n      if (this.snake.length == this.maxX * this.maxY) {\n        return true\n      }\n    }\n\n    // 网格线\n    drawGridLine() {\n      for (let i = 1; i &lt; this.maxY; i++) {\n        this.ctx.moveTo(0, i * this.itemWidth)\n        this.ctx.lineTo(this.canvas.width, i * this.itemWidth)\n      }\n\n      for (let i = 1; i &lt; this.maxX; i++) {\n        this.ctx.moveTo(i * this.itemWidth, 0)\n        this.ctx.lineTo(i * this.itemWidth, this.canvas.height)\n      }\n      this.ctx.lineWidth = 1\n      this.ctx.strokeStyle = &#39;#ddd&#39;\n      this.ctx.stroke()\n    }\n\n    // 绘制\n    draw() {\n      // 清空画布\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      this.drawGridLine()\n\n      this.ctx.fillStyle=&quot;#000&quot;\n      this.ctx.fillRect(\n        this.food[0] * this.itemWidth + this.j,\n        this.food[1] * this.itemWidth + this.j,\n        this.itemWidth - this.j * 2,\n        this.itemWidth -  + this.j * 2\n      )\n      this.j ^= 1\n\n      this.ctx.fillStyle=&quot;green&quot;\n      this.ctx.fillRect(\n        this.snake[0][0] * this.itemWidth + 0.5,\n        this.snake[0][1] * this.itemWidth + 0.5,\n        this.itemWidth - 1,\n        this.itemWidth - 1\n      )\n      this.ctx.fillStyle=&quot;red&quot;\n      for (let i = 1; i &lt; this.snake.length; i++) {\n        this.ctx.fillRect(\n          this.snake[i][0] * this.itemWidth + 0.5,\n          this.snake[i][1] * this.itemWidth + 0.5,\n          this.itemWidth - 1,\n          this.itemWidth - 1\n        )\n      }\n    }\n  }\n  greedySnake = new GreedySnake()\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"canvas实现带笔锋手写笔记\"><a href=\"#canvas实现带笔锋手写笔记\" class=\"headerlink\" title=\"canvas实现带笔锋手写笔记\"></a>canvas实现带笔锋手写笔记</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;\n    &lt;title&gt;canvas 手写毛笔字效果&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n      #canvasId {\n        background-color: #ffffcc;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n\n  &lt;body style=&quot;touch-action: none&quot;&gt;\n    &lt;canvas id=&quot;canvasId&quot; width=&quot;800&quot; height=&quot;720&quot;&gt;&lt;/canvas&gt;&lt;br /&gt;\n    &lt;script&gt;\n      Array.prototype.clone = function () {\n        return [].concat(this)\n        //或者 return this.concat();\n      }\n      class Point {\n        constructor(x, y, time) {\n          this.x = x\n          this.y = y\n          this.isControl = false\n          this.time = Date.now()\n          this.lineWidth = 0\n          this.isAdd = false\n        }\n      }\n\n      class Line {\n        constructor() {\n          this.points = new Array()\n          this.changeWidthCount = 0\n          this.lineWidth = 10\n        }\n      }\n      class HandwritingSelf {\n        constructor(canvas) {\n          this.canvas = canvas\n          this.ctx = canvas.getContext(&quot;2d&quot;)\n          // this.points = new Array();\n          this.line = new Line()\n          this.pointLines = new Array() //Line数组\n          this.k = 0.5\n          this.begin = null\n          this.middle = null\n          this.end = null\n          this.preTime = null\n          this.lineWidth = 8\n          this.isDown = false\n        }\n        down(x, y) {\n          this.isDown = true\n          this.line = new Line()\n          this.line.lineWidth = this.lineWidth\n          let currentPoint = new Point(x, y, Date.now())\n          this.addPoint(currentPoint)\n\n          this.preTime = Date.now()\n        }\n        move(x, y) {\n          // console.log(&quot;move:&quot;,x,y)\n          if (this.isDown) {\n            let currentPoint = new Point(x, y, Date.now())\n            this.addPoint(currentPoint)\n            this.draw()\n          }\n        }\n        up(x, y) {\n          // if (e.touches.length &gt; 0) {\n          let currentPoint = new Point(x, y, Date.now())\n          this.addPoint(currentPoint)\n          // }\n          this.draw(true)\n\n          this.pointLines.push(this.line)\n\n          this.begin = null\n          this.middle = null\n          this.end = null\n          this.isDown = false\n        }\n        draw(isUp = false) {\n          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n          this.ctx.strokeStyle = &quot;rgba(255,20,87,1)&quot;\n\n          //绘制不包含this.line的线条\n          this.pointLines.forEach((line, index) =&gt; {\n            let points = line.points\n            this.ctx.beginPath()\n            this.ctx.ellipse(\n              points[0].x - 1.5,\n              points[0].y,\n              6,\n              3,\n              Math.PI / 4,\n              0,\n              Math.PI * 2\n            )\n            this.ctx.fill()\n            this.ctx.beginPath()\n            this.ctx.moveTo(points[0].x, points[0].y)\n            let lastW = line.lineWidth\n            this.ctx.lineWidth = line.lineWidth\n            this.ctx.lineJoin = &quot;round&quot;\n            this.ctx.lineCap = &quot;round&quot;\n            let minLineW = line.lineWidth / 4\n            let isChangeW = false\n\n            let changeWidthCount = line.changeWidthCount\n            for (let i = 1; i &lt;= points.length; i++) {\n              if (i == points.length) {\n                this.ctx.stroke()\n                break\n              }\n              if (i &gt; points.length - changeWidthCount) {\n                if (!isChangeW) {\n                  this.ctx.stroke() //将之前的线条不变的path绘制完\n                  isChangeW = true\n                  if (i &gt; 1 &amp;&amp; points[i - 1].isControl) continue\n                }\n                let w =\n                  ((lastW - minLineW) / changeWidthCount) *\n                    (points.length - i) +\n                  minLineW\n                points[i - 1].lineWidth = w\n                this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍\n                // this.ctx.strokeStyle = &quot;rgba(&quot;+Math.random()*255+&quot;,&quot;+Math.random()*255+&quot;,&quot;+Math.random()*255+&quot;,1)&quot;;\n                this.ctx.lineWidth = w\n                this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点\n                this.ctx.lineTo(points[i].x, points[i].y)\n                this.ctx.stroke() //将之前的线条不变的path绘制完\n              } else {\n                if (points[i].isControl &amp;&amp; points[i + 1]) {\n                  this.ctx.quadraticCurveTo(\n                    points[i].x,\n                    points[i].y,\n                    points[i + 1].x,\n                    points[i + 1].y\n                  )\n                } else if (i &gt;= 1 &amp;&amp; points[i - 1].isControl) {\n                  //上一个是控制点 当前点已经被绘制\n                } else this.ctx.lineTo(points[i].x, points[i].y)\n              }\n            }\n          })\n\n          //绘制this.line线条\n          let points\n          if (isUp) points = this.line.points\n          else points = this.line.points.clone()\n          //当前绘制的线条最后几个补点 贝塞尔方式增加点\n          let count = 0\n          let insertCount = 0\n          let i = points.length - 1\n          let endPoint = points[i]\n          let controlPoint\n          let startPoint\n          while (i &gt;= 0) {\n            if (points[i].isControl == true) {\n              controlPoint = points[i]\n              count++\n            } else {\n              startPoint = points[i]\n            }\n            if (startPoint &amp;&amp; controlPoint &amp;&amp; endPoint) {\n              //使用贝塞尔计算补点\n              let dis =\n                this.z_distance(startPoint, controlPoint) +\n                this.z_distance(controlPoint, endPoint)\n              let insertPoints = this.BezierCalculate(\n                [startPoint, controlPoint, endPoint],\n                Math.floor(dis / 6) + 1\n              )\n              insertCount += insertPoints.length\n              var index = i //插入位置\n              // 把insertPoints 变成一个适合splice的数组（包含splice前2个参数的数组）\n              insertPoints.unshift(index, 1)\n              Array.prototype.splice.apply(points, insertPoints)\n\n              //补完点后\n              endPoint = startPoint\n              startPoint = null\n            }\n            if (count &gt;= 6) break\n            i--\n          }\n          //确定最后线宽变化的点数\n          let changeWidthCount = count + insertCount\n          if (isUp) this.line.changeWidthCount = changeWidthCount\n\n          //制造椭圆头\n          this.ctx.fillStyle = &quot;rgba(255,20,87,1)&quot;\n          this.ctx.beginPath()\n          this.ctx.ellipse(\n            points[0].x - 1.5,\n            points[0].y,\n            6,\n            3,\n            Math.PI / 4,\n            0,\n            Math.PI * 2\n          )\n          this.ctx.fill()\n\n          this.ctx.beginPath()\n          this.ctx.moveTo(points[0].x, points[0].y)\n          let lastW = this.line.lineWidth\n          this.ctx.lineWidth = this.line.lineWidth\n          this.ctx.lineJoin = &quot;round&quot;\n          this.ctx.lineCap = &quot;round&quot;\n          let minLineW = this.line.lineWidth / 4\n          let isChangeW = false\n          for (let i = 1; i &lt;= points.length; i++) {\n            if (i == points.length) {\n              this.ctx.stroke()\n              break\n            }\n            //最后的一些点线宽变细\n            if (i &gt; points.length - changeWidthCount) {\n              if (!isChangeW) {\n                this.ctx.stroke() //将之前的线条不变的path绘制完\n                isChangeW = true\n                if (i &gt; 1 &amp;&amp; points[i - 1].isControl) continue\n              }\n\n              //计算线宽\n              let w =\n                ((lastW - minLineW) / changeWidthCount) * (points.length - i) +\n                minLineW\n              points[i - 1].lineWidth = w\n              this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍\n              // this.ctx.strokeStyle = &quot;rgba(&quot; + Math.random() * 255 + &quot;,&quot; + Math.random() * 255 + &quot;,&quot; + Math.random() * 255 + &quot;,0.5)&quot;;\n              this.ctx.lineWidth = w\n              this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点\n              this.ctx.lineTo(points[i].x, points[i].y)\n              this.ctx.stroke() //将之前的线条不变的path绘制完\n            } else {\n              if (points[i].isControl &amp;&amp; points[i + 1]) {\n                this.ctx.quadraticCurveTo(\n                  points[i].x,\n                  points[i].y,\n                  points[i + 1].x,\n                  points[i + 1].y\n                )\n              } else if (i &gt;= 1 &amp;&amp; points[i - 1].isControl) {\n                //上一个是控制点 当前点已经被绘制\n              } else this.ctx.lineTo(points[i].x, points[i].y)\n            }\n          }\n        }\n\n        addPoint(p) {\n          if (this.line.points.length &gt;= 1) {\n            let last_point = this.line.points[this.line.points.length - 1]\n            let distance = this.z_distance(p, last_point)\n            if (distance &lt; 10) {\n              return\n            }\n          }\n\n          if (this.line.points.length == 0) {\n            this.begin = p\n            p.isControl = true\n            this.pushPoint(p)\n          } else {\n            this.middle = p\n            let controlPs = this.computeControlPoints(\n              this.k,\n              this.begin,\n              this.middle,\n              null\n            )\n            this.pushPoint(controlPs.first)\n            this.pushPoint(p)\n            p.isControl = true\n\n            this.begin = this.middle\n          }\n        }\n\n        addOtherPoint(p1, p2, w1, w2) {\n          let otherPoints = new Array()\n          let dis = this.z_distance(p1, p2)\n          if (dis &gt;= 25) {\n            otherPoints.push(p1)\n            let insertPCount = Math.floor(dis / 20)\n            for (let j = 0; j &lt; insertPCount; j++) {\n              let insertP = new Point(\n                p1.x + ((j + 1) / (insertPCount + 1)) * (p2.x - p1.x),\n                p1.y + ((j + 1) / (insertPCount + 1)) * (p2.y - p1.y)\n              )\n              insertP.isAdd = true\n              otherPoints.push(insertP)\n            }\n            otherPoints.push(p2)\n          }\n          let count = otherPoints.length\n          if (count &gt; 0) {\n            console.log(&quot;addOtherPoint&quot;)\n            debugger\n            let diffW = (w2 - w1) / (count - 1)\n            for (let i = 1; i &lt; count; i++) {\n              let w = w1 + diffW * i\n              this.ctx.beginPath()\n              this.ctx.lineWidth = w\n              this.ctx.moveTo(otherPoints[i - 1].x, otherPoints[i - 1].y)\n              this.ctx.lineTo(otherPoints[i].x, otherPoints[i].y)\n              this.ctx.stroke()\n            }\n          }\n          return otherPoints\n        }\n        pushPoint(p) {\n          //排除重复点\n          if (\n            this.line.points.length &gt;= 1 &amp;&amp;\n            this.line.points[this.line.points.length - 1].x == p.x &amp;&amp;\n            this.line.points[this.line.points.length - 1].y == p.y\n          )\n            return\n          this.line.points.push(p)\n        }\n        computeControlPoints(k, begin, middle, end) {\n          if (k &gt; 0.5 || k &lt;= 0) return\n\n          let diff1 = new Point(middle.x - begin.x, middle.y - begin.y)\n          let diff2 = null\n          if (end) diff2 = new Point(end.x - middle.x, end.y - middle.y)\n\n          // let l1 = (diff1.x ** 2 + diff1.y ** 2) ** (1 / 2)\n          // let l2 = (diff2.x ** 2 + diff2.y ** 2) ** (1 / 2)\n\n          let first = new Point(middle.x - k * diff1.x, middle.y - k * diff1.y)\n          let second = null\n          if (diff2)\n            second = new Point(middle.x + k * diff2.x, middle.y + k * diff2.y)\n          return { first: first, second: second }\n        }\n        // W_current =\n        // 　　W_previous + min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) &gt;= 0\n        // 　　W_previous - min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) &lt; 0\n        // 　　W_current 　　　　  当前线段的宽度\n        // 　　W_previous　　　　与当前线条相邻的前一条线段的宽度\n        // 　　distance 　　    　　    当前线条的长度\n        // 　　w_k 　　　　　　　    设定的一个固定阈值,表示:单位距离内, 笔迹的线条宽度可以变化的最大量.\n        // 　　distance * w_k 　　  即为当前线段的长度内, 笔宽可以相对于前一条线段笔宽的基础上, 最多能够变宽或者可以变窄多少.\n        z_linewidth(b, e, bwidth, step) {\n          if (e.time == b.time) return bwidth\n\n          let max_speed = 2.0\n          let d = this.z_distance(b, e)\n          let s = d / (e.time - b.time) //计算速度\n          console.log(&quot;s&quot;, e.time - b.time, s)\n          s = s &gt; max_speed ? max_speed : s\n\n          // let w = (max_speed - s) / max_speed;\n          let w = 0.5 / s\n\n          let max_dif = d * step\n          console.log(w, bwidth, max_dif)\n          if (w &lt; 0.05) w = 0.05\n          if (Math.abs(w - bwidth) &gt; max_dif) {\n            if (w &gt; bwidth) w = bwidth + max_dif\n            else w = bwidth - max_dif\n          }\n          // printf(&quot;d:%.4f, time_diff:%lld, speed:%.4f, width:%.4f\\n&quot;, d, e.t-b.t, s, w);\n          return w\n        }\n        z_distance(b, e) {\n          return Math.sqrt(Math.pow(e.x - b.x, 2) + Math.pow(e.y - b.y, 2))\n        }\n        BezierCalculate(poss, precision) {\n          //维度，坐标轴数（二维坐标，三维坐标...）\n          let dimersion = 2\n\n          //贝塞尔曲线控制点数（阶数）\n          let number = poss.length\n\n          //控制点数不小于 2 ，至少为二维坐标系\n          if (number &lt; 2 || dimersion &lt; 2) return null\n\n          let result = new Array()\n\n          //计算杨辉三角\n          let mi = new Array()\n          mi[0] = mi[1] = 1\n          for (let i = 3; i &lt;= number; i++) {\n            let t = new Array()\n            for (let j = 0; j &lt; i - 1; j++) {\n              t[j] = mi[j]\n            }\n\n            mi[0] = mi[i - 1] = 1\n            for (let j = 0; j &lt; i - 2; j++) {\n              mi[j + 1] = t[j] + t[j + 1]\n            }\n          }\n\n          //计算坐标点\n          for (let i = 0; i &lt; precision; i++) {\n            let t = i / precision\n            let p = new Point(0, 0)\n            p.isAdd = true\n            result.push(p)\n            for (let j = 0; j &lt; dimersion; j++) {\n              let temp = 0.0\n              for (let k = 0; k &lt; number; k++) {\n                temp +=\n                  Math.pow(1 - t, number - k - 1) *\n                  (j == 0 ? poss[k].x : poss[k].y) *\n                  Math.pow(t, k) *\n                  mi[k]\n              }\n              j == 0 ? (p.x = temp) : (p.y = temp)\n            }\n          }\n\n          return result\n        }\n      }\n\n      //以下代码为鼠标移动事件部分\n      let handwriting = new HandwritingSelf(document.getElementById(&quot;canvasId&quot;))\n      // document.ontouchstart = document.onmousedown\n      document.onpointerdown = function (e) {\n        if (e.type == &quot;touchstart&quot;)\n          handwriting.down(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.down(e.x, e.y)\n      }\n      // document.ontouchmove = document.onmousemove\n      document.onpointermove = function (e) {\n        if (e.type == &quot;touchmove&quot;)\n          handwriting.move(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.move(e.x, e.y)\n      }\n      // document.ontouchend = document.onmouseup\n      document.onpointerup = function (e) {\n        if (e.type == &quot;touchend&quot;)\n          handwriting.up(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.up(e.x, e.y)\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"代码雨\"><a href=\"#代码雨\" class=\"headerlink\" title=\"代码雨\"></a>代码雨</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;title&gt;Code&lt;/title&gt;\n    &lt;style&gt;\n      body {\n        margin: 0;\n        overflow: hidden;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;\n    &lt;script&gt;\n      const width = (document.getElementById(&quot;myCanvas&quot;).width = 1920) //screen.availWidth;\n      const height = (document.getElementById(&quot;myCanvas&quot;).height = 1080) //screen.availHeight;\n      const ctx = document.getElementById(&quot;myCanvas&quot;).getContext(&quot;2d&quot;)\n      const arr = Array(Math.ceil(width / 10)).fill(0)\n      const str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;.split(&quot;&quot;)\n\n      function rain() {\n        ctx.fillStyle = &quot;rgba(0,0,0,0.05)&quot;\n        ctx.fillRect(0, 0, width, height)\n        ctx.fillStyle = &quot;#0f0&quot;\n        arr.forEach(function (value, index) {\n          ctx.fillText(\n            str[Math.floor(Math.random() * str.length)],\n            index * 10,\n            value + 10\n          )\n          arr[index] =\n            value &gt;= height || value &gt; 8888 * Math.random() ? 0 : value + 10\n        })\n      }\n\n      setInterval(rain, 30)\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"qq企鹅\"><a href=\"#qq企鹅\" class=\"headerlink\" title=\"qq企鹅\"></a>qq企鹅</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      html,\n      body,\n      div,\n      strong {\n        margin: 0;\n        padding: 0;\n      }\n      body {\n        overflow: hidden;\n      }\n      .wrap {\n        width: 600px;\n        margin: 50px auto 0;\n        position: relative;\n      }\n      /* ……………………………………………………………………企鹅头部…………………………………………………………………… */\n\n      /* 上半部分黑色头部 */\n      .headtop {\n        width: 240px;\n        height: 110px;\n        background: #000;\n        margin: 0 auto;\n        border-top-left-radius: 120px 110px;\n        border-top-right-radius: 120px 110px;\n        position: relative;\n        z-index: 999;\n      }\n      /* 下半部分黑色头部 */\n      .headbottom {\n        width: 240px;\n        height: 90px;\n        background: #000;\n        border-bottom-left-radius: 120px 90px;\n        border-bottom-right-radius: 120px 90px;\n        position: absolute;\n        top: 110px;\n        z-index: 1;\n      }\n\n      h1 {\n        position: absolute;\n      }\n      /* 左眼部分 */\n      .lefteye {\n        width: 46px;\n        height: 70px;\n        background: #fff;\n        border-radius: 50% 50%;\n        position: absolute;\n\n        top: 30px;\n        left: 64px;\n        z-index: 2;\n      }\n      .lefteye_in {\n        width: 20px;\n        height: 30px;\n        background: #000;\n        border-radius: 50% 50%;\n        margin-left: 23px;\n        margin-top: 20px;\n      }\n      .eyeshow {\n        display: block;\n        width: 8px;\n        height: 10px;\n        border-radius: 50% 50%;\n        background: #fff;\n        position: absolute;\n        top: 26px;\n        left: 32px;\n      }\n\n      /*右眼部分 */\n      .righteye {\n        width: 46px;\n        height: 70px;\n        background: #fff;\n        border-radius: 50% 50%;\n        position: absolute;\n        top: 30px;\n        left: 130px;\n        z-index: 2;\n      }\n      .righteye_in {\n        width: 19px;\n        height: 23px;\n        background: #000;\n        border-top-left-radius: 17px 30px;\n        border-top-right-radius: 17px 30px;\n        border-bottom-left-radius: 5px;\n        border-bottom-right-radius: 5px;\n        border: 1px solid #000;\n        margin-left: 7px;\n        margin-top: 16px;\n      }\n      .eyebai {\n        display: block;\n        width: 12px;\n        height: 19px;\n        border-top-left-radius: 5px 14px;\n        border-top-right-radius: 8px 14px;\n        background: #fff;\n        margin-top: 10px;\n        margin-left: 4px;\n      }\n      /*右眼部分 */\n\n      /*嘴巴*/\n      .mouth {\n        width: 158px;\n        height: 56px;\n        background: #ffa600;\n        border-radius: 50%;\n        position: absolute;\n        top: 106px;\n        left: 42px;\n        z-index: 2;\n      }\n      .mouth_bar {\n        width: 126px;\n        height: 30px;\n        background: #000;\n        position: absolute;\n        top: 142px;\n        left: 55px;\n        z-index: 2;\n        border-bottom-left-radius: 76px 96px;\n        border-bottom-right-radius: 76px 96px;\n      }\n      .mouth_bar1 {\n        width: 126px;\n        height: 20px;\n        background: #ffa600;\n        position: absolute;\n        z-index: 3;\n        border-bottom-left-radius: 104px 32px;\n        border-bottom-right-radius: 104px 32px;\n      }\n      /*嘴巴*/\n      /* ……………………………………………………………………end  企鹅头部…………………………………………………………………… */\n\n      /* ……………………………………………………………………star 企鹅身体…………………………………………………………………… */\n\n      /* 企鹅身体黑色部分 */\n      .body {\n        width: 276px;\n        height: 260px;\n        background: #000;\n        position: absolute;\n        top: 142px;\n        left: 167px;\n        border-top-left-radius: 160px 140px;\n        border-bottom-left-radius: 160px 140px;\n        border-top-right-radius: 160px 140px;\n        border-bottom-right-radius: 160px 140px;\n        z-index: 2;\n      }\n      /* 企鹅身体黑色部分 */\n\n      /* 红色围脖 */\n      .body_1 {\n        width: 264px;\n        height: 137px;\n        background: #ff0000;\n        border: 5px solid #000;\n        border-top-left-radius: 195px 100px;\n        border-bottom-left-radius: 237px 146px;\n        border-top-right-radius: 195px 100px;\n        border-bottom-right-radius: 269px 146px;\n        position: absolute;\n        bottom: 159px;\n        left: 0px;\n      }\n\n      .body_2 {\n        width: 249px;\n        height: 139px;\n        position: absolute;\n        background: #000;\n        top: -33px;\n        left: 7px;\n        border-radius: 50%;\n        border: 1px #000 solid;\n      }\n\n      .body_3 {\n        width: 241px;\n        height: 145px;\n        position: absolute;\n        background: red;\n        top: 0px;\n        left: 5px;\n        border-radius: 50%;\n      }\n      /* 红色围脖 */\n\n      /* 白色企鹅肚子 */\n      .tummy {\n        width: 240px;\n        height: 240px;\n        background: #fff;\n        position: absolute;\n        top: 11px;\n        left: 17px;\n        border-radius: 50%;\n      }\n      /* 白色企鹅肚子 */\n\n      /* 企鹅口袋 */\n      .pocket {\n        width: 58px;\n        height: 78px;\n        position: absolute;\n        top: 72px;\n        left: 19px;\n        border: 3px solid #000;\n        background: red;\n        border-top-left-radius: 20px 52px;\n        border-bottom-left-radius: 40px 40px;\n        border-top-right-radius: 0px 0px;\n        border-bottom-right-radius: 21px 21px;\n      }\n\n      .pocket .pocket_line1 {\n        width: 11px;\n        height: 43px;\n        border-bottom-left-radius: 29px 57px;\n        border-top-left-radius: 0px 0px;\n        border: 9px solid #000;\n        border-top: none;\n        border-right: none;\n        position: absolute;\n        top: 0px;\n        left: 30px;\n        -webkit-transform: rotateZ(10deg);\n        -moz-transform: rotateZ(10deg);\n        -ms-transform: rotateZ(10deg);\n        -o-transform: rotateZ(10deg);\n        transform: rotateZ(10deg);\n      }\n\n      .pocket .pocket_line2 {\n        width: 2px;\n        height: 45px;\n        border-bottom-left-radius: 11px 24px;\n        border-top-left-radius: 10px 15px;\n        border: 9px solid red;\n        border-top: none;\n        border-right: none;\n        position: absolute;\n        top: 0px;\n        left: 2px;\n      }\n\n      /* 企鹅左右手 */\n      .lefthand,\n      .righthand {\n        width: 49px;\n        height: 160px;\n        background: #000;\n        position: absolute;\n      }\n\n      .lefthand {\n        top: 20px;\n        left: -29px;\n        border-top-left-radius: 89px 166px;\n        border-top-right-radius: 6px 63px;\n        border-bottom-left-radius: 85px 194px;\n        border-bottom-right-radius: 40px 128px;\n        -webkit-transform: rotateZ(20deg);\n        -moz-transform: rotateZ(20deg);\n        -ms-transform: rotateZ(20deg);\n        -o-transform: rotateZ(20deg);\n        transform: rotateZ(20deg);\n        -webkit-animation: left_rotate 0.5s infinite;\n        -moz-animation: left_rotate 0.5s infinite;\n        -ms-animation: left_rotate 0.5s infinite;\n        -o-animation: left_rotate 0.5s infinite;\n        animation: left_rotate 0.5s infinite;\n        -webkit-animation-direction: alternate;\n        -moz-animation-direction: alternate;\n        -ms-animation-direction: alternate;\n        -o-animation-direction: alternate;\n        animation-direction: alternate;\n      }\n      .righthand {\n        top: 20px;\n        left: 258px;\n        border-top-right-radius: 89px 166px;\n        border-bottom-right-radius: 85px 194px;\n        border-top-left-radius: 6px 63px;\n        border-bottom-left-radius: 40px 128px;\n        -webkit-transform: rotateZ(-20deg);\n        -moz-transform: rotateZ(-20deg);\n        -ms-transform: rotateZ(-20deg);\n        -o-transform: rotateZ(-20deg);\n        transform: rotateZ(-20deg);\n        -webkit-animation: right_rotate 0.5s infinite;\n        -moz-animation: right_rotate 0.5s infinite;\n        -ms-animation: right_rotate 0.5s infinite;\n        -o-animation: right_rotate 0.5s infinite;\n        animation: right_rotate 0.5s infinite;\n        -webkit-animation-direction: alternate;\n        -moz-animation-direction: alternate;\n        -ms-animation-direction: alternate;\n        -o-animation-direction: alternate;\n        animation-direction: alternate;\n      }\n      /* 企鹅左右手 */\n      /* ……………………………………………………………………end 企鹅身体…………………………………………………………………… */\n\n      /* ……………………………………………………………………star 企鹅脚部…………………………………………………………………… */\n      .footer .left_footer,\n      .footer .right_footer {\n        width: 134px;\n        height: 74px;\n        position: absolute;\n        background: #ffa600;\n        border: 3px solid #000;\n        border-radius: 50%;\n        z-index: 1;\n      }\n\n      .footer .left_footer {\n        top: 347px;\n        left: 163px;\n      }\n\n      .footer .right_footer {\n        top: 347px;\n        left: 320px;\n      }\n      /* ……………………………………………………………………end 企鹅脚部…………………………………………………………………… */\n\n      @keyframes left_rotate {\n        from {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(60deg);\n        }\n\n        to {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(30deg);\n        }\n      }\n\n      @keyframes right_rotate {\n        from {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-60deg);\n        }\n\n        to {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-30deg);\n        }\n      }\n\n      @-webkit-keyframes left_rotate {\n        from {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(60deg);\n        }\n\n        to {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(30deg);\n        }\n      }\n\n      @-webkit-keyframes right_rotate {\n        from {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-60deg);\n        }\n\n        to {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-30deg);\n        }\n      }\n      @-moz-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-moz-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n      @-ms-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-ms-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n      @-o-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-o-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=&quot;wrap&quot;&gt;\n      &lt;!-- 企鹅头部 --&gt;\n      &lt;div class=&quot;headtop&quot;&gt;\n        &lt;div class=&quot;headbottom&quot;&gt;&lt;/div&gt;\n        &lt;!-- 眼睛部分 --&gt;\n        &lt;h1 class=&quot;lefteye&quot;&gt;\n          &lt;p class=&quot;lefteye_in&quot;&gt;\n            &lt;strong class=&quot;eyeshow&quot;&gt;&lt;/strong&gt;\n          &lt;/p&gt;\n        &lt;/h1&gt;\n        &lt;h1 class=&quot;righteye&quot;&gt;\n          &lt;p class=&quot;righteye_in&quot;&gt;\n            &lt;strong class=&quot;eyebai&quot;&gt;&lt;/strong&gt;\n          &lt;/p&gt;\n        &lt;/h1&gt;\n        &lt;!-- 嘴巴部分 --&gt;\n        &lt;h1 class=&quot;mouth&quot;&gt;&lt;/h1&gt;\n        &lt;p class=&quot;mouth_bar&quot;&gt;\n          &lt;strong class=&quot;mouth_bar1&quot;&gt;&lt;/strong&gt;\n        &lt;/p&gt;\n      &lt;/div&gt;\n\n      &lt;!-- 企鹅头部 --&gt;\n\n      &lt;!-- 企鹅身体 --&gt;\n      &lt;div class=&quot;body&quot;&gt;\n        &lt;div class=&quot;tummy&quot;&gt;\n          &lt;div class=&quot;pocket&quot;&gt;\n            &lt;div class=&quot;pocket_line1&quot;&gt;\n              &lt;div class=&quot;pocket_line2&quot;&gt;&lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;hand&quot;&gt;\n          &lt;div class=&quot;lefthand&quot;&gt;&lt;/div&gt;\n          &lt;div class=&quot;righthand&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;body_1&quot;&gt;\n          &lt;div class=&quot;body_2&quot;&gt;\n            &lt;div class=&quot;body_3&quot;&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;!-- 企鹅身体 --&gt;\n\n      &lt;!-- 企鹅脚丫 --&gt;\n      &lt;div class=&quot;footer&quot;&gt;\n        &lt;div class=&quot;left_footer&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;right_footer&quot;&gt;&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;!-- 企鹅脚丫 --&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"页面浮动多边形跟随鼠标移动\"><a href=\"#页面浮动多边形跟随鼠标移动\" class=\"headerlink\" title=\"页面浮动多边形跟随鼠标移动\"></a>页面浮动多边形跟随鼠标移动</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e635cd6c5a0d4086ad1c2edefeb44a4e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"页面浮动多边形跟随鼠标移动\"><br><!-- ![页面浮动多边形跟随鼠标移动][img1] --></p>\n<pre><code class=\"javascript\">//鼠标绘制多边形\n!(function() {\n  //封装方法，压缩之后减少文件大小\n  function get_attribute(node, attr, default_value) {\n    return node.getAttribute(attr) || default_value\n  }\n  //封装方法，压缩之后减少文件大小\n  function get_by_tagname(name) {\n    return document.getElementsByTagName(name)\n  }\n  //获取配置参数\n  function get_config_option() {\n    var scripts = get_by_tagname(&quot;script&quot;),\n      script_len = scripts.length,\n      script = scripts[script_len - 1] //当前加载的script\n    return {\n      l: script_len, //长度，用于生成id用\n      z: get_attribute(script, &quot;zIndex&quot;, -1), //z-index\n      o: get_attribute(script, &quot;opacity&quot;, 0.5), //opacity\n      c: get_attribute(script, &quot;color&quot;, &quot;0,0,0&quot;), //color\n      n: get_attribute(script, &quot;count&quot;, 99), //count\n    }\n  }\n  //设置canvas的高宽\n  function set_canvas_size() {\n    ;(canvas_width = the_canvas.width =\n      window.innerWidth ||\n      document.documentElement.clientWidth ||\n      document.body.clientWidth),\n      (canvas_height = the_canvas.height =\n        window.innerHeight ||\n        document.documentElement.clientHeight ||\n        document.body.clientHeight)\n  }\n\n  //绘制过程\n  function draw_canvas() {\n    context.clearRect(0, 0, canvas_width, canvas_height)\n    //随机的线条和当前位置联合数组\n    var e, i, d, x_dist, y_dist, dist //临时节点\n    //遍历处理每一个点\n    random_points.forEach(function(r, idx) {\n      ;(r.x += r.xa),\n        (r.y += r.ya), //移动\n        (r.xa *= r.x &gt; canvas_width || r.x &lt; 0 ? -1 : 1),\n        (r.ya *= r.y &gt; canvas_height || r.y &lt; 0 ? -1 : 1), //碰到边界，反向反弹\n        context.fillRect(r.x - 0.5, r.y - 0.5, 1, 1) //绘制一个宽高为1的点\n      //从下一个点开始\n      for (i = idx + 1; i &lt; all_array.length; i++) {\n        e = all_array[i]\n        // 当前点存在\n        if (null !== e.x &amp;&amp; null !== e.y) {\n          x_dist = r.x - e.x //x轴距离 l\n          y_dist = r.y - e.y //y轴距离 n\n          dist = x_dist * x_dist + y_dist * y_dist //总距离, m\n\n          dist &lt; e.max &amp;&amp;\n            (e === current_point &amp;&amp;\n              dist &gt;= e.max / 2 &amp;&amp;\n              ((r.x -= 0.03 * x_dist), (r.y -= 0.03 * y_dist)), //靠近的时候加速\n            (d = (e.max - dist) / e.max),\n            context.beginPath(),\n            (context.lineWidth = d / 2),\n            (context.strokeStyle = &quot;rgba(&quot; + config.c + &quot;,&quot; + (d + 0.2) + &quot;)&quot;),\n            context.moveTo(r.x, r.y),\n            context.lineTo(e.x, e.y),\n            context.stroke())\n        }\n      }\n    }),\n      frame_func(draw_canvas)\n  }\n  //创建画布，并添加到body中\n  var the_canvas = document.createElement(&quot;canvas&quot;), //画布\n    config = get_config_option(), //配置\n    canvas_id = &quot;c_n&quot; + config.l, //canvas id\n    context = the_canvas.getContext(&quot;2d&quot;),\n    canvas_width,\n    canvas_height,\n    frame_func =\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(func) {\n        window.setTimeout(func, 1000 / 45)\n      },\n    random = Math.random,\n    current_point = {\n      x: null, //当前鼠标x\n      y: null, //当前鼠标y\n      max: 20000, // 圈半径的平方\n    },\n    all_array\n  the_canvas.id = canvas_id\n  the_canvas.style.cssText =\n    &quot;position:fixed;top:0;left:0;z-index:&quot; + config.z + &quot;;opacity:&quot; + config.o\n  get_by_tagname(&quot;body&quot;)[0].appendChild(the_canvas)\n\n  //初始化画布大小\n  set_canvas_size()\n  window.onresize = set_canvas_size\n  //当时鼠标位置存储，离开的时候，释放当前位置信息\n  ;(window.onmousemove = function(e) {\n    e = e || window.event\n    current_point.x = e.clientX\n    current_point.y = e.clientY\n  }),\n    (window.onmouseout = function() {\n      current_point.x = null\n      current_point.y = null\n    })\n  //随机生成config.n条线位置信息\n  for (var random_points = [], i = 0; config.n &gt; i; i++) {\n    var x = random() * canvas_width, //随机位置\n      y = random() * canvas_height,\n      xa = 2 * random() - 1, //随机运动方向\n      ya = 2 * random() - 1\n    // 随机点\n    random_points.push({\n      x: x,\n      y: y,\n      xa: xa,\n      ya: ya,\n      max: 6000, //沾附距离\n    })\n  }\n  all_array = random_points.concat([current_point])\n  //0.1秒后绘制\n  setTimeout(function() {\n    draw_canvas()\n  }, 100)\n})()\n</code></pre>\n<h2 id=\"每日一言功能\"><a href=\"#每日一言功能\" class=\"headerlink\" title=\"每日一言功能\"></a>每日一言功能</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b7a8b1a5b3e4577b1b67efee35b54ba~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"每日一言功能\"></p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;strong&gt;&lt;p id=&quot;hitokoto&quot;&gt;每日一言获取中...&lt;/p&gt;&lt;/strong&gt;\n  &lt;script&gt;\n    //每日一言\n    $(function() {\n      var xhr = new XMLHttpRequest()\n      xhr.open(&quot;get&quot;, &quot;https://v1.hitokoto.cn&quot;)\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var data = JSON.parse(xhr.responseText)\n          var hitokoto = document.getElementById(&quot;hitokoto&quot;)\n          hitokoto.innerText = data.hitokoto\n        }\n      }\n      xhr.send()\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h2 id=\"鼠标点击出现爱心特效\"><a href=\"#鼠标点击出现爱心特效\" class=\"headerlink\" title=\"鼠标点击出现爱心特效\"></a>鼠标点击出现爱心特效</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da17b3c0f8374b11bf92938a7cb32031~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"鼠标点击出现不同颜色爱心\"></p>\n<pre><code class=\"javascript\">//鼠标点击爱心\n!(function(e, t, a) {\n  function r() {\n    for (var e = 0; e &lt; s.length; e++)\n      s[e].alpha &lt;= 0\n        ? (t.body.removeChild(s[e].el), s.splice(e, 1))\n        : (s[e].y--,\n          (s[e].scale += 0.004),\n          (s[e].alpha -= 0.013),\n          (s[e].el.style.cssText =\n            &quot;left:&quot; +\n            s[e].x +\n            &quot;px;top:&quot; +\n            s[e].y +\n            &quot;px;opacity:&quot; +\n            s[e].alpha +\n            &quot;;transform:scale(&quot; +\n            s[e].scale +\n            &quot;,&quot; +\n            s[e].scale +\n            &quot;) rotate(45deg);background:&quot; +\n            s[e].color +\n            &quot;;z-index:99999&quot;))\n    requestAnimationFrame(r)\n  }\n  function n() {\n    var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick\n    e.onclick = function(e) {\n      t &amp;&amp; t(), o(e)\n    }\n  }\n  function o(e) {\n    var a = t.createElement(&quot;div&quot;)\n    ;(a.className = &quot;heart&quot;),\n      s.push({\n        el: a,\n        x: e.clientX - 5,\n        y: e.clientY - 5,\n        scale: 1,\n        alpha: 1,\n        color: c(),\n      }),\n      t.body.appendChild(a)\n  }\n  function i(e) {\n    var a = t.createElement(&quot;style&quot;)\n    a.type = &quot;text/css&quot;\n    try {\n      a.appendChild(t.createTextNode(e))\n    } catch (t) {\n      a.styleSheet.cssText = e\n    }\n    t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)\n  }\n  function c() {\n    return (\n      &quot;rgb(&quot; +\n      ~~(255 * Math.random()) +\n      &quot;,&quot; +\n      ~~(255 * Math.random()) +\n      &quot;,&quot; +\n      ~~(255 * Math.random()) +\n      &quot;)&quot;\n    )\n  }\n  var s = []\n  ;(e.requestAnimationFrame =\n    e.requestAnimationFrame ||\n    e.webkitRequestAnimationFrame ||\n    e.mozRequestAnimationFrame ||\n    e.oRequestAnimationFrame ||\n    e.msRequestAnimationFrame ||\n    function(e) {\n      setTimeout(e, 1e3 / 60)\n    }),\n    i(\n      &quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;\n    ),\n    n(),\n    r()\n})(window, document)\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5015800b668b4f329c0c414283c79d5a~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"鼠标点击出现‘富强明主’字体\"></p>\n<pre><code class=\"javascript\">\n&lt;script&gt;\n    //定义获取词语下标\nvar a_idx = 0;\njQuery(document).ready(function($) {\n        //点击body时触发事件\n    $(&quot;body&quot;).click(function(e) {\n    //需要显示的词语\n    var a = new Array(&quot;富强&quot;,&quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;,&quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;,&quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;,&quot;诚信&quot;, &quot;友善&quot;);\n    //设置词语给span标签\n    var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]);\n    //下标等于原来下标+1  余 词语总数\n    a_idx = (a_idx + 1)% a.length;\n    //获取鼠标指针的位置，分别相对于文档的左和右边缘。\n    //获取x和y的指针坐标\n    var x = e.pageX, y = e.pageY;\n    //在鼠标的指针的位置给$i定义的span标签添加css样式\n    $i.css({&quot;z-index&quot; : 999999,\n        &quot;top&quot; : y - 20,\n        &quot;left&quot; : x,\n        &quot;position&quot; : &quot;absolute&quot;,\n        &quot;font-weight&quot; : &quot;bold&quot;,\n        &quot;color&quot; : &quot;#ff6651&quot;\n        });\n    //在body添加这个标签\n    $(&quot;body&quot;).append($i);\n        //animate() 方法执行 CSS 属性集的自定义动画。\n        //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。\n        //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp\n        $i.animate({\n        //将原来的位置向上移动180\n            &quot;top&quot; : y - 180,\n                &quot;opacity&quot; : 0\n         //1500动画的速度\n        }, 1500, function() {\n        //时间到了自动删除\n            $i.remove();\n        });\n    });\n});\n\n&lt;/script&gt;\n\n</code></pre>\n<h2 id=\"macOS-Dock-效果\"><a href=\"#macOS-Dock-效果\" class=\"headerlink\" title=\"macOS Dock 效果\"></a>macOS Dock 效果</h2><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdcbc5783ecd4331b40b1326ebc0143f~tplv-k3u1fbpfcp-watermark.image\" alt=\"macOS中Dock效果\"></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      html {\n        font-size: 15px;\n      }\n\n      body {\n        margin: 0;\n        padding: 0;\n        display: flex;\n        width: 100%;\n        min-height: 100vh;\n        overflow: hidden;\n        align-items: flex-end;\n        background-image: linear-gradient(\n          109.6deg,\n          rgba(25, 170, 209, 1) 11.3%,\n          rgba(21, 65, 249, 1) 69.9%\n        );\n      }\n\n      .glass {\n        width: 100%;\n        height: 8rem;\n        background: rgba(255, 255, 255, 0.25);\n        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n        backdrop-filter: blur(4px);\n        -webkit-backdrop-filter: blur(4px);\n        border: 1px solid rgba(255, 255, 255, 0.18);\n        display: flex;\n        justify-content: center;\n      }\n\n      .dock {\n        --scale: 1;\n\n        list-style: none;\n        margin: 0;\n        padding: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .dock li {\n        font-size: calc(6rem * var(--scale));\n        padding: 0 0.5rem;\n        cursor: default;\n\n        position: relative;\n        top: calc((6rem * var(--scale) - 6rem) / 2 * -1);\n\n        transition: 15ms all ease-out;\n      }\n\n      .dock li.loading {\n        animation: 1s loading ease-in infinite;\n      }\n\n      @keyframes loading {\n        0%,\n        100% {\n          transform: translateY(0px);\n        }\n        60% {\n          transform: translateY(-40px);\n        }\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=&quot;glass&quot;&gt;\n      &lt;ul class=&quot;dock&quot;&gt;\n        &lt;li&gt;😃&lt;/li&gt;\n        &lt;li&gt;😊&lt;/li&gt;\n        &lt;li&gt;😜&lt;/li&gt;\n        &lt;li&gt;😍&lt;/li&gt;\n        &lt;li&gt;🤩&lt;/li&gt;\n        &lt;li&gt;🥳&lt;/li&gt;\n        &lt;li&gt;🥶&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      document.querySelectorAll(&quot;.dock li&quot;).forEach((li) =&gt; {\n        li.addEventListener(&quot;click&quot;, (e) =&gt; {\n          e.currentTarget.classList.add(&quot;loading&quot;)\n        })\n\n        li.addEventListener(&quot;mousemove&quot;, (e) =&gt; {\n          let item = e.target\n          let itemRect = item.getBoundingClientRect()\n          let offset = Math.abs(e.clientX - itemRect.left) / itemRect.width\n\n          let prev = item.previousElementSibling || null\n          let next = item.nextElementSibling || null\n\n          let scale = 0.6\n\n          resetScale()\n\n          if (prev) {\n            prev.style.setProperty(&quot;--scale&quot;, 1 + scale * Math.abs(offset - 1))\n          }\n\n          item.style.setProperty(&quot;--scale&quot;, 1 + scale)\n\n          if (next) {\n            next.style.setProperty(&quot;--scale&quot;, 1 + scale * offset)\n          }\n        })\n      })\n\n      document.querySelector(&quot;.dock&quot;).addEventListener(&quot;mouseleave&quot;, (e) =&gt; {\n        resetScale()\n      })\n\n      function resetScale() {\n        document.querySelectorAll(&quot;.dock li&quot;).forEach((li) =&gt; {\n          li.style.setProperty(&quot;--scale&quot;, 1)\n        })\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"canvas-实现水印\"><a href=\"#canvas-实现水印\" class=\"headerlink\" title=\"canvas 实现水印\"></a>canvas 实现水印</h2><pre><code class=\"javascript\">var watermark = {}\n\nfunction setWatermark(args) {\n  //声明一个怪异一点的变量，确保id的唯一性\n  var id = &quot;111.222.333.456&quot;\n  var xIndex = 15 //绘制文本的 x 坐标位置\n  var yIndex = 65 //绘制文本的 y 坐标位置\n  var xInterval = 25 //有多个参数时的行间间隔\n  if (document.getElementById(id) !== null) {\n    document.body.removeChild(document.getElementById(id))\n  }\n  //利用canvas绘制水印信息\n  var can = document.createElement(&quot;canvas&quot;)\n  can.width = 250\n  can.height = 150\n  var cans = can.getContext(&quot;2d&quot;)\n  cans.rotate((-20 * Math.PI) / 180)\n  cans.font = &quot;17px Vedana&quot;\n  // ziti yanse\n  cans.fillStyle = &quot;rgba(200, 200, 200, 0.30)&quot;\n  cans.textAlign = &quot;left&quot;\n  cans.textBaseline = &quot;Middle&quot;\n  for (let i = 0; i &lt; args.length; i++) {\n    cans.fillText(args[i], xIndex, yIndex) //绘制水印文案\n    yIndex += xInterval //设置每行间隔\n  }\n  //创建div用于显示\n  var div = document.createElement(&quot;div&quot;)\n  div.id = id\n  div.style.pointerEvents = &quot;none&quot;\n  div.style.top = &quot;70px&quot;\n  div.style.left = &quot;90px&quot;\n  div.style.position = &quot;fixed&quot;\n  div.style.zIndex = &quot;100000&quot;\n  div.style.width = document.documentElement.clientWidth - 50 + &quot;px&quot;\n  div.style.height = document.documentElement.clientHeight - 50 + &quot;px&quot;\n  //div承载水印显示\n  div.style.background =\n    &quot;url(&quot; + can.toDataURL(&quot;image/png&quot;) + &quot;) left top repeat&quot;\n  document.body.appendChild(div)\n  return id\n}\n\nwatermark.set = function() {\n  let args = Array.prototype.slice.apply(arguments)\n  let id = setWatermark(args)\n  // 检测如果水印被去掉了，自动给加上\n  setInterval(function() {\n    if (document.getElementById(id) === null) {\n      id = setWatermark(args)\n    }\n  }, 500)\n  //在窗口大小改变之后,自动触发加水印事件\n  window.onresize = function() {\n    setWatermark(args)\n  }\n}\nwindow.watermark = watermark\n\nwatermark.set(&quot;绝密档案&quot;, &quot;严禁外泄&quot;)\n</code></pre>\n<h2 id=\"canvas实现验证码\"><a href=\"#canvas实现验证码\" class=\"headerlink\" title=\"canvas实现验证码\"></a>canvas实现验证码</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot; /&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;canvas id=&quot;canvas&quot; width=&quot;120&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt;\n  &lt;a href=&quot;#&quot; id=&quot;changeImg&quot;&gt;看不清，换一张&lt;/a&gt;\n  &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;\n  &lt;script&gt;\n    // 随机数\n    function randomNum(min, max) {\n      return Math.floor(Math.random() * (max - min) + min);\n    }\n    /**生成一个随机色**/\n    function randomColor(min, max) {\n      var r = randomNum(min, max);\n      var g = randomNum(min, max);\n      var b = randomNum(min, max);\n      return &quot;rgb(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;)&quot;;\n    }\n    drawPic();\n    document.getElementById(&quot;changeImg&quot;).onclick = function (e) {\n      e.preventDefault();\n      drawPic();\n    }\n\n    var Vcode = &#39;&#39;\n\n    /**绘制验证码图片**/\n    function drawPic() {\n      var canvas = document.getElementById(&quot;canvas&quot;);\n      var width = canvas.width;\n      var height = canvas.height;\n      var ctx = canvas.getContext(&#39;2d&#39;);\n      ctx.textBaseline = &#39;bottom&#39;;\n\n      /**绘制背景色**/\n      ctx.fillStyle = randomColor(180, 240); //颜色若太深可能导致看不清\n      ctx.fillRect(0, 0, width, height);\n      /**绘制文字**/\n      var str = &#39;ABCEFGHJKLMNPQRSTWXY123456789&#39;;\n      vCode = &#39;&#39;\n      for (var i = 0; i &lt; 4; i++) {\n        var txt = str[randomNum(0, str.length)];    // 每次随机生成的数\n        vCode += txt\n        ctx.fillStyle = randomColor(50, 160);  //随机生成字体颜色\n        ctx.font = randomNum(15, 40) + &#39;px SimHei&#39;; //随机生成字体大小\n        var x = 10 + i * 25;\n        var y = randomNum(25, 45);\n        var deg = randomNum(-45, 45);\n        //修改坐标原点和旋转角度\n        ctx.translate(x, y);\n        ctx.rotate(deg * Math.PI / 180);\n        ctx.fillText(txt, 0, 0);\n        //恢复坐标原点和旋转角度\n        ctx.rotate(-deg * Math.PI / 180);\n        ctx.translate(-x, -y);\n      }\n      /* *绘制干扰线* */\n      for (var i = 0; i &lt; 4; i++) {\n        ctx.strokeStyle = randomColor(40, 180);\n        ctx.beginPath();\n        ctx.moveTo(randomNum(0, width), randomNum(0, height));\n        ctx.lineTo(randomNum(0, width), randomNum(0, height));\n        ctx.stroke();\n      }\n      /**绘制干扰点**/\n      for (var i = 0; i &lt; 20; i++) {\n        ctx.fillStyle = randomColor(0, 255);\n        ctx.beginPath();\n        ctx.arc(randomNum(0, width), randomNum(0, height), 1, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n      console.log(&quot;随机生成的验证码是:::&quot;, vCode);\n    }\n    let text = document.getElementById(&#39;text&#39;)\n    text.onblur = function(e) {\n      console.log(text.value,&#39;value&#39;)\n      if(text.value == vCode) {\n\n      } else {\n        alert(&#39;请输入正确的验证码&#39;)\n      }\n    }\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"纯css实现霓虹灯效果\"><a href=\"#纯css实现霓虹灯效果\" class=\"headerlink\" title=\"纯css实现霓虹灯效果\"></a>纯css实现霓虹灯效果</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style&gt;\n    .light {\n      position: relative;\n      padding: 25px 30px;\n      color: #03e9f4;\n      font-size: 24px;\n      text-transform: uppercase;\n      transition: 0.5s;\n      letter-spacing: 4px;\n      cursor: pointer;\n      overflow: hidden;\n      width: 200px;\n      height: 100px;\n    }\n    .light:hover {\n      background-color: #03e9f4;\n      color: #050801;\n      box-shadow: 0 0 5px #03e9f4,\n                  0 0 25px #03e9f4,\n                  0 0 50px #03e9f4,\n                  0 0 200px #03e9f4;\n    }\n    .light div {\n      position: absolute;\n    }\n    .light div:nth-child(1){\n      width: 100%;\n      height: 2px;\n      top: 0;\n      left: -100%;\n      background: linear-gradient(to right,transparent,#03e9f4);\n      animation: animate1 2s linear infinite;\n    }\n    .light div:nth-child(2){\n      width: 2px;\n      height: 100%;\n      top: -100%;\n      right: 0;\n      background: linear-gradient(to bottom,transparent,#03e9f4);\n      animation: animate2 2s linear infinite;\n      animation-delay: 0.5s;\n    }\n    .light div:nth-child(3){\n      width: 100%;\n      height: 2px;\n      bottom: 0;\n      right: -100%;\n      background: linear-gradient(to left,transparent,#03e9f4);\n      animation: animate3 2s linear infinite;\n      animation-delay: 1s;\n    }\n    .light div:nth-child(4){\n      width: 2px;\n      height: 100%;\n      bottom: -100%;\n      left: 0;\n      background: linear-gradient(to top,transparent,#03e9f4);\n      animation: animate4 2s linear infinite;\n      animation-delay: 1.5s;\n    }\n    @keyframes animate1 {\n      0% {\n        left: -100%;\n      }\n      50%,100% {\n        left: 100%;\n      }\n    }\n    @keyframes animate2 {\n      0% {\n        top: -100%;\n      }\n      50%,100% {\n        top: 100%;\n      }\n    }\n    @keyframes animate3 {\n      0% {\n        right: -100%;\n      }\n      50%,100% {\n        right: 100%;\n      }\n    }\n    @keyframes animate4 {\n      0% {\n        bottom: -100%;\n      }\n      50%,100% {\n        bottom: 100%;\n      }\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;light&quot;&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n    Neon Button\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"canvas实现刮刮乐\"><a href=\"#canvas实现刮刮乐\" class=\"headerlink\" title=\"canvas实现刮刮乐\"></a>canvas实现刮刮乐</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;img src=&quot;./男1.jpg&quot; width=&quot;400&quot; id=&quot;img&quot; alt=&quot;&quot; /&gt;\n    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;txt&quot; /&gt;\n    &lt;!-- &lt;canvas&gt;&lt;/canvas&gt; --&gt;\n    &lt;script&gt;\n      const oImg = document.getElementById(&quot;img&quot;)\n      const txt = document.getElementById(&quot;txt&quot;)\n      //oImg.readyState 图片加载状态\n      if (oImg.readyState === &quot;complete&quot;) {\n        draw() //true表示已经加载完成 执行draw()方法\n      } else {\n        //图片加载完成执行draw方法\n        oImg.onload = draw\n      }\n\n      function draw() {\n        //等图片加载完成后再添加canvas画布在上面\n        let can = document.createElement(&quot;canvas&quot;) //创建一个canvas画布\n        can.width = oImg.width //等于图片的宽高\n        can.height = oImg.height\n        can.style.position = &quot;absolute&quot; //canvas画布设置浮动会漂浮在图片上\n        can.style.left = oImg.offsetLeft + &quot;px&quot; //保存与画布位置一致\n        can.style.top = oImg.offsetTop + &quot;px&quot;\n        //找到图片的父级：parentNode  在oImg子元素前面添加canvas标签：insertBefore\n        oImg.parentNode.insertBefore(can, oImg) //在img前面去插入canvas标签\n        let ctx = can.getContext(&quot;2d&quot;)\n        ctx.fillStyle = &quot;#bbb&quot; //刮刮乐的颜色\n        ctx.fillRect(0, 0, oImg.width, oImg.height) //填充宽度\n\n        //合成:处理合成图片的透明样式；\n        //拖拽的时候，canvas图层显示透明；destination-out：新图形与原图形重叠部分透明\n        ctx.globalCompositeOperation = &quot;destination-out&quot;\n        ctx.strokeStyle = &quot;#eee&quot; //触笔的颜色 随便  因为它终究变成透明\n        ctx.lineWidth = 30 //拖动时开始画线的线宽\n        ctx.lineCap = &quot;round&quot; //这两步是把画笔变成圆形\n\n        //按下，移动，抬起事件\n        can.onmousedown = function (e) {\n          e = e || window.event //兼容低版本IE浏览器\n          //e.pageX距离文档右边缘； offsetLeft：canvas画布距离文档的右边距离\n          let x = e.pageX - can.offsetLeft //得到的x是在canvas上的坐标值\n          let y = e.pageY - can.offsetTop\n          ctx.beginPath()\n          // ctx.moveTo(  x,y )//从哪里开始来画\n          ctx.arc(x, y, 15, 0, 6.3, false) //点第一下是画一个圆\n          ctx.fill()\n          //按下后拖拽\n          can.onmousemove = function (e) {\n            //拖动时一直执行下面\n            e = e || window.event //兼容低版本IE浏览器\n            ctx.beginPath() //拖动时开始画线\n            ctx.moveTo(x, y) //起始点\n            ctx.lineTo(e.pageX - can.offsetLeft, e.pageY - can.offsetTop) //移动的过程\n\n            //每次移动的时候，样式所在的坐标；\n            x = e.pageX - can.offsetLeft //第二次渲染刮图片效果的起始点应该在上一次的终止点\n            y = e.pageY - can.offsetTop\n            ctx.stroke() //弹出图形并恢复画布\n          }\n          document.onmouseup = function () {\n            //抬起后将事件注销\n            can.onmousemove = null\n            this.onmouseup = null\n            check() //完成后通过像素计算刮过的的百分比\n          }\n        }\n        function check() {\n          //获取画布的像素列表\n          let data = ctx.getImageData(0, 0, can.width, can.height).data\n          let n = 0 //计算透明像素的个数\n          for (let i = 0; i &lt; data.length; i += 4) {\n            //感觉这一步比较消耗性能\n            //RGBA\n            if (\n              data[i] == 0 &amp;&amp;\n              data[i + 1] == 0 &amp;&amp;\n              data[i + 2] == 0 &amp;&amp;\n              data[i + 3] == 0\n            ) {\n              n++\n            }\n          }\n          let f = (n * 100) / (can.width * can.height) //算出所刮的面积的占比；\n          txt.value = `刮开面积:${f.toFixed(2)}%`\n          //刮开面积的比例\n          if (f &gt; 30) {\n            //如果所刮的面积大于30%   则将canvas画布整体清除fillRect\n            ctx.beginPath()\n            ctx.fillRect(0, 0, can.width, can.height)\n            txt.value = &quot;刮开面积大于30%，全部显示&quot;\n          }\n        }\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"swiper轮播图组件\"><a href=\"#swiper轮播图组件\" class=\"headerlink\" title=\"swiper轮播图组件\"></a>swiper轮播图组件</h2><blockquote>\n<p>拖拽、回弹物料效果是参照开源项目swiper.js做的<br><code>`</code>javascript<br>/**</p>\n<ul>\n<li>轮播组件</li>\n<li>@param {object} params 配置传参</li>\n<li>@param {string} params.el 组件节点 class|id|<label></label></li>\n<li>@param {number} params.moveTime 过渡时间（毫秒）默认 300</li>\n<li>@param {number} params.interval 自动播放间隔（毫秒）默认 3000</li>\n<li>@param {boolean} params.loop 是否需要回路</li>\n<li>@param {boolean} params.vertical 是否垂直滚动</li>\n<li>@param {boolean} params.autoPaly 是否需要自动播放</li>\n<li>@param {boolean} params.pagination 是否需要底部圆点</li>\n<li>@param {(index: number) =&gt; void} params.slideCallback 滑动/切换结束回调</li>\n<li>@author <a href=\"https://github.com/Hansen-hjs\" target=\"_blank\" rel=\"noopener\">https://github.com/Hansen-hjs</a></li>\n<li>@description </li>\n<li>移动端<code>swiper</code>组件，如果需要兼容<code>pc</code>自行修改对应的<code>touch</code>到<code>mouse</code>事件即可。现成效果预览：<a href=\"https://huangjingsheng.gitee.io/hjs/cv/demo/face/\" target=\"_blank\" rel=\"noopener\">https://huangjingsheng.gitee.io/hjs/cv/demo/face/</a><br>*/<br>function swiper(params) {<br> /**<ul>\n<li>css class 命名列表</li>\n<li>@dec [&quot;滑动列表&quot;,&quot;滑动item&quot;,&quot;圆点容器&quot;,&quot;底部圆点&quot;,&quot;圆点高亮&quot;]<br><em>/<br>const classNames = [&quot;.swiper_list&quot;, &quot;.swiper_item&quot;, &quot;.swiper_pagination&quot;, &quot;.swiper_dot&quot;, &quot;.swiper_dot_active&quot;];<br>/** 滑动结束函数 </em>/<br>const slideEnd = params.slideCallback || function() {};<br>/**</li>\n<li>组件节点</li>\n<li>@type {HTMLElement}<br>*/<br>let node = null;<br>/**</li>\n<li>item列表容器</li>\n<li>@type {HTMLElement}<br>*/<br>let nodeItem = null;<br>/**</li>\n<li>item节点列表</li>\n<li>@type {Array<htmlelement>}<br>*/<br>let nodeItems = [];<br>/**</htmlelement></li>\n<li>圆点容器</li>\n<li>@type {HTMLElement}<br>*/<br>let nodePagination = null;<br>/**</li>\n<li>圆点节点列表</li>\n<li>@type {Array<htmlelement>}<br><em>/<br>let nodePaginationItems = [];<br>/** 是否需要底部圆点 </em>/<br>let pagination = false;<br>/<strong> 是否需要回路 */<br>let isLoop = false;<br>/</strong> 方向 <code>X =&gt; true</code> | <code>Y =&gt; false</code> <em>/<br>let direction = false;<br>/** 是否需要自动播放 </em>/<br>let autoPaly = false;<br>/<strong> 自动播放间隔（毫秒）默认 3000 */<br>let interval = 3000;<br>/</strong> 过渡时间（毫秒）默认 300 */<br>let moveTime = 300;</htmlelement></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code>/** 设置动画 */\nfunction startAnimation() {\n    nodeItem.style.transition = `${moveTime / 1000}s all`; \n}\n\n/** 关闭动画 */\nfunction stopAnimation() {\n    nodeItem.style.transition = &quot;0s all&quot;;\n}\n\n/**\n * 属性样式滑动\n * @param {number} n 移动的距离\n */\nfunction slideStyle(n) {\n    let x = 0, y = 0;\n    if (direction) {\n        y = n;\n    } else {\n        x = n;\n    }\n    nodeItem.style.transform = `translate3d(${x}px, ${y}px, 0px)`;\n}\n\n/**\n * 事件开始\n * @param {number} width 滚动容器的宽度\n * @param {number} height 滚动容器的高度\n */\nfunction main(width, height) {\n    /**\n     * 动画帧\n     * @type {requestAnimationFrame}\n     */\n    const animation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n    /** 触摸开始时间 */\n    let startTime = 0;\n    /** 触摸结束时间 */\n    let endTime = 0;\n    /** 开始的距离 */\n    let startDistance = 0;\n    /** 结束的距离 */\n    let endDistance = 0;\n    /** 结束距离状态 */\n    let endState = 0;\n    /** 移动的距离 */\n    let moveDistance = 0;\n    /** 圆点位置 &amp;&amp; 当前 item 索引 */\n    let index = 0;\n    /** 动画帧计数 */\n    let count = 0;\n    /** loop 帧计数 */\n    let loopCount = 0;\n    /** 移动范围 */\n    let range = direction ? height : width;\n\n    /** 获取拖动距离 */\n    function getDragDistance() {\n        /** 拖动距离 */\n        let dragDistance = 0;\n        // 默认这个公式\n        dragDistance = moveDistance + (endDistance - startDistance);\n        // 判断最大正负值\n        if ((endDistance - startDistance) &gt;= range) {\n            dragDistance = moveDistance + range;\n        } else if ((endDistance - startDistance) &lt;= -range) {\n            dragDistance = moveDistance - range;\n        }\n        // 没有 loop 的时候惯性拖拽\n        if (!isLoop) {\n            if ((endDistance - startDistance) &gt; 0 &amp;&amp; index === 0) {\n                // console.log(&quot;到达最初&quot;);\n                dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6));\n            } else if ((endDistance - startDistance) &lt; 0 &amp;&amp; index === nodeItems.length - 1) {\n                // console.log(&quot;到达最后&quot;);\n                dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6));\n            }\n        }\n        return dragDistance;\n    }\n\n    /**\n     * 判断触摸处理函数 \n     * @param {number} slideDistance 滑动的距离\n     */\n    function judgeTouch(slideDistance) {\n        //    这里我设置了200毫秒的有效拖拽间隔\n        if ((endTime - startTime) &lt; 200) return true;\n        // 这里判断方向（正值和负值）\n        if (slideDistance &lt; 0) {\n            if ((endDistance - startDistance) &lt; (slideDistance / 2)) return true;\n            return false;\n        } else {\n            if ((endDistance - startDistance) &gt; (slideDistance / 2)) return true;\n            return false;\n        }\n    }\n\n    /** 返回原来位置 */\n    function backLocation() {\n        startAnimation();\n        slideStyle(moveDistance);\n    }\n\n    /**\n     * 滑动\n     * @param {number} slideDistance 滑动的距离\n     */\n    function slideMove(slideDistance) {\n        startAnimation();\n        slideStyle(slideDistance);\n        loopCount = 0;\n        // 判断 loop 时回到第一张或最后一张\n        if (isLoop &amp;&amp; index &lt; 0) {\n            // 我这里是想让滑块过渡完之后再重置位置所以加的延迟 (之前用setTimeout，快速滑动有问题，然后换成 requestAnimationFrame解决了这类问题)\n            function loopMoveMin() {\n                loopCount += 1;\n                if (loopCount &lt; moveTime / 1000 * 60) return animation(loopMoveMin);\n                stopAnimation();\n                slideStyle(range * -(nodeItems.length - 3));\n                // 重置一下位置\n                moveDistance = range * -(nodeItems.length - 3);\n            }\n            loopMoveMin();\n            index = nodeItems.length - 3;\n        } else if (isLoop &amp;&amp; index &gt; nodeItems.length - 3) {\n            function loopMoveMax() {\n                loopCount += 1;\n                if (loopCount &lt; moveTime / 1000 * 60) return animation(loopMoveMax);\n                stopAnimation();\n                slideStyle(0);\n                moveDistance = 0;\n            }\n            loopMoveMax();\n            index = 0;\n        }\n        // console.log(`第${ index+1 }张`);    // 这里可以做滑动结束回调\n        if (pagination) {\n            nodePagination.querySelector(classNames[4]).className = classNames[3].slice(1);\n            nodePaginationItems[index].classList.add(classNames[4].slice(1));\n        }\n    }\n\n    /** 判断移动 */\n    function judgeMove() {\n        // 判断是否需要执行过渡\n        if (endDistance &lt; startDistance) {\n            // 往上滑动 or 向左滑动\n            if (judgeTouch(-range)) {\n                // 判断有loop的时候不需要执行下面的事件\n                if (!isLoop &amp;&amp; moveDistance === (-(nodeItems.length - 1) * range)) return backLocation();\n                index += 1;\n                slideMove(moveDistance - range);\n                moveDistance -= range;\n                slideEnd(index);\n            } else {\n                backLocation();\n            }\n        } else {\n            // 往下滑动 or 向右滑动\n            if (judgeTouch(range)) {\n                if (!isLoop &amp;&amp; moveDistance === 0) return backLocation();\n                index -= 1;\n                slideMove(moveDistance + range);\n                moveDistance += range;\n                slideEnd(index)\n            } else {\n                backLocation();\n            }\n        }\n    }\n\n    /** 自动播放移动 */\n    function autoMove() {\n        // 这里判断 loop 的自动播放\n        if (isLoop) {\n            index += 1;\n            slideMove(moveDistance - range);\n            moveDistance -= range;\n        } else {\n            if (index &gt;= nodeItems.length - 1) {\n                index = 0;\n                slideMove(0);\n                moveDistance = 0;\n            } else {\n                index += 1;\n                slideMove(moveDistance - range);\n                moveDistance -= range;\n            }\n        }\n        slideEnd(index);\n    }\n\n    /** 开始自动播放 */\n    function startAuto() {\n        count += 1;\n        if (count &lt; interval / 1000 * 60) return animation(startAuto);\n        count = 0;\n        autoMove();\n        startAuto();\n    }\n\n    // 判断是否需要开启自动播放\n    if (autoPaly &amp;&amp; nodeItems.length &gt; 1) startAuto();\n\n    // 开始触摸\n    nodeItem.addEventListener(&quot;touchstart&quot;, ev =&gt; {\n        startTime = Date.now();\n        count = 0;\n        loopCount = moveTime / 1000 * 60;\n        stopAnimation();\n        startDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX;\n    });\n\n    // 触摸移动\n    nodeItem.addEventListener(&quot;touchmove&quot;, ev =&gt; {\n        ev.preventDefault();\n        count = 0;\n        endDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX;\n        slideStyle(getDragDistance());\n    });\n\n    // 触摸离开\n    nodeItem.addEventListener(&quot;touchend&quot;, () =&gt; {\n        endTime = Date.now();\n        // 判断是否点击\n        if (endState !== endDistance) {\n            judgeMove();\n        } else {\n            backLocation();\n        }\n        // 更新位置 \n        endState = endDistance;\n        // 重新打开自动播\n        count = 0;\n    });\n}\n\n/**\n * 输出回路：如果要回路的话前后增加元素\n * @param {number} width 滚动容器的宽度\n * @param {number} height 滚动容器的高度\n */\nfunction outputLoop(width, height) {\n    const first = nodeItems[0].cloneNode(true), last = nodeItems[nodeItems.length - 1].cloneNode(true);\n    nodeItem.insertBefore(last, nodeItems[0]);\n    nodeItem.appendChild(first);\n    nodeItems.unshift(last);\n    nodeItems.push(first);\n    if (direction) {\n        nodeItem.style.top = `${-height}px`;\n    } else {\n        nodeItem.style.left = `${-width}px`;\n    }\n}\n\n/**\n * 输出动态布局\n * @param {number} width 滚动容器的宽度\n * @param {number} height 滚动容器的高度\n */\nfunction outputLayout(width, height) {\n    if (direction) {\n        for (let i = 0; i &lt; nodeItems.length; i++) {\n            nodeItems[i].style.height = `${height}px`;\n        }\n    } else {\n        nodeItem.style.width = `${width * nodeItems.length}px`;\n        for (let i = 0; i &lt; nodeItems.length; i++) {\n            nodeItems[i].style.width = `${width}px`;\n        }\n    }\n}\n\n/** 输出底部圆点 */\nfunction outputPagination() {\n    let paginations = &quot;&quot;;\n    nodePagination = node.querySelector(classNames[2]);\n    // 如果没有找到对应节点则创建一个\n    if (!nodePagination) {\n        nodePagination = document.createElement(&quot;div&quot;);\n        nodePagination.className = classNames[2].slice(1);\n        node.appendChild(nodePagination);\n    }\n    for (let i = 0; i &lt; nodeItems.length; i++) {\n        paginations += `&lt;div class=&quot;${classNames[3].slice(1)}&quot;&gt;&lt;/div&gt;`;\n    }\n    nodePagination.innerHTML = paginations;\n    nodePaginationItems = [...nodePagination.querySelectorAll(classNames[3])];\n    nodePagination.querySelector(classNames[3]).classList.add(classNames[4].slice(1));\n}\n\n/** 初始化动态布局 */\nfunction initLayout() {\n    node = document.querySelector(params.el);\n    if (!node) return console.warn(&quot;没有可执行的节点！&quot;);\n    nodeItem = node.querySelector(classNames[0]);\n    if (!nodeItem) return console.warn(`缺少&quot;${classNames[0]}&quot;节点！`);\n    nodeItems = [...node.querySelectorAll(classNames[1])];\n    if (nodeItems.length == 0) return console.warn(&quot;滑动节点个数必须大于0！&quot;);\n    const moveWidth = node.offsetWidth, moveHeight = node.offsetHeight;\n    if (pagination) outputPagination();\n    if (isLoop) outputLoop(moveWidth, moveHeight);\n    outputLayout(moveWidth, moveHeight);\n    main(moveWidth, moveHeight);\n}\n\n/** 初始化参数 */\nfunction initParams() {\n    if (typeof params !== &quot;object&quot;) return console.warn(&quot;传参有误&quot;);\n    pagination = params.pagination || false;\n    direction = params.vertical || false;\n    autoPaly = params.autoPaly || false;\n    isLoop = params.loop || false;\n    moveTime = params.moveTime || 300;\n    interval = params.interval || 3000;\n    initLayout();\n}\ninitParams();\n</code></pre><p>}</p>\n<pre><code>\n## 图片懒加载\n&gt;非传统实现方式，性能最优\n```javascript\n/**\n * 懒加载\n * @description 可加载`&lt;img&gt;`、`&lt;video&gt;`、`&lt;audio&gt;`等一些引用资源路径的标签\n * @param {object} params 传参对象\n * @param {string?} params.lazyAttr 自定义加载的属性（可选）\n * @param {&quot;src&quot;|&quot;background&quot;} params.loadType 加载的类型（默认为`src`）\n * @param {string?} params.errorPath 加载失败时显示的资源路径，仅在`loadType`设置为`src`中可用（可选）\n */\nfunction lazyLoad(params) {\n    const attr = params.lazyAttr || &quot;lazy&quot;;\n    const type = params.loadType || &quot;src&quot;;\n\n    /** 更新整个文档的懒加载节点 */\n    function update() {\n        const els = document.querySelectorAll(`[${attr}]`);\n        for (let i = 0; i &lt; els.length; i++) {\n            const el = els[i];\n            observer.observe(el);\n        }\n    }\n\n    /**\n     * 加载图片\n     * @param {HTMLImageElement} el 图片节点\n     */\n    function loadImage(el) {\n        const cache = el.src; // 缓存当前`src`加载失败时候用\n        el.src = el.getAttribute(attr);\n        el.onerror = function () {\n            el.src = params.errorPath || cache;\n        }\n    }\n\n    /**\n     * 加载单个节点\n     * @param {HTMLElement} el \n     */\n    function loadElement(el) {\n        switch (type) {\n            case &quot;src&quot;:\n                loadImage(el);\n                break;\n            case &quot;background&quot;:\n                el.style.backgroundImage = `url(${el.getAttribute(attr)})`;\n                break;\n        }\n        el.removeAttribute(attr);\n        observer.unobserve(el);\n    }\n\n    /** \n     * 监听器 \n     * [MDN说明](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)\n    */\n    const observer = new IntersectionObserver(function(entries) {\n        for (let i = 0; i &lt; entries.length; i++) {\n            const item = entries[i];\n            if (item.isIntersecting) {\n                loadElement(item.target);\n            }\n        }\n    })\n\n    update();\n\n    return {\n        observer,\n        update\n    }\n}\n\n</code></pre><p>在vue中使用指令去使用</p>\n<pre><code class=\"javascript\">import Vue from &quot;vue&quot;;\n\n/** 添加一个加载`src`的指令 */\nconst lazySrc = lazyLoad({\n    lazyAttr: &quot;vlazy&quot;,\n    errorPath: &quot;./img/error.jpg&quot;\n})\n\nVue.directive(&quot;v-lazy&quot;, {\n    inserted(el, binding) {\n        el.setAttribute(&quot;vlazy&quot;, binding.value); // 跟上面的对应\n        lazySrc.observer.observe(el);\n    }\n})\n\n/** 添加一个加载`background`的指令 */\nconst lazyBg = lazyLoad({\n    lazyAttr: &quot;vlazybg&quot;,\n    loadType: &quot;background&quot;\n})\n\nVue.directive(&quot;v-lazybg&quot;, {\n    inserted(el, binding) {\n        el.setAttribute(&quot;vlazybg&quot;, binding.value); // 跟上面的对应\n        lazyBg.observer.observe(el);\n    }\n})\n\n\n</code></pre>\n<h2 id=\"上传图片\"><a href=\"#上传图片\" class=\"headerlink\" title=\"上传图片\"></a>上传图片</h2><pre><code class=\"html\">&lt;!-- 先准备好一个input标签，然后设置type=&quot;file&quot;，最后挂载一个onchange事件 --&gt;\n&lt;input class=&quot;upload-input&quot; type=&quot;file&quot; name=&quot;picture&quot; onchange=&quot;upLoadImage(this)&quot;&gt;\n</code></pre>\n<pre><code class=\"javascript\">/**\n * input上传图片\n * @param {HTMLInputElement} el \n */\nfunction upLoadImage(el) {\n    /** 上传文件 */\n    const file = el.files[0];\n    /** 上传类型数组 */\n    const types = [&quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;, &quot;image/gif&quot;];\n    // 判断文件类型\n    if (types.indexOf(file.type) &lt; 0) {\n        file.value = null; // 这里一定要清空当前错误的内容\n        return alert(&quot;文件格式只支持：jpg 和 png&quot;);\n    }\n    // 判断大小\n    if (file.size &gt; 2 * 1024 * 1024) {\n        file.value = null;\n        return alert(&quot;上传的文件不能大于2M&quot;);\n    }\n\n    const formData = new FormData();    // 这个是传给后台的数据\n    formData.append(&quot;img&quot;, file);       // 这里`img`是跟后台约定好的`key`字段\n    console.log(formData, file);\n    // 最后POST给后台，这里我用上面的方法\n    ajax({\n        url: &quot;http://xxx.com/uploadImg&quot;,\n        method: &quot;POST&quot;,\n        data: {},\n        formData: formData,\n        overtime: 5000,\n        success(res) {\n            console.log(&quot;上传成功&quot;, res);\n        },\n        fail(err) {\n            console.log(&quot;上传失败&quot;, err);\n        },\n        timeout() {\n            console.warn(&quot;XMLHttpRequest 请求超时 !!!&quot;);\n        }\n    });\n}\n\n</code></pre>\n<p><a href=\"https://github.com/Hansen-hjs/my-note/blob/master/JavaScript/upload-img.html\" target=\"_blank\" rel=\"noopener\">base64转换和静态预览</a></p>\n<h2 id=\"下拉刷新组件\"><a href=\"#下拉刷新组件\" class=\"headerlink\" title=\"下拉刷新组件\"></a>下拉刷新组件</h2><blockquote>\n<p>拖拽效果参考上面swiper的实现方式，下拉中的效果是可以自己定义的<br><code>`</code>javascript<br>// 这里我做的不是用 window 的滚动事件，而是用最外层的绑定触摸下拉事件去实现<br>// 好处是我用在Vue这类单页应用的时候，组件销毁时不用去解绑 window 的 scroll 事件<br>// 但是滑动到底部事件就必须要用 window 的 scroll 事件，这点需要注意</p>\n</blockquote>\n<p>/**</p>\n<ul>\n<li>下拉刷新组件</li>\n<li>@param {object} option 配置</li>\n<li>@param {HTMLElement} option.el 下拉元素（必选）</li>\n<li>@param {number} option.distance 下拉距离[px]（可选）</li>\n<li>@param {number} option.deviation 顶部往下偏移量[px]（可选）</li>\n<li><p>@param {string} option.loadIcon 下拉中的 icon html（可选）<br><em>/<br>function dropDownRefresh(option) {<br> const doc = document;<br> /** 整体节点 </em>/<br> const page = option.el;<br> /<strong> 下拉距离 */<br> const distance = option.distance || 88;<br> /</strong> 顶部往下偏移量 <em>/<br> const deviation = option.deviation || 0;<br> /** 顶层节点 </em>/<br> const topNode = doc.createElement(&quot;div&quot;);<br> /*<em> 下拉时遮罩 </em>/<br> const maskNode = doc.createElement(&quot;div&quot;);</p>\n<p> topNode.innerHTML = <code>&lt;div refresh-icon style=&quot;transition: .2s all;&quot;&gt;&lt;svg style=&quot;transform: rotate(90deg); display: block;&quot; t=&quot;1570593064555&quot; viewBox=&quot;0 0 1575 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;26089&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;path d=&quot;M1013.76 0v339.968H484.115692V679.778462h529.644308v339.968l529.644308-485.612308v-48.600616L1013.76 0zM243.396923 679.857231h144.462769V339.968H243.396923V679.778462z m-240.797538 0h144.462769V339.968H2.599385V679.778462z&quot; fill=&quot;#000000&quot; fill-opacity=&quot;.203&quot; p-id=&quot;26090&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/div&gt;&lt;div refresh-loading style=&quot;display: none; animation: refresh-loading 1s linear infinite;&quot;&gt;${option.loadIcon || &#39;&lt;p style=&quot;font-size: 15px; color: #666;&quot;&gt;loading...&lt;/p&gt;&#39;}&lt;/div&gt;</code>;<br> topNode.style.cssText = <code>width: 100%; height: ${distance}px; position: fixed; top: ${-distance + deviation}px; left: 0; z-index: 10; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; box-sizing: border-box; margin: 0; padding: 0;</code>;<br> maskNode.style.cssText = &quot;position: fixed; top: 0; left: 0; width: 100%; height: 100vh; box-sizing: border-box; margin: 0; padding: 0; background-color: rgba(0,0,0,0); z-index: 999;&quot;;<br> page.parentNode.insertBefore(topNode, page);</p>\n<p> /**</p>\n<ul>\n<li>设置动画时间</li>\n<li><p>@param {number} n 秒数<br>*/<br>function setAnimation(n) {<br> page.style.transition = topNode.style.transition = n + &quot;s all&quot;;<br>}</p>\n<p>/**</p>\n</li>\n<li>设置滑动距离</li>\n<li><p>@param {number} n 滑动的距离（像素）<br>*/<br>function setSlide(n) {<br> page.style.transform = topNode.style.transform = <code>translate3d(0px, ${n}px, 0px)</code>;<br>}</p>\n<p>/<strong> 下拉提示 icon */<br>const icon = topNode.querySelector(&quot;[refresh-icon]&quot;);<br>/</strong> 下拉 loading 动画 */<br>const loading = topNode.querySelector(&quot;[refresh-loading]&quot;);</p>\n<p>return {<br> /**</p>\n<ul>\n<li>监听开始刷新</li>\n<li>@param {Function} callback 下拉结束回调</li>\n<li><p>@param {(n: number) =&gt; void} rangeCallback 下拉状态回调<br><em>/<br>onRefresh(callback, rangeCallback = null) {<br> /** 顶部距离 </em>/<br> let scrollTop = 0;<br> /<strong> 开始距离 */<br> let startDistance = 0;<br> /</strong> 结束距离 <em>/<br> let endDistance = 0;<br> /** 最后移动的距离 </em>/<br> let range = 0;</p>\n<p> // 触摸开始<br> page.addEventListener(&quot;touchstart&quot;, function (e) {</p>\n<pre><code> startDistance = e.touches[0].pageY;\n scrollTop = 1;\n setAnimation(0);\n</code></pre><p> });</p>\n<p> // 触摸移动<br> page.addEventListener(&quot;touchmove&quot;, function (e) {</p>\n<pre><code> scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop;\n // 没到达顶部就停止\n if (scrollTop != 0) return;\n endDistance = e.touches[0].pageY;\n range = Math.floor(endDistance - startDistance);\n // 判断如果是下滑才执行\n if (range &gt; 0) {\n     // 阻止浏览自带的下拉效果\n     e.preventDefault();\n     // 物理回弹公式计算距离\n     range = range - (range * 0.5);\n     // 下拉时icon旋转\n     if (range &gt; distance) {\n         icon.style.transform = &quot;rotate(180deg)&quot;;\n     } else {\n         icon.style.transform = &quot;rotate(0deg)&quot;;\n     }\n     setSlide(range);\n     // 回调距离函数 如果有需要\n     if (typeof rangeCallback === &quot;function&quot;) rangeCallback(range);\n }\n</code></pre><p> });</p>\n<p> // 触摸结束<br> page.addEventListener(&quot;touchend&quot;, function () {</p>\n<pre><code> setAnimation(0.3);\n // console.log(`移动的距离：${range}, 最大距离：${distance}`);\n if (range &gt; distance &amp;&amp; range &gt; 1 &amp;&amp; scrollTop === 0) {\n     setSlide(distance);\n     doc.body.appendChild(maskNode);\n     // 阻止往上滑动\n     maskNode.ontouchmove = e =&gt; e.preventDefault();\n     // 回调成功下拉到最大距离并松开函数\n     if (typeof callback === &quot;function&quot;) callback();\n     icon.style.display = &quot;none&quot;;\n     loading.style.display = &quot;block&quot;;\n } else {\n     setSlide(0);\n }\n</code></pre><p> });</p>\n<p>},<br>/*<em> 结束下拉 </em>/<br>end() {<br> maskNode.parentNode.removeChild(maskNode);<br> setAnimation(0.3);<br> setSlide(0);<br> icon.style.display = &quot;block&quot;;<br> loading.style.display = &quot;none&quot;;<br>}<br>}<br>}</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>\n## 监听滚动到底部\n```javascript\n/**\n * 监听滚动到底部\n * @param {object} options 传参对象\n * @param {number} options.distance 距离底部多少像素触发（px）\n * @param {boolean} options.once 是否为一次性（防止重复用）\n * @param {() =&gt; void} options.callback 到达底部回调函数\n */\nfunction onScrollToBottom(options) {\n    const { distance = 0, once = false, callback = null } = options;\n    const doc = document;\n    /** 滚动事件 */\n    function onScroll() {\n        /** 滚动的高度 */\n        let scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop;\n        /** 滚动条高度 */\n        let scrollHeight = doc.documentElement.scrollTop === 0 ? doc.body.scrollHeight : doc.documentElement.scrollHeight;\n        if (scrollHeight - scrollTop - distance &lt;= window.innerHeight) {\n            if (typeof callback === &quot;function&quot;) callback();\n            if (once) window.removeEventListener(&quot;scroll&quot;, onScroll);\n        }\n    }\n    window.addEventListener(&quot;scroll&quot;, onScroll);\n    // 必要时先执行一次\n    // onScroll(); \n}\n\n</code></pre><h2 id=\"音频播放组件\"><a href=\"#音频播放组件\" class=\"headerlink\" title=\"音频播放组件\"></a>音频播放组件</h2><pre><code class=\"javascript\">/**\n * `AudioContext`音频组件 \n * [资料参考](https://www.cnblogs.com/Wayou/p/html5_audio_api_visualizer.html)\n * @description 解决在移动端网页上标签播放音频延迟的方案 貌似`H5`游戏引擎也是使用这个实现\n */\nfunction audioComponent() {\n    /**\n     * 音频上下文\n     * @type {AudioContext}\n     */\n    const context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext)();\n    /** \n     * @type {AnalyserNode} \n     */\n    const analyser = context.createAnalyser();;\n    /**\n     * @type {AudioBufferSourceNode}\n     */\n    let bufferNode = null;\n    /**\n     * @type {AudioBuffer}\n     */\n    let buffer = null;\n    /** 是否加载完成 */\n    let loaded = false;\n\n    analyser.fftSize = 256;\n\n    return {\n        /**\n         * 加载路径音频文件\n         * @param {string} url 音频路径\n         * @param {(res: AnalyserNode) =&gt; void} callback 加载完成回调\n         */\n        loadPath(url, callback) {\n            const XHR = new XMLHttpRequest(); \n            XHR.open(&quot;GET&quot;, url, true); \n            XHR.responseType = &quot;arraybuffer&quot;; \n            // 先加载音频文件\n            XHR.onload = () =&gt; {\n                context.decodeAudioData(XHR.response, audioBuffer =&gt; {\n                    // 最后缓存音频资源\n                    buffer = audioBuffer;\n                    loaded = true;\n                    typeof callback === &quot;function&quot; &amp;&amp; callback(analyser);\n                });\n            }\n            XHR.send(null);\n        },\n\n        /** \n         * 加载 input 音频文件\n         * @param {File} file 音频文件\n         * @param {(res: AnalyserNode) =&gt; void} callback 加载完成回调\n         */\n        loadFile(file, callback) {\n            const FR = new FileReader();\n            // 先加载音频文件\n            FR.onload = e =&gt; {\n                const res = e.target.result;\n                // 然后解码\n                context.decodeAudioData(res, audioBuffer =&gt; {\n                    // 最后缓存音频资源\n                    buffer = audioBuffer;\n                    loaded = true;\n                    typeof callback === &quot;function&quot; &amp;&amp; callback(analyser);\n                });\n            }\n            FR.readAsArrayBuffer(file);\n        },\n\n        /** 播放音频 */\n        play() {\n            if (!loaded) return console.warn(&quot;音频未加载完成 !!!&quot;);\n            // 这里有个问题，就是创建的音频对象不能缓存下来然后多次执行 start , 所以每次都要创建然后 start()\n            bufferNode = context.createBufferSource();\n            bufferNode.connect(analyser);\n            analyser.connect(context.destination);\n            bufferNode.buffer = buffer;\n            bufferNode.start(0);\n        },\n\n        /** 停止播放 */\n        stop() {\n            if (!bufferNode) return console.warn(&quot;音频未播放 !!!&quot;);\n            bufferNode.stop();\n        }\n    }\n}\n\n</code></pre>\n<h2 id=\"全局监听图片错误并替换到默认图片\"><a href=\"#全局监听图片错误并替换到默认图片\" class=\"headerlink\" title=\"全局监听图片错误并替换到默认图片\"></a>全局监听图片错误并替换到默认图片</h2><pre><code class=\"javascript\">window.addEventListener(&quot;error&quot;, e =&gt; {\n    /** 默认`base64`图片 */\n    const defaultImg = &#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJoAAACACAYAAADzsnDqAAANXElEQVR4Xu2dDYxcVRXHz3mz0FgjICBSgkZAQD5CwQ+Qz4BBBUEkUJpK0FAUYmms2O47d7oSmYbYnXfeLIXl01ojBAnSokRQQIWAIvEjkfBhUZGPEkMFDajgbjdu5x1zYVpmd2d25r1335uZzrkJIenec869//ubO/Pux3kIWlSBHBTAHGJoCFUAFDSFIBcFFLRcZNYgCpoykIsCClouMmsQBU0ZyEUBBS0XmTWIgqYM5KKAgpaLzBpEQVMGclFAQctFZg2ioCkDuSigoOUiswbJHLTR0dE5W7ZsWQAAB6rcnVMAETcj4vO+7z/QiVZkCtrIyMhB1Wr12wBwcic6pzFnKiAiq4wxpby1yRS0IAhuR8RFeXdK47VUYCERbWhZy2GFzEBbs2bNvMnJyc0O26qu3CnwJBHNd+eutafMQBseHj65UCg81LoJWqMTChBRZmPfqD+ZBVPQOoFP+zEVtPa10popFFDQUoinpu0r0E+gPVytVle1L43WjKNAoVC4YrZlpb4CjYhOiSOe1m1fAWa2D2JN1y8VtPa11JqzKKCgvS3OwzqjZfdZUdAUtOzoqvOsoCloCppLBdpYsNWvTpeCT/OlM5rOaBni9bZrBU1BU9BcKqBfnS7VjO9LZzSd0eJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQVPQ4lOTwEJBU9ASYBPfREFT0OJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQesgaMy8NxG9HH/Yes9CQesQaOVy+f2e560koiW9h038FitoHQKNmb8LABeJSNEYE8Qfut6yUNA6ABozfwoAfmZDi8gEIl5IRHf0FjrxWqugdQC0MAwfFZHj6obqT4i42Pf938Ubvt6praDlDFoQBMsQ8ZrpiCDifWNjYwtKpdJ47+DTfksVtBxBC8NwLxH5MwC8u8kQ3UhEl7Y/fL1TU0HLF7TrRaQVSIaIuHcQaq+lClpOoJXL5ZM8z/tlG8MyHkXR4mKxuL6Nuj1TRUHLCTRmfhAAPtEmGU9v3br13KGhIfs1u0MUBS0H0Jj5EgCwSZrjlHuJ6Iw4Bt1cV0HLGLTR0dFdtmzZ8gwivjcuCCJygzFmaVy7bqyvoGUMWhiGIyKyPMXg+0RUSWHfFabMfJ6IHIaIhwKA/e+w+oZp2qoUwxQEwdGImHYRdgwAziGin6doSteZhmF4eBRFi2rp+A9Q0FIMETP/FAA+k8LFNtONY2Njx61atep1B766zgUzn0tEP8yzYZ3Myu00yQszfxEAbnEo3k+I6LMO/fW1qx0CtFKptPPcuXOfBYD3uRxNRLzO9/2vuvTZr752CNCY+VsAMJTRIF5MROsy8h3b7erVq/fwPG8fz/PmAcA+iDhPRP4LAPZA58sDAwN/nzNnzstLly61/9Y1pedBC8PwCBF5IitF7SB6nnes7/t/zCrGbH5rs7X9Cj8TAOz/92izHRtF5E7P8+7rhlMqPQ8aM98FAGe3KX7Sak8R0RFJjZPYMfNpAHABAJwOALsn8VFnsxEAHkDEdZ36wPQ0aOVyeaHneXkdYLyHiM5KOeAtzZn5wwDwNQCwDzeui126ucYem/J9/x+unc/mr6dBY2b7AHBAXoKJyJXGmG9mES8Ign0R0QK2DAB2ziJGnc8XLHBENOOcXlZxexY0ZrYD3ok3r5xBRPe6HJBKpXJSFEVrAeBgl37b8PXAwMDAkuXLl9sPbKalJ0FbvXr1QQMDA3/JVJkmzhHx9UKhsN/y5ctfcxE/DMOFIpLX13+jJr8aRdEXisXifS7608xHT4IWBMEdiLgwS2Fa+HbyYlVmvgoAvt7BftSHXkZE12bVlp4DLQiCsxDxx1kJ0q5fRLzF9/0L260/vR4z311brkjqwrkdIn7e9/0fOHcMAD0HGjM/DQCHZCFGXJ8issQYc1NcuyAIRhAxzQmTuCHbrl8oFI5csWKF83XJngKNmQkAuu3y71FE9Hi7I8nMdhb8Xrv1O1DvbwBwtOvUET0DWi2lwYsdEL5VyP8Q0W6tKtm/l8vl+Z7n2eNHe7VTv0Udg4j3FwqFvyLibpOTk/sDQAgAxzrw7XzNsGdAY+ZbayvlDnR07uIhImp5P4GZ7ekSFwuxixrdtC+VSnPnzp17m6OdkstcrrP1BGj1KQ2cI+LIISIO+77fdGO/tqWUegkBEa/2fb/pkyozHwkA9qWwbc2ys3T/BUT8uKsdhJ4ALQiCxxFxviMmMnMjIp8zxtinyRmFmS1kdv8yVfE875DBwcFZb2sxs/0NmPiJuK6Bq4noG6kaXDPuetDCMLxMRNa46GzWPkTkVGOMveY3pTg8lPkcEX2wVT+Y+csA8J1W9dr4+1htVkt9cqWrQbMpDQBgs4gU2hCl01VeJ6Jdm8xmvwWAYxw0cBMR7dfKj+Mn22uJyO6/pipdDdq2nGapepif8c1EtHh6OHspRESectUMEdnFGPPGbP7CMFwrIhe7iCkizxpjDkzrq2tBi5HSIK0GTuyb/T5jZnsi42onQd7K79bw67nefxiGj4uIs9+01Wr1lJUrVz6cpg9dCxoz/x4APpamcznaVolooMnXpn0CPNlVW0RkyBgz3Mzf6OjonImJiQlX8Wp+RohoMI3PrgQtCIJLEfH6NB3L01ZEfmGMsVklp5Ra2qxXHLflLiI6p5nPSqVyQhRFj7iMKSLPGGNSHWHqOtBsSoOJiQl70eIdLsXK0peI3GaMsceupxRmtuf873Ec+yUi2reZzzAMl4vIiOOY9iu75W/D2WJ2HWjMfCMAfMW1UFn6E5GrjDErGoCWJNlMy6Yi4v6+79tTsjNKEAS3126jt/QTp0KhUDh4xYoVz8Sxqa/bVaCFYXiMiNilgJ4qzTJ9h2F4hYiUXHdGRM4zxtzZyG9Wp1vSPhB0G2iPiMgJrgcma38icpExZsaJDGa2qbPsrOa0NNvuqlQqe0ZR9E+nwd52dj4R3Z7Ud9eA5nA1O6kWie2iKDqzWCzavB9TShiGd4tIFmkVHiSiUxt8Vdu8IzPakbhjdYYiMmiMSfzbrytAq12Stde/Gq6suxAqYx8NL6wws30QsA8Erssb4+Pju5dKpa31jpn5cgC40nUw62+HAC0IAnvXMPU2RxYCt+lzMRHd3GCGsfuNdt/ReRGRY4wxdq1xewmCYAMiLnAe7C3QLjDG2CNIiUrHZ7SRkZGjqtXqY4la3yVGIkLGGHvocEphZju72Fkmi3IpEdkn9O2Fme1TYertokaNbWdHYrZOdhy0MAwfFJGWhwazGClXPhEx9H3fHjOfUjJeeF5HRNv3M8Mw3E9EnnfVp+l+PM87bHBw0N7XSFQ6Clrt7LzLnGaJRHBg1HBDPQiCcxAxq4R3jxHRR7a1vVKpnB1Fkc1DkkkZGBjYI81d1k6DZvOqvicTZfJ12jCjd6VSOTSKIptgJZNSv7YVBEEJEa/IJBDAq0S0ZxrfnQbN2WZzGhHS2orIK8aYvRv5YWZ7aHBKouK08ers38yaOTIyclC1WrW33e0x7ixKwxk7TqBOghannV1fN4qiE4vF4q+nNzTjmcaG2wQANtV9lnvDC9LmvFXQ3CFcISJ/ujtmPhEAfuUuTO6eXhsfH59XKpX+lyaygpZGvam2Tc/zM7O9TJLqmI27Zsb2dBsRzTiZEteLghZXsVnqR1F0WrFYfPNNx/UlCAJ72bfsMFSerj7t4p0LCprbIbuJiJZMd7l+/frCpk2bHnV0QWWbe3u0+nIReRIR7SWeczNIF9GwP0kkU9CSqNbERkTGd9ppp/mNEtsFQbAAETc4CreRiA6f7mt4ePgDhUKh4Tm1uHHtkzQiHk9Ez8W1bVRfQXOhYp2P2dKPMrPdKzw/bUhEPM73/d808sPMNqWXi1y7Tt+JpaClHfWZ9i+Oj48fWSqV/j39T66SvMz2HidHyyk7VJIX90PcPR6bZk90cbnXpofwff/JJjOafZPyeSmk2OHSVqXQortNEfGJycnJTw4NDTU87eogEd8GIpqRWjUMw3eKyGYA2CWpQr2YiG//QqHg5IdkUtE6bDfrtk3a1KIissoYs/0+QrlcPh0RRxGxZW6OZrr0ZGpR2xlmtlsyx3d4wDsWXkSWGmNuaNaAIAjWIeKXUjTwXwDwvIjsmgYwG7/ZBZsUbZtimtnDgI1SS2z8fQB4l6sG95ifLQBwAhE1PdjJzPbV2td1sl+IeInv+y6yDzXtRqag1WD7aO1T+6FOitnJ2PaExWzxXTwgJOzfSyKyzBjzo4T2bZtlDlrbLenzivZWu51ZMro11UjdtTbtRLOnV9fDoaC5VjSlvxyAW+t53trBwcE/pGxqLHMFLZZc+VWu5e1Y5PI1ip7n3Zo3YNsUU9DyYydRpDQvhq3trd6/Q78YNpGqatRSAX3VdUuJtEI/K6Bfnf08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0MpaP08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0P9H/gjHdvP/Qy/AAAAAElFTkSuQmCC&#39;;\n    /**\n     * @type {HTMLImageElement}\n     */\n    const node = e.target;\n    if (node.nodeName &amp;&amp; node.nodeName.toLocaleLowerCase() === &quot;img&quot;) {     \n        node.style.objectFit = &quot;cover&quot;;\n        node.src = defaultImg;\n    }\n}, true);\n\n</code></pre>\n<h2 id=\"复制功能\"><a href=\"#复制功能\" class=\"headerlink\" title=\"复制功能\"></a>复制功能</h2><p>翻 <code>Clipboard.js</code> 这个插件库源码的时候找到核心代码 <code>setSelectionRange(start: number, end: number)</code>，百度上搜到的复制功能全部都少了这个操作，所以搜到的复制文本代码在 ios 和 IE 等一些浏览器上复制不了。</p>\n<pre><code class=\"javascript\">/**\n * 复制文本\n * @param {string} text 复制的内容\n * @param {() =&gt; void} success 成功回调\n * @param {(tip: string) =&gt; void} fail 出错回调\n */\nfunction copyText(text, success = null, fail = null) {\n    text = text.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;);\n    if (!text) {\n        typeof fail === &quot;function&quot; &amp;&amp; fail(&quot;复制的内容不能为空！&quot;);\n        return;\n    }\n    const id = &quot;the-clipboard&quot;;\n    /**\n     * 粘贴板节点\n     * @type {HTMLTextAreaElement}\n     */\n    let clipboard = document.getElementById(id);\n    if (!clipboard) {\n        clipboard = document.createElement(&quot;textarea&quot;);\n        clipboard.id = id;\n        clipboard.readOnly = true\n        clipboard.style.cssText = &quot;font-size: 15px; position: fixed; top: -1000%; left: -1000%;&quot;;\n        document.body.appendChild(clipboard);\n    }\n    clipboard.value = text;\n    clipboard.select();\n    clipboard.setSelectionRange(0, text.length);\n    const state = document.execCommand(&quot;copy&quot;);\n    if (state) {\n        typeof success === &quot;function&quot; &amp;&amp; success();\n    } else {\n        typeof fail === &quot;function&quot; &amp;&amp; fail(&quot;复制失败&quot;);\n    }\n}\n\n</code></pre>\n<h2 id=\"检测类型\"><a href=\"#检测类型\" class=\"headerlink\" title=\"检测类型\"></a>检测类型</h2><pre><code class=\"javascript\">/**\n * 检测类型\n * @param {any} target 检测的目标\n * @returns {&quot;string&quot;|&quot;number&quot;|&quot;array&quot;|&quot;object&quot;|&quot;function&quot;|&quot;null&quot;|&quot;undefined&quot;} 只枚举一些常用的类型\n */\nfunction checkType(target) {\n    /** @type {string} */\n    const value = Object.prototype.toString.call(target);\n    const result = value.match(/\\[object (\\S*)\\]/)[1];\n    return result.toLocaleLowerCase();\n}\n\n</code></pre>\n<h2 id=\"格式化日期（代码极少版）\"><a href=\"#格式化日期（代码极少版）\" class=\"headerlink\" title=\"格式化日期（代码极少版）\"></a>格式化日期（代码极少版）</h2><pre><code class=\"javascript\">/**\n * 获取指定日期时间戳\n * @param {number} time 毫秒数\n */\nfunction getDateFormat(time = Date.now()) {\n    const date = new Date(time);\n    return `${date.toLocaleDateString()} ${date.toTimeString().slice(0, 8)}`;\n}\n\n</code></pre>\n<h2 id=\"js小数精度计算\"><a href=\"#js小数精度计算\" class=\"headerlink\" title=\"js小数精度计算\"></a>js小数精度计算</h2><pre><code class=\"javascript\">/**\n * 数字运算（主要用于小数点精度问题）\n * @param {number} a 前面的值\n * @param {&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;} type 计算方式\n * @param {number} b 后面的值\n * @example \n * ```js\n * // 可链式调用\n * const res = computeNumber(1.3, &quot;-&quot;, 1.2).next(&quot;+&quot;, 1.5).next(&quot;*&quot;, 2.3).next(&quot;/&quot;, 0.2).result;\n * console.log(res);\n *\n</code></pre>\n<p> */<br>function computeNumber(a, type, b) {<br>    /**</p>\n<pre><code> * 获取数字小数点的长度\n * @param {number} n 数字\n */\nfunction getDecimalLength(n) {\n    const decimal = n.toString().split(&quot;.&quot;)[1];\n    return decimal ? decimal.length : 0;\n}\n/**\n * 修正小数点\n * @description 防止出现 `33.33333*100000 = 3333332.9999999995` &amp;&amp; `33.33*10 = 333.29999999999995` 这类情况做的处理\n * @param {number} n\n */\nconst amend = (n, precision = 15) =&gt; parseFloat(Number(n).toPrecision(precision));\nconst power = Math.pow(10, Math.max(getDecimalLength(a), getDecimalLength(b)));\nlet result = 0;\n\na = amend(a * power);\nb = amend(b * power);\n\nswitch (type) {\n    case &quot;+&quot;:\n        result = (a + b) / power;\n        break;\n    case &quot;-&quot;:\n        result = (a - b) / power;\n        break;\n    case &quot;*&quot;:\n        result = (a * b) / (power * power);\n        break;\n    case &quot;/&quot;:\n        result = a / b;\n        break;\n}\n\nresult = amend(result);\n\nreturn {\n    /** 计算结果 */\n    result,\n    /**\n     * 继续计算\n     * @param {&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;} nextType 继续计算方式\n     * @param {number} nextValue 继续计算的值\n     */\n    next(nextType, nextValue) {\n        return computeNumber(result, nextType, nextValue);\n    }\n};\n</code></pre><p>}</p>\n<pre><code>\n## 一行css适配rem\n750是设计稿的宽度：之后的单位直接1:1使用设计稿的大小，单位是rem\n```javascript\nhtml{ font-size: calc(100vw / 750); }\n</code></pre><h2 id=\"好用的格式化日期方法\"><a href=\"#好用的格式化日期方法\" class=\"headerlink\" title=\"好用的格式化日期方法\"></a>好用的格式化日期方法</h2><pre><code class=\"javascript\">/**\n * 格式化日期\n * @param {string | number | Date} value 指定日期\n * @param {string} format 格式化的规则\n * @example\n * ```js\n * formatDate();\n * formatDate(1603264465956);\n * formatDate(1603264465956, &quot;h:m:s&quot;);\n * formatDate(1603264465956, &quot;Y年M月D日&quot;);\n *\n</code></pre>\n<p> */<br>function formatDate(value = Date.now(), format = &quot;Y-M-D h:m:s&quot;) {<br>    const formatNumber = n =&gt; <code>0${n}</code>.slice(-2);<br>    const date = new Date(value);<br>    const formatList = [&quot;Y&quot;, &quot;M&quot;, &quot;D&quot;, &quot;h&quot;, &quot;m&quot;, &quot;s&quot;];<br>    const resultList = [];<br>    resultList.push(date.getFullYear().toString());<br>    resultList.push(formatNumber(date.getMonth() + 1));<br>    resultList.push(formatNumber(date.getDate()));<br>    resultList.push(formatNumber(date.getHours()));<br>    resultList.push(formatNumber(date.getMinutes()));<br>    resultList.push(formatNumber(date.getSeconds()));<br>    for (let i = 0; i &lt; resultList.length; i++) {<br>        format = format.replace(formatList[i], resultList[i]);<br>    }<br>    return format;<br>}</p>\n<pre><code>\n## 网页定位\n这里使用百度定位，无论代码封装、调用方式还是位置准确性都比微信sdk那个好用太多了，包括在任何网页端；\n[文档说明](http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey)\n[获取百度地图key](http://lbsyun.baidu.com/apiconsole/key#/home)\n```javascript\n/**\n * 插入脚本\n * @param {string} link 脚本路径\n * @param {Function} callback 脚本加载完成回调\n */\nfunction insertScript(link, callback) {\n    const label = document.createElement(&quot;script&quot;);\n    label.src = link;\n    label.onload = function () {\n        if (label.parentNode) label.parentNode.removeChild(label);\n        if (typeof callback === &quot;function&quot;) callback();\n    }\n    document.body.appendChild(label);\n}\n\n/**\n * 获取定位信息 \n * @returns {Promise&lt;{ city: string, districtName: string, province: string, longitude: number, latitude: number }&gt;}\n*/\nfunction getLocationInfo() {\n    /**\n     * 使用百度定位\n     * @param {(value: any) =&gt; void} callback\n     */\n    function useBaiduLocation(callback) {\n        const geolocation = new BMap.Geolocation({\n            maximumAge: 10\n        })\n        geolocation.getCurrentPosition(function(res) {\n            console.log(&quot;%c 使用百度定位 &gt;&gt;&quot;, &quot;background-color: #4e6ef2; padding: 2px 6px; color: #fff; border-radius: 2px&quot;, res);\n            callback({\n                city: res.address.city,\n                districtName: res.address.district,\n                province: res.address.province,\n                longitude: Number(res.longitude),\n                latitude: Number(res.latitude)\n            })\n        })\n    }\n\n    return new Promise(function (resolve, reject) {\n        if (!window._baiduLocation) {\n            window._baiduLocation = function () {\n                useBaiduLocation(resolve);\n            }\n            // ak=你自己的key\n            insertScript(&quot;https://api.map.baidu.com/api?v=2.0&amp;ak=66vCKv7PtNlOprFEe9kneTHEHl8DY1mR&amp;callback=_baiduLocation&quot;);\n        } else {\n            useBaiduLocation(resolve);\n        }\n    })\n}\n\n</code></pre><h2 id=\"输入保留数字-lt-input-type-quot-text-quot-gt\"><a href=\"#输入保留数字-lt-input-type-quot-text-quot-gt\" class=\"headerlink\" title=\"输入保留数字&lt;input type=&quot;text&quot;&gt;\"></a>输入保留数字<code>&lt;input type=&quot;text&quot;&gt;</code></h2><p>使用场景：用户在输入框输入内容时，实时过滤保持数字值显示；</p>\n<p>tips：在Firefox中设置 <code>&lt;input type=&quot;number&quot;&gt;</code> 会有样式 bug</p>\n<pre><code class=\"javascript\">/**\n * 输入只能是数字\n * @param {string | number} value 输入的值\n * @param {boolean} decimal 是否要保留小数\n * @param {boolean} negative 是否可以为负数\n */\nfunction inputOnlyNumber(value, decimal, negative) {\n    let result = value.toString().trim();\n    if (result.length === 0) return &quot;&quot;;\n    const minus = (negative &amp;&amp; result[0] == &quot;-&quot;) ? &quot;-&quot; : &quot;&quot;;\n    if (decimal) {\n        result = result.replace(/[^0-9.]+/ig, &quot;&quot;);\n        let array = result.split(&quot;.&quot;);\n        if (array.length &gt; 1) {\n            result = array[0] + &quot;.&quot; + array[1];\n        }\n    } else {\n        result = result.replace(/[^0-9]+/ig, &quot;&quot;);\n    }\n    return minus + result;\n}\n\n</code></pre>\n<h2 id=\"Intl-NumberFormat（格式化数字）\"><a href=\"#Intl-NumberFormat（格式化数字）\" class=\"headerlink\" title=\"Intl.NumberFormat（格式化数字）\"></a>Intl.NumberFormat（格式化数字）</h2><ul>\n<li>现在JS提供了一个更加可用和规范化的API——Intl.NumberFormat。对于常用的货币格式化都有良好的支持。<blockquote>\n<p>推荐使用</p>\n<pre><code class=\"javascript\">new Intl.NumberFormat().format(123456.789);\n// 显示结果为：123,456.789\n</code></pre>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"javascript\">new Intl.NumberFormat(&#39;ja-JP&#39;, { style: &#39;currency&#39;, currency: &#39;JPY&#39; }).format(12345.678);\n// 结果显示为：&quot;￥12,346&quot;\n</code></pre>\n<ul>\n<li><p>正则表达式 （古早的做法）</p>\n<pre><code class=\"javascript\">const number = 1234567;\nnumber.toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, &#39;$1,&#39;);\n// 结果为：1,234,567\n</code></pre>\n</li>\n<li><p>Date API</p>\n<pre><code class=\"javascript\">const number = 123456.789;\nnumber.toLocaleString();// 结果为：123,456.789\n</code></pre>\n</li>\n</ul>\n<h2 id=\"加密\"><a href=\"#加密\" class=\"headerlink\" title=\"加密\"></a>加密</h2><h3 id=\"base64加密\"><a href=\"#base64加密\" class=\"headerlink\" title=\"base64加密\"></a>base64加密</h3><pre><code class=\"javascript\">var str = &#39;hello&#39;;\nvar str64 = window.btoa(str);\nconsole.log(&#39;经base64编码后：&#39;+ str64); // 经base64编码后：aGVsbG8=\nconsole.log(&#39;经base64解码后：&#39; + window.atob(str64)); // 经base64解码后：hello\n\n</code></pre>\n<h3 id=\"编码和解码字符串\"><a href=\"#编码和解码字符串\" class=\"headerlink\" title=\"编码和解码字符串\"></a>编码和解码字符串</h3><p>使用JS函数的<code>escape()</code>和<code>unescape()</code>，分别是编码和解码字符串</p>\n<pre><code class=\"javascript\">var escape1 = escape(&#39;我的名字是：Neo&#39;); // 编码\nvar unescape1 = unescape(escape1); // 解码\nconsole.log(escape1) // %u6211%u7684%u540D%u5B57%u662F%uFF1ANeo\nconsole.log(unescape1) // &quot;我的名字是：Neo&quot;\n</code></pre>\n<h2 id=\"lucky-canvas【大转盘-九宫格】抽奖\"><a href=\"#lucky-canvas【大转盘-九宫格】抽奖\" class=\"headerlink\" title=\"lucky-canvas【大转盘/九宫格】抽奖\"></a>lucky-canvas【大转盘/九宫格】抽奖</h2><p><a href=\"https://100px.net/\" target=\"_blank\" rel=\"noopener\">lucky-canvas【大转盘/九宫格】抽奖</a></p>\n<h2 id=\"FineBI大屏\"><a href=\"#FineBI大屏\" class=\"headerlink\" title=\"FineBI大屏\"></a>FineBI大屏</h2><p><a href=\"https://help.fanruan.com/finebi/\" target=\"_blank\" rel=\"noopener\">FineBI大屏</a></p>\n<h2 id=\"大屏数据展示模板\"><a href=\"#大屏数据展示模板\" class=\"headerlink\" title=\"大屏数据展示模板\"></a>大屏数据展示模板</h2><p><a href=\"https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi\" target=\"_blank\" rel=\"noopener\">大屏数据展示模板</a></p>\n<h2 id=\"js拖动滑块验证功能\"><a href=\"#js拖动滑块验证功能\" class=\"headerlink\" title=\"js拖动滑块验证功能\"></a>js拖动滑块验证功能</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;title&gt;滑块解锁封装js方法&lt;/title&gt;\n    &lt;!--注：这里首次用到了iconfont的语法，即矢量图标--&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;font/iconfont.css&quot; /&gt;\n    &lt;style&gt;\n      * {\n        padding: 0;\n        margin: 0;\n      }\n      #box {\n        position: relative;\n        width: 300px;\n        height: 40px;\n        margin: 0 auto;\n        margin-top: 10px;\n        background-color: #e8e8e8;\n        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);\n      }\n      .bgColor {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 40px;\n        height: 40px;\n        background-color: lightblue;\n      }\n      .txt {\n        position: absolute;\n        width: 100%;\n        height: 40px;\n        line-height: 40px;\n        font-size: 14px;\n        color: #000;\n        text-align: center;\n      }\n      .slider {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 50px;\n        height: 38px;\n        border: 1px solid #ccc;\n        background: #fff;\n        text-align: center;\n        cursor: move;\n      }\n      .slider &gt; i {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n      }\n      .slider.active &gt; i {\n        color: green;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;box&quot; onselectstart=&quot;return false;&quot;&gt;\n      &lt;div class=&quot;bgColor&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;txt&quot;&gt;滑动解锁&lt;/div&gt;\n      &lt;!--给i标签添加上相应字体图标的类名即可--&gt;\n      &lt;div class=&quot;slider&quot;&gt;&lt;i class=&quot;iconfont icon-double-right&quot;&gt;&lt;/i&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n      //一、定义了一个获取元素的方法\n      function getEle(selector) {\n        return document.querySelector(selector)\n      }\n      //二、获取到需要用到的DOM元素\n      var box = getEle(&quot;#box&quot;), //容器\n        bgColor = getEle(&quot;.bgColor&quot;), //背景色\n        txt = getEle(&quot;.txt&quot;), //文本\n        slider = getEle(&quot;.slider&quot;), //滑块\n        icon = getEle(&quot;.slider&gt;i&quot;),\n        successMoveDistance = box.offsetWidth - slider.offsetWidth, //解锁需要滑动的距离\n        downX, //用于存放鼠标按下时的位置\n        isSuccess = false //是否解锁成功的标志，默认不成功\n\n      //三、给滑块添加鼠标按下事件\n      slider.onmousedown = mousedownHandler\n\n      //3.1鼠标按下事件的方法实现\n      function mousedownHandler(e) {\n        bgColor.style.transition = &quot;&quot;\n        slider.style.transition = &quot;&quot;\n        var e = e || window.event || e.which\n        downX = e.clientX\n        //在鼠标按下时，分别给鼠标添加移动和松开事件\n        document.onmousemove = mousemoveHandler\n        document.onmouseup = mouseupHandler\n      }\n\n      //四、定义一个获取鼠标当前需要移动多少距离的方法\n      function getOffsetX(offset, min, max) {\n        if (offset &lt; min) {\n          offset = min\n        } else if (offset &gt; max) {\n          offset = max\n        }\n        return offset\n      }\n\n      //3.1.1鼠标移动事件的方法实现\n      function mousemoveHandler(e) {\n        var e = e || window.event || e.which\n        var moveX = e.clientX\n        var offsetX = getOffsetX(moveX - downX, 0, successMoveDistance)\n        bgColor.style.width = offsetX + &quot;px&quot;\n        slider.style.left = offsetX + &quot;px&quot;\n\n        if (offsetX == successMoveDistance) {\n          success()\n        }\n        //如果不设置滑块滑动时会出现问题（目前还不知道为什么）\n        e.preventDefault()\n      }\n\n      //3.1.2鼠标松开事件的方法实现\n      function mouseupHandler(e) {\n        if (!isSuccess) {\n          bgColor.style.width = 0 + &quot;px&quot;\n          slider.style.left = 0 + &quot;px&quot;\n          bgColor.style.transition = &quot;width 0.8s linear&quot;\n          slider.style.transition = &quot;left 0.8s linear&quot;\n        }\n        document.onmousemove = null\n        document.onmouseup = null\n      }\n\n      //五、定义一个滑块解锁成功的方法\n      function success() {\n        isSuccess = true\n        txt.innerHTML = &quot;解锁成功&quot;\n        bgColor.style.backgroundColor = &quot;lightgreen&quot;\n        slider.className = &quot;slider active&quot;\n        icon.className = &quot;iconfont icon-xuanzhong&quot;\n        //滑动成功时，移除鼠标按下事件和鼠标移动事件\n        slider.onmousedown = null\n        document.onmousemove = null\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"canvas实现贪吃蛇\"><a href=\"#canvas实现贪吃蛇\" class=\"headerlink\" title=\"canvas实现贪吃蛇\"></a>canvas实现贪吃蛇</h2><p><a href=\"https://juejin.cn/post/6959789039566192654#heading-14\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;贪吃蛇&lt;/title&gt;\n  &lt;style&gt;\n    body {\n      background-color: #eee;\n    }\n    .container {\n      text-align: center;\n    }\n    .top {\n      margin: 20px auto;\n      width: 640px;\n    }\n    #score {\n      float: left;\n    }\n    .main {\n      position: absolute;\n      left: 50%;\n      transform: translateX(-50%);\n      width: 642px;\n      height: 402px;\n    }\n    #snake {\n      border: 1px solid #000;\n      width: 640px;\n      height: 400px;\n      display: inline-block;\n      z-index: 99;\n      background-color: rgba(0, 0, 0, .1);\n    }\n    #mask {\n      background-color: rgba(0, 0, 0, .5);\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      z-index: 100;\n      display: block;\n      color: #fff;\n      line-height: 400px;\n      text-align: center;\n      font-size: 30px;\n      cursor: pointer;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;top&quot;&gt;\n      &lt;span id=&quot;score&quot;&gt;Score: 0&lt;/span&gt;\n      &lt;button id=&quot;restart&quot;&gt;重新开始&lt;/button&gt;\n      &lt;button id=&quot;stop&quot;&gt;暂停&lt;/button&gt;\n      &lt;button id=&quot;continue&quot;&gt;继续&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;\n      &lt;canvas id=&quot;snake&quot; width=&quot;640&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;\n      &lt;div id=&quot;mask&quot;&gt;开始&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n&lt;script&gt;\n  let greedySnake = null\n  let score = document.querySelector(&#39;#score&#39;)\n  let restart = document.querySelector(&#39;#restart&#39;)\n  let stop = document.querySelector(&#39;#stop&#39;)\n  let conti = document.querySelector(&#39;#continue&#39;)\n  let mask = document.querySelector(&#39;#mask&#39;)\n\n  restart.onclick = () =&gt; {\n    if (!greedySnake.isStart) return\n    greedySnake.start()\n  }\n  stop.onclick = () =&gt; {\n    if (greedySnake.isStop || !greedySnake.isStart) return\n    greedySnake.stop()\n  }\n  conti.onclick = () =&gt; {\n    if (!greedySnake.isStop || !greedySnake.isStart) return\n    greedySnake.continue()\n  }\n  mask.onclick = () =&gt; {\n    if (!greedySnake.isStart) {\n      greedySnake.start()\n    } else {\n      greedySnake.continue()\n    }\n  }\n\n  // 大小为64 * 40\n  class GreedySnake {\n    constructor() {\n      this.canvas = document.querySelector(&#39;#snake&#39;)\n      this.ctx = this.canvas.getContext(&#39;2d&#39;)\n      this.maxX = 64          // 最大行\n      this.maxY = 40          // 最大列\n      this.itemWidth = 10     // 每个点的大小\n      this.direction = &#39;right&#39;// up down right left 方向\n      this.speed = 150        // ms 速度\n      this.isStop = false     // 是否暂停\n      this.isOver = false     // 是否结束\n      this.isStart = false    // 是否开始\n      this.score = 0          // 分数\n      this.timer = null       // 移动定时器\n      this.j = 1\n      this.canChange = true\n\n      this.grid = new Array()\n\n      for (let i = 0; i &lt; this.maxX; i++) {\n        for (let j = 0; j &lt; this.maxY; j++) {\n          this.grid.push([i, j])\n        } \n      }\n\n      this.drawGridLine()\n      this.getDirection()\n    }\n\n    // 开始\n    start() {\n      if (this.timer) {\n        clearTimeout(this.timer)\n      }\n      if (!this.isStart) {\n        this.isStart = true\n      }\n      this.score = 0\n      this.speed = 150\n      this.isStop = false\n      this.isOver = false\n      this.direction = &#39;right&#39;\n      this.createSnake()\n      this.createFood()\n      this.draw()\n      this.move()\n      mask.style.display = &#39;none&#39;\n    }\n\n    // 创建蛇主体\n    createSnake() {\n      this.snake = [\n        [4, 25],\n        [3, 25],\n        [2, 25],\n        [1, 25],\n        [0, 25]\n      ]\n    }\n\n    // 移动\n    move() {\n      if (this.isStop) return\n\n      let [x, y] = this.snake[0]\n      switch(this.direction) {\n        case &#39;left&#39;:\n          x--\n          break\n        case &#39;right&#39;:\n          x++\n          break\n        case &#39;up&#39;:\n          y--\n          break\n        case &#39;down&#39;:\n          y++\n          break\n      }\n\n      // 如果下一步不是食物的位置\n      if (x !== this.food[0] || y !== this.food[1]) {\n        this.snake.pop()\n      } else {\n        this.createFood()\n      }\n\n      if (this.over([x, y])) {\n        this.isOver = true\n        mask.style.display = &#39;block&#39;\n        mask.innerHTML = &#39;结束&#39;\n        return\n      }\n      if (this.completed()) {\n        mask.style.display = &#39;block&#39;\n        mask.innerHTML = &#39;恭喜您，游戏通关&#39;\n        return\n      }\n\n      this.snake.unshift([x, y])\n\n      this.draw()\n      this.canChange = true\n      this.timer = setTimeout(() =&gt; this.move(), this.speed)\n    }\n\n    // 暂停游戏\n    stop() {\n      if (this.isOver) return\n      this.isStop = true\n      mask.style.display = &#39;block&#39;\n      mask.innerHTML = &#39;暂停&#39;\n    }\n\n    // 继续游戏\n    continue() {\n      if (this.isOver) return\n      this.isStop = false\n      this.move()\n      mask.style.display = &#39;none&#39;\n    }\n\n    getDirection() {\n      // 上38 下40 左37 右39 不能往相反的方向走\n      document.onkeydown = (e) =&gt; {\n        // 在贪吃蛇移动的间隔内不能连续改变两次方向\n        if (!this.canChange) return\n        switch(e.keyCode) {\n          case 37:\n            if (this.direction !== &#39;right&#39;) {\n              this.direction = &#39;left&#39;\n              this.canChange = false\n            }\n            break\n          case 38:\n            if (this.direction !== &#39;down&#39;) {\n              this.direction = &#39;up&#39;\n              this.canChange = false\n            }\n            break\n          case 39:\n            if (this.direction !== &#39;left&#39;) {\n              this.direction = &#39;right&#39;\n              this.canChange = false\n            }\n            break\n          case 40:\n            if (this.direction !== &#39;up&#39;) {\n              this.direction = &#39;down&#39;\n              this.canChange = false\n            }\n            break\n          case 32:\n            // 空格暂停与继续\n            if (!this.isStop) {\n              this.stop()\n            } else {\n              this.continue()\n            }\n            break\n        }\n      }\n    }\n    createPos() {\n      let [x, y] = this.grid[(Math.random() * this.grid.length) | 0]\n\n      for (let i = 0; i &lt; this.snake.length; i++) {\n        if (this.snake[i][0] == x &amp;&amp; this.snake[i][1] == y) {\n          return this.createPos()\n        }\n      }\n\n      return [x, y]\n    }\n    // 生成食物\n    createFood() {\n      this.food = this.createPos()\n\n      // 更新分数\n      score.innerHTML = &#39;Score: &#39;+ this.score++\n\n      if (this.speed &gt; 50) {\n        this.speed--\n      }\n    }\n\n    // 结束\n    over([x, y]) {\n      if (x &lt; 0 || x &gt;= this.maxX || y &lt; 0 || y &gt;= this.maxY) {\n        return true\n      }\n\n      if (this.snake.some(v =&gt; v[0] === x &amp;&amp; v[1] === y)) {\n        return true\n      }\n    }\n\n    // 完成\n    completed() {\n      if (this.snake.length == this.maxX * this.maxY) {\n        return true\n      }\n    }\n\n    // 网格线\n    drawGridLine() {\n      for (let i = 1; i &lt; this.maxY; i++) {\n        this.ctx.moveTo(0, i * this.itemWidth)\n        this.ctx.lineTo(this.canvas.width, i * this.itemWidth)\n      }\n\n      for (let i = 1; i &lt; this.maxX; i++) {\n        this.ctx.moveTo(i * this.itemWidth, 0)\n        this.ctx.lineTo(i * this.itemWidth, this.canvas.height)\n      }\n      this.ctx.lineWidth = 1\n      this.ctx.strokeStyle = &#39;#ddd&#39;\n      this.ctx.stroke()\n    }\n\n    // 绘制\n    draw() {\n      // 清空画布\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      this.drawGridLine()\n\n      this.ctx.fillStyle=&quot;#000&quot;\n      this.ctx.fillRect(\n        this.food[0] * this.itemWidth + this.j,\n        this.food[1] * this.itemWidth + this.j,\n        this.itemWidth - this.j * 2,\n        this.itemWidth -  + this.j * 2\n      )\n      this.j ^= 1\n\n      this.ctx.fillStyle=&quot;green&quot;\n      this.ctx.fillRect(\n        this.snake[0][0] * this.itemWidth + 0.5,\n        this.snake[0][1] * this.itemWidth + 0.5,\n        this.itemWidth - 1,\n        this.itemWidth - 1\n      )\n      this.ctx.fillStyle=&quot;red&quot;\n      for (let i = 1; i &lt; this.snake.length; i++) {\n        this.ctx.fillRect(\n          this.snake[i][0] * this.itemWidth + 0.5,\n          this.snake[i][1] * this.itemWidth + 0.5,\n          this.itemWidth - 1,\n          this.itemWidth - 1\n        )\n      }\n    }\n  }\n  greedySnake = new GreedySnake()\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"canvas实现带笔锋手写笔记\"><a href=\"#canvas实现带笔锋手写笔记\" class=\"headerlink\" title=\"canvas实现带笔锋手写笔记\"></a>canvas实现带笔锋手写笔记</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;\n    &lt;title&gt;canvas 手写毛笔字效果&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n      #canvasId {\n        background-color: #ffffcc;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n\n  &lt;body style=&quot;touch-action: none&quot;&gt;\n    &lt;canvas id=&quot;canvasId&quot; width=&quot;800&quot; height=&quot;720&quot;&gt;&lt;/canvas&gt;&lt;br /&gt;\n    &lt;script&gt;\n      Array.prototype.clone = function () {\n        return [].concat(this)\n        //或者 return this.concat();\n      }\n      class Point {\n        constructor(x, y, time) {\n          this.x = x\n          this.y = y\n          this.isControl = false\n          this.time = Date.now()\n          this.lineWidth = 0\n          this.isAdd = false\n        }\n      }\n\n      class Line {\n        constructor() {\n          this.points = new Array()\n          this.changeWidthCount = 0\n          this.lineWidth = 10\n        }\n      }\n      class HandwritingSelf {\n        constructor(canvas) {\n          this.canvas = canvas\n          this.ctx = canvas.getContext(&quot;2d&quot;)\n          // this.points = new Array();\n          this.line = new Line()\n          this.pointLines = new Array() //Line数组\n          this.k = 0.5\n          this.begin = null\n          this.middle = null\n          this.end = null\n          this.preTime = null\n          this.lineWidth = 8\n          this.isDown = false\n        }\n        down(x, y) {\n          this.isDown = true\n          this.line = new Line()\n          this.line.lineWidth = this.lineWidth\n          let currentPoint = new Point(x, y, Date.now())\n          this.addPoint(currentPoint)\n\n          this.preTime = Date.now()\n        }\n        move(x, y) {\n          // console.log(&quot;move:&quot;,x,y)\n          if (this.isDown) {\n            let currentPoint = new Point(x, y, Date.now())\n            this.addPoint(currentPoint)\n            this.draw()\n          }\n        }\n        up(x, y) {\n          // if (e.touches.length &gt; 0) {\n          let currentPoint = new Point(x, y, Date.now())\n          this.addPoint(currentPoint)\n          // }\n          this.draw(true)\n\n          this.pointLines.push(this.line)\n\n          this.begin = null\n          this.middle = null\n          this.end = null\n          this.isDown = false\n        }\n        draw(isUp = false) {\n          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n          this.ctx.strokeStyle = &quot;rgba(255,20,87,1)&quot;\n\n          //绘制不包含this.line的线条\n          this.pointLines.forEach((line, index) =&gt; {\n            let points = line.points\n            this.ctx.beginPath()\n            this.ctx.ellipse(\n              points[0].x - 1.5,\n              points[0].y,\n              6,\n              3,\n              Math.PI / 4,\n              0,\n              Math.PI * 2\n            )\n            this.ctx.fill()\n            this.ctx.beginPath()\n            this.ctx.moveTo(points[0].x, points[0].y)\n            let lastW = line.lineWidth\n            this.ctx.lineWidth = line.lineWidth\n            this.ctx.lineJoin = &quot;round&quot;\n            this.ctx.lineCap = &quot;round&quot;\n            let minLineW = line.lineWidth / 4\n            let isChangeW = false\n\n            let changeWidthCount = line.changeWidthCount\n            for (let i = 1; i &lt;= points.length; i++) {\n              if (i == points.length) {\n                this.ctx.stroke()\n                break\n              }\n              if (i &gt; points.length - changeWidthCount) {\n                if (!isChangeW) {\n                  this.ctx.stroke() //将之前的线条不变的path绘制完\n                  isChangeW = true\n                  if (i &gt; 1 &amp;&amp; points[i - 1].isControl) continue\n                }\n                let w =\n                  ((lastW - minLineW) / changeWidthCount) *\n                    (points.length - i) +\n                  minLineW\n                points[i - 1].lineWidth = w\n                this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍\n                // this.ctx.strokeStyle = &quot;rgba(&quot;+Math.random()*255+&quot;,&quot;+Math.random()*255+&quot;,&quot;+Math.random()*255+&quot;,1)&quot;;\n                this.ctx.lineWidth = w\n                this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点\n                this.ctx.lineTo(points[i].x, points[i].y)\n                this.ctx.stroke() //将之前的线条不变的path绘制完\n              } else {\n                if (points[i].isControl &amp;&amp; points[i + 1]) {\n                  this.ctx.quadraticCurveTo(\n                    points[i].x,\n                    points[i].y,\n                    points[i + 1].x,\n                    points[i + 1].y\n                  )\n                } else if (i &gt;= 1 &amp;&amp; points[i - 1].isControl) {\n                  //上一个是控制点 当前点已经被绘制\n                } else this.ctx.lineTo(points[i].x, points[i].y)\n              }\n            }\n          })\n\n          //绘制this.line线条\n          let points\n          if (isUp) points = this.line.points\n          else points = this.line.points.clone()\n          //当前绘制的线条最后几个补点 贝塞尔方式增加点\n          let count = 0\n          let insertCount = 0\n          let i = points.length - 1\n          let endPoint = points[i]\n          let controlPoint\n          let startPoint\n          while (i &gt;= 0) {\n            if (points[i].isControl == true) {\n              controlPoint = points[i]\n              count++\n            } else {\n              startPoint = points[i]\n            }\n            if (startPoint &amp;&amp; controlPoint &amp;&amp; endPoint) {\n              //使用贝塞尔计算补点\n              let dis =\n                this.z_distance(startPoint, controlPoint) +\n                this.z_distance(controlPoint, endPoint)\n              let insertPoints = this.BezierCalculate(\n                [startPoint, controlPoint, endPoint],\n                Math.floor(dis / 6) + 1\n              )\n              insertCount += insertPoints.length\n              var index = i //插入位置\n              // 把insertPoints 变成一个适合splice的数组（包含splice前2个参数的数组）\n              insertPoints.unshift(index, 1)\n              Array.prototype.splice.apply(points, insertPoints)\n\n              //补完点后\n              endPoint = startPoint\n              startPoint = null\n            }\n            if (count &gt;= 6) break\n            i--\n          }\n          //确定最后线宽变化的点数\n          let changeWidthCount = count + insertCount\n          if (isUp) this.line.changeWidthCount = changeWidthCount\n\n          //制造椭圆头\n          this.ctx.fillStyle = &quot;rgba(255,20,87,1)&quot;\n          this.ctx.beginPath()\n          this.ctx.ellipse(\n            points[0].x - 1.5,\n            points[0].y,\n            6,\n            3,\n            Math.PI / 4,\n            0,\n            Math.PI * 2\n          )\n          this.ctx.fill()\n\n          this.ctx.beginPath()\n          this.ctx.moveTo(points[0].x, points[0].y)\n          let lastW = this.line.lineWidth\n          this.ctx.lineWidth = this.line.lineWidth\n          this.ctx.lineJoin = &quot;round&quot;\n          this.ctx.lineCap = &quot;round&quot;\n          let minLineW = this.line.lineWidth / 4\n          let isChangeW = false\n          for (let i = 1; i &lt;= points.length; i++) {\n            if (i == points.length) {\n              this.ctx.stroke()\n              break\n            }\n            //最后的一些点线宽变细\n            if (i &gt; points.length - changeWidthCount) {\n              if (!isChangeW) {\n                this.ctx.stroke() //将之前的线条不变的path绘制完\n                isChangeW = true\n                if (i &gt; 1 &amp;&amp; points[i - 1].isControl) continue\n              }\n\n              //计算线宽\n              let w =\n                ((lastW - minLineW) / changeWidthCount) * (points.length - i) +\n                minLineW\n              points[i - 1].lineWidth = w\n              this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍\n              // this.ctx.strokeStyle = &quot;rgba(&quot; + Math.random() * 255 + &quot;,&quot; + Math.random() * 255 + &quot;,&quot; + Math.random() * 255 + &quot;,0.5)&quot;;\n              this.ctx.lineWidth = w\n              this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点\n              this.ctx.lineTo(points[i].x, points[i].y)\n              this.ctx.stroke() //将之前的线条不变的path绘制完\n            } else {\n              if (points[i].isControl &amp;&amp; points[i + 1]) {\n                this.ctx.quadraticCurveTo(\n                  points[i].x,\n                  points[i].y,\n                  points[i + 1].x,\n                  points[i + 1].y\n                )\n              } else if (i &gt;= 1 &amp;&amp; points[i - 1].isControl) {\n                //上一个是控制点 当前点已经被绘制\n              } else this.ctx.lineTo(points[i].x, points[i].y)\n            }\n          }\n        }\n\n        addPoint(p) {\n          if (this.line.points.length &gt;= 1) {\n            let last_point = this.line.points[this.line.points.length - 1]\n            let distance = this.z_distance(p, last_point)\n            if (distance &lt; 10) {\n              return\n            }\n          }\n\n          if (this.line.points.length == 0) {\n            this.begin = p\n            p.isControl = true\n            this.pushPoint(p)\n          } else {\n            this.middle = p\n            let controlPs = this.computeControlPoints(\n              this.k,\n              this.begin,\n              this.middle,\n              null\n            )\n            this.pushPoint(controlPs.first)\n            this.pushPoint(p)\n            p.isControl = true\n\n            this.begin = this.middle\n          }\n        }\n\n        addOtherPoint(p1, p2, w1, w2) {\n          let otherPoints = new Array()\n          let dis = this.z_distance(p1, p2)\n          if (dis &gt;= 25) {\n            otherPoints.push(p1)\n            let insertPCount = Math.floor(dis / 20)\n            for (let j = 0; j &lt; insertPCount; j++) {\n              let insertP = new Point(\n                p1.x + ((j + 1) / (insertPCount + 1)) * (p2.x - p1.x),\n                p1.y + ((j + 1) / (insertPCount + 1)) * (p2.y - p1.y)\n              )\n              insertP.isAdd = true\n              otherPoints.push(insertP)\n            }\n            otherPoints.push(p2)\n          }\n          let count = otherPoints.length\n          if (count &gt; 0) {\n            console.log(&quot;addOtherPoint&quot;)\n            debugger\n            let diffW = (w2 - w1) / (count - 1)\n            for (let i = 1; i &lt; count; i++) {\n              let w = w1 + diffW * i\n              this.ctx.beginPath()\n              this.ctx.lineWidth = w\n              this.ctx.moveTo(otherPoints[i - 1].x, otherPoints[i - 1].y)\n              this.ctx.lineTo(otherPoints[i].x, otherPoints[i].y)\n              this.ctx.stroke()\n            }\n          }\n          return otherPoints\n        }\n        pushPoint(p) {\n          //排除重复点\n          if (\n            this.line.points.length &gt;= 1 &amp;&amp;\n            this.line.points[this.line.points.length - 1].x == p.x &amp;&amp;\n            this.line.points[this.line.points.length - 1].y == p.y\n          )\n            return\n          this.line.points.push(p)\n        }\n        computeControlPoints(k, begin, middle, end) {\n          if (k &gt; 0.5 || k &lt;= 0) return\n\n          let diff1 = new Point(middle.x - begin.x, middle.y - begin.y)\n          let diff2 = null\n          if (end) diff2 = new Point(end.x - middle.x, end.y - middle.y)\n\n          // let l1 = (diff1.x ** 2 + diff1.y ** 2) ** (1 / 2)\n          // let l2 = (diff2.x ** 2 + diff2.y ** 2) ** (1 / 2)\n\n          let first = new Point(middle.x - k * diff1.x, middle.y - k * diff1.y)\n          let second = null\n          if (diff2)\n            second = new Point(middle.x + k * diff2.x, middle.y + k * diff2.y)\n          return { first: first, second: second }\n        }\n        // W_current =\n        // 　　W_previous + min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) &gt;= 0\n        // 　　W_previous - min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) &lt; 0\n        // 　　W_current 　　　　  当前线段的宽度\n        // 　　W_previous　　　　与当前线条相邻的前一条线段的宽度\n        // 　　distance 　　    　　    当前线条的长度\n        // 　　w_k 　　　　　　　    设定的一个固定阈值,表示:单位距离内, 笔迹的线条宽度可以变化的最大量.\n        // 　　distance * w_k 　　  即为当前线段的长度内, 笔宽可以相对于前一条线段笔宽的基础上, 最多能够变宽或者可以变窄多少.\n        z_linewidth(b, e, bwidth, step) {\n          if (e.time == b.time) return bwidth\n\n          let max_speed = 2.0\n          let d = this.z_distance(b, e)\n          let s = d / (e.time - b.time) //计算速度\n          console.log(&quot;s&quot;, e.time - b.time, s)\n          s = s &gt; max_speed ? max_speed : s\n\n          // let w = (max_speed - s) / max_speed;\n          let w = 0.5 / s\n\n          let max_dif = d * step\n          console.log(w, bwidth, max_dif)\n          if (w &lt; 0.05) w = 0.05\n          if (Math.abs(w - bwidth) &gt; max_dif) {\n            if (w &gt; bwidth) w = bwidth + max_dif\n            else w = bwidth - max_dif\n          }\n          // printf(&quot;d:%.4f, time_diff:%lld, speed:%.4f, width:%.4f\\n&quot;, d, e.t-b.t, s, w);\n          return w\n        }\n        z_distance(b, e) {\n          return Math.sqrt(Math.pow(e.x - b.x, 2) + Math.pow(e.y - b.y, 2))\n        }\n        BezierCalculate(poss, precision) {\n          //维度，坐标轴数（二维坐标，三维坐标...）\n          let dimersion = 2\n\n          //贝塞尔曲线控制点数（阶数）\n          let number = poss.length\n\n          //控制点数不小于 2 ，至少为二维坐标系\n          if (number &lt; 2 || dimersion &lt; 2) return null\n\n          let result = new Array()\n\n          //计算杨辉三角\n          let mi = new Array()\n          mi[0] = mi[1] = 1\n          for (let i = 3; i &lt;= number; i++) {\n            let t = new Array()\n            for (let j = 0; j &lt; i - 1; j++) {\n              t[j] = mi[j]\n            }\n\n            mi[0] = mi[i - 1] = 1\n            for (let j = 0; j &lt; i - 2; j++) {\n              mi[j + 1] = t[j] + t[j + 1]\n            }\n          }\n\n          //计算坐标点\n          for (let i = 0; i &lt; precision; i++) {\n            let t = i / precision\n            let p = new Point(0, 0)\n            p.isAdd = true\n            result.push(p)\n            for (let j = 0; j &lt; dimersion; j++) {\n              let temp = 0.0\n              for (let k = 0; k &lt; number; k++) {\n                temp +=\n                  Math.pow(1 - t, number - k - 1) *\n                  (j == 0 ? poss[k].x : poss[k].y) *\n                  Math.pow(t, k) *\n                  mi[k]\n              }\n              j == 0 ? (p.x = temp) : (p.y = temp)\n            }\n          }\n\n          return result\n        }\n      }\n\n      //以下代码为鼠标移动事件部分\n      let handwriting = new HandwritingSelf(document.getElementById(&quot;canvasId&quot;))\n      // document.ontouchstart = document.onmousedown\n      document.onpointerdown = function (e) {\n        if (e.type == &quot;touchstart&quot;)\n          handwriting.down(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.down(e.x, e.y)\n      }\n      // document.ontouchmove = document.onmousemove\n      document.onpointermove = function (e) {\n        if (e.type == &quot;touchmove&quot;)\n          handwriting.move(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.move(e.x, e.y)\n      }\n      // document.ontouchend = document.onmouseup\n      document.onpointerup = function (e) {\n        if (e.type == &quot;touchend&quot;)\n          handwriting.up(e.touches[0].pageX, e.touches[0].pageY)\n        else handwriting.up(e.x, e.y)\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"代码雨\"><a href=\"#代码雨\" class=\"headerlink\" title=\"代码雨\"></a>代码雨</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;title&gt;Code&lt;/title&gt;\n    &lt;style&gt;\n      body {\n        margin: 0;\n        overflow: hidden;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;\n    &lt;script&gt;\n      const width = (document.getElementById(&quot;myCanvas&quot;).width = 1920) //screen.availWidth;\n      const height = (document.getElementById(&quot;myCanvas&quot;).height = 1080) //screen.availHeight;\n      const ctx = document.getElementById(&quot;myCanvas&quot;).getContext(&quot;2d&quot;)\n      const arr = Array(Math.ceil(width / 10)).fill(0)\n      const str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;.split(&quot;&quot;)\n\n      function rain() {\n        ctx.fillStyle = &quot;rgba(0,0,0,0.05)&quot;\n        ctx.fillRect(0, 0, width, height)\n        ctx.fillStyle = &quot;#0f0&quot;\n        arr.forEach(function (value, index) {\n          ctx.fillText(\n            str[Math.floor(Math.random() * str.length)],\n            index * 10,\n            value + 10\n          )\n          arr[index] =\n            value &gt;= height || value &gt; 8888 * Math.random() ? 0 : value + 10\n        })\n      }\n\n      setInterval(rain, 30)\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<h2 id=\"qq企鹅\"><a href=\"#qq企鹅\" class=\"headerlink\" title=\"qq企鹅\"></a>qq企鹅</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      html,\n      body,\n      div,\n      strong {\n        margin: 0;\n        padding: 0;\n      }\n      body {\n        overflow: hidden;\n      }\n      .wrap {\n        width: 600px;\n        margin: 50px auto 0;\n        position: relative;\n      }\n      /* ……………………………………………………………………企鹅头部…………………………………………………………………… */\n\n      /* 上半部分黑色头部 */\n      .headtop {\n        width: 240px;\n        height: 110px;\n        background: #000;\n        margin: 0 auto;\n        border-top-left-radius: 120px 110px;\n        border-top-right-radius: 120px 110px;\n        position: relative;\n        z-index: 999;\n      }\n      /* 下半部分黑色头部 */\n      .headbottom {\n        width: 240px;\n        height: 90px;\n        background: #000;\n        border-bottom-left-radius: 120px 90px;\n        border-bottom-right-radius: 120px 90px;\n        position: absolute;\n        top: 110px;\n        z-index: 1;\n      }\n\n      h1 {\n        position: absolute;\n      }\n      /* 左眼部分 */\n      .lefteye {\n        width: 46px;\n        height: 70px;\n        background: #fff;\n        border-radius: 50% 50%;\n        position: absolute;\n\n        top: 30px;\n        left: 64px;\n        z-index: 2;\n      }\n      .lefteye_in {\n        width: 20px;\n        height: 30px;\n        background: #000;\n        border-radius: 50% 50%;\n        margin-left: 23px;\n        margin-top: 20px;\n      }\n      .eyeshow {\n        display: block;\n        width: 8px;\n        height: 10px;\n        border-radius: 50% 50%;\n        background: #fff;\n        position: absolute;\n        top: 26px;\n        left: 32px;\n      }\n\n      /*右眼部分 */\n      .righteye {\n        width: 46px;\n        height: 70px;\n        background: #fff;\n        border-radius: 50% 50%;\n        position: absolute;\n        top: 30px;\n        left: 130px;\n        z-index: 2;\n      }\n      .righteye_in {\n        width: 19px;\n        height: 23px;\n        background: #000;\n        border-top-left-radius: 17px 30px;\n        border-top-right-radius: 17px 30px;\n        border-bottom-left-radius: 5px;\n        border-bottom-right-radius: 5px;\n        border: 1px solid #000;\n        margin-left: 7px;\n        margin-top: 16px;\n      }\n      .eyebai {\n        display: block;\n        width: 12px;\n        height: 19px;\n        border-top-left-radius: 5px 14px;\n        border-top-right-radius: 8px 14px;\n        background: #fff;\n        margin-top: 10px;\n        margin-left: 4px;\n      }\n      /*右眼部分 */\n\n      /*嘴巴*/\n      .mouth {\n        width: 158px;\n        height: 56px;\n        background: #ffa600;\n        border-radius: 50%;\n        position: absolute;\n        top: 106px;\n        left: 42px;\n        z-index: 2;\n      }\n      .mouth_bar {\n        width: 126px;\n        height: 30px;\n        background: #000;\n        position: absolute;\n        top: 142px;\n        left: 55px;\n        z-index: 2;\n        border-bottom-left-radius: 76px 96px;\n        border-bottom-right-radius: 76px 96px;\n      }\n      .mouth_bar1 {\n        width: 126px;\n        height: 20px;\n        background: #ffa600;\n        position: absolute;\n        z-index: 3;\n        border-bottom-left-radius: 104px 32px;\n        border-bottom-right-radius: 104px 32px;\n      }\n      /*嘴巴*/\n      /* ……………………………………………………………………end  企鹅头部…………………………………………………………………… */\n\n      /* ……………………………………………………………………star 企鹅身体…………………………………………………………………… */\n\n      /* 企鹅身体黑色部分 */\n      .body {\n        width: 276px;\n        height: 260px;\n        background: #000;\n        position: absolute;\n        top: 142px;\n        left: 167px;\n        border-top-left-radius: 160px 140px;\n        border-bottom-left-radius: 160px 140px;\n        border-top-right-radius: 160px 140px;\n        border-bottom-right-radius: 160px 140px;\n        z-index: 2;\n      }\n      /* 企鹅身体黑色部分 */\n\n      /* 红色围脖 */\n      .body_1 {\n        width: 264px;\n        height: 137px;\n        background: #ff0000;\n        border: 5px solid #000;\n        border-top-left-radius: 195px 100px;\n        border-bottom-left-radius: 237px 146px;\n        border-top-right-radius: 195px 100px;\n        border-bottom-right-radius: 269px 146px;\n        position: absolute;\n        bottom: 159px;\n        left: 0px;\n      }\n\n      .body_2 {\n        width: 249px;\n        height: 139px;\n        position: absolute;\n        background: #000;\n        top: -33px;\n        left: 7px;\n        border-radius: 50%;\n        border: 1px #000 solid;\n      }\n\n      .body_3 {\n        width: 241px;\n        height: 145px;\n        position: absolute;\n        background: red;\n        top: 0px;\n        left: 5px;\n        border-radius: 50%;\n      }\n      /* 红色围脖 */\n\n      /* 白色企鹅肚子 */\n      .tummy {\n        width: 240px;\n        height: 240px;\n        background: #fff;\n        position: absolute;\n        top: 11px;\n        left: 17px;\n        border-radius: 50%;\n      }\n      /* 白色企鹅肚子 */\n\n      /* 企鹅口袋 */\n      .pocket {\n        width: 58px;\n        height: 78px;\n        position: absolute;\n        top: 72px;\n        left: 19px;\n        border: 3px solid #000;\n        background: red;\n        border-top-left-radius: 20px 52px;\n        border-bottom-left-radius: 40px 40px;\n        border-top-right-radius: 0px 0px;\n        border-bottom-right-radius: 21px 21px;\n      }\n\n      .pocket .pocket_line1 {\n        width: 11px;\n        height: 43px;\n        border-bottom-left-radius: 29px 57px;\n        border-top-left-radius: 0px 0px;\n        border: 9px solid #000;\n        border-top: none;\n        border-right: none;\n        position: absolute;\n        top: 0px;\n        left: 30px;\n        -webkit-transform: rotateZ(10deg);\n        -moz-transform: rotateZ(10deg);\n        -ms-transform: rotateZ(10deg);\n        -o-transform: rotateZ(10deg);\n        transform: rotateZ(10deg);\n      }\n\n      .pocket .pocket_line2 {\n        width: 2px;\n        height: 45px;\n        border-bottom-left-radius: 11px 24px;\n        border-top-left-radius: 10px 15px;\n        border: 9px solid red;\n        border-top: none;\n        border-right: none;\n        position: absolute;\n        top: 0px;\n        left: 2px;\n      }\n\n      /* 企鹅左右手 */\n      .lefthand,\n      .righthand {\n        width: 49px;\n        height: 160px;\n        background: #000;\n        position: absolute;\n      }\n\n      .lefthand {\n        top: 20px;\n        left: -29px;\n        border-top-left-radius: 89px 166px;\n        border-top-right-radius: 6px 63px;\n        border-bottom-left-radius: 85px 194px;\n        border-bottom-right-radius: 40px 128px;\n        -webkit-transform: rotateZ(20deg);\n        -moz-transform: rotateZ(20deg);\n        -ms-transform: rotateZ(20deg);\n        -o-transform: rotateZ(20deg);\n        transform: rotateZ(20deg);\n        -webkit-animation: left_rotate 0.5s infinite;\n        -moz-animation: left_rotate 0.5s infinite;\n        -ms-animation: left_rotate 0.5s infinite;\n        -o-animation: left_rotate 0.5s infinite;\n        animation: left_rotate 0.5s infinite;\n        -webkit-animation-direction: alternate;\n        -moz-animation-direction: alternate;\n        -ms-animation-direction: alternate;\n        -o-animation-direction: alternate;\n        animation-direction: alternate;\n      }\n      .righthand {\n        top: 20px;\n        left: 258px;\n        border-top-right-radius: 89px 166px;\n        border-bottom-right-radius: 85px 194px;\n        border-top-left-radius: 6px 63px;\n        border-bottom-left-radius: 40px 128px;\n        -webkit-transform: rotateZ(-20deg);\n        -moz-transform: rotateZ(-20deg);\n        -ms-transform: rotateZ(-20deg);\n        -o-transform: rotateZ(-20deg);\n        transform: rotateZ(-20deg);\n        -webkit-animation: right_rotate 0.5s infinite;\n        -moz-animation: right_rotate 0.5s infinite;\n        -ms-animation: right_rotate 0.5s infinite;\n        -o-animation: right_rotate 0.5s infinite;\n        animation: right_rotate 0.5s infinite;\n        -webkit-animation-direction: alternate;\n        -moz-animation-direction: alternate;\n        -ms-animation-direction: alternate;\n        -o-animation-direction: alternate;\n        animation-direction: alternate;\n      }\n      /* 企鹅左右手 */\n      /* ……………………………………………………………………end 企鹅身体…………………………………………………………………… */\n\n      /* ……………………………………………………………………star 企鹅脚部…………………………………………………………………… */\n      .footer .left_footer,\n      .footer .right_footer {\n        width: 134px;\n        height: 74px;\n        position: absolute;\n        background: #ffa600;\n        border: 3px solid #000;\n        border-radius: 50%;\n        z-index: 1;\n      }\n\n      .footer .left_footer {\n        top: 347px;\n        left: 163px;\n      }\n\n      .footer .right_footer {\n        top: 347px;\n        left: 320px;\n      }\n      /* ……………………………………………………………………end 企鹅脚部…………………………………………………………………… */\n\n      @keyframes left_rotate {\n        from {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(60deg);\n        }\n\n        to {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(30deg);\n        }\n      }\n\n      @keyframes right_rotate {\n        from {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-60deg);\n        }\n\n        to {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-30deg);\n        }\n      }\n\n      @-webkit-keyframes left_rotate {\n        from {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(60deg);\n        }\n\n        to {\n          -webkit-transform-origin: right 30%;\n          -webkit-transform: rotateZ(30deg);\n        }\n      }\n\n      @-webkit-keyframes right_rotate {\n        from {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-60deg);\n        }\n\n        to {\n          -webkit-transform-origin: left 30%;\n          -webkit-transform: rotateZ(-30deg);\n        }\n      }\n      @-moz-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-moz-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n      @-ms-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-ms-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n      @-o-keyframes left_rotate {\n        from {\n          transform-origin: right 30%;\n          transform: rotateZ(60deg);\n        }\n\n        to {\n          transform-origin: right 30%;\n          transform: rotateZ(30deg);\n        }\n      }\n\n      @-o-keyframes right_rotate {\n        from {\n          transform-origin: left 30%;\n          transform: rotateZ(-60deg);\n        }\n\n        to {\n          transform-origin: left 30%;\n          transform: rotateZ(-30deg);\n        }\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=&quot;wrap&quot;&gt;\n      &lt;!-- 企鹅头部 --&gt;\n      &lt;div class=&quot;headtop&quot;&gt;\n        &lt;div class=&quot;headbottom&quot;&gt;&lt;/div&gt;\n        &lt;!-- 眼睛部分 --&gt;\n        &lt;h1 class=&quot;lefteye&quot;&gt;\n          &lt;p class=&quot;lefteye_in&quot;&gt;\n            &lt;strong class=&quot;eyeshow&quot;&gt;&lt;/strong&gt;\n          &lt;/p&gt;\n        &lt;/h1&gt;\n        &lt;h1 class=&quot;righteye&quot;&gt;\n          &lt;p class=&quot;righteye_in&quot;&gt;\n            &lt;strong class=&quot;eyebai&quot;&gt;&lt;/strong&gt;\n          &lt;/p&gt;\n        &lt;/h1&gt;\n        &lt;!-- 嘴巴部分 --&gt;\n        &lt;h1 class=&quot;mouth&quot;&gt;&lt;/h1&gt;\n        &lt;p class=&quot;mouth_bar&quot;&gt;\n          &lt;strong class=&quot;mouth_bar1&quot;&gt;&lt;/strong&gt;\n        &lt;/p&gt;\n      &lt;/div&gt;\n\n      &lt;!-- 企鹅头部 --&gt;\n\n      &lt;!-- 企鹅身体 --&gt;\n      &lt;div class=&quot;body&quot;&gt;\n        &lt;div class=&quot;tummy&quot;&gt;\n          &lt;div class=&quot;pocket&quot;&gt;\n            &lt;div class=&quot;pocket_line1&quot;&gt;\n              &lt;div class=&quot;pocket_line2&quot;&gt;&lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;hand&quot;&gt;\n          &lt;div class=&quot;lefthand&quot;&gt;&lt;/div&gt;\n          &lt;div class=&quot;righthand&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;body_1&quot;&gt;\n          &lt;div class=&quot;body_2&quot;&gt;\n            &lt;div class=&quot;body_3&quot;&gt;&lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;!-- 企鹅身体 --&gt;\n\n      &lt;!-- 企鹅脚丫 --&gt;\n      &lt;div class=&quot;footer&quot;&gt;\n        &lt;div class=&quot;left_footer&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;right_footer&quot;&gt;&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;!-- 企鹅脚丫 --&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cku2cstou00084v9k8g2y1fhu","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstp6000h4v9kowrarhol"},{"post_id":"cku2cstoc00004v9kz6ppx3ie","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstp8000m4v9kgg99pkvk"},{"post_id":"cku2cstoz000a4v9kaif0k2o3","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstpa000p4v9kw583tcdy"},{"post_id":"cku2cstom00024v9kow4bcp2e","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstpb000r4v9kl8yknsv0"},{"post_id":"cku2cstos00064v9k17pp3pd1","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstpd000u4v9kzikab86n"},{"post_id":"cku2cstpx000w4v9kbz3gu4u3","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstpz000y4v9kenr32uix"},{"post_id":"cku2cstqi00114v9k1hyp65m5","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstqn00144v9k04ilmwld"},{"post_id":"cku2cstr000154v9k5dc25lp7","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstr200174v9kfirc29tk"},{"post_id":"cku2cstr700184v9kz3pswskr","category_id":"cku2cstr800194v9kfdthtt4k","_id":"cku2cstra001c4v9kddofq1ed"},{"post_id":"cku2cstrd001d4v9k0o0vkc61","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstrh001h4v9k0wpj0ese"},{"post_id":"cku2cstre001e4v9kqgoc1gmb","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstrh001i4v9k8d52ynl4"},{"post_id":"cku2cstrn001k4v9kv2ikpvfe","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstro001m4v9kf3y57irv"},{"post_id":"cku2cstrt001n4v9kex869l3q","category_id":"cku2cstop00044v9kje35v5k8","_id":"cku2cstrw001p4v9k1j8tb9tu"}],"PostTag":[{"post_id":"cku2cstou00084v9k8g2y1fhu","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstp4000e4v9k0slh299t"},{"post_id":"cku2cstoc00004v9kz6ppx3ie","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstp6000g4v9k40l57ylo"},{"post_id":"cku2cstoz000a4v9kaif0k2o3","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstp8000l4v9k7vkby1t1"},{"post_id":"cku2cstom00024v9kow4bcp2e","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstp9000o4v9k2ihrdvet"},{"post_id":"cku2cstos00064v9k17pp3pd1","tag_id":"cku2cstp6000j4v9k426xfzjo","_id":"cku2cstpb000s4v9kpv3ozh4s"},{"post_id":"cku2cstpx000w4v9kbz3gu4u3","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstq1000z4v9kbgmoncyg"},{"post_id":"cku2cstpx000w4v9kbz3gu4u3","tag_id":"cku2cstpy000x4v9k70n3aqte","_id":"cku2cstq200104v9k1poxthva"},{"post_id":"cku2cstqi00114v9k1hyp65m5","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstql00134v9kos1fu952"},{"post_id":"cku2cstr000154v9k5dc25lp7","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstr200164v9k1fgn0ygu"},{"post_id":"cku2cstr700184v9kz3pswskr","tag_id":"cku2cstr9001a4v9kmiph0hh5","_id":"cku2cstra001b4v9kqoa63dkk"},{"post_id":"cku2cstrd001d4v9k0o0vkc61","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstrg001f4v9kijsu0zx0"},{"post_id":"cku2cstre001e4v9kqgoc1gmb","tag_id":"cku2cstrg001g4v9k18dy5f0c","_id":"cku2cstrj001j4v9kz4oqewaq"},{"post_id":"cku2cstrn001k4v9kv2ikpvfe","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstro001l4v9k89tejwi3"},{"post_id":"cku2cstrt001n4v9kex869l3q","tag_id":"cku2cstor00054v9kjr6hntcr","_id":"cku2cstrw001o4v9kqhe4duo5"}],"Tag":[{"name":"web","_id":"cku2cstor00054v9kjr6hntcr"},{"name":"mac","_id":"cku2cstp6000j4v9k426xfzjo"},{"name":"悦读","_id":"cku2cstpy000x4v9k70n3aqte"},{"name":"前端","_id":"cku2cstr9001a4v9kmiph0hh5"},{"name":"后端","_id":"cku2cstrg001g4v9k18dy5f0c"}]}}