{"meta":{"title":"DarkStrand","subtitle":null,"description":"everything will be ok","author":"DarkStrand","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-08-12T02:40:48.568Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-08-12T02:40:48.567Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-08-12T02:40:48.569Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-08-12T02:40:48.568Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-08-12T02:40:48.570Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-08-12T02:40:48.571Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-08-12T02:40:48.571Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-08-12T02:40:48.572Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-08-12T02:40:48.573Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-08-12T02:40:48.572Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-08-12T02:40:48.573Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-08-12T02:40:48.574Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Nodejs","slug":"nodejs","date":"2021-08-12T10:45:51.947Z","updated":"2021-08-12T11:12:45.599Z","comments":true,"path":"2021/08/12/nodejs/","link":"","permalink":"/2021/08/12/nodejs/","excerpt":"","text":"01-Node.js基础一、Node.js是什么Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. 1、 特性Node.js可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如： 文件的读写（File System） 进程的管理（Process） 网络通信（HTTP/HTTPS） 2、举例2.1 浏览器安全级别的限制Ajax限制&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;browser-safe-sandbox&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;browser-safe-sandbox&lt;/div&gt; &lt;script&gt; const xhr = new XMLHttpRequest() xhr.open(&#39;get&#39;, &#39;https://m.maoyan.com/ajax/moreClassicList?sortId=1&amp;showType=3&amp;limit=10&amp;offset=30&amp;optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&amp;optimus_risk_level=71&amp;optimus_code=10&#39;, false) xhr.send() &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 浏览器预览browser-sync start --server --files **/* --directory 2.2 文件的读写（File System）const fs = require(&#39;fs&#39;) fs.readFile(&#39;./ajax.png&#39;, &#39;utf-8&#39;, (err, content) =&gt; { console.log(content) }) 2.3 进程的管理（Process）function main(argv) { console.log(argv) } main(process.argv.slice(2)) 运行 node 2.3-process.js argv1 argv2 2.4 网络通信（HTTP/HTTPS）const http = require(&quot;http&quot;) http.createServer((req,res) =&gt; { res.writeHead(200, { &quot;content-type&quot;: &quot;text/plain&quot; }) res.write(&quot;hello nodejs&quot;) res.end() }).listen(3000) 二、Node相关工具1、NVM：Node Version Manager1.1 Mac安装nvmhttps://github.com/nvm-sh/nvm/blob/master/README.md 1.2 Windows安装nvmnvm-windows nodist 1.3 常用的nvm命令 nvm list：查看当前环境安装了哪些版本 nvm use 14.15.0：切换node版本 nvm alias default (v)14.15.0：切换node默认版本 2、NPM：Node Package Manager npm view jquery versions：查看包的所有版本 2.1 全局安装package$ npm install forever --global (-g) $ forever $ npm uninstall forever --global $ forever 全局安装包的目录 Mac /Users/felix/.nvm/versions/node/nvm各个版本/bin/ Windows C:\\Users\\你的用户名\\AppData\\Roaming\\npm\\node_modules 2.2 本地安装package$ cd ~/desktop $ mkdir gp-project $ cd gp-project $ npm install underscore $ npm list (ls) 2.3 package.json初始化$ pwd $ npm init -y $ ls $ cat package.json 2.4 使用package.json npm install —production：只拉取生产环境的包 $ npm install underscore --save $ cat package.json $ npm install lodash --save-dev $ cat package.json $ rm -rf node_modules $ ls $ npm install $ npm uninstall underscore --save $ npm list | grep underscore // 查看underscore包的树(依赖关系) $ cat package.json “dependencies”：这些包是你的应用程序在生产环境中所需要的。 “devDepedencies”：这些包只是在开发和测试中需要的。 // package.json { ... &quot;dependencies&quot;: { // --save / -S }, &quot;devDependencies&quot;: { // --save-dev / -D } } 2.5 安装指定版本的包 npm install jquery@2.2.4： 安装指定版本 npm install jquery@1 -S：安装1最高的版本 $ pwd $ npm list $ npm info underscore $ npm view underscore versions $ npm install underscore@1.8.0 $ npm list $ npm uninstall underscore $ npm list 2.6 更新本地安装的包 -13.4.6 major: 13（主版本号）,minor: 4（次版本号），patch：6（补丁，单数不稳定，双数稳定） npm outdated：查看哪些包过期 npm update：更新所有的包 $ npm info underscore $ npm view underscore versions // 查看underscore包所有的版本 $ npm install underscore@1.4.4 --save-dev // 安装1.4.4的underscore到开发环境 $ npm list | grep gulp // 查看gulp包的依赖关系 $ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本 $ npm list | grep gulp $ npm update { &quot;dependencies&quot;: { &quot;jquery&quot;: &quot;^1.12.4&quot;, // ^锁定主版本号 &quot;jquery&quot;: &quot;~1.12.4&quot;, // ~锁定主版本号和次版本号 jquery: &quot;1.12.4&quot;, // 全部锁定 jquery: &quot;*&quot; // 最新版本 } } 2.7 清除缓存 npm cache clean --force 2.8 上传自己的包2.8.1 编写模块保存为index.js exports.sayHello = function(){ return &#39;Hello World&#39;; } 2.8.2 初始化描述文件 npm init package.json { &quot;name&quot;: &quot;gp19-npm&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;gp19 self module&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;make test&quot; }, &quot;repository&quot;: { &quot;type&quot;: &quot;Git&quot;, &quot;url&quot;: &quot;git+https://github.com/lurongtao/gp19-npm.git&quot; }, &quot;keywords&quot;: [ &quot;demo&quot; ], &quot;author&quot;: &quot;Felixlu&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bugs&quot;: { &quot;url&quot;: &quot;https://github.com/lurongtao/gp19-npm/issues&quot; }, &quot;homepage&quot;: &quot;https://github.com/lurongtao/gp19-npm#readme&quot;, } 2.8.3 注册npm仓库账号 npm adduser https://www.npmjs.com 上面的账号 felix_lurt/qqmko09ijn $ npm adduser 2.8.4 上传包 npm publish 坑：403 Forbidden 查看npm源：npm config get registry 切换npm源方法一：npm config set registry http://registry.npmjs.org 切换npm源方法二：nrm use npm 2.8.5 安装包 npm install gp19-npm 2.8.6 卸载包查看当前项目引用了哪些包 ： npm ls 卸载包： npm unpublish --force 2.8.7 使用引入包var hello = require(&#39;gp19-npm&#39;) hello.sayHello() 2.9 npm脚本Node开发离不开npm，而脚本功能是npm最强大、最常用的功能之一。 2.9.1 什么是npm脚本？npm允许在package.json文件里面，使用scripts字段定义脚本命令。 { // ... &quot;scripts&quot;: { &quot;builds&quot;: &quot;node build.js&quot; } } 2.9.2 执行顺序如果npm脚本里面需要执行多个任务，那么需要明确它们的执行顺序。 scripts1.js var x = 0 console.log(x) scripts2.js var y = 0 console.log(y) &quot;scripts&quot; : { &quot;script1&quot;: &quot;node script1.js&quot;, &quot;script2&quot;: &quot;ndoe script2.js&quot; } 如果是并行执行（即同时的平行执行），可以使用&amp;符号。 $ npm run script1 &amp; npm run script2 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。 $ npm run script1 &amp;&amp; npm run script2 2.9.3 简写形式常用的npm脚本简写形式 npm start 是 npm run start 2.9.4 变量npm脚本有一个非常强大功能，就是可以使用npm的内部变量。 首先，通过npm _package_前缀，npm脚本可以拿到package.json里面的字段。比如，下面是一个package.json。 注意：一定要在npm脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到的 { &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;scripts&quot;: { &quot;view&quot;: &quot;node view.js&quot; } } 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。 // view.js console.log(process.env.npm_package_name); // foo console.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是Bash脚本，可以用$npm_package_name和 $npm_package_version取到这两个值。 npmpackage前缀也支持嵌套的package.json字段。 &quot;repository&quot;: { &quot;type&quot;: &#39;git&#39;, &quot;url&quot;: &quot;xxx&quot; }, &quot;scripts&quot;: { &quot;view&quot;: &quot;echo $npm_package_repository_type&quot; } 上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。 下面是另外一个例子。 &quot;scripts&quot;: { &quot;install&quot;: &quot;foo.js&quot; } 上面代码中，npm_package_scripts_install变量的值等于foo.js。 然后，npm脚本还可以通过npmconfig前缀，拿到npm的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发型标签，可以通过npm_config_tag取到。 &quot;view&quot;: &quot;echo $npm_config_tag&quot;, 注意，package.json里面的config对象，可以被环境变量覆盖。 { &quot;name&quot;: &quot;foo&quot;, &quot;config&quot;: {&quot;port&quot;: &quot;8080&quot;}, &quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;} } 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。 $ npm config set foo:port 80 最后，env命令可以列出所有环境变量。 “env”:”env” 2.10 npm安装git上发布的包# 这样适合安装公司内部的git服务器上的项目 npm install git+https://git@github.com:lurongtao/gp-project.git # 或者以ssh的方式 npm install git+ssh://git@github.com:lurongtao/gp-project.git 2.11 cross-env使用2.11.1 cross-env是什么运行跨平台设置和使用环境变量的脚本 2.11.2 出现原因当您使用NODE_ENV=production，来设置环境变量时，大多数Windows命令提示将会阻塞（报错）。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows不支持NOE_ENV=production的设置方式。 2.11.3 解决cross-env使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包（cross-env）能够提供一个设置环境变量的scripts，让你能够以Unix方式设置环境变量，然后在Windows上也能兼容运行。 2.11.4 安装npm install --save-dev cross-env 2.11.5 使用{ &quot;scripts&quot;: { &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot; } } NODE_ENV环境变量将由cross-env设置，打印process.env.NODE_ENV === &#39;production&#39; 3、NRM：npm registry manager3.1 手工切换源3.1.1 查看当前源npm config get registry 3.1.2 切换淘宝源npm config set registry https://registry.npm.taobao.org 3.2 NRM管理源NRM是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在npm源间切换。 3.2.1 安装nrm在命令行执行命令，npm install -g nrm，全局安装nrm。 3.2.2 使用nrm执行命令nrm ls查看可选的源。其中，带*的是当前使用的源，上面输出表明当前源是官方源。 3.2.3 切换nrm如果要切换到taobao源，执行命令nrm use taobao。 3.2.4 测试速度你还可以通过nrm test测试相应源的响应时间。 4、 NPX：npm package extentionnpm从5.2版开始，增加了npx命令。它有很多用处，本文介绍该命令的主要使用场景。 Node自带npm模块，所以可以直接使用npx命令。万一不能用，就要手动安装一下。 $ npm install -g npx 4.1 调用项目安装的模块npx想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。 $ npm install -D mocha 一般来说，调用Mocha，只能在项目脚本和package.json的scripts字段里面，如果想在命令行下调用，必须像下面这样。 # 项目的根目录下执行 $ node-modules/.bin/mocha --version npx就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。 $ npx mocha --version npx的原理很简单，就是运行的时候，会倒node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。 由于npx会检查环境变量$PATH，所以系统命令也可以调用。 # 等同于 ls $ npx ls 注意，Bash内置的命令不在$PATH里面，所以不能用。比如cd 是Bash命令，因此就不能用npx cd。 4.2 避免全局安装模块除了调用项目内部模块，npx还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx可以运行它，而且不进行全局安装。 $ npx create-react-app my-react-app 上面代码运行时，npx将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。 注意，只要npx后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个Web服务。 $ npx http-server 4.3 –no–install参数和–ignore-existing参数如果想让npx强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。 $ npx --no-install http-server 反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用–ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。 $ npx --ignore-existing http-server 5、node的浏览端调试 node --inspect --inspect-brk server.js 6、node进程管理工具 supervisor nodemon npm install nodemon nodemon server.js forever pm2 三、模块/包与CommonJS1、模块/包分类Node.js有三类模块，即内置的模块、第三方的模块、自定义的模块。 1.1 内置的模块Node.js内置模块又叫核心模块，Node.js安装完成可直接使用。如： const path = require(&#39;path&#39;) var extname = path.extname(&#39;index.html&#39;) console.log(extname) 1.2 第三方的Node.js模块第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如： npm install chalk const chalk = require(&#39;chalk&#39;) console.log(chalk.blue(&#39;Hello world!&#39;)) 1.3 自定义的Node.js模块自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。 自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。 1.3.1 模块定义、接口暴露和引用接口我们可以把公共的功能抽离成为一个单独的js文件作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过exports或者module.exports暴露属性或者方法。 m1.js const name = &#39;gp19&#39; const sayName = () =&gt; { console.log(name) } console.log(&#39;module 1&#39;) // 接口暴露方法一： module.exports = { say: sayName } // 接口暴露方法二： exports.say = sayName // 错误！ exports = { say: sayName } main.js const m1 = require(&#39;./m1&#39;) m1.say() 1.3.2 模块的循环引用由于exports使用方式不对，会在两个不同js循环引用的情况下，导致其中一个js无法获取另外一个js的方法，从而导致执行报错。如： a.js exports.done = false const b = require(&#39;./b.js&#39;) console.log(&#39;in a, b.done = %j&#39;, b.done) exports.done = true console.log(&#39;a done&#39;) b.js console.log(&#39;b starting&#39;) exports.done = false const a = require(&#39;./a.js&#39;) console.log(&#39;in b, a.done= %j&#39;, a.done) exports.done = true console.log(&#39;b done&#39;) main.js console.log(&#39;main starting&#39;) const a = require(&#39;./a.js&#39;) const b = require(&#39;./b.js&#39;) console.log(&#39;in main, a.done = %j, b.done = %j&#39;, a.done, b.done) main.js首先会load a.js，此时执行到const b = require(&#39;./b.js&#39;);的时候，程序会转去loadb.js, 在b.js中执行到const a = require(&#39;./a.js&#39;); 为了防止无限循环，将a.jsexports的未完成副本返回到b.js模块。然后b.js完成加载，并将其导出对象提供给a.js模块。 我们知道nodeJs的对每个js文件进行了一层包装称为module，module中有一个属性exports，当调用require(&#39;a.js&#39;)的时候其实返回的是module.exports对象，module.exports初始化为一个{}空的object，所以在上面的例子中，执行到b.js中const a = require(&#39;./a.js&#39;);时不会load新的a module, 而是将已经load但是还未完成的a module的exports属性返回给b module，所以b.js拿到的是a module的exports对象，即：{done:false}, 虽然在a.js中exports.done被修改成了true，但是由于此时a.js未load完成，所以在b.js输出的a module的属性done为false，而在main.js中输出的a module的属性done为true. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。 四、常用内置模块这里介绍几个常用的内置模块：url，querystring，http，events，fs，stream，readline，crypto，zlib 1、url1.1 parse 要解析的内容，是否查询字符串 url.parse(urlString[,parseQueryString[,slashesDenoteHost]]) const url = require(&#39;url&#39;) const urlString = &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39; const parsedStr = url.parse(urlString) console.log(parsedStr) =&gt; Url { protocol: &#39;https:&#39;, slashes: true, auth: null, host: &#39;www.baidu.com:443&#39;, port: &#39;443&#39;, hostname: &#39;www.baidu.com&#39;, hash: &#39;#tag=110&#39;, search: &#39;?id=8&amp;name=mouse&#39;, query: [Object: null prototype] { id: &#39;8&#39;, name: &#39;mouse&#39; }, pathname: &#39;/ad/index.html&#39;, path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;, href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39; } 1.2 format 将一个解析后的URL对象、转成、一个格式化的URL字符串。 url.format(urlObject) const url = require(&#39;url&#39;) const urlObject = { protocol: &#39;https:&#39;, slashes: true, auth: null, host: &#39;www.baidu.com:443&#39;, port: &#39;443&#39;, hostname: &#39;www.baidu.com&#39;, hash: &#39;#tag=110&#39;, search: &#39;?id=8&amp;name=mouse&#39;, query: { id: &#39;8&#39;, name: &#39;mouse&#39; }, pathname: &#39;/ad/index.html&#39;, path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;, href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39; } const parsedObj = url.format(urlObject) console.log(parsedObj) =&gt; &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39; 1.3 resolve 用于拼接URL（替换 域名后面第一个/后的内容,如果出现.就向上返回一级之后再拼接，两个..就向上反两级再拼接） url.resolve(from, to) const url = require(&#39;url&#39;) var a = url.resolve(&#39;/one/two/three&#39;, &#39;four&#39;) var b = url.resolve(&#39;http://example.com/&#39;, &#39;/one&#39;) var c = url.resolve(&#39;http://example.com/one&#39;, &#39;/two&#39;); var d = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;./two&#39;); var e = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;../two&#39;); var f = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;.../two&#39;); console.log(a +&quot;,&quot;+ b +&quot;,&quot;+ c+&#39;,&#39;+d+&#39;,&#39;+e+&#39;,&#39;+f); =&gt; /one/two/four, http://example.com/one, http://example.com/two, http://example.com/one/ddd/ddd/two, http://example.com/one/ddd/two http://example.com/one/ddd/ddd/.../two 2、querystring2.1 parse 将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。 querystring.parse(str[, sep[, eq[, options]]]) str：欲转换的字符串 sep：设置分隔符，默认为&amp; eq：设置赋值符，默认为= [options]maxKeys：可接受字符串的最大长度，默认为1000 const querystring = require(&#39;querystring&#39;) var qs = &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#39; var parsed = querystring.parse(qs) console.log(parsed) =&gt; { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; } 2.2 stringify 将对象转换成字符串，字符串里多个参数将用 ‘&amp;’ 分隔，将用 ‘=’ 赋值。 querystring.stringify(obj[, sep[, eq[, options]]]) obj：欲转换的对象 sep：设置分隔符，默认为&amp; eq：设置赋值符，默认为= const querystring = require(&#39;querystring&#39;) var qo = { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; } var parsed = querystring.stringify(qo) console.log(parsed) ==&gt; &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39; const querystring = require(&#39;querystring&#39;) var qo = {foo: &#39;bar&#39;, baz: &#39;qux&#39;} var parsed =querystring.stringify(qo, &#39;;&#39;, &#39;:&#39;) console.log(parsed) ==&gt; &#39;foo:bar;baz:qux&#39; 2.3 escape/unescape 以针对网址查询字符串的特定要求优化的方式对给定的 str 执行网址百分比编码 querystring.escape() 方法被 querystring.stringify() 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 querystring.escape 分配给替代函数来提供替换的百分比编码实现。 querystring.escape(str) const querystring = require(&#39;querystring&#39;) var str = &#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39; var escaped = querystring.escape(str) console.log(escaped) ==&gt; &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39; 在给定的 str 上执行网址百分比编码字符的解码。 querystring.unescape() 方法被 querystring.parse() 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 querystring.unescape 分配给替代函数来提供替代的解码实现。 默认情况下，querystring.unescape() 方法将尝试使用 JavaScript 内置的 decodeURIComponent() 方法进行解码。 如果失败，则将使用更安全的不会因格式错误的网址而抛出错误的同类方法。 querystring.unescape(str) const querystring = require(&#39;querystring&#39;) var str = &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39; var unescaped = querystring.unescape(str) console.log(unescaped) ==&gt; &#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39; 3、http/https3.1 getvar http = require(&#39;http&#39;) var https = require(&#39;https&#39;) // 1、接口 2、跨域 const server = http.createServer((request, response) =&gt; { var url = request.url.substr(1) var data = &#39;&#39; response.writeHeader(200, { &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;, &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; }) //response.write(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;) //response.end() // 或 //response.end(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;) https.get(`https://m.lagou.com/listmore.json${url}`, (res) =&gt; { res.on(&#39;data&#39;, (chunk) =&gt; { data += chunk }) res.on(&#39;end&#39;, () =&gt; { response.end(JSON.stringify({ ret: true, data })) }) }) }) server.listen(8080, () =&gt; { console.log(&#39;localhost:8080&#39;) }) 3.2 post:服务器提交（攻击）const https = require(&#39;https&#39;) const querystring = require(&#39;querystring&#39;) const postData = querystring.stringify({ province: &#39;上海&#39;, city: &#39;上海&#39;, district: &#39;宝山区&#39;, address: &#39;同济支路199号智慧七立方3号楼2-4层&#39;, latitude: 43.0, longitude: 160.0, message: &#39;求购一条小鱼&#39;, contact: &#39;13666666&#39;, type: &#39;sell&#39;, time: 1571217561 }) const options = { protocol: &#39;http:&#39;, hostname: &#39;localhost&#39;, method: &#39;POST&#39;, port: 3000, path: &#39;/index.php/trade/add_item&#39;, headers: { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;Content-Length&#39;: Buffer.byteLength(postData) } } const server = http.createServer((req, res) =&gt; { const request = http.request(options, result =&gt; { }) req.write(postData) req.end() res.end() }) server.listen(8080, ()=&gt; { console.log(&#39;localhost:8080&#39;) }) //function doPost() { // let data // let req = https.request(options, (res) =&gt; { // res.on(&#39;data&#39;, chunk =&gt; data += chunk) // res.on(&#39;end&#39;, () =&gt; { // console.log(data) // }) // }) // req.write(postData) // req.end() //} // setInterval(() =&gt; { // doPost() // }, 1000) 3.3 跨域：JSONPconst http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const app = http.createServer((req, res) =&gt; { let urlObj = url.parse(req.url, true) switch (urlObj.pathname) { case &#39;/api/user&#39;: res.end(`${urlObj.query.cb}({&quot;name&quot;: &quot;gp145&quot;})`) break default: res.end(&#39;404.&#39;) break } }) app.listen(8080, () =&gt; { console.log(&#39;localhost:8080&#39;) }) 3.4 跨域：CORSconst http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const querystring = require(&#39;querystring&#39;) const app = http.createServer((req, res) =&gt; { let data = &#39;&#39; let urlObj = url.parse(req.url, true) res.writeHead(200, { &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;, &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; }) req.on(&#39;data&#39;, (chunk) =&gt; { data += chunk }) req.on(&#39;end&#39;, () =&gt; { responseResult(querystring.parse(data)) }) function responseResult(data) { switch (urlObj.pathname) { case &#39;/api/login&#39;: res.end(JSON.stringify({ message: data })) break default: res.end(&#39;404.&#39;) break } } }) app.listen(8080, () =&gt; { console.log(&#39;localhost:8080&#39;) }) 3.5 跨域：middleware(http-proxy-middware)const http = require(&#39;http&#39;) const proxy = require(&#39;http-proxy-middleware&#39;) http.createServer((req, res) =&gt; { let url = req.url res.writeHead(200, { &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; }) if (/^\\/api/.test(url)) { let apiProxy = proxy(&#39;/api&#39;, { target: &#39;https://m.lagou.com&#39;, changeOrigin: true, pathRewrite: { &#39;^/api&#39;: &#39;&#39; } }) // http-proy-middleware 在Node.js中使用的方法 apiProxy(req, res) } else { switch (url) { case &#39;/index.html&#39;: res.end(&#39;index.html&#39;) break case &#39;/search.html&#39;: res.end(&#39;search.html&#39;) break default: res.end(&#39;[404]page not found.&#39;) } } }).listen(8080) 3.6 爬虫const https = require(&#39;https&#39;) const http = require(&#39;http&#39;) const cheerio = require(&#39;cheerio&#39;) http.createServer((request, response) =&gt; { response.writeHead(200, { &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39; }) const options = { protocol: &#39;https:&#39;, hostname: &#39;maoyan.com&#39;, port: 443, path: &#39;/&#39;, method: &#39;GET&#39; } const req = https.request(options, (res) =&gt; { let data = &#39;&#39; res.on(&#39;data&#39;, (chunk) =&gt; { data += chunk }) res.on(&#39;end&#39;, () =&gt; { filterData(data) }) }) function filterData(data) { let $ = cheerio.load(data) let $movieList = $(&#39;.movie-item&#39;) let movies = [] $movieList.each((index, value) =&gt; { movies.push({ title: $(value).find(&#39;.movie-title&#39;).attr(&#39;title&#39;), score: $(value).find(&#39;.movie-score i&#39;).text(), }) }) response.end(JSON.stringify(movies)) } req.end() }).listen(9000) 4、Eventsconst EventEmitter = require(&#39;events&#39;) class MyEventEmitter extends EventEmitter {} const event = new MyEventEmitter() event.on(&#39;play&#39;, (movie) =&gt; { console.log(movie) }) event.emit(&#39;play&#39;, &#39;我和我的祖国&#39;) event.emit(&#39;play&#39;, &#39;中国机长&#39;) 5、File Systemconst fs = require(&#39;fs&#39;) const fsP = require(&#39;fs&#39;).promises // 创建文件夹 fs.mkdir(&#39;./logs&#39;, (err) =&gt; { console.log(&#39;done.&#39;) }) // 文件夹改名 fs.rename(&#39;./logs&#39;, &#39;./log&#39;, () =&gt; { console.log(&#39;done&#39;) }) // 删除文件夹 fs.rmdir(&#39;./log&#39;, () =&gt; { console.log(&#39;done.&#39;) }) // 写内容到文件里 fs.writeFile( &#39;./logs/log1.txt&#39;, &#39;hello&#39;, // 错误优先的回调函数 (err) =&gt; { if (err) { console.log(err.message) } else { console.log(&#39;文件创建成功&#39;) } } ) // 给文件追加内容 fs.appendFile(&#39;./logs/log1.txt&#39;, &#39;\\nworld&#39;, () =&gt; { console.log(&#39;done.&#39;) }) // 读取文件内容 fs.readFile(&#39;./logs/log1.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; { console.log(data) }) // 删除文件 fs.unlink(&#39;./logs/log1.txt&#39;, (err) =&gt; { console.log(&#39;done.&#39;) }) // 批量写文件 for (var i = 0; i &lt; 10; i++) { fs.writeFile(`./logs/log-${i}.txt`, `log-${i}`, (err) =&gt; { console.log(&#39;done.&#39;) }) } // 读取文件/目录信息 fs.readdir(&#39;./&#39;, (err, data) =&gt; { data.forEach((value, index) =&gt; { fs.stat(`./${value}`, (err, stats) =&gt; { // console.log(value + &#39;:&#39; + stats.size) console.log(value + &#39; is &#39; + (stats.isDirectory() ? &#39;directory&#39; : &#39;file&#39;)) }) }) }) // 同步读取文件 try { const content = fs.readFileSync(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;) console.log(content) console.log(0) } catch (e) { console.log(e.message) } console.log(1) // 异步读取文件：方法一 fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; { console.log(content) console.log(0) }) console.log(1) // 异步读取文件：方法二 fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;).then(result =&gt; { console.log(result) }) // 异步读取文件：方法三 function getFile() { return new Promise((resolve) =&gt; { fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; { resolve(data) }) }) } ;(async () =&gt; { console.log(await getFile()) })() // 异步读取文件：方法四 const fsp = fsP.readFile(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;).then((result) =&gt; { console.log(result) }) console.log(fsP) // watch 监测文件变化 fs.watch(&#39;./logs/log-0.txt&#39;, () =&gt; { console.log(0) }) 6、Streamconst fs = require(&#39;fs&#39;) const readstream = fs.createReadStream(&#39;./note.txt&#39;) const writestream = fs.createWriteStream(&#39;./note2.txt&#39;) writestream.write(readstream) 7、Zlibconst fs = require(&#39;fs&#39;) const zlib = require(&#39;zlib&#39;) const gzip = zlib.createGzip() const readstream = fs.createReadStream(&#39;./note.txt&#39;) const writestream = fs.createWriteStream(&#39;./note2.txt&#39;) readstream .pipe(gzip) .pipe(writestream) writestream.write(readstream) 8、ReadLineconst readline = require(&#39;readline&#39;) const rl = readline.createInterface({ input: process.stdin, output: process.stdout }) rl.question(&#39;What do you think of Node.js? &#39;, (answer) =&gt; { // TODO: Log the answer in a database console.log(`Thank you for your valuable feedback: ${answer}`) rl.close() }) 9、Cryptoconst crypto = require(&#39;crypto&#39;) const secret = &#39;abcdefg&#39; const hash = crypto.createHmac(&#39;sha256&#39;, secret) .update(&#39;I love you&#39;) .digest(&#39;hex&#39;) console.log(hash) 五、路由var http = require(&#39;http&#39;) var fs = require(&#39;fs&#39;) http.createServer( function ( req, res ) { switch ( req.url ) { case &#39;/home&#39;: res.write(&#39;home&#39;) res.end() break case &#39;/mine&#39;: res.write(&#39;mine&#39;) res.end() break case &#39;/login&#39;: fs.readFile( &#39;./static/login.html&#39;,function ( error , data ) { if ( error ) throw error res.write( data ) res.end() }) break case &#39;/fulian.jpg&#39;: fs.readFile( &#39;./static/fulian.jpg&#39;, &#39;binary&#39;, function( error , data ) { if( error ) throw error res.write( data, &#39;binary&#39; ) res.end() }) break default: break } }).listen( 8000, &#39;localhost&#39;, function () { console.log( &#39;服务器运行在： http://localhost:8000&#39; ) }) 六、静态资源服务6.1 readStaticFile/modules/readStaticFile.js // 引入依赖的模块 var path = require(&#39;path&#39;) var fs = require(&#39;fs&#39;) var mime = require(&#39;mime&#39;) function readStaticFile(res, filePathname) { var ext = path.parse(filePathname).ext var mimeType = mime.getType(ext) // 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 if (ext) { // 根据传入的目标文件路径来读取对应文件 fs.readFile(filePathname, (err, data) =&gt; { // 错误处理 if (err) { res.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; }) res.write(&quot;404 - NOT FOUND&quot;) res.end() } else { res.writeHead(200, { &quot;Content-Type&quot;: mimeType }) res.write(data) res.end() } }); // 返回 true 表示, 客户端想要的 是 静态文件 return true } else { // 返回 false 表示, 客户端想要的 不是 静态文件 return false } } // 导出函数 module.exports = readStaticFile 6.2 server/server.js // 引入相关模块 var http = require(&#39;http&#39;); var url = require(&#39;url&#39;); var path = require(&#39;path&#39;); var readStaticFile = require(&#39;./modules/readStaticFile&#39;); // 搭建 HTTP 服务器 var server = http.createServer(function(req, res) { var urlObj = url.parse(req.url); var urlPathname = urlObj.pathname; var filePathname = path.join(__dirname, &quot;/public&quot;, urlPathname); // 读取静态文件 readStaticFile(res, filePathname); }); // 在 3000 端口监听请求 server.listen(3000, function() { console.log(&quot;服务器运行中.&quot;); console.log(&quot;正在监听 3000 端口:&quot;) }) 6.3 最终目录结构 02-Express基于Node.js平台，快速、开放、极简的web开发框架。 $ npm install express --save 一、特色1、Web应用Express是一个基于Node.js平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种Web和移动设备应用。 2、API丰富的HTTP快捷方法和任意排列组合的Connect中间件，让你创建健壮、友好的API变得既快速又简单。 3、性能Express不对Node.js已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的基本性能。 二、安装首先假定你已经安装了Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。 $ mkdir myapp $ cd myapp 通过npm init命令为你的应用创建一个package.json文件。欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。 $ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。你可以直接按“回车”键接受默认设置即可，下面这个除外： entry point: (index.js) 键入app.js或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的index.js文件名，只需按“回车”键即可。 接下来安装Express并将其保存到依赖列表中： $ npm install express --save 如果只是临时安装Express，不想将它添加到依赖列表中，只需略去–save参数即可： $ npm install express 安装Node模块时，如果指定了--save 参数，那么此模块将被添加到package.json文件中dependencies依赖列表中。然后通过npm install 命令即可 三、Hello World实例接下来，我们一起创建一个基本的Express应用。 注意：这里所创建的是一个最最简单的Express应用，并且仅仅只有一个文件 - 和通过Express应用生成器所创建的应用完全不一样，Express应用生成器所创建的应用框架包含多JavaScript文件、Jade模板和针对不同用途的子目录。 进入myapp目录，创建一个名为app.js的文件，然后将下列代码复制进去： var express = require(&#39;express&#39;); var app = express(); app.get(&#39;/&#39;, function (req, res) { res.send(&#39;Hello World!&#39;); }); var server = app.listen(3000, function () { var host = server.address().address; var port = server.address().port; console.log(&#39;Example app listening at http://%s:%s&#39;, host, port); }); 上面的代码启动一个服务并监听从3000端口进入的所有连接请求。他将对所有(/)URL或 路由返回“Hello World！”字符串。对于其他所有路径全部返回 404 Not Found。 req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on(‘data’, callback) 以及任何 Node 提供的方法。 通过如下命令启动此应用： $ node app.js 然后在浏览器中打开 http://localhost:3000/ 并查看输出结果。 四、路由路由是指如何定义应用的端点（URls）以及如何响应客户端的请求。 路由是由一个URI、HTTP请求（GET、POST等）和若干个句柄组成，它的结构如下：app.METHOD(path, [callback..], callback)， app 是 express 对象的一个实例，METHOD是一个 HTTP 请求方法，path 是服务器上的路径， callback 是当路由匹配时要执行的函数。 下面是一个基本的路由示例： var express = require(&#39;express&#39;); var app = express(); // respond with &quot;hello world&quot; when a GET request is made to the homepage app.get(&#39;/&#39;, function(req, res) { res.send(&#39;hello world&#39;); }); 1、路由方法路由方法源于 HTTP 请求方法，和 express 实例相关联。 下面这个例子展示了为应用跟路径定义的 GET 和 POST 请求： // GET method route // 对网站首页的访问返回 &quot;Hello World!&quot; 字样 app.get(&#39;/&#39;, function (req, res) { res.send(&#39;Hello World!&#39;) }) // 网站首页接受 POST 请求 app.post(&#39;/&#39;, function (req, res) { res.send(&#39;Got a POST request&#39;) }) // /user 节点接受 PUT 请求 app.put(&#39;/user&#39;, function (req, res) { res.send(&#39;Got a PUT request at /user&#39;) }) // /user 节点接受 DELETE 请求 app.delete(&#39;/user&#39;, function (req, res) { res.send(&#39;Got a DELETE request at /user&#39;) }) Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。 有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如：app[&#39;m-search&#39;](&#39;/&#39;, function ...) app.all()是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 在下面的例子中，来自”/secret”的请求，不管使用 GET、POST、PUT、DELETE或其他任何http模块支持的HTTP请求，句柄都会得到执行。 app.all(&#39;/secret&#39;, function (req, res, next) { console.log(&#39;Accessing the secret section ...&#39;) next(); // pass control to the next handler }) 2、路由路径路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。 Express使用path-to-regexp匹配路由路径，请参考文档查阅所有定义路由路径的方法。Express Route Tester是测试基本Express路径的好工具，但不支持模式匹配。 查询字符串不是路由路径的一部分。 使用字符串的路由路径示例： // 匹配根路径的请求 app.get(&#39;/&#39;, function (req, res) { res.send(&#39;root&#39;); }); // 匹配 /about 路径的请求 app.get(&#39;/about&#39;, function (req, res) { res.send(&#39;about&#39;); }); // 匹配 /random.text 路径的请求 app.get(&#39;/random.text&#39;, function (req, res) { res.send(&#39;random.text&#39;); }); 使用字符串模式的路由路径示例： // 匹配 acd 和 abcd app.get(&#39;/ab?cd&#39;, function(req, res) { res.send(&#39;ab?cd&#39;); }); // 匹配 abcd、abbcd、abbbcd等 app.get(&#39;/ab+cd&#39;, function(req, res) { res.send(&#39;ab+cd&#39;); }); // 匹配 abcd、abxcd、abRABDOMcd、ab123cd等 app.get(&#39;/ab*cd&#39;, function(req, res) { res.send(&#39;ab*cd&#39;); }); // 匹配 /abe 和 /abcde app.get(&#39;/ab(cd)?e&#39;, function(req, res) { res.send(&#39;ab(cd)?e&#39;); }); 字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。 使用正则表达式的路由路径示例： // 匹配任何路径中含有 a 的路径： app.get(/a/, function(req, res) { res.send(&#39;/a/&#39;); }); // 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等 app.get(/.*fly$/, function(req, res) { res.send(&#39;/.*fly$/&#39;); }); 3、路由句柄可以为请求处理提供多个回调函数，其行为类似中间件。唯一的区别是这些回调函数有可能调用next(&#39;route&#39;)方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。 路由句柄有多种形式，可以是一个函数、一个函数数组、或者是两者混合，如下所示。 使用一个回调函数处理路由： app.get(&#39;/example/a&#39;, function(req, res) { res.send(&#39;Hello from A!&#39;) }) 使用多个回调函数处理路由（记得指定next对象）： app.get(&#39;/example/b&#39;, function (req, res, next) { console.log(&#39;response will be sent by the next function ...&#39;); next(); }, function (req, res) { res.send(&#39;Hello from B!&#39;); }); 使用回调函数数组处理路由： var cb0 = function (req, res, next) { console.log(&#39;CB0&#39;) next() } var cb1 = function (req, res, next) { console.log(&#39;CB1&#39;) next() } var cb2 = function (req, res) { res.send(&#39;Hello from C!&#39;) } app.get(&#39;/example/c&#39;, [cb0, cb1, cb2]) 混合使用函数和函数数组处理路由： var cb0 = function (req, res, next) { console.log(&#39;CB0&#39;) next() } var cb1 = function (req, res, next) { console.log(&#39;CB1&#39;) next() } app.get(&#39;/example/d&#39;, [cb0, cb1], function (req, res, next) { console.log(&#39;response will be sent by the next function ...&#39;) next() }, function (req, res) { res.send(&#39;Hello from D!&#39;) }) 4、响应方法下表中响应对象(res)的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。 方法 描述 res.download() 提示下载文件 res.end() 终结响应处理流程 res.json() 发送一个JSON格式的响应 res.jsonp() 发送一个支持JSONP的JSON格式的响应 res.direct() 重定向请求 res.render() 渲染视图模板 res.send() 发送各种类型的响应 res.sendFile() 以八位字节流的形式发送文件 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送 5、app.route()可使用app.route()创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。 下面这个示例程序使用app.route()定义了链式路由句柄。 app.route(&#39;/book&#39;) .get(function(req, res) { res.send(&#39;Get a random book&#39;); }) .post(function(req, res) { res.send(&#39;Add a book&#39;); }) .put(function(req, res) { res.send(&#39;Update the book&#39;); }); 6、express.Router可使用express.Router类创建模块化、可挂载的路由句柄。Router实例是一个完整的中间件和路由系统，因此常称其为一个’mini-app’。 下面的实例程序创建了一个路由模块，并加载 了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。 在app目录下创建名为bird.js的文件，内容如下： var express = require(&#39;express&#39;); var router = express.Router(); // 该路由使用的中间件 router.use(function timeLog(req, res, next) { console.log(&#39;Time: &#39;, Date.now()); next(); }); // 定义网站主页的路由 router.get(&#39;/&#39;, function(req, res) { res.send(&#39;Birds home page&#39;); }); // 定义 about 页面的路由 router.get(&#39;/about&#39;, function(req, res) { res.send(&#39;About birds&#39;); }); module.exports = router; 然后在应用中加载路由模块： var birds = require(&#39;./birds&#39;) ... app.use(&#39;/birds&#39;, birds) 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。 五、利用Express托管静态文件通过Express内置的express.static可以方便地托管静态文件，例如图片、CSS、JavaScript文件等。 将静态资源文件所在的目录作为参数传递给express.static中间件就可以提供静态资源文件的访问了。例如，假设在public目录放置了图片、CSS和JavaScript文件，你就可以： app.use(express.static(&#39;public&#39;)) 现在，public目录下面的文件就可以访问了。 http://localhost:3000/images/kitten.jpg http://localhost:3000/css/style.css http://localhost:3000/js/app.js http://localhost:3000/images/bg.png http://localhost:3000/hello.html 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在URL中。 如果你的静态资源存放在多个目录下面，你可以多次调用express.static中间件： app.use(express.static(&#39;public&#39;)) app.use(express.static(&#39;files&#39;)) 访问静态资源文件时，express.static中间件会根据目录添加的顺序查找所需的文件。 如果你希望所有通过express.static访问的文件都存放在一个”虚拟(virtual)“目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示： app.use(&#39;/static&#39;, express.static(&#39;public&#39;)) 现在，你就可以通过带有”/static“前缀的地址来访问public目录下面的文件了。 http://localhost:3000/static/images/kitten.jpg http://localhost:3000/static/css/style.css http://localhost:3000/static/js/app.js http://localhost:3000/static/images/bg.png http://localhost:3000/static/hello.html 六、使用中间件Express是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。 中间件（Middleware）是一个函数，它可以访问请求对象（request object(req)），响应对象(response object(res))，和web应用中处于请求-响应循环流程中的中间件，一般被命名为next的变量。 中间件的功能包括： 执行任何代码 修改请求和响应对象 终结请求-响应循环 调用堆栈中的下一个中间件 如果当前中间件没有终结请求-响应循环，则必须调用next()方法将控制权交给下一个中间件，否则请求就会挂起。 Express应用可使用如下几种中间件： 应用级中间件 路由级中间件 错误处理中间件 内置中间件 第三方中间件 使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。 1、应用级中间件应用级中间件绑定到app对象，使用app.use()和app.METHOD()，其中，METHOD是需要处理的HTTP请求的方法，例如GET,PUT,POST等等，全部小写。例如： var app = express() // 没有挂载路径的中间件，应用的每个请求都会执行该中间件 app.use(function (req, res, next) { console.log(&#39;Time:&#39;, Date.now()) next() }) // 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它 app.use(&#39;/user/:id&#39;, function(req, res, next) { console.log(&#39;Request Type:&#39;, req.method) next() }) // 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求 app.get(&#39;/user/:id&#39;, function(req, res, next) { res.send(&#39;USER&#39;) }) 下面这个例子展示了在一个挂载点装载一组中间件。 // 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息 app.use(&#39;/user/:id&#39;, function(req, res, next) { console.log(&#39;Request URL:&#39;, req.originalUrl) next() }, function(req, res, next) { console.log(&#39;Request Type:&#39;, req.method) next() }) 作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。 第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。 // 一个中间件栈，处理指向 /user/:id 的 GET请求 app.get(&#39;/user/:id&#39;, function(req, res, next) { console.log(&#39;ID:&#39;, req.params.id) next() }, function(req, res, next) { res.send(&#39;User Info&#39;) }) // 处理 /user/:id, 打印出用户id app.get(&#39;/user/:id&#39;, function(req, res, next) { res.end(req.params.id) }) 如果需要在中间件栈中跳过剩余中间件，调用 next(&#39;route&#39;)方法将控制权交给下一个路由。注意：next(&#39;route&#39;)只对使用 app.VERB() 或 router.VERB()加载的中间件有效。 // 一个中间件栈，处理指向 /user/:id 的 GET 请求 app.get(&#39;/user/:id&#39;, function(req, res, next) { // 如果 user id 为0，跳到下一个路由 if (req.params.id === 0) next(&#39;route&#39;) // 否则将控制权交给栈中下一个中间件 else next() }, function(req, res, next) { // 渲染常规页面 res.render(&#39;regular&#39;) }) // 处理 /user/:id, 渲染一个特殊页面 app.get(&#39;/user/:id&#39;, function(req, res, next) { res.render(&#39;special&#39;) }) 2、路由级中间件路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。 var router = express.Router() 路由级使用router.use()或router.VERB()加载。 上述在应用级创建的中间件系统，可通过如下代码改写为路由级。 var app = express() var router = express.Router() // 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件 router.use(function (req, res, next) { console.log(&#39;Time:&#39;, Date.now()) next() }) // 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息 router.use(&#39;/user/:id&#39;, function(req, res, next) { console.log(&#39;Request URL:&#39;, req.originalUrl) next() }, function (req, res, next) { console.log(&#39;Request Type:&#39;, req.method) next() }) // 一个中间件栈，处理指向 /user/:id 的 GET 请求 router.get(&#39;/user/:id&#39;, function (req, res, next) { // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next(&#39;route&#39;) // 负责将控制权交给栈中下一个中间件 else next() // }, function (req, res, next) { // 渲染常规页面 res.render(&#39;regular&#39;) }) // 处理 /user/:id， 渲染一个特殊页面 router.get(&#39;/user/:id&#39;, function (req, res, next) { console.log(req.params.id) res.render(&#39;special&#39;) }) // 将路由挂载至应用 app.use(&#39;/&#39;, router) 3、错误处理中间件 错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 错误处理中间件和其他中间件定义类似，只是要使用4个参数，而不是3个，其签名如下：(err,req,res,next)。 app.use(function(err, req, res, next) { console.error(err.stack) res.status(500).send(&#39;Something broke!&#39;) }) 4、内置中间件从4.x版本开始，Express已经不再依赖Connect了。除了express.static，Express以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。 express.static(root, [options]) express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在Express应用中提托管静态资源。 参数 root 指提供静态资源的根目录。 可选的 options 参数拥有如下属性。 属性 描述 类型 缺省值 dotfiles 是否对外输出文件名以点（.）开头的文件。可选值为”allow“，”deny“和”ignore“。 String ”ignore“ etag 是否启用etag生成 Boolean true extensions 设置文件扩展名备份选项 Array [] index 发送目录索引文件，设置为false禁用目录索引 Mixed “index.html” lastModified 设置Last-Modified头为文件在操作系统上的最后修改日期。可能值为true或false Boolean true maxAge 以毫秒或者其字符串格式设置Cache-Control头的max-age属性。 Number 0 redirect 当路径为目录时，重定向至”/“ Boolean true setHeaders 设置HTTP头以提供文件的函数 Function 下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。 var options = { dotfiles: &#39;ignore&#39;, etag: false, extensions: [&#39;htm&#39;, &#39;html&#39;], index: false, maxAge: &#39;1d&#39;, redirect: false, setHeaders: function (res, path, stat) { res.set(&#39;x-timestamp&#39;, Date.now()) } } app.use(express.static(&#39;public&#39;, options)) 每个应用可有多个静态目录。 app.use(express.static(&#39;public&#39;)) app.use(express.static(&#39;uploads&#39;)) app.use(express.static(&#39;files&#39;)) 5、第三方中间件通过使用第三方中间件从而为 Express 应用增加更多功能。 安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。 下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser $ npm install cookie-parser var express = require(&#39;express&#39;) var app = express() var cookieParser = require(&#39;cookie-parser&#39;) // 加载用于解析 cookie 的中间件 app.use(cookieParser()) 七、在Express中使用模板引擎需要在应用中进行如下设置才能让Express渲染模板文件： views，放模板文件的目录，比如：app.set(&#39;views&#39;, &#39;./views&#39;) view engine，模板引擎，比如：app.set(&#39;view engine&#39;, &#39;ejs&#39;) art-template art-template for express 4.x. 1、Install npm install --save art-template npm install --save express-art-template 2、Example var express = require(&#39;express&#39;) var app = express() // view engine setup app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)) app.set(&#39;view&#39;, { debug: process.env.NODE_ENV !== &#39;production&#39; }) app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)) app.set(&#39;view engine&#39;, &#39;art&#39;) // routes app.get(&#39;/&#39;, function (req, res) { res.render(&#39;index.art&#39;, { user: { name: &#39;aui&#39;, tags: [&#39;art&#39;, &#39;template&#39;, &#39;nodejs&#39;] } }) }) 03-Koa2一、koa2快速开始因为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以上node.js环境 版本v7.6以上 npm 版本3.x以上","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2021-08-12T10:44:10.293Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}