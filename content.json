{"meta":{"title":"DarkStrand","subtitle":null,"description":"everything will be ok","author":"DarkStrand","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-08-12T02:40:48.567Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-08-12T02:40:48.568Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-08-12T02:40:48.568Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-08-12T02:40:48.570Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-08-12T02:40:48.569Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-08-12T02:40:48.571Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-08-12T12:54:52.145Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-08-12T02:40:48.571Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-08-12T02:40:48.573Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-08-12T02:40:48.572Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-08-12T02:40:48.573Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-08-12T02:40:48.574Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"canvas","slug":"canvas","date":"2021-08-13T08:00:45.558Z","updated":"2021-08-13T08:08:32.209Z","comments":true,"path":"2021/08/13/canvas/","link":"","permalink":"/2021/08/13/canvas/","excerpt":"","text":"一、canvas简介canvas是HTML5新增的，一个可以使用脚本（通常为JavaScript）在其中绘制图像的HTML元素。它可以用来制作照片或者制作简单（也不是那么简单）的动画，甚至可以进行实时视频处理和渲染。 它最初由苹果内部使用自己MacOS X Webkit推出，供应用程序使用像仪表盘的构件和Safari浏览器使用。后来，有人通过Gecko内核的浏览器（尤其是Mozilla和Firefox），Opera和Chrome和超文本网络应用技术工作组建议为下一代的网络技术使用该元素。 Canvas是由HTML代码配合高度和宽度属性而定义出的可绘制区域。JavaScript代码可以访问该区域，类似于其他通用的二维API，通过一套完整的绘图函数来动态生成图形。 Mozilla程序从Geko1.8（Firefox1.5）开始支持canvas，Internet Explorer从IE9开始canvas。Chrome和Opera9+也支持canvas。 二、Canvas基本使用2.1canvas元素canvas看起来和&lt;img&gt;标签一样，只是canvas只有两个可选的属性width、height属性，而没有src、alt属性。 如果不给canvas设置width、height属性时，则默认width为300、height为150，单位都是px。也可以使用css属性来设置宽高，但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用css属性来设置canvas的宽高。 替换内容 由于某些较老的浏览器（尤其是IE9之前的IE浏览器）或者浏览器不支持HTML元素canvas，在这些浏览器上你应该总是能展示替代内容。 支持canvas的浏览器会只渲染canvas标签，而忽略其中的替代内容。不支持canvas的浏览器会直接渲染替代内容。 用文本替换： &lt;canvas&gt; 你的浏览器不支持canvas，请升级你的浏览器。 &lt;/canvas&gt; 用&lt;img&gt;替换： &lt;canvas&gt; &lt;img src=&quot;./美女.jgp&quot; alt=&quot;&quot;&gt; &lt;/canvas&gt; 结束标签不可省略 与&lt;img&gt;元素不同，canvas元素需要结束标签（）。如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。 ##2.2渲染上下文（Thre Rending Context） canvas会创建一个固定大小的画布，会公开一个或多个渲染上下文(画笔)，使用渲染上下文来绘制和处理要展示的内容。 我们重点研究2D渲染上下文。其他的上下文我们暂不研究，比如，WebGL使用了基于OpenGLES的3D上下文。 var canvas = document.getElementById(&#39;tutorial&#39;); //获得2d上下文对象 var ctx = canvas.getContext(&#39;2d&#39;) 2.3检测支持性var canvas = document.getElementById(&#39;tutorial&#39;); if(canvas.getContext) { var ctx = canvas.getContext(&#39;2d&#39;) // drawing code here } else { // canvas-unsupported code here } 2.4代码模板&lt;canvas id=&quot;tutorial&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; function draw() { var canvas = document.getElementById(&#39;tutorial&#39;); if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) //开始写代码 } &lt;/script&gt; 2.5一个简单的例子以下实例绘制两个长方形 &lt;canvas id=&quot;tutorial&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; function draw() { var canvas = document.getElementById(&#39;tutorial&#39;); if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.fillStyle = &quot;rgb(200,0,0)&quot; //绘制矩形 ctx.fillRect (10,10,55,50) ctx.fillStyle = &quot;rgb(0,0,200,0.5)&quot; ctx.fillRect (30,30,55,50) } draw() &lt;/script&gt; 三、绘制形状3.1栅格(grid)和坐标空间如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元 相当于canvas元素中的一像素。栅格的起点为左上角，坐标为(0,0)。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素，坐标为(x,y)。 后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。 3.2绘制矩形canvas只支持一种原生的图形绘制：矩形。所有其他图形都至少需要生成一种路径(path)。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。 canvas提供了三种方法绘制矩形： fillRect(x, y, width, height)：绘制一个填充的矩形。 strokeRect(x, y, width, height)：绘制一个矩形的边框。 clearRect(x, y, width, height)：清除指定的矩形区域，然后这块区域会变的完全透明。 说明：这3个方法具有相同的参数。 x,y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点) width,height：指的是绘制的矩形的宽和高。 function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.fillRect(10,10,100,50) //绘制矩形，填充的默认颜色为黑色 ctx.strokeRect(10, 70, 100 ,50) //绘制矩形边框 } draw() ctx.clearRect(15, 15, 50, 25) 四、绘制路径(path)图形的基本元素是路径。 路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。 一个路径，甚至一个子路径，都是闭合的。 使用路径绘制图形需要一些额外的步骤： 创建路径起始点 调用绘制方法去绘制出路径 把路径封闭 一旦路径生成，通过描边或填充路径区域来渲染图形 下面是需要用到的方法： beginPath() ​ 新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径 moveTo(x, y) 把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。 closePath() 闭合路径之后，图形绘制命令又重新指向到上下文中 stroke() 通过线条来绘制图形轮廓 fill() 通过填充路径的内容区域生成实心的图形 4.1绘制线段function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.beginPath() //新建一条path ctx.moveTo(50,50) // 把画笔移动到指定的坐标 ctx.lineTo(200,50) //绘制一条从当前位置到指定坐标(200,50)的直线 ctx.closePath() //闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做 ctx.stroke() //绘制路径 } draw() 4.2绘制三角形边框function draw() { var canvas = document.getElmentById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.beginPath() ctx.moveTo(50,50) ctx.lineTo(200,50) ctx.lineTo(200,200) ctx.closePath() //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个三角形 ctx.stroke() //描边。stroke不会自动closePath() } draw() 4.3填充三角形function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.beginPath() ctx.moveTo(50,50) ctx.lineTo(200,50) ctx.lineTo(200,200) ctx.fill() //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径 } 4.4绘制圆弧有两个方法可以绘制圆弧： arc(x, y, r, startAngle, endAngle, anticlockwise): 以(x,y) 为圆心，以r为半径，从startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针(默认是顺时针)。 这里的度数都是弧度。 0弧度是指的x轴正方向。 radians = (Math.PI/180)*degrees //角度转换成弧度 arcTo(x1,y1,x2,y2,radius): 根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。 //圆弧案例1 function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.beginPath() ctx.arc(50,50,40,0,Math.PI /2, false) ctx.stroke() } draw() //圆弧案例2 funcion draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.beginPath() ctx.arc(50,50,50,0,Math.PI/2,false) ctx.stroke() ctx.beginPath() ctx.arc(150,50,40,0,-Math.PI/2,true) ctx.closePath() ctx.stroke() ctx.beginPath() ctx.arc(50,150,40,-Math.PI/2,Math.PI/2,false) ctx.fill() ctx.beginPath() ctx.arc(150,150,40,0,Math.PI,false) ctx.fill() } draw() //圆弧案例3 function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.beginPath() ctx.moveTo(50,50) //参数1、2：控制点1坐标 //参数3、4：控制点2坐标 //参数5：圆弧半径 ctx.arcTo(200,50,200,200,100) ctx.lineTo(200,200) ctx.stroke() ctx.beginPath() ctx.rect(50,50,10,10) ctx.rect(200,50,10,10) ctx.rect(200,200,10,10) ctx.fill() } arcTo方法的说明： 这个方法可以这样理解。绘制的弧形是由两条切线所决定。 第1条切线：起始点和控制点1决定的直线。 第2条切线：控制点1和控制点2决定的直线。 其实绘制的圆弧就是与这两条直线相切的圆弧。 4.5绘制贝塞尔曲线4.5.1什么是贝塞尔曲线贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。 一般的矢量图形软件通过它来精确画出曲线，贝兹曲线是由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。 贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具入PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。 贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau 于 1959 年运用 de Casteljau 演算法开发，以稳定数值的方法求出贝兹曲线。 一次贝塞尔曲线其实是一条直线 二次贝塞尔曲线 三次贝塞尔曲线 4.5.2绘制贝塞尔曲线 绘制二次贝塞尔曲线：/kwɒ’drætɪk/ quadraticCurveTo(cp1x,cp1y,x,y) 说明： 参数1和2：控制点坐标 参数3和4：结束点坐标 function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.beginPath() ctx.moveTo(10,200) //起始点 var cp1x = 40, cp1y = 100 //控制点 var x = 200, y = 200 //结束点 //绘制二次贝塞尔曲线 ctx.quadraticCurveTo(cp1x, cp1y, x, y) ctx.stroke() ctx.beginPath() ctx.rect(10,200,10,10) ctx.rect(cp1x,cp1y,10,10) ctx.rect(x,y,10,10) ctx.fill() } draw() 绘制三次贝塞尔曲线: bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) 说明： 参数1和2：控制点1的坐标 参数3和4：控制点2的坐标 参数5和6：结束点的坐标 function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.beginPath() ctx.moveTo(40,200) //起始点 var cp1x = 20, cp1y = 100 //控制点1 var cp2x = 100, cp2y = 120 //控制点2 var x = 200, y = 200 //结束点 //绘制三次贝塞尔曲线 ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) ctx.stroke() ctx.beginPath(); ctx.rect(40, 200, 10, 10); ctx.rect(cp1x, cp1y, 10, 10); ctx.rect(cp2x, cp2y, 10, 10); ctx.rect(x, y, 10, 10); ctx.fill(); } draw() 五、添加样式和颜色在前面的绘制矩形章节中，只用到了默认的线条和颜色。 如果想要给图形上色，有两个重要的属性可以做到。 fillStyle = color 设置图形的填充颜色 strokeStyle = color 设置图形轮廓的颜色 备注： color可以是表达css颜色值的字符串、渐变对象或者图案对象 默认情况下，线条和填充颜色都是黑色 一旦您设置了strokeStyle或者fillStyle的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置fillStyle或strokeStyle的值 fillStylefunction draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) for(var i = 0; i &lt; 6; i++) { for(var j = 0; j &lt; 6; j++) { ctx.fillStyle = &#39;rgb(&#39; + Math.floor(255 - 42.5 * i) + &#39;,&#39; + Math.floor(255 - 42.5 * j) + &#39;,0)&#39; ctx.fillRect(j * 50, i * 50, 50, 50) } } } draw() strokeStylefunction draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) for(var i = 0; i &lt; 6; i++) { for(var j = 0;j &lt; 6;j++) { ctx.strokeStyle = `rgb(${randomInt(0,255)}, ${randomInt(0,255)}, ${randomInt(0,255)})` ctx.strokeRect(j*50,i*50,40,40) } } } draw() //返回随机的[from,to]之间的整数(包括from，也包括to) function randomInt(from,to) { return parseInt(Math.random() * (to-from +1) + from) } Transparency(透明度)globalAlpha = transparencyValue:这个属性影响到canvas里所有图形的透明度，有效的值范围是0.0（完全透明）到1.0（完全不透明），默认是1.0 globalAlpha属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更好一些。 1. line style 线宽。只能是正值。默认是1.0 起始点和终点的连线为中心，上下各占线宽的一半。 ctx.beginPath() ctx.moveTo(10,10) ctx.lineTo(100,10) ctx.lineWidth = 10 ctx.stroke() ctx.beginPath() ctx.moveTo(110,10) ctx.lineTo(160,10) ctx.lineWidth = 20 ctx.stroke() 2. lineCap = type 线条末端样式。 共有三个值： butt： 线段末端以方形结束 round：线段末端以圆形结束 square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一般的矩形区域 var lineCaps = [&#39;butt&#39;, &#39;round&#39;, &#39;square&#39;] for(var i = 0;i&lt;3;i++) { ctx.beginPath() ctx.moveTo(20+30*i,30) ctx.lineTo(20+30*i,100) ctx.lineWidth = 20 ctx.lineCap = lineCaps[i] ctx.stroke() } ctx.beginPath() ctx.moveTo(0,30) ctx.lineTo(300,30) ctx.moveTo(0,100) ctx.lineTo(300,100) ctx.strokeStyle = &#39;red&#39; ctx.lineWidth = 1 ctx.stroke() 3. lineJoin = type 同一个path内，设定线条与线条间接合处的样式。 共有三个值round,bevel和miter： round通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。圆角的半径是线段的宽度。 bevel在相连部分的末端填充一个额外的以三角形为底的区域，每个部分都有各自独立的矩形拐角。 miter(默认)通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。 function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) var lineJoin = [&#39;round&#39;,&#39;bevel&#39;, &#39;miter&#39;] ctx.lineWidth = 20 for(var i =0; i&lt; lineJoin.length;i++) { ctx.lineJoin = lineJoin[i] ctx.beginPath() ctx.moveTo(50,50+i*50) ctx.lineTo(100,100+i*50) ctx.lineTo(150,50+i*50) ctx.lineTo(200,100+i*50) ctx.lineTo(250,50+i*50) ctx.stroke() } } draw() 4. 虚线 用setLineDash方法和lineDashOffset属性来指定虚线样式。 setLineDash方法接收一个数组，来指定线段与间隙的交替； lineDashOffset属性设置起始偏移量。 function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.setLineDash([20,5]) //[实线长度，间隙长度] ctx.lineDashOffset = -0 ctx.strokeRect(50,50,210,210) } draw() 备注：getLineDash()返回一个包含当前虚线样式，长度为非偶数的数组。 六、绘制文本绘制文本的两个方法 canvas提供了两种方法来渲染文本： fillText(text, x, y, [, maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的。 strokeText(text, x, y, [, maxWidth])在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的。 var ctx; function draw() { var canvas = document.getELementById(&#39;tutorial&#39;) if(!canvas.getContext) return ctx = canvas.getContext(&#39;2d&#39;) ctx.font = &#39;100px sans-serif&#39; ctx.fillText(&#39;天若有情&#39;,10,100) ctx.strokeText(&#39;天若有情&#39;,10,200) } draw() 给文本添加样式 font = value 当前我们用来绘制文本的样式。这个字符串使用和css font属性相同的语法。默认的字体是10px sans-serif。 textAlign = value 文本对齐选项。可选的值包括：start，end，left，right，center。默认是start。 textBaseline = value 基线对齐选项，可选的值包括：top，hanging，middle，alphabetic，ideographic，bottom。默认值是alphabetic。 direction = value 文本方向。可能的值包括：ltr，rtl，inherit。默认值是inherit。 七、绘制图片我们也可以在canvas上直接绘制图片。 7.1由零开始创建图片var img = new Image() //创建一个&lt;img&gt;元素 img.src = &#39;myImage.png&#39; //设置图片原地址 绘制img //参数1：要绘制的img //参数2、3：绘制的img在canvas中的坐标 ctx.drawImage(img,0,0) 注意：考虑到图片是从网络加载，如果drawImage的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在img绘制完成之后再drawImage。 var img = new Image() //创建img元素 img.onload = function() { ctx.drawImage(img, 0, 0) } img.src = &#39;myImage.png&#39; //设置图片c地址 7.2 绘制img标签元素中的图片img可以new，也可以来源于我们页面中的标签。 &lt;img src=&quot;./美女.jpg&quot; alt=&quot;&quot; width=&quot;300&quot;&gt;&lt;br&gt; &lt;canvas id=&quot;tutorial&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt; function draw() { var canvas = document.getElementById(&#39;tutorial) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) var img = document.querySelector(&#39;img&#39;) ctx.drawImg(img,0,0) } document.querySelector(&#39;img&#39;).onclick = function() { draw() } 第一张图片就是页面中的 &lt;img&gt; 标签： 7.3 缩放图片drawImage()可以再添加两个参数： drawImage(image,x,y,width,height) 这个方法多了两个参数：width和height，这两个参数用来控制 当像canvas画入时应该缩放的大小。 ctx.drawImage(img,0,0,400,200) ##7.4 切片(slice) drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight) 第一个参数和其他的是相同的，都是一个图像或者另一个canvas的引用。 其他8个参数：前4个事定义图像源的切片位置和大小，后四个则是定义切片的目标显示位置和大小。 八、状态的保存和恢复Saving and restoring state是绘制复杂图形时必不可少的操作。 save()和restore() save和restore方法是用来保存和恢复canvas状态的，都没有参数。 Canvas的状态就是当前画面应用的所有样式和变形的一个快照。 8.1 关于save() Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。 一个绘画状态包括: 当前应用的变形（即移动，旋转和缩放） strokeStyle,fillStyle,globalAlpha,lineWidth,lineCap,lineJoin,miterLimit,shadowOffsetX,shadowOffsetY,shadowBlur,shadowColor,globalCompositeOperation的值 当前的裁切路径（clipping path) 可以调用任意多次save方法（类似数组的push()） 8.2关于resotre() 每一次调用restore方法，上一个保存的状态就从栈中弹出，所有设定都恢复（类似数组pop()） var ctx; function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.fillRect(0,0,150,150) //使用默认设置绘制一个矩形 ctx.save() //保存默认状态 ctx.fillStyle = &#39;red&#39; //在原有配置基础上对颜色做改变 ctx.fillRect(15,15,120,120) //使用心得设置绘制一个矩形 ctx.save() //保存当前状态 ctx.fillStyle = &#39;#FFF&#39; //再次改变颜色状态 ctx.fillRect(30,30,90,90) //使用心得配置绘制一个矩形 ctx.restore() //重新加载之前的颜色状态 ctx.fillRect(45,45,60,60) //使用上一次的配置绘制一个矩形 ctx.restore() //加载默认颜色配置 ctx.fillRect(60,60,30,30) //使用加载的配置绘制一个矩形 } draw() 九、变形9.1translatetranslate(x,y) 用来移动canvas的原点到指定的位置 translate方法接收两个参数。x是左右偏移量，y是上下偏移量，如图所示。 在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用restore方法比手动恢复原形的状态要简单得多。又如果你是在一个循环中做位移但没有保存和恢复canvas的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出canvas范围以外了。注意：translate移动的是canvas的坐标原点(坐标变换)。 var ctx; function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.save() //保存坐标原点平移之前的状态 ctx.translate(100,100) ctx.strokeRect(0,0,100,100) ctx.restore() ctx.translate(220,200) ctx.fillRect(0,0,100,100) } draw() 9.2 rotaterotate(angle) 旋转坐标轴。 这个方法只接受一个参数：旋转的角度（angle），它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。 function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvs.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.fillStyle = &#39;red&#39; ctx.save() ctx.translate(100,100) ctx.rotate(Math.PI/180*45) ctx.fillStyle = &#39;blue&#39; ctx.fillRect(0,0,100,100) ctx.restore() ctx.save() ctx.translate(0,0) ctx.fillRect(0,0,50,50) ctx.restore() } draw() 9.3 scalescale(x,y) 我们用它来增减图形在canvas中的像素数目，对形状、位图进行缩小或者放大。 scale方法接受两个参数。x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比1.0小表示缩小，比1.0大表示放大，值为1.0时什么效果都没有。 默认情况下，canvas的1单位就是1个像素。举例说，如果我们设置缩放因子是0.5，1个单位就变成对应0.5个像素，这样绘制出来的形状就会是原先的一半。同理，设置为2.0时，1个单位就对应变成了2像素，绘制的结果就是图形放大了2倍。 9.4 transform(变形矩阵)transform(a,b,c,d,e,f) a (m11): Horizontal scaling. b (m12): Horizontal skewing. c (m21): Vertical skewing. d (m22): Vertical scaling. e (dx): Horizontal moving. f (dy): Vertical moving. function draw() { var canvas = document.getElementById(&#39;tutorial&#39;) if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.transform(1,1,0,1,0,0) ctx.fillRect(0,0,100,100) } draw() 十、合成在前面的所有例子中，我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用globalCompositeOperation属性来改变这种情况。 globalCompositeOperation = type var ctx; function draw() { var canvas = document.getElementById(&#39;tutorial&#39;); if(!canvas.getContext) return var ctx = canvas.getContext(&#39;2d&#39;) ctx.fillStyle = &#39;blue&#39; ctx.fillRect(0,0,200,200) ctx.globalCompositeOperation = &#39;source-over&#39; //全局合成操作 ctx.fillStyle = &#39;red&#39; ctx.fillRect(100,100,200,200) } 注：下面的展示中，蓝色是原有的，红色是新的。 type是下面13中字符串值之一: 这是默认设置，新图像会覆盖在原有图像。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"新鲜玩意","slug":"amazing","date":"2021-08-13T00:36:56.751Z","updated":"2021-08-13T01:25:34.880Z","comments":true,"path":"2021/08/13/amazing/","link":"","permalink":"/2021/08/13/amazing/","excerpt":"","text":"页面浮动多边形跟随鼠标移动 //鼠标绘制多边形 !(function() { //封装方法，压缩之后减少文件大小 function get_attribute(node, attr, default_value) { return node.getAttribute(attr) || default_value } //封装方法，压缩之后减少文件大小 function get_by_tagname(name) { return document.getElementsByTagName(name) } //获取配置参数 function get_config_option() { var scripts = get_by_tagname(&quot;script&quot;), script_len = scripts.length, script = scripts[script_len - 1] //当前加载的script return { l: script_len, //长度，用于生成id用 z: get_attribute(script, &quot;zIndex&quot;, -1), //z-index o: get_attribute(script, &quot;opacity&quot;, 0.5), //opacity c: get_attribute(script, &quot;color&quot;, &quot;0,0,0&quot;), //color n: get_attribute(script, &quot;count&quot;, 99), //count } } //设置canvas的高宽 function set_canvas_size() { ;(canvas_width = the_canvas.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth), (canvas_height = the_canvas.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight) } //绘制过程 function draw_canvas() { context.clearRect(0, 0, canvas_width, canvas_height) //随机的线条和当前位置联合数组 var e, i, d, x_dist, y_dist, dist //临时节点 //遍历处理每一个点 random_points.forEach(function(r, idx) { ;(r.x += r.xa), (r.y += r.ya), //移动 (r.xa *= r.x &gt; canvas_width || r.x &lt; 0 ? -1 : 1), (r.ya *= r.y &gt; canvas_height || r.y &lt; 0 ? -1 : 1), //碰到边界，反向反弹 context.fillRect(r.x - 0.5, r.y - 0.5, 1, 1) //绘制一个宽高为1的点 //从下一个点开始 for (i = idx + 1; i &lt; all_array.length; i++) { e = all_array[i] // 当前点存在 if (null !== e.x &amp;&amp; null !== e.y) { x_dist = r.x - e.x //x轴距离 l y_dist = r.y - e.y //y轴距离 n dist = x_dist * x_dist + y_dist * y_dist //总距离, m dist &lt; e.max &amp;&amp; (e === current_point &amp;&amp; dist &gt;= e.max / 2 &amp;&amp; ((r.x -= 0.03 * x_dist), (r.y -= 0.03 * y_dist)), //靠近的时候加速 (d = (e.max - dist) / e.max), context.beginPath(), (context.lineWidth = d / 2), (context.strokeStyle = &quot;rgba(&quot; + config.c + &quot;,&quot; + (d + 0.2) + &quot;)&quot;), context.moveTo(r.x, r.y), context.lineTo(e.x, e.y), context.stroke()) } } }), frame_func(draw_canvas) } //创建画布，并添加到body中 var the_canvas = document.createElement(&quot;canvas&quot;), //画布 config = get_config_option(), //配置 canvas_id = &quot;c_n&quot; + config.l, //canvas id context = the_canvas.getContext(&quot;2d&quot;), canvas_width, canvas_height, frame_func = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(func) { window.setTimeout(func, 1000 / 45) }, random = Math.random, current_point = { x: null, //当前鼠标x y: null, //当前鼠标y max: 20000, // 圈半径的平方 }, all_array the_canvas.id = canvas_id the_canvas.style.cssText = &quot;position:fixed;top:0;left:0;z-index:&quot; + config.z + &quot;;opacity:&quot; + config.o get_by_tagname(&quot;body&quot;)[0].appendChild(the_canvas) //初始化画布大小 set_canvas_size() window.onresize = set_canvas_size //当时鼠标位置存储，离开的时候，释放当前位置信息 ;(window.onmousemove = function(e) { e = e || window.event current_point.x = e.clientX current_point.y = e.clientY }), (window.onmouseout = function() { current_point.x = null current_point.y = null }) //随机生成config.n条线位置信息 for (var random_points = [], i = 0; config.n &gt; i; i++) { var x = random() * canvas_width, //随机位置 y = random() * canvas_height, xa = 2 * random() - 1, //随机运动方向 ya = 2 * random() - 1 // 随机点 random_points.push({ x: x, y: y, xa: xa, ya: ya, max: 6000, //沾附距离 }) } all_array = random_points.concat([current_point]) //0.1秒后绘制 setTimeout(function() { draw_canvas() }, 100) })() 每日一言功能 &lt;body&gt; &lt;strong&gt;&lt;p id=&quot;hitokoto&quot;&gt;每日一言获取中...&lt;/p&gt;&lt;/strong&gt; &lt;script&gt; //每日一言 $(function() { var xhr = new XMLHttpRequest() xhr.open(&quot;get&quot;, &quot;https://v1.hitokoto.cn&quot;) xhr.onreadystatechange = function() { if (xhr.readyState === 4) { var data = JSON.parse(xhr.responseText) var hitokoto = document.getElementById(&quot;hitokoto&quot;) hitokoto.innerText = data.hitokoto } } xhr.send() }) &lt;/script&gt; &lt;/body&gt; 鼠标点击出现爱心特效 //鼠标点击爱心 !(function(e, t, a) { function r() { for (var e = 0; e &lt; s.length; e++) s[e].alpha &lt;= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, (s[e].scale += 0.004), (s[e].alpha -= 0.013), (s[e].el.style.cssText = &quot;left:&quot; + s[e].x + &quot;px;top:&quot; + s[e].y + &quot;px;opacity:&quot; + s[e].alpha + &quot;;transform:scale(&quot; + s[e].scale + &quot;,&quot; + s[e].scale + &quot;) rotate(45deg);background:&quot; + s[e].color + &quot;;z-index:99999&quot;)) requestAnimationFrame(r) } function n() { var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick e.onclick = function(e) { t &amp;&amp; t(), o(e) } } function o(e) { var a = t.createElement(&quot;div&quot;) ;(a.className = &quot;heart&quot;), s.push({ el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: c(), }), t.body.appendChild(a) } function i(e) { var a = t.createElement(&quot;style&quot;) a.type = &quot;text/css&quot; try { a.appendChild(t.createTextNode(e)) } catch (t) { a.styleSheet.cssText = e } t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) } function c() { return ( &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; ) } var s = [] ;(e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) { setTimeout(e, 1e3 / 60) }), i( &quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot; ), n(), r() })(window, document) &lt;script&gt; //定义获取词语下标 var a_idx = 0; jQuery(document).ready(function($) { //点击body时触发事件 $(&quot;body&quot;).click(function(e) { //需要显示的词语 var a = new Array(&quot;富强&quot;,&quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;,&quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;,&quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;,&quot;诚信&quot;, &quot;友善&quot;); //设置词语给span标签 var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); //下标等于原来下标+1 余 词语总数 a_idx = (a_idx + 1)% a.length; //获取鼠标指针的位置，分别相对于文档的左和右边缘。 //获取x和y的指针坐标 var x = e.pageX, y = e.pageY; //在鼠标的指针的位置给$i定义的span标签添加css样式 $i.css({&quot;z-index&quot; : 999999, &quot;top&quot; : y - 20, &quot;left&quot; : x, &quot;position&quot; : &quot;absolute&quot;, &quot;font-weight&quot; : &quot;bold&quot;, &quot;color&quot; : &quot;#ff6651&quot; }); //在body添加这个标签 $(&quot;body&quot;).append($i); //animate() 方法执行 CSS 属性集的自定义动画。 //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。 //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp $i.animate({ //将原来的位置向上移动180 &quot;top&quot; : y - 180, &quot;opacity&quot; : 0 //1500动画的速度 }, 1500, function() { //时间到了自动删除 $i.remove(); }); }); }); &lt;/script&gt; macOS Dock 效果 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html { font-size: 15px; } body { margin: 0; padding: 0; display: flex; width: 100%; min-height: 100vh; overflow: hidden; align-items: flex-end; background-image: linear-gradient( 109.6deg, rgba(25, 170, 209, 1) 11.3%, rgba(21, 65, 249, 1) 69.9% ); } .glass { width: 100%; height: 8rem; background: rgba(255, 255, 255, 0.25); box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); border: 1px solid rgba(255, 255, 255, 0.18); display: flex; justify-content: center; } .dock { --scale: 1; list-style: none; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; } .dock li { font-size: calc(6rem * var(--scale)); padding: 0 0.5rem; cursor: default; position: relative; top: calc((6rem * var(--scale) - 6rem) / 2 * -1); transition: 15ms all ease-out; } .dock li.loading { animation: 1s loading ease-in infinite; } @keyframes loading { 0%, 100% { transform: translateY(0px); } 60% { transform: translateY(-40px); } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;glass&quot;&gt; &lt;ul class=&quot;dock&quot;&gt; &lt;li&gt;😃&lt;/li&gt; &lt;li&gt;😊&lt;/li&gt; &lt;li&gt;😜&lt;/li&gt; &lt;li&gt;😍&lt;/li&gt; &lt;li&gt;🤩&lt;/li&gt; &lt;li&gt;🥳&lt;/li&gt; &lt;li&gt;🥶&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; document.querySelectorAll(&quot;.dock li&quot;).forEach((li) =&gt; { li.addEventListener(&quot;click&quot;, (e) =&gt; { e.currentTarget.classList.add(&quot;loading&quot;) }) li.addEventListener(&quot;mousemove&quot;, (e) =&gt; { let item = e.target let itemRect = item.getBoundingClientRect() let offset = Math.abs(e.clientX - itemRect.left) / itemRect.width let prev = item.previousElementSibling || null let next = item.nextElementSibling || null let scale = 0.6 resetScale() if (prev) { prev.style.setProperty(&quot;--scale&quot;, 1 + scale * Math.abs(offset - 1)) } item.style.setProperty(&quot;--scale&quot;, 1 + scale) if (next) { next.style.setProperty(&quot;--scale&quot;, 1 + scale * offset) } }) }) document.querySelector(&quot;.dock&quot;).addEventListener(&quot;mouseleave&quot;, (e) =&gt; { resetScale() }) function resetScale() { document.querySelectorAll(&quot;.dock li&quot;).forEach((li) =&gt; { li.style.setProperty(&quot;--scale&quot;, 1) }) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; canvas 实现水印var watermark = {} function setWatermark(args) { //声明一个怪异一点的变量，确保id的唯一性 var id = &quot;111.222.333.456&quot; var xIndex = 15 //绘制文本的 x 坐标位置 var yIndex = 65 //绘制文本的 y 坐标位置 var xInterval = 25 //有多个参数时的行间间隔 if (document.getElementById(id) !== null) { document.body.removeChild(document.getElementById(id)) } //利用canvas绘制水印信息 var can = document.createElement(&quot;canvas&quot;) can.width = 250 can.height = 150 var cans = can.getContext(&quot;2d&quot;) cans.rotate((-20 * Math.PI) / 180) cans.font = &quot;17px Vedana&quot; // ziti yanse cans.fillStyle = &quot;rgba(200, 200, 200, 0.30)&quot; cans.textAlign = &quot;left&quot; cans.textBaseline = &quot;Middle&quot; for (let i = 0; i &lt; args.length; i++) { cans.fillText(args[i], xIndex, yIndex) //绘制水印文案 yIndex += xInterval //设置每行间隔 } //创建div用于显示 var div = document.createElement(&quot;div&quot;) div.id = id div.style.pointerEvents = &quot;none&quot; div.style.top = &quot;70px&quot; div.style.left = &quot;90px&quot; div.style.position = &quot;fixed&quot; div.style.zIndex = &quot;100000&quot; div.style.width = document.documentElement.clientWidth - 50 + &quot;px&quot; div.style.height = document.documentElement.clientHeight - 50 + &quot;px&quot; //div承载水印显示 div.style.background = &quot;url(&quot; + can.toDataURL(&quot;image/png&quot;) + &quot;) left top repeat&quot; document.body.appendChild(div) return id } watermark.set = function() { let args = Array.prototype.slice.apply(arguments) let id = setWatermark(args) // 检测如果水印被去掉了，自动给加上 setInterval(function() { if (document.getElementById(id) === null) { id = setWatermark(args) } }, 500) //在窗口大小改变之后,自动触发加水印事件 window.onresize = function() { setWatermark(args) } } window.watermark = watermark watermark.set(&quot;绝密档案&quot;, &quot;严禁外泄&quot;) canvas实现验证码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;120&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt; &lt;a href=&quot;#&quot; id=&quot;changeImg&quot;&gt;看不清，换一张&lt;/a&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt; &lt;script&gt; // 随机数 function randomNum(min, max) { return Math.floor(Math.random() * (max - min) + min); } /**生成一个随机色**/ function randomColor(min, max) { var r = randomNum(min, max); var g = randomNum(min, max); var b = randomNum(min, max); return &quot;rgb(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;)&quot;; } drawPic(); document.getElementById(&quot;changeImg&quot;).onclick = function (e) { e.preventDefault(); drawPic(); } var Vcode = &#39;&#39; /**绘制验证码图片**/ function drawPic() { var canvas = document.getElementById(&quot;canvas&quot;); var width = canvas.width; var height = canvas.height; var ctx = canvas.getContext(&#39;2d&#39;); ctx.textBaseline = &#39;bottom&#39;; /**绘制背景色**/ ctx.fillStyle = randomColor(180, 240); //颜色若太深可能导致看不清 ctx.fillRect(0, 0, width, height); /**绘制文字**/ var str = &#39;ABCEFGHJKLMNPQRSTWXY123456789&#39;; vCode = &#39;&#39; for (var i = 0; i &lt; 4; i++) { var txt = str[randomNum(0, str.length)]; // 每次随机生成的数 vCode += txt ctx.fillStyle = randomColor(50, 160); //随机生成字体颜色 ctx.font = randomNum(15, 40) + &#39;px SimHei&#39;; //随机生成字体大小 var x = 10 + i * 25; var y = randomNum(25, 45); var deg = randomNum(-45, 45); //修改坐标原点和旋转角度 ctx.translate(x, y); ctx.rotate(deg * Math.PI / 180); ctx.fillText(txt, 0, 0); //恢复坐标原点和旋转角度 ctx.rotate(-deg * Math.PI / 180); ctx.translate(-x, -y); } /* *绘制干扰线* */ for (var i = 0; i &lt; 4; i++) { ctx.strokeStyle = randomColor(40, 180); ctx.beginPath(); ctx.moveTo(randomNum(0, width), randomNum(0, height)); ctx.lineTo(randomNum(0, width), randomNum(0, height)); ctx.stroke(); } /**绘制干扰点**/ for (var i = 0; i &lt; 20; i++) { ctx.fillStyle = randomColor(0, 255); ctx.beginPath(); ctx.arc(randomNum(0, width), randomNum(0, height), 1, 0, 2 * Math.PI); ctx.fill(); } console.log(&quot;随机生成的验证码是:::&quot;, vCode); } let text = document.getElementById(&#39;text&#39;) text.onblur = function(e) { console.log(text.value,&#39;value&#39;) if(text.value == vCode) { } else { alert(&#39;请输入正确的验证码&#39;) } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 纯css实现霓虹灯效果&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .light { position: relative; padding: 25px 30px; color: #03e9f4; font-size: 24px; text-transform: uppercase; transition: 0.5s; letter-spacing: 4px; cursor: pointer; overflow: hidden; width: 200px; height: 100px; } .light:hover { background-color: #03e9f4; color: #050801; box-shadow: 0 0 5px #03e9f4, 0 0 25px #03e9f4, 0 0 50px #03e9f4, 0 0 200px #03e9f4; } .light div { position: absolute; } .light div:nth-child(1){ width: 100%; height: 2px; top: 0; left: -100%; background: linear-gradient(to right,transparent,#03e9f4); animation: animate1 2s linear infinite; } .light div:nth-child(2){ width: 2px; height: 100%; top: -100%; right: 0; background: linear-gradient(to bottom,transparent,#03e9f4); animation: animate2 2s linear infinite; animation-delay: 0.5s; } .light div:nth-child(3){ width: 100%; height: 2px; bottom: 0; right: -100%; background: linear-gradient(to left,transparent,#03e9f4); animation: animate3 2s linear infinite; animation-delay: 1s; } .light div:nth-child(4){ width: 2px; height: 100%; bottom: -100%; left: 0; background: linear-gradient(to top,transparent,#03e9f4); animation: animate4 2s linear infinite; animation-delay: 1.5s; } @keyframes animate1 { 0% { left: -100%; } 50%,100% { left: 100%; } } @keyframes animate2 { 0% { top: -100%; } 50%,100% { top: 100%; } } @keyframes animate3 { 0% { right: -100%; } 50%,100% { right: 100%; } } @keyframes animate4 { 0% { bottom: -100%; } 50%,100% { bottom: 100%; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;light&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; Neon Button &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; canvas实现刮刮乐&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;./男1.jpg&quot; width=&quot;400&quot; id=&quot;img&quot; alt=&quot;&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;txt&quot; /&gt; &lt;!-- &lt;canvas&gt;&lt;/canvas&gt; --&gt; &lt;script&gt; const oImg = document.getElementById(&quot;img&quot;) const txt = document.getElementById(&quot;txt&quot;) //oImg.readyState 图片加载状态 if (oImg.readyState === &quot;complete&quot;) { draw() //true表示已经加载完成 执行draw()方法 } else { //图片加载完成执行draw方法 oImg.onload = draw } function draw() { //等图片加载完成后再添加canvas画布在上面 let can = document.createElement(&quot;canvas&quot;) //创建一个canvas画布 can.width = oImg.width //等于图片的宽高 can.height = oImg.height can.style.position = &quot;absolute&quot; //canvas画布设置浮动会漂浮在图片上 can.style.left = oImg.offsetLeft + &quot;px&quot; //保存与画布位置一致 can.style.top = oImg.offsetTop + &quot;px&quot; //找到图片的父级：parentNode 在oImg子元素前面添加canvas标签：insertBefore oImg.parentNode.insertBefore(can, oImg) //在img前面去插入canvas标签 let ctx = can.getContext(&quot;2d&quot;) ctx.fillStyle = &quot;#bbb&quot; //刮刮乐的颜色 ctx.fillRect(0, 0, oImg.width, oImg.height) //填充宽度 //合成:处理合成图片的透明样式； //拖拽的时候，canvas图层显示透明；destination-out：新图形与原图形重叠部分透明 ctx.globalCompositeOperation = &quot;destination-out&quot; ctx.strokeStyle = &quot;#eee&quot; //触笔的颜色 随便 因为它终究变成透明 ctx.lineWidth = 30 //拖动时开始画线的线宽 ctx.lineCap = &quot;round&quot; //这两步是把画笔变成圆形 //按下，移动，抬起事件 can.onmousedown = function (e) { e = e || window.event //兼容低版本IE浏览器 //e.pageX距离文档右边缘； offsetLeft：canvas画布距离文档的右边距离 let x = e.pageX - can.offsetLeft //得到的x是在canvas上的坐标值 let y = e.pageY - can.offsetTop ctx.beginPath() // ctx.moveTo( x,y )//从哪里开始来画 ctx.arc(x, y, 15, 0, 6.3, false) //点第一下是画一个圆 ctx.fill() //按下后拖拽 can.onmousemove = function (e) { //拖动时一直执行下面 e = e || window.event //兼容低版本IE浏览器 ctx.beginPath() //拖动时开始画线 ctx.moveTo(x, y) //起始点 ctx.lineTo(e.pageX - can.offsetLeft, e.pageY - can.offsetTop) //移动的过程 //每次移动的时候，样式所在的坐标； x = e.pageX - can.offsetLeft //第二次渲染刮图片效果的起始点应该在上一次的终止点 y = e.pageY - can.offsetTop ctx.stroke() //弹出图形并恢复画布 } document.onmouseup = function () { //抬起后将事件注销 can.onmousemove = null this.onmouseup = null check() //完成后通过像素计算刮过的的百分比 } } function check() { //获取画布的像素列表 let data = ctx.getImageData(0, 0, can.width, can.height).data let n = 0 //计算透明像素的个数 for (let i = 0; i &lt; data.length; i += 4) { //感觉这一步比较消耗性能 //RGBA if ( data[i] == 0 &amp;&amp; data[i + 1] == 0 &amp;&amp; data[i + 2] == 0 &amp;&amp; data[i + 3] == 0 ) { n++ } } let f = (n * 100) / (can.width * can.height) //算出所刮的面积的占比； txt.value = `刮开面积:${f.toFixed(2)}%` //刮开面积的比例 if (f &gt; 30) { //如果所刮的面积大于30% 则将canvas画布整体清除fillRect ctx.beginPath() ctx.fillRect(0, 0, can.width, can.height) txt.value = &quot;刮开面积大于30%，全部显示&quot; } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; swiper轮播图组件 拖拽、回弹物料效果是参照开源项目swiper.js做的`javascript/** 轮播组件 @param {object} params 配置传参 @param {string} params.el 组件节点 class|id| @param {number} params.moveTime 过渡时间（毫秒）默认 300 @param {number} params.interval 自动播放间隔（毫秒）默认 3000 @param {boolean} params.loop 是否需要回路 @param {boolean} params.vertical 是否垂直滚动 @param {boolean} params.autoPaly 是否需要自动播放 @param {boolean} params.pagination 是否需要底部圆点 @param {(index: number) =&gt; void} params.slideCallback 滑动/切换结束回调 @author https://github.com/Hansen-hjs @description 移动端swiper组件，如果需要兼容pc自行修改对应的touch到mouse事件即可。现成效果预览：https://huangjingsheng.gitee.io/hjs/cv/demo/face/*/function swiper(params) { /** css class 命名列表 @dec [“滑动列表”,”滑动item”,”圆点容器”,”底部圆点”,”圆点高亮”]/const classNames = [“.swiper_list”, “.swiper_item”, “.swiper_pagination”, “.swiper_dot”, “.swiper_dot_active”];/** 滑动结束函数 /const slideEnd = params.slideCallback || function() {};/** 组件节点 @type {HTMLElement}*/let node = null;/** item列表容器 @type {HTMLElement}*/let nodeItem = null;/** item节点列表 @type {Array}*/let nodeItems = [];/** 圆点容器 @type {HTMLElement}*/let nodePagination = null;/** 圆点节点列表 @type {Array}/let nodePaginationItems = [];/** 是否需要底部圆点 /let pagination = false;/ 是否需要回路 */let isLoop = false;/ 方向 X =&gt; true | Y =&gt; false /let direction = false;/** 是否需要自动播放 /let autoPaly = false;/ 自动播放间隔（毫秒）默认 3000 */let interval = 3000;/ 过渡时间（毫秒）默认 300 */let moveTime = 300; /** 设置动画 */ function startAnimation() { nodeItem.style.transition = `${moveTime / 1000}s all`; } /** 关闭动画 */ function stopAnimation() { nodeItem.style.transition = &quot;0s all&quot;; } /** * 属性样式滑动 * @param {number} n 移动的距离 */ function slideStyle(n) { let x = 0, y = 0; if (direction) { y = n; } else { x = n; } nodeItem.style.transform = `translate3d(${x}px, ${y}px, 0px)`; } /** * 事件开始 * @param {number} width 滚动容器的宽度 * @param {number} height 滚动容器的高度 */ function main(width, height) { /** * 动画帧 * @type {requestAnimationFrame} */ const animation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; /** 触摸开始时间 */ let startTime = 0; /** 触摸结束时间 */ let endTime = 0; /** 开始的距离 */ let startDistance = 0; /** 结束的距离 */ let endDistance = 0; /** 结束距离状态 */ let endState = 0; /** 移动的距离 */ let moveDistance = 0; /** 圆点位置 &amp;&amp; 当前 item 索引 */ let index = 0; /** 动画帧计数 */ let count = 0; /** loop 帧计数 */ let loopCount = 0; /** 移动范围 */ let range = direction ? height : width; /** 获取拖动距离 */ function getDragDistance() { /** 拖动距离 */ let dragDistance = 0; // 默认这个公式 dragDistance = moveDistance + (endDistance - startDistance); // 判断最大正负值 if ((endDistance - startDistance) &gt;= range) { dragDistance = moveDistance + range; } else if ((endDistance - startDistance) &lt;= -range) { dragDistance = moveDistance - range; } // 没有 loop 的时候惯性拖拽 if (!isLoop) { if ((endDistance - startDistance) &gt; 0 &amp;&amp; index === 0) { // console.log(&quot;到达最初&quot;); dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6)); } else if ((endDistance - startDistance) &lt; 0 &amp;&amp; index === nodeItems.length - 1) { // console.log(&quot;到达最后&quot;); dragDistance = moveDistance + ((endDistance - startDistance) - ((endDistance - startDistance) * 0.6)); } } return dragDistance; } /** * 判断触摸处理函数 * @param {number} slideDistance 滑动的距离 */ function judgeTouch(slideDistance) { // 这里我设置了200毫秒的有效拖拽间隔 if ((endTime - startTime) &lt; 200) return true; // 这里判断方向（正值和负值） if (slideDistance &lt; 0) { if ((endDistance - startDistance) &lt; (slideDistance / 2)) return true; return false; } else { if ((endDistance - startDistance) &gt; (slideDistance / 2)) return true; return false; } } /** 返回原来位置 */ function backLocation() { startAnimation(); slideStyle(moveDistance); } /** * 滑动 * @param {number} slideDistance 滑动的距离 */ function slideMove(slideDistance) { startAnimation(); slideStyle(slideDistance); loopCount = 0; // 判断 loop 时回到第一张或最后一张 if (isLoop &amp;&amp; index &lt; 0) { // 我这里是想让滑块过渡完之后再重置位置所以加的延迟 (之前用setTimeout，快速滑动有问题，然后换成 requestAnimationFrame解决了这类问题) function loopMoveMin() { loopCount += 1; if (loopCount &lt; moveTime / 1000 * 60) return animation(loopMoveMin); stopAnimation(); slideStyle(range * -(nodeItems.length - 3)); // 重置一下位置 moveDistance = range * -(nodeItems.length - 3); } loopMoveMin(); index = nodeItems.length - 3; } else if (isLoop &amp;&amp; index &gt; nodeItems.length - 3) { function loopMoveMax() { loopCount += 1; if (loopCount &lt; moveTime / 1000 * 60) return animation(loopMoveMax); stopAnimation(); slideStyle(0); moveDistance = 0; } loopMoveMax(); index = 0; } // console.log(`第${ index+1 }张`); // 这里可以做滑动结束回调 if (pagination) { nodePagination.querySelector(classNames[4]).className = classNames[3].slice(1); nodePaginationItems[index].classList.add(classNames[4].slice(1)); } } /** 判断移动 */ function judgeMove() { // 判断是否需要执行过渡 if (endDistance &lt; startDistance) { // 往上滑动 or 向左滑动 if (judgeTouch(-range)) { // 判断有loop的时候不需要执行下面的事件 if (!isLoop &amp;&amp; moveDistance === (-(nodeItems.length - 1) * range)) return backLocation(); index += 1; slideMove(moveDistance - range); moveDistance -= range; slideEnd(index); } else { backLocation(); } } else { // 往下滑动 or 向右滑动 if (judgeTouch(range)) { if (!isLoop &amp;&amp; moveDistance === 0) return backLocation(); index -= 1; slideMove(moveDistance + range); moveDistance += range; slideEnd(index) } else { backLocation(); } } } /** 自动播放移动 */ function autoMove() { // 这里判断 loop 的自动播放 if (isLoop) { index += 1; slideMove(moveDistance - range); moveDistance -= range; } else { if (index &gt;= nodeItems.length - 1) { index = 0; slideMove(0); moveDistance = 0; } else { index += 1; slideMove(moveDistance - range); moveDistance -= range; } } slideEnd(index); } /** 开始自动播放 */ function startAuto() { count += 1; if (count &lt; interval / 1000 * 60) return animation(startAuto); count = 0; autoMove(); startAuto(); } // 判断是否需要开启自动播放 if (autoPaly &amp;&amp; nodeItems.length &gt; 1) startAuto(); // 开始触摸 nodeItem.addEventListener(&quot;touchstart&quot;, ev =&gt; { startTime = Date.now(); count = 0; loopCount = moveTime / 1000 * 60; stopAnimation(); startDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX; }); // 触摸移动 nodeItem.addEventListener(&quot;touchmove&quot;, ev =&gt; { ev.preventDefault(); count = 0; endDistance = direction ? ev.touches[0].clientY : ev.touches[0].clientX; slideStyle(getDragDistance()); }); // 触摸离开 nodeItem.addEventListener(&quot;touchend&quot;, () =&gt; { endTime = Date.now(); // 判断是否点击 if (endState !== endDistance) { judgeMove(); } else { backLocation(); } // 更新位置 endState = endDistance; // 重新打开自动播 count = 0; }); } /** * 输出回路：如果要回路的话前后增加元素 * @param {number} width 滚动容器的宽度 * @param {number} height 滚动容器的高度 */ function outputLoop(width, height) { const first = nodeItems[0].cloneNode(true), last = nodeItems[nodeItems.length - 1].cloneNode(true); nodeItem.insertBefore(last, nodeItems[0]); nodeItem.appendChild(first); nodeItems.unshift(last); nodeItems.push(first); if (direction) { nodeItem.style.top = `${-height}px`; } else { nodeItem.style.left = `${-width}px`; } } /** * 输出动态布局 * @param {number} width 滚动容器的宽度 * @param {number} height 滚动容器的高度 */ function outputLayout(width, height) { if (direction) { for (let i = 0; i &lt; nodeItems.length; i++) { nodeItems[i].style.height = `${height}px`; } } else { nodeItem.style.width = `${width * nodeItems.length}px`; for (let i = 0; i &lt; nodeItems.length; i++) { nodeItems[i].style.width = `${width}px`; } } } /** 输出底部圆点 */ function outputPagination() { let paginations = &quot;&quot;; nodePagination = node.querySelector(classNames[2]); // 如果没有找到对应节点则创建一个 if (!nodePagination) { nodePagination = document.createElement(&quot;div&quot;); nodePagination.className = classNames[2].slice(1); node.appendChild(nodePagination); } for (let i = 0; i &lt; nodeItems.length; i++) { paginations += `&lt;div class=&quot;${classNames[3].slice(1)}&quot;&gt;&lt;/div&gt;`; } nodePagination.innerHTML = paginations; nodePaginationItems = [...nodePagination.querySelectorAll(classNames[3])]; nodePagination.querySelector(classNames[3]).classList.add(classNames[4].slice(1)); } /** 初始化动态布局 */ function initLayout() { node = document.querySelector(params.el); if (!node) return console.warn(&quot;没有可执行的节点！&quot;); nodeItem = node.querySelector(classNames[0]); if (!nodeItem) return console.warn(`缺少&quot;${classNames[0]}&quot;节点！`); nodeItems = [...node.querySelectorAll(classNames[1])]; if (nodeItems.length == 0) return console.warn(&quot;滑动节点个数必须大于0！&quot;); const moveWidth = node.offsetWidth, moveHeight = node.offsetHeight; if (pagination) outputPagination(); if (isLoop) outputLoop(moveWidth, moveHeight); outputLayout(moveWidth, moveHeight); main(moveWidth, moveHeight); } /** 初始化参数 */ function initParams() { if (typeof params !== &quot;object&quot;) return console.warn(&quot;传参有误&quot;); pagination = params.pagination || false; direction = params.vertical || false; autoPaly = params.autoPaly || false; isLoop = params.loop || false; moveTime = params.moveTime || 300; interval = params.interval || 3000; initLayout(); } initParams(); } ## 图片懒加载 &gt;非传统实现方式，性能最优 ```javascript /** * 懒加载 * @description 可加载`&lt;img&gt;`、`&lt;video&gt;`、`&lt;audio&gt;`等一些引用资源路径的标签 * @param {object} params 传参对象 * @param {string?} params.lazyAttr 自定义加载的属性（可选） * @param {&quot;src&quot;|&quot;background&quot;} params.loadType 加载的类型（默认为`src`） * @param {string?} params.errorPath 加载失败时显示的资源路径，仅在`loadType`设置为`src`中可用（可选） */ function lazyLoad(params) { const attr = params.lazyAttr || &quot;lazy&quot;; const type = params.loadType || &quot;src&quot;; /** 更新整个文档的懒加载节点 */ function update() { const els = document.querySelectorAll(`[${attr}]`); for (let i = 0; i &lt; els.length; i++) { const el = els[i]; observer.observe(el); } } /** * 加载图片 * @param {HTMLImageElement} el 图片节点 */ function loadImage(el) { const cache = el.src; // 缓存当前`src`加载失败时候用 el.src = el.getAttribute(attr); el.onerror = function () { el.src = params.errorPath || cache; } } /** * 加载单个节点 * @param {HTMLElement} el */ function loadElement(el) { switch (type) { case &quot;src&quot;: loadImage(el); break; case &quot;background&quot;: el.style.backgroundImage = `url(${el.getAttribute(attr)})`; break; } el.removeAttribute(attr); observer.unobserve(el); } /** * 监听器 * [MDN说明](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver) */ const observer = new IntersectionObserver(function(entries) { for (let i = 0; i &lt; entries.length; i++) { const item = entries[i]; if (item.isIntersecting) { loadElement(item.target); } } }) update(); return { observer, update } } 在vue中使用指令去使用 import Vue from &quot;vue&quot;; /** 添加一个加载`src`的指令 */ const lazySrc = lazyLoad({ lazyAttr: &quot;vlazy&quot;, errorPath: &quot;./img/error.jpg&quot; }) Vue.directive(&quot;v-lazy&quot;, { inserted(el, binding) { el.setAttribute(&quot;vlazy&quot;, binding.value); // 跟上面的对应 lazySrc.observer.observe(el); } }) /** 添加一个加载`background`的指令 */ const lazyBg = lazyLoad({ lazyAttr: &quot;vlazybg&quot;, loadType: &quot;background&quot; }) Vue.directive(&quot;v-lazybg&quot;, { inserted(el, binding) { el.setAttribute(&quot;vlazybg&quot;, binding.value); // 跟上面的对应 lazyBg.observer.observe(el); } }) 上传图片&lt;!-- 先准备好一个input标签，然后设置type=&quot;file&quot;，最后挂载一个onchange事件 --&gt; &lt;input class=&quot;upload-input&quot; type=&quot;file&quot; name=&quot;picture&quot; onchange=&quot;upLoadImage(this)&quot;&gt; /** * input上传图片 * @param {HTMLInputElement} el */ function upLoadImage(el) { /** 上传文件 */ const file = el.files[0]; /** 上传类型数组 */ const types = [&quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;, &quot;image/gif&quot;]; // 判断文件类型 if (types.indexOf(file.type) &lt; 0) { file.value = null; // 这里一定要清空当前错误的内容 return alert(&quot;文件格式只支持：jpg 和 png&quot;); } // 判断大小 if (file.size &gt; 2 * 1024 * 1024) { file.value = null; return alert(&quot;上传的文件不能大于2M&quot;); } const formData = new FormData(); // 这个是传给后台的数据 formData.append(&quot;img&quot;, file); // 这里`img`是跟后台约定好的`key`字段 console.log(formData, file); // 最后POST给后台，这里我用上面的方法 ajax({ url: &quot;http://xxx.com/uploadImg&quot;, method: &quot;POST&quot;, data: {}, formData: formData, overtime: 5000, success(res) { console.log(&quot;上传成功&quot;, res); }, fail(err) { console.log(&quot;上传失败&quot;, err); }, timeout() { console.warn(&quot;XMLHttpRequest 请求超时 !!!&quot;); } }); } base64转换和静态预览 下拉刷新组件 拖拽效果参考上面swiper的实现方式，下拉中的效果是可以自己定义的`javascript// 这里我做的不是用 window 的滚动事件，而是用最外层的绑定触摸下拉事件去实现// 好处是我用在Vue这类单页应用的时候，组件销毁时不用去解绑 window 的 scroll 事件// 但是滑动到底部事件就必须要用 window 的 scroll 事件，这点需要注意 /** 下拉刷新组件 @param {object} option 配置 @param {HTMLElement} option.el 下拉元素（必选） @param {number} option.distance 下拉距离[px]（可选） @param {number} option.deviation 顶部往下偏移量[px]（可选） @param {string} option.loadIcon 下拉中的 icon html（可选）/function dropDownRefresh(option) { const doc = document; /** 整体节点 / const page = option.el; / 下拉距离 */ const distance = option.distance || 88; / 顶部往下偏移量 / const deviation = option.deviation || 0; /** 顶层节点 / const topNode = doc.createElement(“div”); /* 下拉时遮罩 / const maskNode = doc.createElement(“div”); topNode.innerHTML = &lt;div refresh-icon style=&quot;transition: .2s all;&quot;&gt;&lt;svg style=&quot;transform: rotate(90deg); display: block;&quot; t=&quot;1570593064555&quot; viewBox=&quot;0 0 1575 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;26089&quot; width=&quot;48&quot; height=&quot;48&quot;&gt;&lt;path d=&quot;M1013.76 0v339.968H484.115692V679.778462h529.644308v339.968l529.644308-485.612308v-48.600616L1013.76 0zM243.396923 679.857231h144.462769V339.968H243.396923V679.778462z m-240.797538 0h144.462769V339.968H2.599385V679.778462z&quot; fill=&quot;#000000&quot; fill-opacity=&quot;.203&quot; p-id=&quot;26090&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/div&gt;&lt;div refresh-loading style=&quot;display: none; animation: refresh-loading 1s linear infinite;&quot;&gt;${option.loadIcon || &#39;&lt;p style=&quot;font-size: 15px; color: #666;&quot;&gt;loading...&lt;/p&gt;&#39;}&lt;/div&gt;; topNode.style.cssText = width: 100%; height: ${distance}px; position: fixed; top: ${-distance + deviation}px; left: 0; z-index: 10; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; box-sizing: border-box; margin: 0; padding: 0;; maskNode.style.cssText = “position: fixed; top: 0; left: 0; width: 100%; height: 100vh; box-sizing: border-box; margin: 0; padding: 0; background-color: rgba(0,0,0,0); z-index: 999;”; page.parentNode.insertBefore(topNode, page); /** 设置动画时间 @param {number} n 秒数*/function setAnimation(n) { page.style.transition = topNode.style.transition = n + “s all”;} /** 设置滑动距离 @param {number} n 滑动的距离（像素）*/function setSlide(n) { page.style.transform = topNode.style.transform = translate3d(0px, ${n}px, 0px);} / 下拉提示 icon */const icon = topNode.querySelector(“[refresh-icon]”);/ 下拉 loading 动画 */const loading = topNode.querySelector(“[refresh-loading]”); return { /** 监听开始刷新 @param {Function} callback 下拉结束回调 @param {(n: number) =&gt; void} rangeCallback 下拉状态回调/onRefresh(callback, rangeCallback = null) { /** 顶部距离 / let scrollTop = 0; / 开始距离 */ let startDistance = 0; / 结束距离 / let endDistance = 0; /** 最后移动的距离 / let range = 0; // 触摸开始 page.addEventListener(“touchstart”, function (e) { startDistance = e.touches[0].pageY; scrollTop = 1; setAnimation(0); }); // 触摸移动 page.addEventListener(“touchmove”, function (e) { scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop; // 没到达顶部就停止 if (scrollTop != 0) return; endDistance = e.touches[0].pageY; range = Math.floor(endDistance - startDistance); // 判断如果是下滑才执行 if (range &gt; 0) { // 阻止浏览自带的下拉效果 e.preventDefault(); // 物理回弹公式计算距离 range = range - (range * 0.5); // 下拉时icon旋转 if (range &gt; distance) { icon.style.transform = &quot;rotate(180deg)&quot;; } else { icon.style.transform = &quot;rotate(0deg)&quot;; } setSlide(range); // 回调距离函数 如果有需要 if (typeof rangeCallback === &quot;function&quot;) rangeCallback(range); } }); // 触摸结束 page.addEventListener(“touchend”, function () { setAnimation(0.3); // console.log(`移动的距离：${range}, 最大距离：${distance}`); if (range &gt; distance &amp;&amp; range &gt; 1 &amp;&amp; scrollTop === 0) { setSlide(distance); doc.body.appendChild(maskNode); // 阻止往上滑动 maskNode.ontouchmove = e =&gt; e.preventDefault(); // 回调成功下拉到最大距离并松开函数 if (typeof callback === &quot;function&quot;) callback(); icon.style.display = &quot;none&quot;; loading.style.display = &quot;block&quot;; } else { setSlide(0); } }); },/* 结束下拉 /end() { maskNode.parentNode.removeChild(maskNode); setAnimation(0.3); setSlide(0); icon.style.display = “block”; loading.style.display = “none”;}}} ## 监听滚动到底部 ```javascript /** * 监听滚动到底部 * @param {object} options 传参对象 * @param {number} options.distance 距离底部多少像素触发（px） * @param {boolean} options.once 是否为一次性（防止重复用） * @param {() =&gt; void} options.callback 到达底部回调函数 */ function onScrollToBottom(options) { const { distance = 0, once = false, callback = null } = options; const doc = document; /** 滚动事件 */ function onScroll() { /** 滚动的高度 */ let scrollTop = doc.documentElement.scrollTop === 0 ? doc.body.scrollTop : doc.documentElement.scrollTop; /** 滚动条高度 */ let scrollHeight = doc.documentElement.scrollTop === 0 ? doc.body.scrollHeight : doc.documentElement.scrollHeight; if (scrollHeight - scrollTop - distance &lt;= window.innerHeight) { if (typeof callback === &quot;function&quot;) callback(); if (once) window.removeEventListener(&quot;scroll&quot;, onScroll); } } window.addEventListener(&quot;scroll&quot;, onScroll); // 必要时先执行一次 // onScroll(); } 音频播放组件/** * `AudioContext`音频组件 * [资料参考](https://www.cnblogs.com/Wayou/p/html5_audio_api_visualizer.html) * @description 解决在移动端网页上标签播放音频延迟的方案 貌似`H5`游戏引擎也是使用这个实现 */ function audioComponent() { /** * 音频上下文 * @type {AudioContext} */ const context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext)(); /** * @type {AnalyserNode} */ const analyser = context.createAnalyser();; /** * @type {AudioBufferSourceNode} */ let bufferNode = null; /** * @type {AudioBuffer} */ let buffer = null; /** 是否加载完成 */ let loaded = false; analyser.fftSize = 256; return { /** * 加载路径音频文件 * @param {string} url 音频路径 * @param {(res: AnalyserNode) =&gt; void} callback 加载完成回调 */ loadPath(url, callback) { const XHR = new XMLHttpRequest(); XHR.open(&quot;GET&quot;, url, true); XHR.responseType = &quot;arraybuffer&quot;; // 先加载音频文件 XHR.onload = () =&gt; { context.decodeAudioData(XHR.response, audioBuffer =&gt; { // 最后缓存音频资源 buffer = audioBuffer; loaded = true; typeof callback === &quot;function&quot; &amp;&amp; callback(analyser); }); } XHR.send(null); }, /** * 加载 input 音频文件 * @param {File} file 音频文件 * @param {(res: AnalyserNode) =&gt; void} callback 加载完成回调 */ loadFile(file, callback) { const FR = new FileReader(); // 先加载音频文件 FR.onload = e =&gt; { const res = e.target.result; // 然后解码 context.decodeAudioData(res, audioBuffer =&gt; { // 最后缓存音频资源 buffer = audioBuffer; loaded = true; typeof callback === &quot;function&quot; &amp;&amp; callback(analyser); }); } FR.readAsArrayBuffer(file); }, /** 播放音频 */ play() { if (!loaded) return console.warn(&quot;音频未加载完成 !!!&quot;); // 这里有个问题，就是创建的音频对象不能缓存下来然后多次执行 start , 所以每次都要创建然后 start() bufferNode = context.createBufferSource(); bufferNode.connect(analyser); analyser.connect(context.destination); bufferNode.buffer = buffer; bufferNode.start(0); }, /** 停止播放 */ stop() { if (!bufferNode) return console.warn(&quot;音频未播放 !!!&quot;); bufferNode.stop(); } } } 全局监听图片错误并替换到默认图片window.addEventListener(&quot;error&quot;, e =&gt; { /** 默认`base64`图片 */ const defaultImg = &#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJoAAACACAYAAADzsnDqAAANXElEQVR4Xu2dDYxcVRXHz3mz0FgjICBSgkZAQD5CwQ+Qz4BBBUEkUJpK0FAUYmms2O47d7oSmYbYnXfeLIXl01ojBAnSokRQQIWAIvEjkfBhUZGPEkMFDajgbjdu5x1zYVpmd2d25r1335uZzrkJIenec869//ubO/Pux3kIWlSBHBTAHGJoCFUAFDSFIBcFFLRcZNYgCpoykIsCClouMmsQBU0ZyEUBBS0XmTWIgqYM5KKAgpaLzBpEQVMGclFAQctFZg2ioCkDuSigoOUiswbJHLTR0dE5W7ZsWQAAB6rcnVMAETcj4vO+7z/QiVZkCtrIyMhB1Wr12wBwcic6pzFnKiAiq4wxpby1yRS0IAhuR8RFeXdK47VUYCERbWhZy2GFzEBbs2bNvMnJyc0O26qu3CnwJBHNd+eutafMQBseHj65UCg81LoJWqMTChBRZmPfqD+ZBVPQOoFP+zEVtPa10popFFDQUoinpu0r0E+gPVytVle1L43WjKNAoVC4YrZlpb4CjYhOiSOe1m1fAWa2D2JN1y8VtPa11JqzKKCgvS3OwzqjZfdZUdAUtOzoqvOsoCloCppLBdpYsNWvTpeCT/OlM5rOaBni9bZrBU1BU9BcKqBfnS7VjO9LZzSd0eJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQVPQ4lOTwEJBU9ASYBPfREFT0OJTk8BCQVPQEmAT30RBU9DiU5PAQkFT0BJgE99EQesgaMy8NxG9HH/Yes9CQesQaOVy+f2e560koiW9h038FitoHQKNmb8LABeJSNEYE8Qfut6yUNA6ABozfwoAfmZDi8gEIl5IRHf0FjrxWqugdQC0MAwfFZHj6obqT4i42Pf938Ubvt6praDlDFoQBMsQ8ZrpiCDifWNjYwtKpdJ47+DTfksVtBxBC8NwLxH5MwC8u8kQ3UhEl7Y/fL1TU0HLF7TrRaQVSIaIuHcQaq+lClpOoJXL5ZM8z/tlG8MyHkXR4mKxuL6Nuj1TRUHLCTRmfhAAPtEmGU9v3br13KGhIfs1u0MUBS0H0Jj5EgCwSZrjlHuJ6Iw4Bt1cV0HLGLTR0dFdtmzZ8gwivjcuCCJygzFmaVy7bqyvoGUMWhiGIyKyPMXg+0RUSWHfFabMfJ6IHIaIhwKA/e+w+oZp2qoUwxQEwdGImHYRdgwAziGin6doSteZhmF4eBRFi2rp+A9Q0FIMETP/FAA+k8LFNtONY2Njx61atep1B766zgUzn0tEP8yzYZ3Myu00yQszfxEAbnEo3k+I6LMO/fW1qx0CtFKptPPcuXOfBYD3uRxNRLzO9/2vuvTZr752CNCY+VsAMJTRIF5MROsy8h3b7erVq/fwPG8fz/PmAcA+iDhPRP4LAPZA58sDAwN/nzNnzstLly61/9Y1pedBC8PwCBF5IitF7SB6nnes7/t/zCrGbH5rs7X9Cj8TAOz/92izHRtF5E7P8+7rhlMqPQ8aM98FAGe3KX7Sak8R0RFJjZPYMfNpAHABAJwOALsn8VFnsxEAHkDEdZ36wPQ0aOVyeaHneXkdYLyHiM5KOeAtzZn5wwDwNQCwDzeui126ucYem/J9/x+unc/mr6dBY2b7AHBAXoKJyJXGmG9mES8Ign0R0QK2DAB2ziJGnc8XLHBENOOcXlZxexY0ZrYD3ok3r5xBRPe6HJBKpXJSFEVrAeBgl37b8PXAwMDAkuXLl9sPbKalJ0FbvXr1QQMDA3/JVJkmzhHx9UKhsN/y5ctfcxE/DMOFIpLX13+jJr8aRdEXisXifS7608xHT4IWBMEdiLgwS2Fa+HbyYlVmvgoAvt7BftSHXkZE12bVlp4DLQiCsxDxx1kJ0q5fRLzF9/0L260/vR4z311brkjqwrkdIn7e9/0fOHcMAD0HGjM/DQCHZCFGXJ8issQYc1NcuyAIRhAxzQmTuCHbrl8oFI5csWKF83XJngKNmQkAuu3y71FE9Hi7I8nMdhb8Xrv1O1DvbwBwtOvUET0DWi2lwYsdEL5VyP8Q0W6tKtm/l8vl+Z7n2eNHe7VTv0Udg4j3FwqFvyLibpOTk/sDQAgAxzrw7XzNsGdAY+ZbayvlDnR07uIhImp5P4GZ7ekSFwuxixrdtC+VSnPnzp17m6OdkstcrrP1BGj1KQ2cI+LIISIO+77fdGO/tqWUegkBEa/2fb/pkyozHwkA9qWwbc2ys3T/BUT8uKsdhJ4ALQiCxxFxviMmMnMjIp8zxtinyRmFmS1kdv8yVfE875DBwcFZb2sxs/0NmPiJuK6Bq4noG6kaXDPuetDCMLxMRNa46GzWPkTkVGOMveY3pTg8lPkcEX2wVT+Y+csA8J1W9dr4+1htVkt9cqWrQbMpDQBgs4gU2hCl01VeJ6Jdm8xmvwWAYxw0cBMR7dfKj+Mn22uJyO6/pipdDdq2nGapepif8c1EtHh6OHspRESectUMEdnFGPPGbP7CMFwrIhe7iCkizxpjDkzrq2tBi5HSIK0GTuyb/T5jZnsi42onQd7K79bw67nefxiGj4uIs9+01Wr1lJUrVz6cpg9dCxoz/x4APpamcznaVolooMnXpn0CPNlVW0RkyBgz3Mzf6OjonImJiQlX8Wp+RohoMI3PrgQtCIJLEfH6NB3L01ZEfmGMsVklp5Ra2qxXHLflLiI6p5nPSqVyQhRFj7iMKSLPGGNSHWHqOtBsSoOJiQl70eIdLsXK0peI3GaMsceupxRmtuf873Ec+yUi2reZzzAMl4vIiOOY9iu75W/D2WJ2HWjMfCMAfMW1UFn6E5GrjDErGoCWJNlMy6Yi4v6+79tTsjNKEAS3126jt/QTp0KhUDh4xYoVz8Sxqa/bVaCFYXiMiNilgJ4qzTJ9h2F4hYiUXHdGRM4zxtzZyG9Wp1vSPhB0G2iPiMgJrgcma38icpExZsaJDGa2qbPsrOa0NNvuqlQqe0ZR9E+nwd52dj4R3Z7Ud9eA5nA1O6kWie2iKDqzWCzavB9TShiGd4tIFmkVHiSiUxt8Vdu8IzPakbhjdYYiMmiMSfzbrytAq12Stde/Gq6suxAqYx8NL6wws30QsA8Erssb4+Pju5dKpa31jpn5cgC40nUw62+HAC0IAnvXMPU2RxYCt+lzMRHd3GCGsfuNdt/ReRGRY4wxdq1xewmCYAMiLnAe7C3QLjDG2CNIiUrHZ7SRkZGjqtXqY4la3yVGIkLGGHvocEphZju72Fkmi3IpEdkn9O2Fme1TYertokaNbWdHYrZOdhy0MAwfFJGWhwazGClXPhEx9H3fHjOfUjJeeF5HRNv3M8Mw3E9EnnfVp+l+PM87bHBw0N7XSFQ6Clrt7LzLnGaJRHBg1HBDPQiCcxAxq4R3jxHRR7a1vVKpnB1Fkc1DkkkZGBjYI81d1k6DZvOqvicTZfJ12jCjd6VSOTSKIptgJZNSv7YVBEEJEa/IJBDAq0S0ZxrfnQbN2WZzGhHS2orIK8aYvRv5YWZ7aHBKouK08ers38yaOTIyclC1WrW33e0x7ixKwxk7TqBOghannV1fN4qiE4vF4q+nNzTjmcaG2wQANtV9lnvDC9LmvFXQ3CFcISJ/ujtmPhEAfuUuTO6eXhsfH59XKpX+lyaygpZGvam2Tc/zM7O9TJLqmI27Zsb2dBsRzTiZEteLghZXsVnqR1F0WrFYfPNNx/UlCAJ72bfsMFSerj7t4p0LCprbIbuJiJZMd7l+/frCpk2bHnV0QWWbe3u0+nIReRIR7SWeczNIF9GwP0kkU9CSqNbERkTGd9ppp/mNEtsFQbAAETc4CreRiA6f7mt4ePgDhUKh4Tm1uHHtkzQiHk9Ez8W1bVRfQXOhYp2P2dKPMrPdKzw/bUhEPM73/d808sPMNqWXi1y7Tt+JpaClHfWZ9i+Oj48fWSqV/j39T66SvMz2HidHyyk7VJIX90PcPR6bZk90cbnXpofwff/JJjOafZPyeSmk2OHSVqXQortNEfGJycnJTw4NDTU87eogEd8GIpqRWjUMw3eKyGYA2CWpQr2YiG//QqHg5IdkUtE6bDfrtk3a1KIissoYs/0+QrlcPh0RRxGxZW6OZrr0ZGpR2xlmtlsyx3d4wDsWXkSWGmNuaNaAIAjWIeKXUjTwXwDwvIjsmgYwG7/ZBZsUbZtimtnDgI1SS2z8fQB4l6sG95ifLQBwAhE1PdjJzPbV2td1sl+IeInv+y6yDzXtRqag1WD7aO1T+6FOitnJ2PaExWzxXTwgJOzfSyKyzBjzo4T2bZtlDlrbLenzivZWu51ZMro11UjdtTbtRLOnV9fDoaC5VjSlvxyAW+t53trBwcE/pGxqLHMFLZZc+VWu5e1Y5PI1ip7n3Zo3YNsUU9DyYydRpDQvhq3trd6/Q78YNpGqatRSAX3VdUuJtEI/K6Bfnf08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0MpaP08+jn2XUHLUex+DqWg9fPo59h3BS1Hsfs5lILWz6OfY98VtBzF7udQClo/j36OfVfQchS7n0P9H/gjHdvP/Qy/AAAAAElFTkSuQmCC&#39;; /** * @type {HTMLImageElement} */ const node = e.target; if (node.nodeName &amp;&amp; node.nodeName.toLocaleLowerCase() === &quot;img&quot;) { node.style.objectFit = &quot;cover&quot;; node.src = defaultImg; } }, true); 复制功能翻 Clipboard.js 这个插件库源码的时候找到核心代码 setSelectionRange(start: number, end: number)，百度上搜到的复制功能全部都少了这个操作，所以搜到的复制文本代码在 ios 和 IE 等一些浏览器上复制不了。 /** * 复制文本 * @param {string} text 复制的内容 * @param {() =&gt; void} success 成功回调 * @param {(tip: string) =&gt; void} fail 出错回调 */ function copyText(text, success = null, fail = null) { text = text.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;); if (!text) { typeof fail === &quot;function&quot; &amp;&amp; fail(&quot;复制的内容不能为空！&quot;); return; } const id = &quot;the-clipboard&quot;; /** * 粘贴板节点 * @type {HTMLTextAreaElement} */ let clipboard = document.getElementById(id); if (!clipboard) { clipboard = document.createElement(&quot;textarea&quot;); clipboard.id = id; clipboard.readOnly = true clipboard.style.cssText = &quot;font-size: 15px; position: fixed; top: -1000%; left: -1000%;&quot;; document.body.appendChild(clipboard); } clipboard.value = text; clipboard.select(); clipboard.setSelectionRange(0, text.length); const state = document.execCommand(&quot;copy&quot;); if (state) { typeof success === &quot;function&quot; &amp;&amp; success(); } else { typeof fail === &quot;function&quot; &amp;&amp; fail(&quot;复制失败&quot;); } } 检测类型/** * 检测类型 * @param {any} target 检测的目标 * @returns {&quot;string&quot;|&quot;number&quot;|&quot;array&quot;|&quot;object&quot;|&quot;function&quot;|&quot;null&quot;|&quot;undefined&quot;} 只枚举一些常用的类型 */ function checkType(target) { /** @type {string} */ const value = Object.prototype.toString.call(target); const result = value.match(/\\[object (\\S*)\\]/)[1]; return result.toLocaleLowerCase(); } 格式化日期（代码极少版）/** * 获取指定日期时间戳 * @param {number} time 毫秒数 */ function getDateFormat(time = Date.now()) { const date = new Date(time); return `${date.toLocaleDateString()} ${date.toTimeString().slice(0, 8)}`; } js小数精度计算/** * 数字运算（主要用于小数点精度问题） * @param {number} a 前面的值 * @param {&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;} type 计算方式 * @param {number} b 后面的值 * @example * ```js * // 可链式调用 * const res = computeNumber(1.3, &quot;-&quot;, 1.2).next(&quot;+&quot;, 1.5).next(&quot;*&quot;, 2.3).next(&quot;/&quot;, 0.2).result; * console.log(res); * */function computeNumber(a, type, b) { /** * 获取数字小数点的长度 * @param {number} n 数字 */ function getDecimalLength(n) { const decimal = n.toString().split(&quot;.&quot;)[1]; return decimal ? decimal.length : 0; } /** * 修正小数点 * @description 防止出现 `33.33333*100000 = 3333332.9999999995` &amp;&amp; `33.33*10 = 333.29999999999995` 这类情况做的处理 * @param {number} n */ const amend = (n, precision = 15) =&gt; parseFloat(Number(n).toPrecision(precision)); const power = Math.pow(10, Math.max(getDecimalLength(a), getDecimalLength(b))); let result = 0; a = amend(a * power); b = amend(b * power); switch (type) { case &quot;+&quot;: result = (a + b) / power; break; case &quot;-&quot;: result = (a - b) / power; break; case &quot;*&quot;: result = (a * b) / (power * power); break; case &quot;/&quot;: result = a / b; break; } result = amend(result); return { /** 计算结果 */ result, /** * 继续计算 * @param {&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;} nextType 继续计算方式 * @param {number} nextValue 继续计算的值 */ next(nextType, nextValue) { return computeNumber(result, nextType, nextValue); } }; } ## 一行css适配rem 750是设计稿的宽度：之后的单位直接1:1使用设计稿的大小，单位是rem ```javascript html{ font-size: calc(100vw / 750); } 好用的格式化日期方法/** * 格式化日期 * @param {string | number | Date} value 指定日期 * @param {string} format 格式化的规则 * @example * ```js * formatDate(); * formatDate(1603264465956); * formatDate(1603264465956, &quot;h:m:s&quot;); * formatDate(1603264465956, &quot;Y年M月D日&quot;); * */function formatDate(value = Date.now(), format = “Y-M-D h:m:s”) { const formatNumber = n =&gt; 0${n}.slice(-2); const date = new Date(value); const formatList = [“Y”, “M”, “D”, “h”, “m”, “s”]; const resultList = []; resultList.push(date.getFullYear().toString()); resultList.push(formatNumber(date.getMonth() + 1)); resultList.push(formatNumber(date.getDate())); resultList.push(formatNumber(date.getHours())); resultList.push(formatNumber(date.getMinutes())); resultList.push(formatNumber(date.getSeconds())); for (let i = 0; i &lt; resultList.length; i++) { format = format.replace(formatList[i], resultList[i]); } return format;} ## 网页定位 这里使用百度定位，无论代码封装、调用方式还是位置准确性都比微信sdk那个好用太多了，包括在任何网页端； [文档说明](http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey) [获取百度地图key](http://lbsyun.baidu.com/apiconsole/key#/home) ```javascript /** * 插入脚本 * @param {string} link 脚本路径 * @param {Function} callback 脚本加载完成回调 */ function insertScript(link, callback) { const label = document.createElement(&quot;script&quot;); label.src = link; label.onload = function () { if (label.parentNode) label.parentNode.removeChild(label); if (typeof callback === &quot;function&quot;) callback(); } document.body.appendChild(label); } /** * 获取定位信息 * @returns {Promise&lt;{ city: string, districtName: string, province: string, longitude: number, latitude: number }&gt;} */ function getLocationInfo() { /** * 使用百度定位 * @param {(value: any) =&gt; void} callback */ function useBaiduLocation(callback) { const geolocation = new BMap.Geolocation({ maximumAge: 10 }) geolocation.getCurrentPosition(function(res) { console.log(&quot;%c 使用百度定位 &gt;&gt;&quot;, &quot;background-color: #4e6ef2; padding: 2px 6px; color: #fff; border-radius: 2px&quot;, res); callback({ city: res.address.city, districtName: res.address.district, province: res.address.province, longitude: Number(res.longitude), latitude: Number(res.latitude) }) }) } return new Promise(function (resolve, reject) { if (!window._baiduLocation) { window._baiduLocation = function () { useBaiduLocation(resolve); } // ak=你自己的key insertScript(&quot;https://api.map.baidu.com/api?v=2.0&amp;ak=66vCKv7PtNlOprFEe9kneTHEHl8DY1mR&amp;callback=_baiduLocation&quot;); } else { useBaiduLocation(resolve); } }) } 输入保留数字&lt;input type=&quot;text&quot;&gt;使用场景：用户在输入框输入内容时，实时过滤保持数字值显示； tips：在Firefox中设置 &lt;input type=&quot;number&quot;&gt; 会有样式 bug /** * 输入只能是数字 * @param {string | number} value 输入的值 * @param {boolean} decimal 是否要保留小数 * @param {boolean} negative 是否可以为负数 */ function inputOnlyNumber(value, decimal, negative) { let result = value.toString().trim(); if (result.length === 0) return &quot;&quot;; const minus = (negative &amp;&amp; result[0] == &quot;-&quot;) ? &quot;-&quot; : &quot;&quot;; if (decimal) { result = result.replace(/[^0-9.]+/ig, &quot;&quot;); let array = result.split(&quot;.&quot;); if (array.length &gt; 1) { result = array[0] + &quot;.&quot; + array[1]; } } else { result = result.replace(/[^0-9]+/ig, &quot;&quot;); } return minus + result; } Intl.NumberFormat（格式化数字） 现在JS提供了一个更加可用和规范化的API——Intl.NumberFormat。对于常用的货币格式化都有良好的支持。 推荐使用 new Intl.NumberFormat().format(123456.789); // 显示结果为：123,456.789 new Intl.NumberFormat(&#39;ja-JP&#39;, { style: &#39;currency&#39;, currency: &#39;JPY&#39; }).format(12345.678); // 结果显示为：&quot;￥12,346&quot; 正则表达式 （古早的做法） const number = 1234567; number.toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, &#39;$1,&#39;); // 结果为：1,234,567 Date API const number = 123456.789; number.toLocaleString();// 结果为：123,456.789 加密base64加密var str = &#39;hello&#39;; var str64 = window.btoa(str); console.log(&#39;经base64编码后：&#39;+ str64); // 经base64编码后：aGVsbG8= console.log(&#39;经base64解码后：&#39; + window.atob(str64)); // 经base64解码后：hello 编码和解码字符串使用JS函数的escape()和unescape()，分别是编码和解码字符串 var escape1 = escape(&#39;我的名字是：Neo&#39;); // 编码 var unescape1 = unescape(escape1); // 解码 console.log(escape1) // %u6211%u7684%u540D%u5B57%u662F%uFF1ANeo console.log(unescape1) // &quot;我的名字是：Neo&quot; lucky-canvas【大转盘/九宫格】抽奖lucky-canvas【大转盘/九宫格】抽奖 FineBI大屏FineBI大屏 大屏数据展示模板大屏数据展示模板 js拖动滑块验证功能&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;滑块解锁封装js方法&lt;/title&gt; &lt;!--注：这里首次用到了iconfont的语法，即矢量图标--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;font/iconfont.css&quot; /&gt; &lt;style&gt; * { padding: 0; margin: 0; } #box { position: relative; width: 300px; height: 40px; margin: 0 auto; margin-top: 10px; background-color: #e8e8e8; box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2); } .bgColor { position: absolute; left: 0; top: 0; width: 40px; height: 40px; background-color: lightblue; } .txt { position: absolute; width: 100%; height: 40px; line-height: 40px; font-size: 14px; color: #000; text-align: center; } .slider { position: absolute; left: 0; top: 0; width: 50px; height: 38px; border: 1px solid #ccc; background: #fff; text-align: center; cursor: move; } .slider &gt; i { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } .slider.active &gt; i { color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot; onselectstart=&quot;return false;&quot;&gt; &lt;div class=&quot;bgColor&quot;&gt;&lt;/div&gt; &lt;div class=&quot;txt&quot;&gt;滑动解锁&lt;/div&gt; &lt;!--给i标签添加上相应字体图标的类名即可--&gt; &lt;div class=&quot;slider&quot;&gt;&lt;i class=&quot;iconfont icon-double-right&quot;&gt;&lt;/i&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; //一、定义了一个获取元素的方法 function getEle(selector) { return document.querySelector(selector) } //二、获取到需要用到的DOM元素 var box = getEle(&quot;#box&quot;), //容器 bgColor = getEle(&quot;.bgColor&quot;), //背景色 txt = getEle(&quot;.txt&quot;), //文本 slider = getEle(&quot;.slider&quot;), //滑块 icon = getEle(&quot;.slider&gt;i&quot;), successMoveDistance = box.offsetWidth - slider.offsetWidth, //解锁需要滑动的距离 downX, //用于存放鼠标按下时的位置 isSuccess = false //是否解锁成功的标志，默认不成功 //三、给滑块添加鼠标按下事件 slider.onmousedown = mousedownHandler //3.1鼠标按下事件的方法实现 function mousedownHandler(e) { bgColor.style.transition = &quot;&quot; slider.style.transition = &quot;&quot; var e = e || window.event || e.which downX = e.clientX //在鼠标按下时，分别给鼠标添加移动和松开事件 document.onmousemove = mousemoveHandler document.onmouseup = mouseupHandler } //四、定义一个获取鼠标当前需要移动多少距离的方法 function getOffsetX(offset, min, max) { if (offset &lt; min) { offset = min } else if (offset &gt; max) { offset = max } return offset } //3.1.1鼠标移动事件的方法实现 function mousemoveHandler(e) { var e = e || window.event || e.which var moveX = e.clientX var offsetX = getOffsetX(moveX - downX, 0, successMoveDistance) bgColor.style.width = offsetX + &quot;px&quot; slider.style.left = offsetX + &quot;px&quot; if (offsetX == successMoveDistance) { success() } //如果不设置滑块滑动时会出现问题（目前还不知道为什么） e.preventDefault() } //3.1.2鼠标松开事件的方法实现 function mouseupHandler(e) { if (!isSuccess) { bgColor.style.width = 0 + &quot;px&quot; slider.style.left = 0 + &quot;px&quot; bgColor.style.transition = &quot;width 0.8s linear&quot; slider.style.transition = &quot;left 0.8s linear&quot; } document.onmousemove = null document.onmouseup = null } //五、定义一个滑块解锁成功的方法 function success() { isSuccess = true txt.innerHTML = &quot;解锁成功&quot; bgColor.style.backgroundColor = &quot;lightgreen&quot; slider.className = &quot;slider active&quot; icon.className = &quot;iconfont icon-xuanzhong&quot; //滑动成功时，移除鼠标按下事件和鼠标移动事件 slider.onmousedown = null document.onmousemove = null } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; canvas实现贪吃蛇原文 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;贪吃蛇&lt;/title&gt; &lt;style&gt; body { background-color: #eee; } .container { text-align: center; } .top { margin: 20px auto; width: 640px; } #score { float: left; } .main { position: absolute; left: 50%; transform: translateX(-50%); width: 642px; height: 402px; } #snake { border: 1px solid #000; width: 640px; height: 400px; display: inline-block; z-index: 99; background-color: rgba(0, 0, 0, .1); } #mask { background-color: rgba(0, 0, 0, .5); position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 100; display: block; color: #fff; line-height: 400px; text-align: center; font-size: 30px; cursor: pointer; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;top&quot;&gt; &lt;span id=&quot;score&quot;&gt;Score: 0&lt;/span&gt; &lt;button id=&quot;restart&quot;&gt;重新开始&lt;/button&gt; &lt;button id=&quot;stop&quot;&gt;暂停&lt;/button&gt; &lt;button id=&quot;continue&quot;&gt;继续&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;canvas id=&quot;snake&quot; width=&quot;640&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;div id=&quot;mask&quot;&gt;开始&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; let greedySnake = null let score = document.querySelector(&#39;#score&#39;) let restart = document.querySelector(&#39;#restart&#39;) let stop = document.querySelector(&#39;#stop&#39;) let conti = document.querySelector(&#39;#continue&#39;) let mask = document.querySelector(&#39;#mask&#39;) restart.onclick = () =&gt; { if (!greedySnake.isStart) return greedySnake.start() } stop.onclick = () =&gt; { if (greedySnake.isStop || !greedySnake.isStart) return greedySnake.stop() } conti.onclick = () =&gt; { if (!greedySnake.isStop || !greedySnake.isStart) return greedySnake.continue() } mask.onclick = () =&gt; { if (!greedySnake.isStart) { greedySnake.start() } else { greedySnake.continue() } } // 大小为64 * 40 class GreedySnake { constructor() { this.canvas = document.querySelector(&#39;#snake&#39;) this.ctx = this.canvas.getContext(&#39;2d&#39;) this.maxX = 64 // 最大行 this.maxY = 40 // 最大列 this.itemWidth = 10 // 每个点的大小 this.direction = &#39;right&#39;// up down right left 方向 this.speed = 150 // ms 速度 this.isStop = false // 是否暂停 this.isOver = false // 是否结束 this.isStart = false // 是否开始 this.score = 0 // 分数 this.timer = null // 移动定时器 this.j = 1 this.canChange = true this.grid = new Array() for (let i = 0; i &lt; this.maxX; i++) { for (let j = 0; j &lt; this.maxY; j++) { this.grid.push([i, j]) } } this.drawGridLine() this.getDirection() } // 开始 start() { if (this.timer) { clearTimeout(this.timer) } if (!this.isStart) { this.isStart = true } this.score = 0 this.speed = 150 this.isStop = false this.isOver = false this.direction = &#39;right&#39; this.createSnake() this.createFood() this.draw() this.move() mask.style.display = &#39;none&#39; } // 创建蛇主体 createSnake() { this.snake = [ [4, 25], [3, 25], [2, 25], [1, 25], [0, 25] ] } // 移动 move() { if (this.isStop) return let [x, y] = this.snake[0] switch(this.direction) { case &#39;left&#39;: x-- break case &#39;right&#39;: x++ break case &#39;up&#39;: y-- break case &#39;down&#39;: y++ break } // 如果下一步不是食物的位置 if (x !== this.food[0] || y !== this.food[1]) { this.snake.pop() } else { this.createFood() } if (this.over([x, y])) { this.isOver = true mask.style.display = &#39;block&#39; mask.innerHTML = &#39;结束&#39; return } if (this.completed()) { mask.style.display = &#39;block&#39; mask.innerHTML = &#39;恭喜您，游戏通关&#39; return } this.snake.unshift([x, y]) this.draw() this.canChange = true this.timer = setTimeout(() =&gt; this.move(), this.speed) } // 暂停游戏 stop() { if (this.isOver) return this.isStop = true mask.style.display = &#39;block&#39; mask.innerHTML = &#39;暂停&#39; } // 继续游戏 continue() { if (this.isOver) return this.isStop = false this.move() mask.style.display = &#39;none&#39; } getDirection() { // 上38 下40 左37 右39 不能往相反的方向走 document.onkeydown = (e) =&gt; { // 在贪吃蛇移动的间隔内不能连续改变两次方向 if (!this.canChange) return switch(e.keyCode) { case 37: if (this.direction !== &#39;right&#39;) { this.direction = &#39;left&#39; this.canChange = false } break case 38: if (this.direction !== &#39;down&#39;) { this.direction = &#39;up&#39; this.canChange = false } break case 39: if (this.direction !== &#39;left&#39;) { this.direction = &#39;right&#39; this.canChange = false } break case 40: if (this.direction !== &#39;up&#39;) { this.direction = &#39;down&#39; this.canChange = false } break case 32: // 空格暂停与继续 if (!this.isStop) { this.stop() } else { this.continue() } break } } } createPos() { let [x, y] = this.grid[(Math.random() * this.grid.length) | 0] for (let i = 0; i &lt; this.snake.length; i++) { if (this.snake[i][0] == x &amp;&amp; this.snake[i][1] == y) { return this.createPos() } } return [x, y] } // 生成食物 createFood() { this.food = this.createPos() // 更新分数 score.innerHTML = &#39;Score: &#39;+ this.score++ if (this.speed &gt; 50) { this.speed-- } } // 结束 over([x, y]) { if (x &lt; 0 || x &gt;= this.maxX || y &lt; 0 || y &gt;= this.maxY) { return true } if (this.snake.some(v =&gt; v[0] === x &amp;&amp; v[1] === y)) { return true } } // 完成 completed() { if (this.snake.length == this.maxX * this.maxY) { return true } } // 网格线 drawGridLine() { for (let i = 1; i &lt; this.maxY; i++) { this.ctx.moveTo(0, i * this.itemWidth) this.ctx.lineTo(this.canvas.width, i * this.itemWidth) } for (let i = 1; i &lt; this.maxX; i++) { this.ctx.moveTo(i * this.itemWidth, 0) this.ctx.lineTo(i * this.itemWidth, this.canvas.height) } this.ctx.lineWidth = 1 this.ctx.strokeStyle = &#39;#ddd&#39; this.ctx.stroke() } // 绘制 draw() { // 清空画布 this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height) this.drawGridLine() this.ctx.fillStyle=&quot;#000&quot; this.ctx.fillRect( this.food[0] * this.itemWidth + this.j, this.food[1] * this.itemWidth + this.j, this.itemWidth - this.j * 2, this.itemWidth - + this.j * 2 ) this.j ^= 1 this.ctx.fillStyle=&quot;green&quot; this.ctx.fillRect( this.snake[0][0] * this.itemWidth + 0.5, this.snake[0][1] * this.itemWidth + 0.5, this.itemWidth - 1, this.itemWidth - 1 ) this.ctx.fillStyle=&quot;red&quot; for (let i = 1; i &lt; this.snake.length; i++) { this.ctx.fillRect( this.snake[i][0] * this.itemWidth + 0.5, this.snake[i][1] * this.itemWidth + 0.5, this.itemWidth - 1, this.itemWidth - 1 ) } } } greedySnake = new GreedySnake() &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; canvas实现带笔锋手写笔记&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;title&gt;canvas 手写毛笔字效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #canvasId { background-color: #ffffcc; } &lt;/style&gt; &lt;/head&gt; &lt;body style=&quot;touch-action: none&quot;&gt; &lt;canvas id=&quot;canvasId&quot; width=&quot;800&quot; height=&quot;720&quot;&gt;&lt;/canvas&gt;&lt;br /&gt; &lt;script&gt; Array.prototype.clone = function () { return [].concat(this) //或者 return this.concat(); } class Point { constructor(x, y, time) { this.x = x this.y = y this.isControl = false this.time = Date.now() this.lineWidth = 0 this.isAdd = false } } class Line { constructor() { this.points = new Array() this.changeWidthCount = 0 this.lineWidth = 10 } } class HandwritingSelf { constructor(canvas) { this.canvas = canvas this.ctx = canvas.getContext(&quot;2d&quot;) // this.points = new Array(); this.line = new Line() this.pointLines = new Array() //Line数组 this.k = 0.5 this.begin = null this.middle = null this.end = null this.preTime = null this.lineWidth = 8 this.isDown = false } down(x, y) { this.isDown = true this.line = new Line() this.line.lineWidth = this.lineWidth let currentPoint = new Point(x, y, Date.now()) this.addPoint(currentPoint) this.preTime = Date.now() } move(x, y) { // console.log(&quot;move:&quot;,x,y) if (this.isDown) { let currentPoint = new Point(x, y, Date.now()) this.addPoint(currentPoint) this.draw() } } up(x, y) { // if (e.touches.length &gt; 0) { let currentPoint = new Point(x, y, Date.now()) this.addPoint(currentPoint) // } this.draw(true) this.pointLines.push(this.line) this.begin = null this.middle = null this.end = null this.isDown = false } draw(isUp = false) { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height) this.ctx.strokeStyle = &quot;rgba(255,20,87,1)&quot; //绘制不包含this.line的线条 this.pointLines.forEach((line, index) =&gt; { let points = line.points this.ctx.beginPath() this.ctx.ellipse( points[0].x - 1.5, points[0].y, 6, 3, Math.PI / 4, 0, Math.PI * 2 ) this.ctx.fill() this.ctx.beginPath() this.ctx.moveTo(points[0].x, points[0].y) let lastW = line.lineWidth this.ctx.lineWidth = line.lineWidth this.ctx.lineJoin = &quot;round&quot; this.ctx.lineCap = &quot;round&quot; let minLineW = line.lineWidth / 4 let isChangeW = false let changeWidthCount = line.changeWidthCount for (let i = 1; i &lt;= points.length; i++) { if (i == points.length) { this.ctx.stroke() break } if (i &gt; points.length - changeWidthCount) { if (!isChangeW) { this.ctx.stroke() //将之前的线条不变的path绘制完 isChangeW = true if (i &gt; 1 &amp;&amp; points[i - 1].isControl) continue } let w = ((lastW - minLineW) / changeWidthCount) * (points.length - i) + minLineW points[i - 1].lineWidth = w this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍 // this.ctx.strokeStyle = &quot;rgba(&quot;+Math.random()*255+&quot;,&quot;+Math.random()*255+&quot;,&quot;+Math.random()*255+&quot;,1)&quot;; this.ctx.lineWidth = w this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点 this.ctx.lineTo(points[i].x, points[i].y) this.ctx.stroke() //将之前的线条不变的path绘制完 } else { if (points[i].isControl &amp;&amp; points[i + 1]) { this.ctx.quadraticCurveTo( points[i].x, points[i].y, points[i + 1].x, points[i + 1].y ) } else if (i &gt;= 1 &amp;&amp; points[i - 1].isControl) { //上一个是控制点 当前点已经被绘制 } else this.ctx.lineTo(points[i].x, points[i].y) } } }) //绘制this.line线条 let points if (isUp) points = this.line.points else points = this.line.points.clone() //当前绘制的线条最后几个补点 贝塞尔方式增加点 let count = 0 let insertCount = 0 let i = points.length - 1 let endPoint = points[i] let controlPoint let startPoint while (i &gt;= 0) { if (points[i].isControl == true) { controlPoint = points[i] count++ } else { startPoint = points[i] } if (startPoint &amp;&amp; controlPoint &amp;&amp; endPoint) { //使用贝塞尔计算补点 let dis = this.z_distance(startPoint, controlPoint) + this.z_distance(controlPoint, endPoint) let insertPoints = this.BezierCalculate( [startPoint, controlPoint, endPoint], Math.floor(dis / 6) + 1 ) insertCount += insertPoints.length var index = i //插入位置 // 把insertPoints 变成一个适合splice的数组（包含splice前2个参数的数组） insertPoints.unshift(index, 1) Array.prototype.splice.apply(points, insertPoints) //补完点后 endPoint = startPoint startPoint = null } if (count &gt;= 6) break i-- } //确定最后线宽变化的点数 let changeWidthCount = count + insertCount if (isUp) this.line.changeWidthCount = changeWidthCount //制造椭圆头 this.ctx.fillStyle = &quot;rgba(255,20,87,1)&quot; this.ctx.beginPath() this.ctx.ellipse( points[0].x - 1.5, points[0].y, 6, 3, Math.PI / 4, 0, Math.PI * 2 ) this.ctx.fill() this.ctx.beginPath() this.ctx.moveTo(points[0].x, points[0].y) let lastW = this.line.lineWidth this.ctx.lineWidth = this.line.lineWidth this.ctx.lineJoin = &quot;round&quot; this.ctx.lineCap = &quot;round&quot; let minLineW = this.line.lineWidth / 4 let isChangeW = false for (let i = 1; i &lt;= points.length; i++) { if (i == points.length) { this.ctx.stroke() break } //最后的一些点线宽变细 if (i &gt; points.length - changeWidthCount) { if (!isChangeW) { this.ctx.stroke() //将之前的线条不变的path绘制完 isChangeW = true if (i &gt; 1 &amp;&amp; points[i - 1].isControl) continue } //计算线宽 let w = ((lastW - minLineW) / changeWidthCount) * (points.length - i) + minLineW points[i - 1].lineWidth = w this.ctx.beginPath() //为了开启新的路径 否则每次stroke 都会把之前的路径在描一遍 // this.ctx.strokeStyle = &quot;rgba(&quot; + Math.random() * 255 + &quot;,&quot; + Math.random() * 255 + &quot;,&quot; + Math.random() * 255 + &quot;,0.5)&quot;; this.ctx.lineWidth = w this.ctx.moveTo(points[i - 1].x, points[i - 1].y) //移动到之前的点 this.ctx.lineTo(points[i].x, points[i].y) this.ctx.stroke() //将之前的线条不变的path绘制完 } else { if (points[i].isControl &amp;&amp; points[i + 1]) { this.ctx.quadraticCurveTo( points[i].x, points[i].y, points[i + 1].x, points[i + 1].y ) } else if (i &gt;= 1 &amp;&amp; points[i - 1].isControl) { //上一个是控制点 当前点已经被绘制 } else this.ctx.lineTo(points[i].x, points[i].y) } } } addPoint(p) { if (this.line.points.length &gt;= 1) { let last_point = this.line.points[this.line.points.length - 1] let distance = this.z_distance(p, last_point) if (distance &lt; 10) { return } } if (this.line.points.length == 0) { this.begin = p p.isControl = true this.pushPoint(p) } else { this.middle = p let controlPs = this.computeControlPoints( this.k, this.begin, this.middle, null ) this.pushPoint(controlPs.first) this.pushPoint(p) p.isControl = true this.begin = this.middle } } addOtherPoint(p1, p2, w1, w2) { let otherPoints = new Array() let dis = this.z_distance(p1, p2) if (dis &gt;= 25) { otherPoints.push(p1) let insertPCount = Math.floor(dis / 20) for (let j = 0; j &lt; insertPCount; j++) { let insertP = new Point( p1.x + ((j + 1) / (insertPCount + 1)) * (p2.x - p1.x), p1.y + ((j + 1) / (insertPCount + 1)) * (p2.y - p1.y) ) insertP.isAdd = true otherPoints.push(insertP) } otherPoints.push(p2) } let count = otherPoints.length if (count &gt; 0) { console.log(&quot;addOtherPoint&quot;) debugger let diffW = (w2 - w1) / (count - 1) for (let i = 1; i &lt; count; i++) { let w = w1 + diffW * i this.ctx.beginPath() this.ctx.lineWidth = w this.ctx.moveTo(otherPoints[i - 1].x, otherPoints[i - 1].y) this.ctx.lineTo(otherPoints[i].x, otherPoints[i].y) this.ctx.stroke() } } return otherPoints } pushPoint(p) { //排除重复点 if ( this.line.points.length &gt;= 1 &amp;&amp; this.line.points[this.line.points.length - 1].x == p.x &amp;&amp; this.line.points[this.line.points.length - 1].y == p.y ) return this.line.points.push(p) } computeControlPoints(k, begin, middle, end) { if (k &gt; 0.5 || k &lt;= 0) return let diff1 = new Point(middle.x - begin.x, middle.y - begin.y) let diff2 = null if (end) diff2 = new Point(end.x - middle.x, end.y - middle.y) // let l1 = (diff1.x ** 2 + diff1.y ** 2) ** (1 / 2) // let l2 = (diff2.x ** 2 + diff2.y ** 2) ** (1 / 2) let first = new Point(middle.x - k * diff1.x, middle.y - k * diff1.y) let second = null if (diff2) second = new Point(middle.x + k * diff2.x, middle.y + k * diff2.y) return { first: first, second: second } } // W_current = // W_previous + min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) &gt;= 0 // W_previous - min( abs(k*s - W_previous), distance * K_width_unit_change) (k * s-W_previous) &lt; 0 // W_current 当前线段的宽度 // W_previous 与当前线条相邻的前一条线段的宽度 // distance 当前线条的长度 // w_k 设定的一个固定阈值,表示:单位距离内, 笔迹的线条宽度可以变化的最大量. // distance * w_k 即为当前线段的长度内, 笔宽可以相对于前一条线段笔宽的基础上, 最多能够变宽或者可以变窄多少. z_linewidth(b, e, bwidth, step) { if (e.time == b.time) return bwidth let max_speed = 2.0 let d = this.z_distance(b, e) let s = d / (e.time - b.time) //计算速度 console.log(&quot;s&quot;, e.time - b.time, s) s = s &gt; max_speed ? max_speed : s // let w = (max_speed - s) / max_speed; let w = 0.5 / s let max_dif = d * step console.log(w, bwidth, max_dif) if (w &lt; 0.05) w = 0.05 if (Math.abs(w - bwidth) &gt; max_dif) { if (w &gt; bwidth) w = bwidth + max_dif else w = bwidth - max_dif } // printf(&quot;d:%.4f, time_diff:%lld, speed:%.4f, width:%.4f\\n&quot;, d, e.t-b.t, s, w); return w } z_distance(b, e) { return Math.sqrt(Math.pow(e.x - b.x, 2) + Math.pow(e.y - b.y, 2)) } BezierCalculate(poss, precision) { //维度，坐标轴数（二维坐标，三维坐标...） let dimersion = 2 //贝塞尔曲线控制点数（阶数） let number = poss.length //控制点数不小于 2 ，至少为二维坐标系 if (number &lt; 2 || dimersion &lt; 2) return null let result = new Array() //计算杨辉三角 let mi = new Array() mi[0] = mi[1] = 1 for (let i = 3; i &lt;= number; i++) { let t = new Array() for (let j = 0; j &lt; i - 1; j++) { t[j] = mi[j] } mi[0] = mi[i - 1] = 1 for (let j = 0; j &lt; i - 2; j++) { mi[j + 1] = t[j] + t[j + 1] } } //计算坐标点 for (let i = 0; i &lt; precision; i++) { let t = i / precision let p = new Point(0, 0) p.isAdd = true result.push(p) for (let j = 0; j &lt; dimersion; j++) { let temp = 0.0 for (let k = 0; k &lt; number; k++) { temp += Math.pow(1 - t, number - k - 1) * (j == 0 ? poss[k].x : poss[k].y) * Math.pow(t, k) * mi[k] } j == 0 ? (p.x = temp) : (p.y = temp) } } return result } } //以下代码为鼠标移动事件部分 let handwriting = new HandwritingSelf(document.getElementById(&quot;canvasId&quot;)) // document.ontouchstart = document.onmousedown document.onpointerdown = function (e) { if (e.type == &quot;touchstart&quot;) handwriting.down(e.touches[0].pageX, e.touches[0].pageY) else handwriting.down(e.x, e.y) } // document.ontouchmove = document.onmousemove document.onpointermove = function (e) { if (e.type == &quot;touchmove&quot;) handwriting.move(e.touches[0].pageX, e.touches[0].pageY) else handwriting.move(e.x, e.y) } // document.ontouchend = document.onmouseup document.onpointerup = function (e) { if (e.type == &quot;touchend&quot;) handwriting.up(e.touches[0].pageX, e.touches[0].pageY) else handwriting.up(e.x, e.y) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 代码雨&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Code&lt;/title&gt; &lt;style&gt; body { margin: 0; overflow: hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; const width = (document.getElementById(&quot;myCanvas&quot;).width = 1920) //screen.availWidth; const height = (document.getElementById(&quot;myCanvas&quot;).height = 1080) //screen.availHeight; const ctx = document.getElementById(&quot;myCanvas&quot;).getContext(&quot;2d&quot;) const arr = Array(Math.ceil(width / 10)).fill(0) const str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;.split(&quot;&quot;) function rain() { ctx.fillStyle = &quot;rgba(0,0,0,0.05)&quot; ctx.fillRect(0, 0, width, height) ctx.fillStyle = &quot;#0f0&quot; arr.forEach(function (value, index) { ctx.fillText( str[Math.floor(Math.random() * str.length)], index * 10, value + 10 ) arr[index] = value &gt;= height || value &gt; 8888 * Math.random() ? 0 : value + 10 }) } setInterval(rain, 30) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; qq企鹅&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body, div, strong { margin: 0; padding: 0; } body { overflow: hidden; } .wrap { width: 600px; margin: 50px auto 0; position: relative; } /* ……………………………………………………………………企鹅头部…………………………………………………………………… */ /* 上半部分黑色头部 */ .headtop { width: 240px; height: 110px; background: #000; margin: 0 auto; border-top-left-radius: 120px 110px; border-top-right-radius: 120px 110px; position: relative; z-index: 999; } /* 下半部分黑色头部 */ .headbottom { width: 240px; height: 90px; background: #000; border-bottom-left-radius: 120px 90px; border-bottom-right-radius: 120px 90px; position: absolute; top: 110px; z-index: 1; } h1 { position: absolute; } /* 左眼部分 */ .lefteye { width: 46px; height: 70px; background: #fff; border-radius: 50% 50%; position: absolute; top: 30px; left: 64px; z-index: 2; } .lefteye_in { width: 20px; height: 30px; background: #000; border-radius: 50% 50%; margin-left: 23px; margin-top: 20px; } .eyeshow { display: block; width: 8px; height: 10px; border-radius: 50% 50%; background: #fff; position: absolute; top: 26px; left: 32px; } /*右眼部分 */ .righteye { width: 46px; height: 70px; background: #fff; border-radius: 50% 50%; position: absolute; top: 30px; left: 130px; z-index: 2; } .righteye_in { width: 19px; height: 23px; background: #000; border-top-left-radius: 17px 30px; border-top-right-radius: 17px 30px; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; border: 1px solid #000; margin-left: 7px; margin-top: 16px; } .eyebai { display: block; width: 12px; height: 19px; border-top-left-radius: 5px 14px; border-top-right-radius: 8px 14px; background: #fff; margin-top: 10px; margin-left: 4px; } /*右眼部分 */ /*嘴巴*/ .mouth { width: 158px; height: 56px; background: #ffa600; border-radius: 50%; position: absolute; top: 106px; left: 42px; z-index: 2; } .mouth_bar { width: 126px; height: 30px; background: #000; position: absolute; top: 142px; left: 55px; z-index: 2; border-bottom-left-radius: 76px 96px; border-bottom-right-radius: 76px 96px; } .mouth_bar1 { width: 126px; height: 20px; background: #ffa600; position: absolute; z-index: 3; border-bottom-left-radius: 104px 32px; border-bottom-right-radius: 104px 32px; } /*嘴巴*/ /* ……………………………………………………………………end 企鹅头部…………………………………………………………………… */ /* ……………………………………………………………………star 企鹅身体…………………………………………………………………… */ /* 企鹅身体黑色部分 */ .body { width: 276px; height: 260px; background: #000; position: absolute; top: 142px; left: 167px; border-top-left-radius: 160px 140px; border-bottom-left-radius: 160px 140px; border-top-right-radius: 160px 140px; border-bottom-right-radius: 160px 140px; z-index: 2; } /* 企鹅身体黑色部分 */ /* 红色围脖 */ .body_1 { width: 264px; height: 137px; background: #ff0000; border: 5px solid #000; border-top-left-radius: 195px 100px; border-bottom-left-radius: 237px 146px; border-top-right-radius: 195px 100px; border-bottom-right-radius: 269px 146px; position: absolute; bottom: 159px; left: 0px; } .body_2 { width: 249px; height: 139px; position: absolute; background: #000; top: -33px; left: 7px; border-radius: 50%; border: 1px #000 solid; } .body_3 { width: 241px; height: 145px; position: absolute; background: red; top: 0px; left: 5px; border-radius: 50%; } /* 红色围脖 */ /* 白色企鹅肚子 */ .tummy { width: 240px; height: 240px; background: #fff; position: absolute; top: 11px; left: 17px; border-radius: 50%; } /* 白色企鹅肚子 */ /* 企鹅口袋 */ .pocket { width: 58px; height: 78px; position: absolute; top: 72px; left: 19px; border: 3px solid #000; background: red; border-top-left-radius: 20px 52px; border-bottom-left-radius: 40px 40px; border-top-right-radius: 0px 0px; border-bottom-right-radius: 21px 21px; } .pocket .pocket_line1 { width: 11px; height: 43px; border-bottom-left-radius: 29px 57px; border-top-left-radius: 0px 0px; border: 9px solid #000; border-top: none; border-right: none; position: absolute; top: 0px; left: 30px; -webkit-transform: rotateZ(10deg); -moz-transform: rotateZ(10deg); -ms-transform: rotateZ(10deg); -o-transform: rotateZ(10deg); transform: rotateZ(10deg); } .pocket .pocket_line2 { width: 2px; height: 45px; border-bottom-left-radius: 11px 24px; border-top-left-radius: 10px 15px; border: 9px solid red; border-top: none; border-right: none; position: absolute; top: 0px; left: 2px; } /* 企鹅左右手 */ .lefthand, .righthand { width: 49px; height: 160px; background: #000; position: absolute; } .lefthand { top: 20px; left: -29px; border-top-left-radius: 89px 166px; border-top-right-radius: 6px 63px; border-bottom-left-radius: 85px 194px; border-bottom-right-radius: 40px 128px; -webkit-transform: rotateZ(20deg); -moz-transform: rotateZ(20deg); -ms-transform: rotateZ(20deg); -o-transform: rotateZ(20deg); transform: rotateZ(20deg); -webkit-animation: left_rotate 0.5s infinite; -moz-animation: left_rotate 0.5s infinite; -ms-animation: left_rotate 0.5s infinite; -o-animation: left_rotate 0.5s infinite; animation: left_rotate 0.5s infinite; -webkit-animation-direction: alternate; -moz-animation-direction: alternate; -ms-animation-direction: alternate; -o-animation-direction: alternate; animation-direction: alternate; } .righthand { top: 20px; left: 258px; border-top-right-radius: 89px 166px; border-bottom-right-radius: 85px 194px; border-top-left-radius: 6px 63px; border-bottom-left-radius: 40px 128px; -webkit-transform: rotateZ(-20deg); -moz-transform: rotateZ(-20deg); -ms-transform: rotateZ(-20deg); -o-transform: rotateZ(-20deg); transform: rotateZ(-20deg); -webkit-animation: right_rotate 0.5s infinite; -moz-animation: right_rotate 0.5s infinite; -ms-animation: right_rotate 0.5s infinite; -o-animation: right_rotate 0.5s infinite; animation: right_rotate 0.5s infinite; -webkit-animation-direction: alternate; -moz-animation-direction: alternate; -ms-animation-direction: alternate; -o-animation-direction: alternate; animation-direction: alternate; } /* 企鹅左右手 */ /* ……………………………………………………………………end 企鹅身体…………………………………………………………………… */ /* ……………………………………………………………………star 企鹅脚部…………………………………………………………………… */ .footer .left_footer, .footer .right_footer { width: 134px; height: 74px; position: absolute; background: #ffa600; border: 3px solid #000; border-radius: 50%; z-index: 1; } .footer .left_footer { top: 347px; left: 163px; } .footer .right_footer { top: 347px; left: 320px; } /* ……………………………………………………………………end 企鹅脚部…………………………………………………………………… */ @keyframes left_rotate { from { -webkit-transform-origin: right 30%; -webkit-transform: rotateZ(60deg); } to { -webkit-transform-origin: right 30%; -webkit-transform: rotateZ(30deg); } } @keyframes right_rotate { from { -webkit-transform-origin: left 30%; -webkit-transform: rotateZ(-60deg); } to { -webkit-transform-origin: left 30%; -webkit-transform: rotateZ(-30deg); } } @-webkit-keyframes left_rotate { from { -webkit-transform-origin: right 30%; -webkit-transform: rotateZ(60deg); } to { -webkit-transform-origin: right 30%; -webkit-transform: rotateZ(30deg); } } @-webkit-keyframes right_rotate { from { -webkit-transform-origin: left 30%; -webkit-transform: rotateZ(-60deg); } to { -webkit-transform-origin: left 30%; -webkit-transform: rotateZ(-30deg); } } @-moz-keyframes left_rotate { from { transform-origin: right 30%; transform: rotateZ(60deg); } to { transform-origin: right 30%; transform: rotateZ(30deg); } } @-moz-keyframes right_rotate { from { transform-origin: left 30%; transform: rotateZ(-60deg); } to { transform-origin: left 30%; transform: rotateZ(-30deg); } } @-ms-keyframes left_rotate { from { transform-origin: right 30%; transform: rotateZ(60deg); } to { transform-origin: right 30%; transform: rotateZ(30deg); } } @-ms-keyframes right_rotate { from { transform-origin: left 30%; transform: rotateZ(-60deg); } to { transform-origin: left 30%; transform: rotateZ(-30deg); } } @-o-keyframes left_rotate { from { transform-origin: right 30%; transform: rotateZ(60deg); } to { transform-origin: right 30%; transform: rotateZ(30deg); } } @-o-keyframes right_rotate { from { transform-origin: left 30%; transform: rotateZ(-60deg); } to { transform-origin: left 30%; transform: rotateZ(-30deg); } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;!-- 企鹅头部 --&gt; &lt;div class=&quot;headtop&quot;&gt; &lt;div class=&quot;headbottom&quot;&gt;&lt;/div&gt; &lt;!-- 眼睛部分 --&gt; &lt;h1 class=&quot;lefteye&quot;&gt; &lt;p class=&quot;lefteye_in&quot;&gt; &lt;strong class=&quot;eyeshow&quot;&gt;&lt;/strong&gt; &lt;/p&gt; &lt;/h1&gt; &lt;h1 class=&quot;righteye&quot;&gt; &lt;p class=&quot;righteye_in&quot;&gt; &lt;strong class=&quot;eyebai&quot;&gt;&lt;/strong&gt; &lt;/p&gt; &lt;/h1&gt; &lt;!-- 嘴巴部分 --&gt; &lt;h1 class=&quot;mouth&quot;&gt;&lt;/h1&gt; &lt;p class=&quot;mouth_bar&quot;&gt; &lt;strong class=&quot;mouth_bar1&quot;&gt;&lt;/strong&gt; &lt;/p&gt; &lt;/div&gt; &lt;!-- 企鹅头部 --&gt; &lt;!-- 企鹅身体 --&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;tummy&quot;&gt; &lt;div class=&quot;pocket&quot;&gt; &lt;div class=&quot;pocket_line1&quot;&gt; &lt;div class=&quot;pocket_line2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hand&quot;&gt; &lt;div class=&quot;lefthand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;righthand&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;body_1&quot;&gt; &lt;div class=&quot;body_2&quot;&gt; &lt;div class=&quot;body_3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 企鹅身体 --&gt; &lt;!-- 企鹅脚丫 --&gt; &lt;div class=&quot;footer&quot;&gt; &lt;div class=&quot;left_footer&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right_footer&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 企鹅脚丫 --&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Nodejs","slug":"nodejs","date":"2021-08-12T10:45:51.947Z","updated":"2021-08-13T01:23:02.628Z","comments":true,"path":"2021/08/12/nodejs/","link":"","permalink":"/2021/08/12/nodejs/","excerpt":"","text":"01-Node.js基础一、Node.js是什么Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. 1、 特性Node.js可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如： 文件的读写（File System） 进程的管理（Process） 网络通信（HTTP/HTTPS） 2、举例2.1 浏览器安全级别的限制Ajax限制&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;browser-safe-sandbox&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;browser-safe-sandbox&lt;/div&gt; &lt;script&gt; const xhr = new XMLHttpRequest() xhr.open(&#39;get&#39;, &#39;https://m.maoyan.com/ajax/moreClassicList?sortId=1&amp;showType=3&amp;limit=10&amp;offset=30&amp;optimus_uuid=A5518FF0AFEC11EAAB158D7AB0D05BBBD74C9789D9F649898982E6542C7DD479&amp;optimus_risk_level=71&amp;optimus_code=10&#39;, false) xhr.send() &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 浏览器预览browser-sync start --server --files **/* --directory 2.2 文件的读写（File System）const fs = require(&#39;fs&#39;) fs.readFile(&#39;./ajax.png&#39;, &#39;utf-8&#39;, (err, content) =&gt; { console.log(content) }) 2.3 进程的管理（Process）function main(argv) { console.log(argv) } main(process.argv.slice(2)) 运行 node 2.3-process.js argv1 argv2 2.4 网络通信（HTTP/HTTPS）const http = require(&quot;http&quot;) http.createServer((req,res) =&gt; { res.writeHead(200, { &quot;content-type&quot;: &quot;text/plain&quot; }) res.write(&quot;hello nodejs&quot;) res.end() }).listen(3000) 二、Node相关工具1、NVM：Node Version Manager1.1 Mac安装nvmhttps://github.com/nvm-sh/nvm/blob/master/README.md 1.2 Windows安装nvmnvm-windows nodist 1.3 常用的nvm命令 nvm list：查看当前环境安装了哪些版本 nvm use 14.15.0：切换node版本 nvm alias default (v)14.15.0：切换node默认版本 2、NPM：Node Package Manager npm view jquery versions：查看包的所有版本 2.1 全局安装package$ npm install forever --global (-g) $ forever $ npm uninstall forever --global $ forever 全局安装包的目录 Mac /Users/felix/.nvm/versions/node/nvm各个版本/bin/ Windows C:\\Users\\你的用户名\\AppData\\Roaming\\npm\\node_modules 2.2 本地安装package$ cd ~/desktop $ mkdir gp-project $ cd gp-project $ npm install underscore $ npm list (ls) 2.3 package.json初始化$ pwd $ npm init -y $ ls $ cat package.json 2.4 使用package.json npm install —production：只拉取生产环境的包 $ npm install underscore --save $ cat package.json $ npm install lodash --save-dev $ cat package.json $ rm -rf node_modules $ ls $ npm install $ npm uninstall underscore --save $ npm list | grep underscore // 查看underscore包的树(依赖关系) $ cat package.json “dependencies”：这些包是你的应用程序在生产环境中所需要的。 “devDepedencies”：这些包只是在开发和测试中需要的。 // package.json { ... &quot;dependencies&quot;: { // --save / -S }, &quot;devDependencies&quot;: { // --save-dev / -D } } 2.5 安装指定版本的包 npm install jquery@2.2.4： 安装指定版本 npm install jquery@1 -S：安装1最高的版本 $ pwd $ npm list $ npm info underscore $ npm view underscore versions $ npm install underscore@1.8.0 $ npm list $ npm uninstall underscore $ npm list 2.6 更新本地安装的包 -13.4.6 major: 13（主版本号）,minor: 4（次版本号），patch：6（补丁，单数不稳定，双数稳定） npm outdated：查看哪些包过期 npm update：更新所有的包 $ npm info underscore $ npm view underscore versions // 查看underscore包所有的版本 $ npm install underscore@1.4.4 --save-dev // 安装1.4.4的underscore到开发环境 $ npm list | grep gulp // 查看gulp包的依赖关系 $ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本 $ npm list | grep gulp $ npm update { &quot;dependencies&quot;: { &quot;jquery&quot;: &quot;^1.12.4&quot;, // ^锁定主版本号 &quot;jquery&quot;: &quot;~1.12.4&quot;, // ~锁定主版本号和次版本号 jquery: &quot;1.12.4&quot;, // 全部锁定 jquery: &quot;*&quot; // 最新版本 } } 2.7 清除缓存 npm cache clean --force 2.8 上传自己的包2.8.1 编写模块保存为index.js exports.sayHello = function(){ return &#39;Hello World&#39;; } 2.8.2 初始化描述文件 npm init package.json { &quot;name&quot;: &quot;gp19-npm&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;description&quot;: &quot;gp19 self module&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;make test&quot; }, &quot;repository&quot;: { &quot;type&quot;: &quot;Git&quot;, &quot;url&quot;: &quot;git+https://github.com/lurongtao/gp19-npm.git&quot; }, &quot;keywords&quot;: [ &quot;demo&quot; ], &quot;author&quot;: &quot;Felixlu&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bugs&quot;: { &quot;url&quot;: &quot;https://github.com/lurongtao/gp19-npm/issues&quot; }, &quot;homepage&quot;: &quot;https://github.com/lurongtao/gp19-npm#readme&quot;, } 2.8.3 注册npm仓库账号 npm adduser https://www.npmjs.com 上面的账号 felix_lurt/qqmko09ijn $ npm adduser 2.8.4 上传包 npm publish 坑：403 Forbidden 查看npm源：npm config get registry 切换npm源方法一：npm config set registry http://registry.npmjs.org 切换npm源方法二：nrm use npm 2.8.5 安装包 npm install gp19-npm 2.8.6 卸载包查看当前项目引用了哪些包 ： npm ls 卸载包： npm unpublish --force 2.8.7 使用引入包var hello = require(&#39;gp19-npm&#39;) hello.sayHello() 2.9 npm脚本Node开发离不开npm，而脚本功能是npm最强大、最常用的功能之一。 2.9.1 什么是npm脚本？npm允许在package.json文件里面，使用scripts字段定义脚本命令。 { // ... &quot;scripts&quot;: { &quot;builds&quot;: &quot;node build.js&quot; } } 2.9.2 执行顺序如果npm脚本里面需要执行多个任务，那么需要明确它们的执行顺序。 scripts1.js var x = 0 console.log(x) scripts2.js var y = 0 console.log(y) &quot;scripts&quot; : { &quot;script1&quot;: &quot;node script1.js&quot;, &quot;script2&quot;: &quot;ndoe script2.js&quot; } 如果是并行执行（即同时的平行执行），可以使用&amp;符号。 $ npm run script1 &amp; npm run script2 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。 $ npm run script1 &amp;&amp; npm run script2 2.9.3 简写形式常用的npm脚本简写形式 npm start 是 npm run start 2.9.4 变量npm脚本有一个非常强大功能，就是可以使用npm的内部变量。 首先，通过npm _package_前缀，npm脚本可以拿到package.json里面的字段。比如，下面是一个package.json。 注意：一定要在npm脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到的 { &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;scripts&quot;: { &quot;view&quot;: &quot;node view.js&quot; } } 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。 // view.js console.log(process.env.npm_package_name); // foo console.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是Bash脚本，可以用$npm_package_name和 $npm_package_version取到这两个值。 npmpackage前缀也支持嵌套的package.json字段。 &quot;repository&quot;: { &quot;type&quot;: &#39;git&#39;, &quot;url&quot;: &quot;xxx&quot; }, &quot;scripts&quot;: { &quot;view&quot;: &quot;echo $npm_package_repository_type&quot; } 上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。 下面是另外一个例子。 &quot;scripts&quot;: { &quot;install&quot;: &quot;foo.js&quot; } 上面代码中，npm_package_scripts_install变量的值等于foo.js。 然后，npm脚本还可以通过npmconfig前缀，拿到npm的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发型标签，可以通过npm_config_tag取到。 &quot;view&quot;: &quot;echo $npm_config_tag&quot;, 注意，package.json里面的config对象，可以被环境变量覆盖。 { &quot;name&quot;: &quot;foo&quot;, &quot;config&quot;: {&quot;port&quot;: &quot;8080&quot;}, &quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;} } 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。 $ npm config set foo:port 80 最后，env命令可以列出所有环境变量。 “env”:”env” 2.10 npm安装git上发布的包# 这样适合安装公司内部的git服务器上的项目 npm install git+https://git@github.com:lurongtao/gp-project.git # 或者以ssh的方式 npm install git+ssh://git@github.com:lurongtao/gp-project.git 2.11 cross-env使用2.11.1 cross-env是什么运行跨平台设置和使用环境变量的脚本 2.11.2 出现原因当您使用NODE_ENV=production，来设置环境变量时，大多数Windows命令提示将会阻塞（报错）。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows不支持NOE_ENV=production的设置方式。 2.11.3 解决cross-env使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包（cross-env）能够提供一个设置环境变量的scripts，让你能够以Unix方式设置环境变量，然后在Windows上也能兼容运行。 2.11.4 安装npm install --save-dev cross-env 2.11.5 使用{ &quot;scripts&quot;: { &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot; } } NODE_ENV环境变量将由cross-env设置，打印process.env.NODE_ENV === &#39;production&#39; 3、NRM：npm registry manager3.1 手工切换源3.1.1 查看当前源npm config get registry 3.1.2 切换淘宝源npm config set registry https://registry.npm.taobao.org 3.2 NRM管理源NRM是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在npm源间切换。 3.2.1 安装nrm在命令行执行命令，npm install -g nrm，全局安装nrm。 3.2.2 使用nrm执行命令nrm ls查看可选的源。其中，带*的是当前使用的源，上面输出表明当前源是官方源。 3.2.3 切换nrm如果要切换到taobao源，执行命令nrm use taobao。 3.2.4 测试速度你还可以通过nrm test测试相应源的响应时间。 4、 NPX：npm package extentionnpm从5.2版开始，增加了npx命令。它有很多用处，本文介绍该命令的主要使用场景。 Node自带npm模块，所以可以直接使用npx命令。万一不能用，就要手动安装一下。 $ npm install -g npx 4.1 调用项目安装的模块npx想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。 $ npm install -D mocha 一般来说，调用Mocha，只能在项目脚本和package.json的scripts字段里面，如果想在命令行下调用，必须像下面这样。 # 项目的根目录下执行 $ node-modules/.bin/mocha --version npx就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。 $ npx mocha --version npx的原理很简单，就是运行的时候，会倒node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。 由于npx会检查环境变量$PATH，所以系统命令也可以调用。 # 等同于 ls $ npx ls 注意，Bash内置的命令不在$PATH里面，所以不能用。比如cd 是Bash命令，因此就不能用npx cd。 4.2 避免全局安装模块除了调用项目内部模块，npx还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx可以运行它，而且不进行全局安装。 $ npx create-react-app my-react-app 上面代码运行时，npx将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。 注意，只要npx后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个Web服务。 $ npx http-server 4.3 –no–install参数和–ignore-existing参数如果想让npx强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。 $ npx --no-install http-server 反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用–ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。 $ npx --ignore-existing http-server 5、node的浏览端调试 node --inspect --inspect-brk server.js 6、node进程管理工具 supervisor nodemon npm install nodemon nodemon server.js forever pm2 三、模块/包与CommonJS1、模块/包分类Node.js有三类模块，即内置的模块、第三方的模块、自定义的模块。 1.1 内置的模块Node.js内置模块又叫核心模块，Node.js安装完成可直接使用。如： const path = require(&#39;path&#39;) var extname = path.extname(&#39;index.html&#39;) console.log(extname) 1.2 第三方的Node.js模块第三方的Node.js模块指的是为了实现某些功能，发布的npmjs.org上的模块，按照一定的开源协议供社群使用。如： npm install chalk const chalk = require(&#39;chalk&#39;) console.log(chalk.blue(&#39;Hello world!&#39;)) 1.3 自定义的Node.js模块自定义的Node.js模块，也叫文件模块，是我们自己写的供自己使用的模块。同时，这类模块发布到npmjs.org上就成了开源的第三方模块。 自定义模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、速度相比核心模块稍微慢一些，但是用的非常多。 1.3.1 模块定义、接口暴露和引用接口我们可以把公共的功能抽离成为一个单独的js文件作为一个模块，默认情况下面这个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或者属性，就必须在模块里面通过exports或者module.exports暴露属性或者方法。 m1.js const name = &#39;gp19&#39; const sayName = () =&gt; { console.log(name) } console.log(&#39;module 1&#39;) // 接口暴露方法一： module.exports = { say: sayName } // 接口暴露方法二： exports.say = sayName // 错误！ exports = { say: sayName } main.js const m1 = require(&#39;./m1&#39;) m1.say() 1.3.2 模块的循环引用由于exports使用方式不对，会在两个不同js循环引用的情况下，导致其中一个js无法获取另外一个js的方法，从而导致执行报错。如： a.js exports.done = false const b = require(&#39;./b.js&#39;) console.log(&#39;in a, b.done = %j&#39;, b.done) exports.done = true console.log(&#39;a done&#39;) b.js console.log(&#39;b starting&#39;) exports.done = false const a = require(&#39;./a.js&#39;) console.log(&#39;in b, a.done= %j&#39;, a.done) exports.done = true console.log(&#39;b done&#39;) main.js console.log(&#39;main starting&#39;) const a = require(&#39;./a.js&#39;) const b = require(&#39;./b.js&#39;) console.log(&#39;in main, a.done = %j, b.done = %j&#39;, a.done, b.done) main.js首先会load a.js，此时执行到const b = require(&#39;./b.js&#39;);的时候，程序会转去loadb.js, 在b.js中执行到const a = require(&#39;./a.js&#39;); 为了防止无限循环，将a.jsexports的未完成副本返回到b.js模块。然后b.js完成加载，并将其导出对象提供给a.js模块。 我们知道nodeJs的对每个js文件进行了一层包装称为module，module中有一个属性exports，当调用require(&#39;a.js&#39;)的时候其实返回的是module.exports对象，module.exports初始化为一个{}空的object，所以在上面的例子中，执行到b.js中const a = require(&#39;./a.js&#39;);时不会load新的a module, 而是将已经load但是还未完成的a module的exports属性返回给b module，所以b.js拿到的是a module的exports对象，即：{done:false}, 虽然在a.js中exports.done被修改成了true，但是由于此时a.js未load完成，所以在b.js输出的a module的属性done为false，而在main.js中输出的a module的属性done为true. Nodejs通过上面这种返回未完成exports对象来解决循环引用的问题。 四、常用内置模块这里介绍几个常用的内置模块：url，querystring，http，events，fs，stream，readline，crypto，zlib 1、url1.1 parse 要解析的内容，是否查询字符串 url.parse(urlString[,parseQueryString[,slashesDenoteHost]]) const url = require(&#39;url&#39;) const urlString = &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39; const parsedStr = url.parse(urlString) console.log(parsedStr) =&gt; Url { protocol: &#39;https:&#39;, slashes: true, auth: null, host: &#39;www.baidu.com:443&#39;, port: &#39;443&#39;, hostname: &#39;www.baidu.com&#39;, hash: &#39;#tag=110&#39;, search: &#39;?id=8&amp;name=mouse&#39;, query: [Object: null prototype] { id: &#39;8&#39;, name: &#39;mouse&#39; }, pathname: &#39;/ad/index.html&#39;, path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;, href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39; } 1.2 format 将一个解析后的URL对象、转成、一个格式化的URL字符串。 url.format(urlObject) const url = require(&#39;url&#39;) const urlObject = { protocol: &#39;https:&#39;, slashes: true, auth: null, host: &#39;www.baidu.com:443&#39;, port: &#39;443&#39;, hostname: &#39;www.baidu.com&#39;, hash: &#39;#tag=110&#39;, search: &#39;?id=8&amp;name=mouse&#39;, query: { id: &#39;8&#39;, name: &#39;mouse&#39; }, pathname: &#39;/ad/index.html&#39;, path: &#39;/ad/index.html?id=8&amp;name=mouse&#39;, href: &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39; } const parsedObj = url.format(urlObject) console.log(parsedObj) =&gt; &#39;https://www.baidu.com:443/ad/index.html?id=8&amp;name=mouse#tag=110&#39; 1.3 resolve 用于拼接URL（替换 域名后面第一个/后的内容,如果出现.就向上返回一级之后再拼接，两个..就向上反两级再拼接） url.resolve(from, to) const url = require(&#39;url&#39;) var a = url.resolve(&#39;/one/two/three&#39;, &#39;four&#39;) var b = url.resolve(&#39;http://example.com/&#39;, &#39;/one&#39;) var c = url.resolve(&#39;http://example.com/one&#39;, &#39;/two&#39;); var d = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;./two&#39;); var e = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;../two&#39;); var f = url.resolve(&#39;http://example.com/one/ddd/ddd/ddd&#39;, &#39;.../two&#39;); console.log(a +&quot;,&quot;+ b +&quot;,&quot;+ c+&#39;,&#39;+d+&#39;,&#39;+e+&#39;,&#39;+f); =&gt; /one/two/four, http://example.com/one, http://example.com/two, http://example.com/one/ddd/ddd/two, http://example.com/one/ddd/two http://example.com/one/ddd/ddd/.../two 2、querystring2.1 parse 将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。 querystring.parse(str[, sep[, eq[, options]]]) str：欲转换的字符串 sep：设置分隔符，默认为&amp; eq：设置赋值符，默认为= [options]maxKeys：可接受字符串的最大长度，默认为1000 const querystring = require(&#39;querystring&#39;) var qs = &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#39; var parsed = querystring.parse(qs) console.log(parsed) =&gt; { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; } 2.2 stringify 将对象转换成字符串，字符串里多个参数将用 ‘&amp;’ 分隔，将用 ‘=’ 赋值。 querystring.stringify(obj[, sep[, eq[, options]]]) obj：欲转换的对象 sep：设置分隔符，默认为&amp; eq：设置赋值符，默认为= const querystring = require(&#39;querystring&#39;) var qo = { foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; } var parsed = querystring.stringify(qo) console.log(parsed) ==&gt; &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39; const querystring = require(&#39;querystring&#39;) var qo = {foo: &#39;bar&#39;, baz: &#39;qux&#39;} var parsed =querystring.stringify(qo, &#39;;&#39;, &#39;:&#39;) console.log(parsed) ==&gt; &#39;foo:bar;baz:qux&#39; 2.3 escape/unescape 以针对网址查询字符串的特定要求优化的方式对给定的 str 执行网址百分比编码 querystring.escape() 方法被 querystring.stringify() 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 querystring.escape 分配给替代函数来提供替换的百分比编码实现。 querystring.escape(str) const querystring = require(&#39;querystring&#39;) var str = &#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39; var escaped = querystring.escape(str) console.log(escaped) ==&gt; &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39; 在给定的 str 上执行网址百分比编码字符的解码。 querystring.unescape() 方法被 querystring.parse() 使用，通常不会被直接使用。 导出它主要是为了允许应用程序代码在必要时通过将 querystring.unescape 分配给替代函数来提供替代的解码实现。 默认情况下，querystring.unescape() 方法将尝试使用 JavaScript 内置的 decodeURIComponent() 方法进行解码。 如果失败，则将使用更安全的不会因格式错误的网址而抛出错误的同类方法。 querystring.unescape(str) const querystring = require(&#39;querystring&#39;) var str = &#39;id%3D3%26city%3D%E5%8C%97%E4%BA%AC%26url%3Dhttps%3A%2F%2Fwww.baidu.com&#39; var unescaped = querystring.unescape(str) console.log(unescaped) ==&gt; &#39;id=3&amp;city=北京&amp;url=https://www.baidu.com&#39; 3、http/https3.1 getvar http = require(&#39;http&#39;) var https = require(&#39;https&#39;) // 1、接口 2、跨域 const server = http.createServer((request, response) =&gt; { var url = request.url.substr(1) var data = &#39;&#39; response.writeHeader(200, { &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;, &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; }) //response.write(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;) //response.end() // 或 //response.end(&#39;&lt;div&gt;hello&lt;/div&gt;&#39;) https.get(`https://m.lagou.com/listmore.json${url}`, (res) =&gt; { res.on(&#39;data&#39;, (chunk) =&gt; { data += chunk }) res.on(&#39;end&#39;, () =&gt; { response.end(JSON.stringify({ ret: true, data })) }) }) }) server.listen(8080, () =&gt; { console.log(&#39;localhost:8080&#39;) }) 3.2 post:服务器提交（攻击）const https = require(&#39;https&#39;) const querystring = require(&#39;querystring&#39;) const postData = querystring.stringify({ province: &#39;上海&#39;, city: &#39;上海&#39;, district: &#39;宝山区&#39;, address: &#39;同济支路199号智慧七立方3号楼2-4层&#39;, latitude: 43.0, longitude: 160.0, message: &#39;求购一条小鱼&#39;, contact: &#39;13666666&#39;, type: &#39;sell&#39;, time: 1571217561 }) const options = { protocol: &#39;http:&#39;, hostname: &#39;localhost&#39;, method: &#39;POST&#39;, port: 3000, path: &#39;/index.php/trade/add_item&#39;, headers: { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;Content-Length&#39;: Buffer.byteLength(postData) } } const server = http.createServer((req, res) =&gt; { const request = http.request(options, result =&gt; { }) req.write(postData) req.end() res.end() }) server.listen(8080, ()=&gt; { console.log(&#39;localhost:8080&#39;) }) //function doPost() { // let data // let req = https.request(options, (res) =&gt; { // res.on(&#39;data&#39;, chunk =&gt; data += chunk) // res.on(&#39;end&#39;, () =&gt; { // console.log(data) // }) // }) // req.write(postData) // req.end() //} // setInterval(() =&gt; { // doPost() // }, 1000) 3.3 跨域：JSONPconst http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const app = http.createServer((req, res) =&gt; { let urlObj = url.parse(req.url, true) switch (urlObj.pathname) { case &#39;/api/user&#39;: res.end(`${urlObj.query.cb}({&quot;name&quot;: &quot;gp145&quot;})`) break default: res.end(&#39;404.&#39;) break } }) app.listen(8080, () =&gt; { console.log(&#39;localhost:8080&#39;) }) 3.4 跨域：CORSconst http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const querystring = require(&#39;querystring&#39;) const app = http.createServer((req, res) =&gt; { let data = &#39;&#39; let urlObj = url.parse(req.url, true) res.writeHead(200, { &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39;, &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; }) req.on(&#39;data&#39;, (chunk) =&gt; { data += chunk }) req.on(&#39;end&#39;, () =&gt; { responseResult(querystring.parse(data)) }) function responseResult(data) { switch (urlObj.pathname) { case &#39;/api/login&#39;: res.end(JSON.stringify({ message: data })) break default: res.end(&#39;404.&#39;) break } } }) app.listen(8080, () =&gt; { console.log(&#39;localhost:8080&#39;) }) 3.5 跨域：middleware(http-proxy-middware)const http = require(&#39;http&#39;) const proxy = require(&#39;http-proxy-middleware&#39;) http.createServer((req, res) =&gt; { let url = req.url res.writeHead(200, { &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; }) if (/^\\/api/.test(url)) { let apiProxy = proxy(&#39;/api&#39;, { target: &#39;https://m.lagou.com&#39;, changeOrigin: true, pathRewrite: { &#39;^/api&#39;: &#39;&#39; } }) // http-proy-middleware 在Node.js中使用的方法 apiProxy(req, res) } else { switch (url) { case &#39;/index.html&#39;: res.end(&#39;index.html&#39;) break case &#39;/search.html&#39;: res.end(&#39;search.html&#39;) break default: res.end(&#39;[404]page not found.&#39;) } } }).listen(8080) 3.6 爬虫const https = require(&#39;https&#39;) const http = require(&#39;http&#39;) const cheerio = require(&#39;cheerio&#39;) http.createServer((request, response) =&gt; { response.writeHead(200, { &#39;content-type&#39;: &#39;application/json;charset=utf-8&#39; }) const options = { protocol: &#39;https:&#39;, hostname: &#39;maoyan.com&#39;, port: 443, path: &#39;/&#39;, method: &#39;GET&#39; } const req = https.request(options, (res) =&gt; { let data = &#39;&#39; res.on(&#39;data&#39;, (chunk) =&gt; { data += chunk }) res.on(&#39;end&#39;, () =&gt; { filterData(data) }) }) function filterData(data) { let $ = cheerio.load(data) let $movieList = $(&#39;.movie-item&#39;) let movies = [] $movieList.each((index, value) =&gt; { movies.push({ title: $(value).find(&#39;.movie-title&#39;).attr(&#39;title&#39;), score: $(value).find(&#39;.movie-score i&#39;).text(), }) }) response.end(JSON.stringify(movies)) } req.end() }).listen(9000) 4、Eventsconst EventEmitter = require(&#39;events&#39;) class MyEventEmitter extends EventEmitter {} const event = new MyEventEmitter() event.on(&#39;play&#39;, (movie) =&gt; { console.log(movie) }) event.emit(&#39;play&#39;, &#39;我和我的祖国&#39;) event.emit(&#39;play&#39;, &#39;中国机长&#39;) 5、File Systemconst fs = require(&#39;fs&#39;) const fsP = require(&#39;fs&#39;).promises // 创建文件夹 fs.mkdir(&#39;./logs&#39;, (err) =&gt; { console.log(&#39;done.&#39;) }) // 文件夹改名 fs.rename(&#39;./logs&#39;, &#39;./log&#39;, () =&gt; { console.log(&#39;done&#39;) }) // 删除文件夹 fs.rmdir(&#39;./log&#39;, () =&gt; { console.log(&#39;done.&#39;) }) // 写内容到文件里 fs.writeFile( &#39;./logs/log1.txt&#39;, &#39;hello&#39;, // 错误优先的回调函数 (err) =&gt; { if (err) { console.log(err.message) } else { console.log(&#39;文件创建成功&#39;) } } ) // 给文件追加内容 fs.appendFile(&#39;./logs/log1.txt&#39;, &#39;\\nworld&#39;, () =&gt; { console.log(&#39;done.&#39;) }) // 读取文件内容 fs.readFile(&#39;./logs/log1.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; { console.log(data) }) // 删除文件 fs.unlink(&#39;./logs/log1.txt&#39;, (err) =&gt; { console.log(&#39;done.&#39;) }) // 批量写文件 for (var i = 0; i &lt; 10; i++) { fs.writeFile(`./logs/log-${i}.txt`, `log-${i}`, (err) =&gt; { console.log(&#39;done.&#39;) }) } // 读取文件/目录信息 fs.readdir(&#39;./&#39;, (err, data) =&gt; { data.forEach((value, index) =&gt; { fs.stat(`./${value}`, (err, stats) =&gt; { // console.log(value + &#39;:&#39; + stats.size) console.log(value + &#39; is &#39; + (stats.isDirectory() ? &#39;directory&#39; : &#39;file&#39;)) }) }) }) // 同步读取文件 try { const content = fs.readFileSync(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;) console.log(content) console.log(0) } catch (e) { console.log(e.message) } console.log(1) // 异步读取文件：方法一 fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; { console.log(content) console.log(0) }) console.log(1) // 异步读取文件：方法二 fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;).then(result =&gt; { console.log(result) }) // 异步读取文件：方法三 function getFile() { return new Promise((resolve) =&gt; { fs.readFile(&#39;./logs/log-0.txt&#39;, &#39;utf-8&#39;, (err, data) =&gt; { resolve(data) }) }) } ;(async () =&gt; { console.log(await getFile()) })() // 异步读取文件：方法四 const fsp = fsP.readFile(&#39;./logs/log-1.txt&#39;, &#39;utf-8&#39;).then((result) =&gt; { console.log(result) }) console.log(fsP) // watch 监测文件变化 fs.watch(&#39;./logs/log-0.txt&#39;, () =&gt; { console.log(0) }) 6、Streamconst fs = require(&#39;fs&#39;) const readstream = fs.createReadStream(&#39;./note.txt&#39;) const writestream = fs.createWriteStream(&#39;./note2.txt&#39;) writestream.write(readstream) 7、Zlibconst fs = require(&#39;fs&#39;) const zlib = require(&#39;zlib&#39;) const gzip = zlib.createGzip() const readstream = fs.createReadStream(&#39;./note.txt&#39;) const writestream = fs.createWriteStream(&#39;./note2.txt&#39;) readstream .pipe(gzip) .pipe(writestream) writestream.write(readstream) 8、ReadLineconst readline = require(&#39;readline&#39;) const rl = readline.createInterface({ input: process.stdin, output: process.stdout }) rl.question(&#39;What do you think of Node.js? &#39;, (answer) =&gt; { // TODO: Log the answer in a database console.log(`Thank you for your valuable feedback: ${answer}`) rl.close() }) 9、Cryptoconst crypto = require(&#39;crypto&#39;) const secret = &#39;abcdefg&#39; const hash = crypto.createHmac(&#39;sha256&#39;, secret) .update(&#39;I love you&#39;) .digest(&#39;hex&#39;) console.log(hash) 五、路由var http = require(&#39;http&#39;) var fs = require(&#39;fs&#39;) http.createServer( function ( req, res ) { switch ( req.url ) { case &#39;/home&#39;: res.write(&#39;home&#39;) res.end() break case &#39;/mine&#39;: res.write(&#39;mine&#39;) res.end() break case &#39;/login&#39;: fs.readFile( &#39;./static/login.html&#39;,function ( error , data ) { if ( error ) throw error res.write( data ) res.end() }) break case &#39;/fulian.jpg&#39;: fs.readFile( &#39;./static/fulian.jpg&#39;, &#39;binary&#39;, function( error , data ) { if( error ) throw error res.write( data, &#39;binary&#39; ) res.end() }) break default: break } }).listen( 8000, &#39;localhost&#39;, function () { console.log( &#39;服务器运行在： http://localhost:8000&#39; ) }) 六、静态资源服务6.1 readStaticFile/modules/readStaticFile.js // 引入依赖的模块 var path = require(&#39;path&#39;) var fs = require(&#39;fs&#39;) var mime = require(&#39;mime&#39;) function readStaticFile(res, filePathname) { var ext = path.parse(filePathname).ext var mimeType = mime.getType(ext) // 判断路径是否有后缀, 有的话则说明客户端要请求的是一个文件 if (ext) { // 根据传入的目标文件路径来读取对应文件 fs.readFile(filePathname, (err, data) =&gt; { // 错误处理 if (err) { res.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; }) res.write(&quot;404 - NOT FOUND&quot;) res.end() } else { res.writeHead(200, { &quot;Content-Type&quot;: mimeType }) res.write(data) res.end() } }); // 返回 true 表示, 客户端想要的 是 静态文件 return true } else { // 返回 false 表示, 客户端想要的 不是 静态文件 return false } } // 导出函数 module.exports = readStaticFile 6.2 server/server.js // 引入相关模块 var http = require(&#39;http&#39;); var url = require(&#39;url&#39;); var path = require(&#39;path&#39;); var readStaticFile = require(&#39;./modules/readStaticFile&#39;); // 搭建 HTTP 服务器 var server = http.createServer(function(req, res) { var urlObj = url.parse(req.url); var urlPathname = urlObj.pathname; var filePathname = path.join(__dirname, &quot;/public&quot;, urlPathname); // 读取静态文件 readStaticFile(res, filePathname); }); // 在 3000 端口监听请求 server.listen(3000, function() { console.log(&quot;服务器运行中.&quot;); console.log(&quot;正在监听 3000 端口:&quot;) }) 6.3 最终目录结构 02-Express基于Node.js平台，快速、开放、极简的web开发框架。 $ npm install express --save 一、特色1、Web应用Express是一个基于Node.js平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种Web和移动设备应用。 2、API丰富的HTTP快捷方法和任意排列组合的Connect中间件，让你创建健壮、友好的API变得既快速又简单。 3、性能Express不对Node.js已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的基本性能。 二、安装首先假定你已经安装了Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。 $ mkdir myapp $ cd myapp 通过npm init命令为你的应用创建一个package.json文件。欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。 $ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。你可以直接按“回车”键接受默认设置即可，下面这个除外： entry point: (index.js) 键入app.js或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的index.js文件名，只需按“回车”键即可。 接下来安装Express并将其保存到依赖列表中： $ npm install express --save 如果只是临时安装Express，不想将它添加到依赖列表中，只需略去–save参数即可： $ npm install express 安装Node模块时，如果指定了--save 参数，那么此模块将被添加到package.json文件中dependencies依赖列表中。然后通过npm install 命令即可 三、Hello World实例接下来，我们一起创建一个基本的Express应用。 注意：这里所创建的是一个最最简单的Express应用，并且仅仅只有一个文件 - 和通过Express应用生成器所创建的应用完全不一样，Express应用生成器所创建的应用框架包含多JavaScript文件、Jade模板和针对不同用途的子目录。 进入myapp目录，创建一个名为app.js的文件，然后将下列代码复制进去： var express = require(&#39;express&#39;); var app = express(); app.get(&#39;/&#39;, function (req, res) { res.send(&#39;Hello World!&#39;); }); var server = app.listen(3000, function () { var host = server.address().address; var port = server.address().port; console.log(&#39;Example app listening at http://%s:%s&#39;, host, port); }); 上面的代码启动一个服务并监听从3000端口进入的所有连接请求。他将对所有(/)URL或 路由返回“Hello World！”字符串。对于其他所有路径全部返回 404 Not Found。 req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on(‘data’, callback) 以及任何 Node 提供的方法。 通过如下命令启动此应用： $ node app.js 然后在浏览器中打开 http://localhost:3000/ 并查看输出结果。 四、路由路由是指如何定义应用的端点（URls）以及如何响应客户端的请求。 路由是由一个URI、HTTP请求（GET、POST等）和若干个句柄组成，它的结构如下：app.METHOD(path, [callback..], callback)， app 是 express 对象的一个实例，METHOD是一个 HTTP 请求方法，path 是服务器上的路径， callback 是当路由匹配时要执行的函数。 下面是一个基本的路由示例： var express = require(&#39;express&#39;); var app = express(); // respond with &quot;hello world&quot; when a GET request is made to the homepage app.get(&#39;/&#39;, function(req, res) { res.send(&#39;hello world&#39;); }); 1、路由方法路由方法源于 HTTP 请求方法，和 express 实例相关联。 下面这个例子展示了为应用跟路径定义的 GET 和 POST 请求： // GET method route // 对网站首页的访问返回 &quot;Hello World!&quot; 字样 app.get(&#39;/&#39;, function (req, res) { res.send(&#39;Hello World!&#39;) }) // 网站首页接受 POST 请求 app.post(&#39;/&#39;, function (req, res) { res.send(&#39;Got a POST request&#39;) }) // /user 节点接受 PUT 请求 app.put(&#39;/user&#39;, function (req, res) { res.send(&#39;Got a PUT request at /user&#39;) }) // /user 节点接受 DELETE 请求 app.delete(&#39;/user&#39;, function (req, res) { res.send(&#39;Got a DELETE request at /user&#39;) }) Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。 有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如：app[&#39;m-search&#39;](&#39;/&#39;, function ...) app.all()是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 在下面的例子中，来自”/secret”的请求，不管使用 GET、POST、PUT、DELETE或其他任何http模块支持的HTTP请求，句柄都会得到执行。 app.all(&#39;/secret&#39;, function (req, res, next) { console.log(&#39;Accessing the secret section ...&#39;) next(); // pass control to the next handler }) 2、路由路径路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。 Express使用path-to-regexp匹配路由路径，请参考文档查阅所有定义路由路径的方法。Express Route Tester是测试基本Express路径的好工具，但不支持模式匹配。 查询字符串不是路由路径的一部分。 使用字符串的路由路径示例： // 匹配根路径的请求 app.get(&#39;/&#39;, function (req, res) { res.send(&#39;root&#39;); }); // 匹配 /about 路径的请求 app.get(&#39;/about&#39;, function (req, res) { res.send(&#39;about&#39;); }); // 匹配 /random.text 路径的请求 app.get(&#39;/random.text&#39;, function (req, res) { res.send(&#39;random.text&#39;); }); 使用字符串模式的路由路径示例： // 匹配 acd 和 abcd app.get(&#39;/ab?cd&#39;, function(req, res) { res.send(&#39;ab?cd&#39;); }); // 匹配 abcd、abbcd、abbbcd等 app.get(&#39;/ab+cd&#39;, function(req, res) { res.send(&#39;ab+cd&#39;); }); // 匹配 abcd、abxcd、abRABDOMcd、ab123cd等 app.get(&#39;/ab*cd&#39;, function(req, res) { res.send(&#39;ab*cd&#39;); }); // 匹配 /abe 和 /abcde app.get(&#39;/ab(cd)?e&#39;, function(req, res) { res.send(&#39;ab(cd)?e&#39;); }); 字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。 使用正则表达式的路由路径示例： // 匹配任何路径中含有 a 的路径： app.get(/a/, function(req, res) { res.send(&#39;/a/&#39;); }); // 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等 app.get(/.*fly$/, function(req, res) { res.send(&#39;/.*fly$/&#39;); }); 3、路由句柄可以为请求处理提供多个回调函数，其行为类似中间件。唯一的区别是这些回调函数有可能调用next(&#39;route&#39;)方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。 路由句柄有多种形式，可以是一个函数、一个函数数组、或者是两者混合，如下所示。 使用一个回调函数处理路由： app.get(&#39;/example/a&#39;, function(req, res) { res.send(&#39;Hello from A!&#39;) }) 使用多个回调函数处理路由（记得指定next对象）： app.get(&#39;/example/b&#39;, function (req, res, next) { console.log(&#39;response will be sent by the next function ...&#39;); next(); }, function (req, res) { res.send(&#39;Hello from B!&#39;); }); 使用回调函数数组处理路由： var cb0 = function (req, res, next) { console.log(&#39;CB0&#39;) next() } var cb1 = function (req, res, next) { console.log(&#39;CB1&#39;) next() } var cb2 = function (req, res) { res.send(&#39;Hello from C!&#39;) } app.get(&#39;/example/c&#39;, [cb0, cb1, cb2]) 混合使用函数和函数数组处理路由： var cb0 = function (req, res, next) { console.log(&#39;CB0&#39;) next() } var cb1 = function (req, res, next) { console.log(&#39;CB1&#39;) next() } app.get(&#39;/example/d&#39;, [cb0, cb1], function (req, res, next) { console.log(&#39;response will be sent by the next function ...&#39;) next() }, function (req, res) { res.send(&#39;Hello from D!&#39;) }) 4、响应方法下表中响应对象(res)的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。 方法 描述 res.download() 提示下载文件 res.end() 终结响应处理流程 res.json() 发送一个JSON格式的响应 res.jsonp() 发送一个支持JSONP的JSON格式的响应 res.direct() 重定向请求 res.render() 渲染视图模板 res.send() 发送各种类型的响应 res.sendFile() 以八位字节流的形式发送文件 res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送 5、app.route()可使用app.route()创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。 下面这个示例程序使用app.route()定义了链式路由句柄。 app.route(&#39;/book&#39;) .get(function(req, res) { res.send(&#39;Get a random book&#39;); }) .post(function(req, res) { res.send(&#39;Add a book&#39;); }) .put(function(req, res) { res.send(&#39;Update the book&#39;); }); 6、express.Router可使用express.Router类创建模块化、可挂载的路由句柄。Router实例是一个完整的中间件和路由系统，因此常称其为一个’mini-app’。 下面的实例程序创建了一个路由模块，并加载 了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。 在app目录下创建名为bird.js的文件，内容如下： var express = require(&#39;express&#39;); var router = express.Router(); // 该路由使用的中间件 router.use(function timeLog(req, res, next) { console.log(&#39;Time: &#39;, Date.now()); next(); }); // 定义网站主页的路由 router.get(&#39;/&#39;, function(req, res) { res.send(&#39;Birds home page&#39;); }); // 定义 about 页面的路由 router.get(&#39;/about&#39;, function(req, res) { res.send(&#39;About birds&#39;); }); module.exports = router; 然后在应用中加载路由模块： var birds = require(&#39;./birds&#39;) ... app.use(&#39;/birds&#39;, birds) 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。 五、利用Express托管静态文件通过Express内置的express.static可以方便地托管静态文件，例如图片、CSS、JavaScript文件等。 将静态资源文件所在的目录作为参数传递给express.static中间件就可以提供静态资源文件的访问了。例如，假设在public目录放置了图片、CSS和JavaScript文件，你就可以： app.use(express.static(&#39;public&#39;)) 现在，public目录下面的文件就可以访问了。 http://localhost:3000/images/kitten.jpg http://localhost:3000/css/style.css http://localhost:3000/js/app.js http://localhost:3000/images/bg.png http://localhost:3000/hello.html 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在URL中。 如果你的静态资源存放在多个目录下面，你可以多次调用express.static中间件： app.use(express.static(&#39;public&#39;)) app.use(express.static(&#39;files&#39;)) 访问静态资源文件时，express.static中间件会根据目录添加的顺序查找所需的文件。 如果你希望所有通过express.static访问的文件都存放在一个”虚拟(virtual)“目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示： app.use(&#39;/static&#39;, express.static(&#39;public&#39;)) 现在，你就可以通过带有”/static“前缀的地址来访问public目录下面的文件了。 http://localhost:3000/static/images/kitten.jpg http://localhost:3000/static/css/style.css http://localhost:3000/static/js/app.js http://localhost:3000/static/images/bg.png http://localhost:3000/static/hello.html 六、使用中间件Express是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。 中间件（Middleware）是一个函数，它可以访问请求对象（request object(req)），响应对象(response object(res))，和web应用中处于请求-响应循环流程中的中间件，一般被命名为next的变量。 中间件的功能包括： 执行任何代码 修改请求和响应对象 终结请求-响应循环 调用堆栈中的下一个中间件 如果当前中间件没有终结请求-响应循环，则必须调用next()方法将控制权交给下一个中间件，否则请求就会挂起。 Express应用可使用如下几种中间件： 应用级中间件 路由级中间件 错误处理中间件 内置中间件 第三方中间件 使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。 1、应用级中间件应用级中间件绑定到app对象，使用app.use()和app.METHOD()，其中，METHOD是需要处理的HTTP请求的方法，例如GET,PUT,POST等等，全部小写。例如： var app = express() // 没有挂载路径的中间件，应用的每个请求都会执行该中间件 app.use(function (req, res, next) { console.log(&#39;Time:&#39;, Date.now()) next() }) // 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它 app.use(&#39;/user/:id&#39;, function(req, res, next) { console.log(&#39;Request Type:&#39;, req.method) next() }) // 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求 app.get(&#39;/user/:id&#39;, function(req, res, next) { res.send(&#39;USER&#39;) }) 下面这个例子展示了在一个挂载点装载一组中间件。 // 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息 app.use(&#39;/user/:id&#39;, function(req, res, next) { console.log(&#39;Request URL:&#39;, req.originalUrl) next() }, function(req, res, next) { console.log(&#39;Request Type:&#39;, req.method) next() }) 作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。 第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。 // 一个中间件栈，处理指向 /user/:id 的 GET请求 app.get(&#39;/user/:id&#39;, function(req, res, next) { console.log(&#39;ID:&#39;, req.params.id) next() }, function(req, res, next) { res.send(&#39;User Info&#39;) }) // 处理 /user/:id, 打印出用户id app.get(&#39;/user/:id&#39;, function(req, res, next) { res.end(req.params.id) }) 如果需要在中间件栈中跳过剩余中间件，调用 next(&#39;route&#39;)方法将控制权交给下一个路由。注意：next(&#39;route&#39;)只对使用 app.VERB() 或 router.VERB()加载的中间件有效。 // 一个中间件栈，处理指向 /user/:id 的 GET 请求 app.get(&#39;/user/:id&#39;, function(req, res, next) { // 如果 user id 为0，跳到下一个路由 if (req.params.id === 0) next(&#39;route&#39;) // 否则将控制权交给栈中下一个中间件 else next() }, function(req, res, next) { // 渲染常规页面 res.render(&#39;regular&#39;) }) // 处理 /user/:id, 渲染一个特殊页面 app.get(&#39;/user/:id&#39;, function(req, res, next) { res.render(&#39;special&#39;) }) 2、路由级中间件路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。 var router = express.Router() 路由级使用router.use()或router.VERB()加载。 上述在应用级创建的中间件系统，可通过如下代码改写为路由级。 var app = express() var router = express.Router() // 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件 router.use(function (req, res, next) { console.log(&#39;Time:&#39;, Date.now()) next() }) // 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息 router.use(&#39;/user/:id&#39;, function(req, res, next) { console.log(&#39;Request URL:&#39;, req.originalUrl) next() }, function (req, res, next) { console.log(&#39;Request Type:&#39;, req.method) next() }) // 一个中间件栈，处理指向 /user/:id 的 GET 请求 router.get(&#39;/user/:id&#39;, function (req, res, next) { // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next(&#39;route&#39;) // 负责将控制权交给栈中下一个中间件 else next() // }, function (req, res, next) { // 渲染常规页面 res.render(&#39;regular&#39;) }) // 处理 /user/:id， 渲染一个特殊页面 router.get(&#39;/user/:id&#39;, function (req, res, next) { console.log(req.params.id) res.render(&#39;special&#39;) }) // 将路由挂载至应用 app.use(&#39;/&#39;, router) 3、错误处理中间件 错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 错误处理中间件和其他中间件定义类似，只是要使用4个参数，而不是3个，其签名如下：(err,req,res,next)。 app.use(function(err, req, res, next) { console.error(err.stack) res.status(500).send(&#39;Something broke!&#39;) }) 4、内置中间件从4.x版本开始，Express已经不再依赖Connect了。除了express.static，Express以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。 express.static(root, [options]) express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在Express应用中提托管静态资源。 参数 root 指提供静态资源的根目录。 可选的 options 参数拥有如下属性。 属性 描述 类型 缺省值 dotfiles 是否对外输出文件名以点（.）开头的文件。可选值为”allow“，”deny“和”ignore“。 String ”ignore“ etag 是否启用etag生成 Boolean true extensions 设置文件扩展名备份选项 Array [] index 发送目录索引文件，设置为false禁用目录索引 Mixed “index.html” lastModified 设置Last-Modified头为文件在操作系统上的最后修改日期。可能值为true或false Boolean true maxAge 以毫秒或者其字符串格式设置Cache-Control头的max-age属性。 Number 0 redirect 当路径为目录时，重定向至”/“ Boolean true setHeaders 设置HTTP头以提供文件的函数 Function 下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。 var options = { dotfiles: &#39;ignore&#39;, etag: false, extensions: [&#39;htm&#39;, &#39;html&#39;], index: false, maxAge: &#39;1d&#39;, redirect: false, setHeaders: function (res, path, stat) { res.set(&#39;x-timestamp&#39;, Date.now()) } } app.use(express.static(&#39;public&#39;, options)) 每个应用可有多个静态目录。 app.use(express.static(&#39;public&#39;)) app.use(express.static(&#39;uploads&#39;)) app.use(express.static(&#39;files&#39;)) 5、第三方中间件通过使用第三方中间件从而为 Express 应用增加更多功能。 安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。 下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser $ npm install cookie-parser var express = require(&#39;express&#39;) var app = express() var cookieParser = require(&#39;cookie-parser&#39;) // 加载用于解析 cookie 的中间件 app.use(cookieParser()) 七、在Express中使用模板引擎需要在应用中进行如下设置才能让Express渲染模板文件： views，放模板文件的目录，比如：app.set(&#39;views&#39;, &#39;./views&#39;) view engine，模板引擎，比如：app.set(&#39;view engine&#39;, &#39;ejs&#39;) art-template art-template for express 4.x. 1、Install npm install --save art-template npm install --save express-art-template 2、Example var express = require(&#39;express&#39;) var app = express() // view engine setup app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)) app.set(&#39;view&#39;, { debug: process.env.NODE_ENV !== &#39;production&#39; }) app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)) app.set(&#39;view engine&#39;, &#39;art&#39;) // routes app.get(&#39;/&#39;, function (req, res) { res.render(&#39;index.art&#39;, { user: { name: &#39;aui&#39;, tags: [&#39;art&#39;, &#39;template&#39;, &#39;nodejs&#39;] } }) }) 03-Koa2一、koa2快速开始因为node.js v7.6.0开始完全支持async/await，不需要加flag，所以node.js环境都要7.6.0以上node.js环境 版本v7.6以上 npm 版本3.x以上","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"后端","slug":"后端","permalink":"/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2021-08-12T10:44:10.293Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}